// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/next-env.d.ts

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/package.json

{
  "name": "dermi",
  "version": "0.1.0",
  "apiVersion": "0.1.0",
  "private": true,
  "engines": {
    "node": ">=18.0.0 <20.12.0",
    "yarn": ">=1.0.0 <2.0.0",
    "npm": "please-use-yarn"
  },
  "scripts": {
    "dev": "next dev",
    "dev-db-push": "dotenv -e .env.development.local -- npx prisma db push",
    "build": "prisma generate && next build",
    "start": "next start",
    "lint": "next lint",
    "prettier": "prettier --write .",
    "type-check": "tsc --noEmit",
    "seed:all": "(yarn seed:forms) && exit",
    "seed:forms": "ts-node -r tsconfig-paths/register -r dotenv/config ./src/utils/seeders/formDataSeeder.ts",
    "slicemachine": "start-slicemachine"
  },
  "dependencies": {
    "@aws-sdk/client-cognito-identity": "^3.556.0",
    "@aws-sdk/client-cognito-identity-provider": "^3.398.0",
    "@aws-sdk/client-s3": "^3.637.0",
    "@aws-sdk/client-ses": "^3.637.0",
    "@aws-sdk/client-sfn": "^3.637.0",
    "@aws-sdk/lib-storage": "^3.637.0",
    "@aws-sdk/s3-request-presigner": "^3.637.0",
    "@babel/core": "^7.22.5",
    "@babel/plugin-syntax-import-assertions": "^7.22.5",
    "@datadog/browser-rum": "^5.6.0",
    "@emotion/react": "^11.11.1",
    "@floating-ui/react": "^0.25.1",
    "@google-analytics/data": "^4.8.0",
    "@googlemaps/js-api-loader": "^1.16.2",
    "@headlessui/react": "^1.7.17",
    "@headlessui/tailwindcss": "^0.2.0",
    "@heroicons/react": "^2.0.18",
    "@joshuajaco/react-pdf-renderer-bundled": "^3.1.12",
    "@next/bundle-analyzer": "^14.0.2",
    "@prisma/client": "^5.5.2",
    "@prismicio/client": "^7.4.1",
    "@prismicio/next": "^1.5.0",
    "@prismicio/react": "^2.7.4",
    "@stripe/react-stripe-js": "^2.4.0",
    "@stripe/stripe-js": "^2.2.1",
    "@tailwindcss/forms": "^0.5.7",
    "@tanstack/react-query": "^4.29.19",
    "@tanstack/react-table": "^8.12.0",
    "@typeform/embed-react": "^3.10.0",
    "@types/node": "^20.3.2",
    "@types/react": "18.2.13",
    "@types/react-dom": "18.2.6",
    "@types/swagger-ui-react": "^4.18.0",
    "@types/uuid": "^9.0.7",
    "@typescript-eslint/parser": "^5.0.0",
    "@untitled-ui/icons-react": "^0.1.1",
    "add": "^2.0.6",
    "amazon-cognito-identity-js": "^6.3.12",
    "assert": "^2.1.0",
    "autoprefixer": "10.4.16",
    "aws-crt": "^1.18.0",
    "axios": "^1.5.0",
    "axios-retry": "^4.0.0",
    "cross-env": "^7.0.3",
    "dayjs": "^1.11.8",
    "dotenv": "^16.4.2",
    "encoding": "^0.1.13",
    "eslint": "^8.56.0",
    "eslint-config-next": "^14.2.4",
    "eslint-plugin-prettier": "^4.2.1",
    "formik": "^2.4.5",
    "framer-motion": "^10.16.4",
    "generate-password": "^1.7.0",
    "graphql": "^16.7.1",
    "graphql-request": "^6.1.0",
    "graphql-tag": "^2.12.6",
    "handlebars": "^4.7.8",
    "i18next": "^23.2.3",
    "isomorphic-dompurify": "^1.8.0",
    "lodash.debounce": "^4.0.8",
    "lodash.get": "^4.4.2",
    "lodash.groupby": "^4.6.0",
    "lodash.isempty": "^4.4.0",
    "lodash.mergewith": "^4.6.2",
    "moment": "^2.30.1",
    "mongodb": "^5.6.0",
    "mongodb-client-encryption": "^6.0.0",
    "next": "^14.2.4",
    "next-auth": "^4.23.0",
    "next-compose-plugins": "^2.2.1",
    "next-pwa": "^5.6.0",
    "next-swagger-doc": "^0.4.0",
    "node-gyp": "^10.0.0",
    "openai": "^4.0.0",
    "openapi-types": "^12.1.3",
    "pdf-lib": "^1.17.1",
    "postcss": "8.4.28",
    "prettier": "^2.8.8",
    "prisma": "^5.1.1",
    "qs": "^6.11.2",
    "randexp": "^0.5.3",
    "react": "^18.3.1",
    "react-calendly": "^4.3.0",
    "react-compare-slider": "^3.0.1",
    "react-dom": "^18.3.1",
    "react-i18next": "^13.1.2",
    "react-input-mask": "2.0.4",
    "react-international-phone": "^4.1.0",
    "react-markdown": "^8.0.7",
    "react-player": "^2.12.0",
    "react-spring": "^9.7.3",
    "react-virtuoso": "^4.6.2",
    "redis": "^4.6.12",
    "remark-breaks": "^4.0.0",
    "remark-gfm": "^3.0.1",
    "sharethis-reactjs": "^1.6.0",
    "stripe": "^14.8.0",
    "swagger-jsdoc": "6.1.0",
    "swagger-ui-react": "^5.3.2",
    "swiper": "^11.0.5",
    "tailwind-merge": "^1.14.0",
    "tailwindcss": "3.3.5",
    "ts-node": "^10.9.1",
    "tss-react": "^4.9.0",
    "typescript": "5.1.6",
    "universal-cookie": "^7.0.2",
    "uuid": "^9.0.1",
    "webpack": "5",
    "winston": "^3.11.0",
    "yaml": "^2.3.1",
    "yarn": "^1.22.19",
    "zod": "3.21.1",
    "zod-prisma-types": "^3.1.6"
  },
  "devDependencies": {
    "@slicemachine/adapter-next": "^0.3.23",
    "@svgr/webpack": "^8.1.0",
    "@trivago/prettier-plugin-sort-imports": "^4.2.0",
    "@types/dompurify": "^3.0.2",
    "@types/google.maps": "^3.53.4",
    "@types/lodash.debounce": "^4.0.7",
    "@types/lodash.get": "^4.4.7",
    "@types/lodash.groupby": "^4.6.8",
    "@types/lodash.isempty": "^4.4.9",
    "@types/lodash.mergewith": "^4.6.7",
    "@types/qs": "^6.9.11",
    "@types/react-input-mask": "2.0.4",
    "@typescript-eslint/eslint-plugin": "^5.60.1",
    "eslint-plugin-jsdoc": "^46.4.6",
    "prettier-plugin-tailwindcss": "^0.4.1",
    "prisma": "^5.1.1",
    "slice-machine-ui": "^1.19.1"
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/prismicio-types.d.ts

// Code generated by Slice Machine. DO NOT EDIT.

import type * as prismic from '@prismicio/client';

type Simplify<T> = { [KeyType in keyof T]: T[KeyType] };

/**
 * Item in *Account Navigation → Dropdown Links*
 */
export interface AccountNavigationDocumentDataDropdownLinksItem {
  /**
   * link field in *Account Navigation → Dropdown Links*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: account_navigation.dropdown_links[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * text field in *Account Navigation → Dropdown Links*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_navigation.dropdown_links[].text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  text: prismic.KeyTextField;

  /**
   * Status Badge field in *Account Navigation → Dropdown Links*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_navigation.dropdown_links[].status_badge
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  status_badge: prismic.KeyTextField;
}

type AccountNavigationDocumentDataSlicesSlice = NavigationBarSlice;

/**
 * Content for Account Navigation documents
 */
interface AccountNavigationDocumentData {
  /**
   * Name field in *Account Navigation*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_navigation.name
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;

  /**
   * Logo field in *Account Navigation*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: account_navigation.logo
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  logo: prismic.ImageField<never>;

  /**
   * Survey Button Text field in *Account Navigation*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_navigation.survey_button_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  survey_button_text: prismic.KeyTextField;

  /**
   * Survey Form ID field in *Account Navigation*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_navigation.survey_form_id
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  survey_form_id: prismic.KeyTextField;

  /**
   * Profile Link field in *Account Navigation*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: account_navigation.profile_link
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  profile_link: prismic.LinkField;

  /**
   * Add Family Link field in *Account Navigation*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: account_navigation.add_family_link
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  add_family_link: prismic.LinkField;

  /**
   * Add Family Link Text field in *Account Navigation*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_navigation.add_family_link_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  add_family_link_text: prismic.KeyTextField;

  /**
   * Dropdown Links field in *Account Navigation*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: account_navigation.dropdown_links[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  dropdown_links: prismic.GroupField<
    Simplify<AccountNavigationDocumentDataDropdownLinksItem>
  >;

  /**
   * Dropdown Logout Text field in *Account Navigation*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_navigation.dropdown_logout_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  dropdown_logout_text: prismic.KeyTextField;

  /**
   * Dropdown Divider Text field in *Account Navigation*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_navigation.dropdown_divider_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  dropdown_divider_text: prismic.KeyTextField;

  /**
   * Slice Zone field in *Account Navigation*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: account_navigation.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<AccountNavigationDocumentDataSlicesSlice>;
}

/**
 * Account Navigation document from Prismic
 *
 * - **API ID**: `account_navigation`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type AccountNavigationDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<AccountNavigationDocumentData>,
    'account_navigation',
    Lang
  >;

type AccountNextStepsSectionDocumentDataSlicesSlice = never;

/**
 * Item in *Account Next Steps Section → Status Content*
 */
export interface AccountNextStepsSectionDocumentDataStatusContentItem {
  /**
   * Case Status field in *Account Next Steps Section → Status Content*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.status_content[].case_status
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  case_status: prismic.KeyTextField;

  /**
   * Progress field in *Account Next Steps Section → Status Content*
   *
   * - **Field Type**: Number
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.status_content[].progress
   * - **Documentation**: https://prismic.io/docs/field#number
   */
  progress: prismic.NumberField;

  /**
   * Eyebrow field in *Account Next Steps Section → Status Content*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.status_content[].eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Header field in *Account Next Steps Section → Status Content*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.status_content[].header
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  header: prismic.KeyTextField;

  /**
   * Title field in *Account Next Steps Section → Status Content*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.status_content[].title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Content field in *Account Next Steps Section → Status Content*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.status_content[].content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * CTA Link field in *Account Next Steps Section → Status Content*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.status_content[].cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Link Text field in *Account Next Steps Section → Status Content*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.status_content[].cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_link_text: prismic.KeyTextField;

  /**
   * Secondary Link field in *Account Next Steps Section → Status Content*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.status_content[].secondary_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  secondary_link: prismic.LinkField;

  /**
   * Secondary Link Text field in *Account Next Steps Section → Status Content*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.status_content[].secondary_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  secondary_link_text: prismic.KeyTextField;
}

/**
 * Content for Account Next Steps Section documents
 */
interface AccountNextStepsSectionDocumentData {
  /**
   * Toolbar Title field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.toolbar_title
   * - **Tab**: Toolbar
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  toolbar_title: prismic.KeyTextField;

  /**
   * View Button Text field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.view_button_text
   * - **Tab**: Toolbar
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  view_button_text: prismic.KeyTextField;

  /**
   * Download Button Text field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.download_button_text
   * - **Tab**: Toolbar
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  download_button_text: prismic.KeyTextField;

  /**
   * Print Button Text field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.print_button_text
   * - **Tab**: Toolbar
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  print_button_text: prismic.KeyTextField;

  /**
   * Slice Zone field in *Account Next Steps Section*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.slices[]
   * - **Tab**: Toolbar
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<AccountNextStepsSectionDocumentDataSlicesSlice> /**
   * Default CTA Eyebrow field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.default_cta_eyebrow
   * - **Tab**: Default CTA
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  default_cta_eyebrow: prismic.KeyTextField;

  /**
   * Default CTA Title field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.default_cta_title
   * - **Tab**: Default CTA
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  default_cta_title: prismic.KeyTextField;

  /**
   * Default CTA Content field in *Account Next Steps Section*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.default_cta_content
   * - **Tab**: Default CTA
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  default_cta_content: prismic.RichTextField;

  /**
   * Default CTA Link field in *Account Next Steps Section*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.default_cta_link
   * - **Tab**: Default CTA
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  default_cta_link: prismic.LinkField;

  /**
   * Default CTA Link Text field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.default_cta_link_text
   * - **Tab**: Default CTA
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  default_cta_link_text: prismic.KeyTextField /**
   * Concierge Eyebrow field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.concierge_eyebrow
   * - **Tab**: Concierge CTA
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  concierge_eyebrow: prismic.KeyTextField;

  /**
   * Concierge Logo field in *Account Next Steps Section*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.concierge_logo
   * - **Tab**: Concierge CTA
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  concierge_logo: prismic.ImageField<never>;

  /**
   * Concierge Image field in *Account Next Steps Section*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.concierge_image
   * - **Tab**: Concierge CTA
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  concierge_image: prismic.ImageField<never>;

  /**
   * Concierge Content field in *Account Next Steps Section*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.concierge_content
   * - **Tab**: Concierge CTA
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  concierge_content: prismic.RichTextField;

  /**
   * Concierge CTA Link field in *Account Next Steps Section*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.concierge_cta_link
   * - **Tab**: Concierge CTA
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  concierge_cta_link: prismic.LinkField;

  /**
   * Concierge CTA Link Text field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.concierge_cta_link_text
   * - **Tab**: Concierge CTA
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  concierge_cta_link_text: prismic.KeyTextField /**
   * Start Eyebrow field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.start_eyebrow
   * - **Tab**: Get Started
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  start_eyebrow: prismic.KeyTextField;

  /**
   * Start Header field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.start_header
   * - **Tab**: Get Started
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  start_header: prismic.KeyTextField;

  /**
   * Start Title field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.start_title
   * - **Tab**: Get Started
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  start_title: prismic.KeyTextField;

  /**
   * Start Content field in *Account Next Steps Section*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.start_content
   * - **Tab**: Get Started
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  start_content: prismic.RichTextField;

  /**
   * Start CTA Link field in *Account Next Steps Section*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.start_cta_link
   * - **Tab**: Get Started
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  start_cta_link: prismic.LinkField;

  /**
   * Start CTA Link Text field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.start_cta_link_text
   * - **Tab**: Get Started
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  start_cta_link_text: prismic.KeyTextField;

  /**
   * Start Secondary CTA Link field in *Account Next Steps Section*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.start_secondary_cta_link
   * - **Tab**: Get Started
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  start_secondary_cta_link: prismic.LinkField;

  /**
   * Start Secondary CTA Link Text field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.start_secondary_cta_link_text
   * - **Tab**: Get Started
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  start_secondary_cta_link_text: prismic.KeyTextField /**
   * Progress Total field in *Account Next Steps Section*
   *
   * - **Field Type**: Number
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.progress_total
   * - **Tab**: Next Steps
   * - **Documentation**: https://prismic.io/docs/field#number
   */;
  progress_total: prismic.NumberField;

  /**
   * Status Content field in *Account Next Steps Section*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.status_content[]
   * - **Tab**: Next Steps
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  status_content: prismic.GroupField<
    Simplify<AccountNextStepsSectionDocumentDataStatusContentItem>
  > /**
   * Video Eyebrow field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.video_eyebrow
   * - **Tab**: Video
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  video_eyebrow: prismic.KeyTextField;

  /**
   * Video Title field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.video_title
   * - **Tab**: Video
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  video_title: prismic.KeyTextField;

  /**
   * Video Link field in *Account Next Steps Section*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.video_link
   * - **Tab**: Video
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  video_link: prismic.KeyTextField /**
   * Alert Color field in *Account Next Steps Section*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.alert_color
   * - **Tab**: Alert
   * - **Documentation**: https://prismic.io/docs/field#color
   */;
  alert_color: prismic.ColorField;

  /**
   * Alert Text Color field in *Account Next Steps Section*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.alert_text_color
   * - **Tab**: Alert
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  alert_text_color: prismic.ColorField;

  /**
   * Alert Content field in *Account Next Steps Section*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_next_steps_section.alert_content
   * - **Tab**: Alert
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  alert_content: prismic.RichTextField;
}

/**
 * Account Next Steps Section document from Prismic
 *
 * - **API ID**: `account_next_steps_section`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type AccountNextStepsSectionDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<
    Simplify<AccountNextStepsSectionDocumentData>,
    'account_next_steps_section',
    Lang
  >;

type AccounthomeDocumentDataSlicesSlice =
  | OrdersSectionSlice
  | AccountHeroSlice
  | UserOverviewSlice
  | MessagingCtaSectionSlice
  | TextAreaSlice
  | HeroCarouselSlice;

/**
 * Content for AccountHome documents
 */
interface AccounthomeDocumentData {
  /**
   * Slice Zone field in *AccountHome*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: accounthome.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<AccounthomeDocumentDataSlicesSlice> /**
   * Meta Description field in *AccountHome*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: accounthome.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *AccountHome*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: accounthome.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *AccountHome*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: accounthome.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * AccountHome document from Prismic
 *
 * - **API ID**: `accounthome`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type AccounthomeDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<
    Simplify<AccounthomeDocumentData>,
    'accounthome',
    Lang
  >;

type AccountpageDocumentDataSlicesSlice =
  | StartPopoverSlice
  | ComplaintSelectSlice
  | CalendlySchedulerSlice
  | IconBulletListSlice
  | AccountNotificationsSlice
  | PrimaryUserContextSwitchSlice
  | InfoPopoverSlice
  | OrderConfirmationSlice
  | RedirectSlice
  | SettingsTabSlice
  | BillingHistorySlice
  | PaymentMethodsSlice
  | ComplaintSelectorSlice
  | FormSlice
  | MessagingCtaSectionSlice
  | HeroCarouselSlice
  | TextAreaSlice;

/**
 * Content for AccountPage documents
 */
interface AccountpageDocumentData {
  /**
   * Background Color field in *AccountPage*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: accountpage.background_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color: prismic.ColorField;

  /**
   * Slice Zone field in *AccountPage*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: accountpage.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<AccountpageDocumentDataSlicesSlice> /**
   * Meta Description field in *AccountPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: accountpage.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *AccountPage*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: accountpage.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *AccountPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: accountpage.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * AccountPage document from Prismic
 *
 * - **API ID**: `accountpage`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type AccountpageDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<AccountpageDocumentData>,
    'accountpage',
    Lang
  >;

type BillingDocumentDataSlicesSlice = BillingHistorySlice | PaymentMethodsSlice;

/**
 * Content for Billing documents
 */
interface BillingDocumentData {
  /**
   * Slice Zone field in *Billing*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: billing.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<BillingDocumentDataSlicesSlice>;
}

/**
 * Billing document from Prismic
 *
 * - **API ID**: `billing`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type BillingDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<BillingDocumentData>,
    'billing',
    Lang
  >;

type BlogAdCardDocumentDataSlicesSlice = never;

/**
 * Content for Blog Ad Card documents
 */
interface BlogAdCardDocumentData {
  /**
   * Link field in *Blog Ad Card*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_ad_card.link
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Image field in *Blog Ad Card*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_ad_card.image
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Slice Zone field in *Blog Ad Card*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_ad_card.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<BlogAdCardDocumentDataSlicesSlice>;
}

/**
 * Blog Ad Card document from Prismic
 *
 * - **API ID**: `blog_ad_card`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type BlogAdCardDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<BlogAdCardDocumentData>,
    'blog_ad_card',
    Lang
  >;

type BlogAuthorDocumentDataSlicesSlice = never;

/**
 * Content for Blog Author documents
 */
interface BlogAuthorDocumentData {
  /**
   * Name field in *Blog Author*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_author.name
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;

  /**
   * Avatar field in *Blog Author*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_author.avatar
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  avatar: prismic.ImageField<never>;

  /**
   * Slice Zone field in *Blog Author*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_author.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<BlogAuthorDocumentDataSlicesSlice>;
}

/**
 * Blog Author document from Prismic
 *
 * - **API ID**: `blog_author`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type BlogAuthorDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<BlogAuthorDocumentData>,
    'blog_author',
    Lang
  >;

type BlogNewsletterDocumentDataSlicesSlice = never;

/**
 * Content for Blog Newsletter documents
 */
interface BlogNewsletterDocumentData {
  /**
   * Background Color Start field in *Blog Newsletter*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.background_color_start
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *Blog Newsletter*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.background_color_end
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Title field in *Blog Newsletter*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *Blog Newsletter*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.title_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Text field in *Blog Newsletter*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  text: prismic.RichTextField;

  /**
   * Text Color field in *Blog Newsletter*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.text_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  text_color: prismic.ColorField;

  /**
   * Label field in *Blog Newsletter*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.label
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  label: prismic.KeyTextField;

  /**
   * Label Color field in *Blog Newsletter*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.label_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  label_color: prismic.ColorField;

  /**
   * Placeholder field in *Blog Newsletter*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.placeholder
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  placeholder: prismic.KeyTextField;

  /**
   * Subscribe Button Text field in *Blog Newsletter*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.subscribe_button_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subscribe_button_text: prismic.KeyTextField;

  /**
   * Subscribe Button Text Color field in *Blog Newsletter*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.subscribe_button_text_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  subscribe_button_text_color: prismic.ColorField;

  /**
   * Subscribe Button Color field in *Blog Newsletter*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.subscribe_button_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  subscribe_button_color: prismic.ColorField;

  /**
   * Subscribing Text field in *Blog Newsletter*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.subscribing_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subscribing_text: prismic.KeyTextField;

  /**
   * Subscribed Text field in *Blog Newsletter*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.subscribed_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subscribed_text: prismic.KeyTextField;

  /**
   * Invalid Email Text field in *Blog Newsletter*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.invalid_email_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  invalid_email_text: prismic.KeyTextField;

  /**
   * Slice Zone field in *Blog Newsletter*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_newsletter.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<BlogNewsletterDocumentDataSlicesSlice>;
}

/**
 * Blog Newsletter document from Prismic
 *
 * - **API ID**: `blog_newsletter`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type BlogNewsletterDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<BlogNewsletterDocumentData>,
    'blog_newsletter',
    Lang
  >;

/**
 * Item in *Blog Search → Links*
 */
export interface BlogSearchDocumentDataLinksItem {
  /**
   * Link field in *Blog Search → Links*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.links[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Link Text field in *Blog Search → Links*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.links[].link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  link_text: prismic.KeyTextField;
}

type BlogSearchDocumentDataSlicesSlice = never;

/**
 * Content for Blog Search documents
 */
interface BlogSearchDocumentData {
  /**
   * Show Navigation Header field in *Blog Search*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: false
   * - **API ID Path**: blog_search.show_navigation_header
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  show_navigation_header: prismic.BooleanField;

  /**
   * Initial Header Theme field in *Blog Search*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.initial_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  initial_header_theme: prismic.ContentRelationshipField;

  /**
   * Scroll Header Theme field in *Blog Search*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.scroll_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  scroll_header_theme: prismic.ContentRelationshipField;

  /**
   * Logo field in *Blog Search*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.logo
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  logo: prismic.ImageField<never>;

  /**
   * Search Placeholder field in *Blog Search*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.search_placeholder
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  search_placeholder: prismic.KeyTextField;

  /**
   * Header Background Color field in *Blog Search*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.header_background_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  header_background_color: prismic.ColorField;

  /**
   * Link Color field in *Blog Search*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.link_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  link_color: prismic.ColorField;

  /**
   * Links field in *Blog Search*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.links[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  links: prismic.GroupField<Simplify<BlogSearchDocumentDataLinksItem>>;

  /**
   * Header field in *Blog Search*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.header
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  header: prismic.KeyTextField;

  /**
   * No Posts Title field in *Blog Search*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.no_posts_title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_posts_title: prismic.KeyTextField;

  /**
   * No Posts Description field in *Blog Search*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.no_posts_description
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  no_posts_description: prismic.RichTextField;

  /**
   * No Posts Link field in *Blog Search*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.no_posts_link
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  no_posts_link: prismic.LinkField;

  /**
   * No Posts Link Text field in *Blog Search*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.no_posts_link_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_posts_link_text: prismic.KeyTextField;

  /**
   * Slice Zone field in *Blog Search*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<BlogSearchDocumentDataSlicesSlice> /**
   * Meta Description field in *Blog Search*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: blog_search.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *Blog Search*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_search.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *Blog Search*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: blog_search.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * Blog Search document from Prismic
 *
 * - **API ID**: `blog_search`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type BlogSearchDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<
    Simplify<BlogSearchDocumentData>,
    'blog_search',
    Lang
  >;

/**
 * Item in *Blog Tag → Links*
 */
export interface BlogTagDocumentDataLinksItem {
  /**
   * Link field in *Blog Tag → Links*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.links[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Link Text field in *Blog Tag → Links*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.links[].link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  link_text: prismic.KeyTextField;
}

type BlogTagDocumentDataSlicesSlice = never;

/**
 * Content for Blog Tag documents
 */
interface BlogTagDocumentData {
  /**
   * Show Navigation Header field in *Blog Tag*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: false
   * - **API ID Path**: blog_tag.show_navigation_header
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  show_navigation_header: prismic.BooleanField;

  /**
   * Initial Header Theme field in *Blog Tag*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.initial_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  initial_header_theme: prismic.ContentRelationshipField;

  /**
   * Scroll Header Theme field in *Blog Tag*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.scroll_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  scroll_header_theme: prismic.ContentRelationshipField;

  /**
   * Search Placeholder field in *Blog Tag*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.search_placeholder
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  search_placeholder: prismic.KeyTextField;

  /**
   * Header Background Color field in *Blog Tag*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.header_background_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  header_background_color: prismic.ColorField;

  /**
   * Link Color field in *Blog Tag*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.link_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  link_color: prismic.ColorField;

  /**
   * Links field in *Blog Tag*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.links[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  links: prismic.GroupField<Simplify<BlogTagDocumentDataLinksItem>>;

  /**
   * Page Title field in *Blog Tag*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.page_title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  page_title: prismic.KeyTextField;

  /**
   * No Posts Title field in *Blog Tag*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.no_posts_title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_posts_title: prismic.KeyTextField;

  /**
   * No Posts Description field in *Blog Tag*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.no_posts_description
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  no_posts_description: prismic.RichTextField;

  /**
   * No Posts Link field in *Blog Tag*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.no_posts_link
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  no_posts_link: prismic.LinkField;

  /**
   * No Posts Link Text field in *Blog Tag*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.no_posts_link_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_posts_link_text: prismic.KeyTextField;

  /**
   * Slice Zone field in *Blog Tag*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<BlogTagDocumentDataSlicesSlice> /**
   * Meta Description field in *Blog Tag*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: blog_tag.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *Blog Tag*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_tag.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *Blog Tag*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: blog_tag.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * Blog Tag document from Prismic
 *
 * - **API ID**: `blog_tag`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type BlogTagDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<
    Simplify<BlogTagDocumentData>,
    'blog_tag',
    Lang
  >;

type BlogauthorDocumentDataSlicesSlice = TextAreaSlice | HeroCarouselSlice;

/**
 * Content for BlogAuthor documents
 */
interface BlogauthorDocumentData {
  /**
   * Slice Zone field in *BlogAuthor*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: blogauthor.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<BlogauthorDocumentDataSlicesSlice> /**
   * Meta Description field in *BlogAuthor*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: blogauthor.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *BlogAuthor*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: blogauthor.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *BlogAuthor*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: blogauthor.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * BlogAuthor document from Prismic
 *
 * - **API ID**: `blogauthor`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type BlogauthorDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<BlogauthorDocumentData>,
    'blogauthor',
    Lang
  >;

type BlogcategoryDocumentDataSlicesSlice = TextAreaSlice;

/**
 * Content for BlogCategory documents
 */
interface BlogcategoryDocumentData {
  /**
   * Category Name field in *BlogCategory*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blogcategory.category_name
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  category_name: prismic.KeyTextField;

  /**
   * Slice Zone field in *BlogCategory*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: blogcategory.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<BlogcategoryDocumentDataSlicesSlice> /**
   * Meta Description field in *BlogCategory*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: blogcategory.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *BlogCategory*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: blogcategory.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *BlogCategory*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: blogcategory.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * BlogCategory document from Prismic
 *
 * - **API ID**: `blogcategory`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type BlogcategoryDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<BlogcategoryDocumentData>,
    'blogcategory',
    Lang
  >;

/**
 * Item in *BlogHome → Links*
 */
export interface BloghomeDocumentDataLinksItem {
  /**
   * Link field in *BlogHome → Links*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: bloghome.links[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Link Text field in *BlogHome → Links*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: bloghome.links[].link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  link_text: prismic.KeyTextField;
}

type BloghomeDocumentDataSlicesSlice =
  | BlogCtaBannerSlice
  | BlogCategorySectionSlice
  | FeaturedBlogSectionSlice
  | TextAreaSlice;

/**
 * Content for BlogHome documents
 */
interface BloghomeDocumentData {
  /**
   * Show Navigation Header field in *BlogHome*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: false
   * - **API ID Path**: bloghome.show_navigation_header
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  show_navigation_header: prismic.BooleanField;

  /**
   * Initial Header Theme field in *BlogHome*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: bloghome.initial_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  initial_header_theme: prismic.ContentRelationshipField<'navigation'>;

  /**
   * Scroll Header Theme field in *BlogHome*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: bloghome.scroll_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  scroll_header_theme: prismic.ContentRelationshipField<'navigation'>;

  /**
   * Logo field in *BlogHome*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: bloghome.logo
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  logo: prismic.ImageField<never>;

  /**
   * Search Placeholder field in *BlogHome*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: bloghome.search_placeholder
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  search_placeholder: prismic.KeyTextField;

  /**
   * Header Background Color field in *BlogHome*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: bloghome.header_background_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  header_background_color: prismic.ColorField;

  /**
   * Link Color field in *BlogHome*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: bloghome.link_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  link_color: prismic.ColorField;

  /**
   * Links field in *BlogHome*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: bloghome.links[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  links: prismic.GroupField<Simplify<BloghomeDocumentDataLinksItem>>;

  /**
   * Slice Zone field in *BlogHome*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: bloghome.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<BloghomeDocumentDataSlicesSlice> /**
   * Meta Description field in *BlogHome*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: bloghome.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *BlogHome*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: bloghome.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *BlogHome*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: bloghome.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * BlogHome document from Prismic
 *
 * - **API ID**: `bloghome`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type BloghomeDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<
    Simplify<BloghomeDocumentData>,
    'bloghome',
    Lang
  >;

/**
 * Item in *BlogPost → Categories*
 */
export interface BlogpostDocumentDataCategoriesItem {
  /**
   * Category field in *BlogPost → Categories*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: blogpost.categories[].category
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  category: prismic.ContentRelationshipField<'blogcategory'>;
}

type BlogpostDocumentDataSlicesSlice =
  | RelatedBlogArticlesSlice
  | BlogArticleSlice
  | TextAreaSlice
  | HeroCarouselSlice;

/**
 * Content for BlogPost documents
 */
interface BlogpostDocumentData {
  /**
   * Show Navigation Header field in *BlogPost*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: false
   * - **API ID Path**: blogpost.show_navigation_header
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  show_navigation_header: prismic.BooleanField;

  /**
   * Initial Header Theme field in *BlogPost*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: blogpost.initial_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  initial_header_theme: prismic.ContentRelationshipField<'navigation'>;

  /**
   * Scroll Header Theme field in *BlogPost*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: blogpost.scroll_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  scroll_header_theme: prismic.ContentRelationshipField<'navigation'>;

  /**
   * Author field in *BlogPost*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: blogpost.author
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  author: prismic.ContentRelationshipField<'blog_author'>;

  /**
   * Publication Date field in *BlogPost*
   *
   * - **Field Type**: Date
   * - **Placeholder**: *None*
   * - **API ID Path**: blogpost.publication_date
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#date
   */
  publication_date: prismic.DateField;

  /**
   * Read Time field in *BlogPost*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blogpost.read_time
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  read_time: prismic.KeyTextField;

  /**
   * Title field in *BlogPost*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blogpost.title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Short Description field in *BlogPost*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blogpost.short_description
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  short_description: prismic.KeyTextField;

  /**
   * Thumbnail field in *BlogPost*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: blogpost.thumbnail
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  thumbnail: prismic.ImageField<never>;

  /**
   * Categories field in *BlogPost*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: blogpost.categories[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  categories: prismic.GroupField<Simplify<BlogpostDocumentDataCategoriesItem>>;

  /**
   * Slice Zone field in *BlogPost*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: blogpost.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<BlogpostDocumentDataSlicesSlice> /**
   * Meta Description field in *BlogPost*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: blogpost.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *BlogPost*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: blogpost.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *BlogPost*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: blogpost.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * BlogPost document from Prismic
 *
 * - **API ID**: `blogpost`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type BlogpostDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<BlogpostDocumentData>,
    'blogpost',
    Lang
  >;

type CasesPageDocumentDataSlicesSlice = never;

/**
 * Content for Cases Page documents
 */
interface CasesPageDocumentData {
  /**
   * Slice Zone field in *Cases Page*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: cases_page.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<CasesPageDocumentDataSlicesSlice> /**
   * Meta Description field in *Cases Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: cases_page.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *Cases Page*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cases_page.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *Cases Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: cases_page.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField /**
   * No Cases Image field in *Cases Page*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cases_page.no_cases_image
   * - **Tab**: No Cases
   * - **Documentation**: https://prismic.io/docs/field#image
   */;
  no_cases_image: prismic.ImageField<never>;

  /**
   * No Cases Title field in *Cases Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cases_page.no_cases_title
   * - **Tab**: No Cases
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_cases_title: prismic.KeyTextField;

  /**
   * No Cases Content field in *Cases Page*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cases_page.no_cases_content
   * - **Tab**: No Cases
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  no_cases_content: prismic.RichTextField;

  /**
   * No Cases Content With Name field in *Cases Page*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cases_page.no_cases_content_with_name
   * - **Tab**: No Cases
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  no_cases_content_with_name: prismic.RichTextField;

  /**
   * No Cases Primary CTA Link field in *Cases Page*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cases_page.no_cases_primary_cta_link
   * - **Tab**: No Cases
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  no_cases_primary_cta_link: prismic.LinkField;

  /**
   * No Cases Primary CTA Text field in *Cases Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cases_page.no_cases_primary_cta_text
   * - **Tab**: No Cases
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_cases_primary_cta_text: prismic.KeyTextField;

  /**
   * No Cases Primary CTA Style field in *Cases Page*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: cases_page.no_cases_primary_cta_style
   * - **Tab**: No Cases
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  no_cases_primary_cta_style: prismic.SelectField<
    'solid-black' | 'solid-accent' | 'solid-gray' | 'outline-gray'
  >;

  /**
   * No Cases Secondary CTA Link field in *Cases Page*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cases_page.no_cases_secondary_cta_link
   * - **Tab**: No Cases
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  no_cases_secondary_cta_link: prismic.LinkField;

  /**
   * No Cases Secondary CTA Text field in *Cases Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cases_page.no_cases_secondary_cta_text
   * - **Tab**: No Cases
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_cases_secondary_cta_text: prismic.KeyTextField;

  /**
   * No Cases Secondary CTA Style field in *Cases Page*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: cases_page.no_cases_secondary_cta_style
   * - **Tab**: No Cases
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  no_cases_secondary_cta_style: prismic.SelectField<
    'solid-black' | 'solid-accent' | 'solid-gray' | 'outline-gray'
  >;

  /**
   * No Cases Background Image field in *Cases Page*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cases_page.no_cases_background_image
   * - **Tab**: No Cases
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  no_cases_background_image: prismic.ImageField<never>;
}

/**
 * Cases Page document from Prismic
 *
 * - **API ID**: `cases_page`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type CasesPageDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<
    Simplify<CasesPageDocumentData>,
    'cases_page',
    Lang
  >;

type ConciergeaccountpageDocumentDataSlicesSlice =
  | IconBulletListSlice
  | SettingsTabSlice
  | StatsBannerSlice
  | PerksListSlice
  | MessagingCtaSectionSlice;

type ConciergeaccountpageDocumentDataSlices2Slice =
  | IconBulletListSlice
  | StatsBannerSlice
  | PerksListSlice
  | MessagingCtaSectionSlice
  | SettingsTabSlice;

/**
 * Content for ConciergeAccountPage documents
 */
interface ConciergeaccountpageDocumentData {
  /**
   * Slice Zone field in *ConciergeAccountPage*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: conciergeaccountpage.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<ConciergeaccountpageDocumentDataSlicesSlice> /**
   * Meta Description field in *ConciergeAccountPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: conciergeaccountpage.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *ConciergeAccountPage*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: conciergeaccountpage.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *ConciergeAccountPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: conciergeaccountpage.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField /**
   * Slice Zone field in *ConciergeAccountPage*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: conciergeaccountpage.slices2[]
   * - **Tab**: Subscribed
   * - **Documentation**: https://prismic.io/docs/field#slices
   */;
  slices2: prismic.SliceZone<ConciergeaccountpageDocumentDataSlices2Slice>;
}

/**
 * ConciergeAccountPage document from Prismic
 *
 * - **API ID**: `conciergeaccountpage`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type ConciergeaccountpageDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<
    Simplify<ConciergeaccountpageDocumentData>,
    'conciergeaccountpage',
    Lang
  >;

type EstheticianPageDocumentDataSlicesSlice = CalendlySchedulerSlice;

type EstheticianPageDocumentDataSlices2Slice = InfoPopoverSlice;

/**
 * Content for Esthetician Page documents
 */
interface EstheticianPageDocumentData {
  /**
   * Brand Image field in *Esthetician Page*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: esthetician_page.brand_image
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  brand_image: prismic.ImageField<never>;

  /**
   * Title field in *Esthetician Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: esthetician_page.title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Description field in *Esthetician Page*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: esthetician_page.description
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  description: prismic.RichTextField;

  /**
   * Slice Zone field in *Esthetician Page*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: esthetician_page.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<EstheticianPageDocumentDataSlicesSlice> /**
   * Meta Description field in *Esthetician Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: esthetician_page.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *Esthetician Page*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: esthetician_page.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *Esthetician Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: esthetician_page.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField /**
   * Slice Zone field in *Esthetician Page*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: esthetician_page.slices2[]
   * - **Tab**: No Concierge
   * - **Documentation**: https://prismic.io/docs/field#slices
   */;
  slices2: prismic.SliceZone<EstheticianPageDocumentDataSlices2Slice>;
}

/**
 * Esthetician Page document from Prismic
 *
 * - **API ID**: `esthetician_page`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type EstheticianPageDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<
    Simplify<EstheticianPageDocumentData>,
    'esthetician_page',
    Lang
  >;

type FooterDocumentDataSlicesSlice = FooterGroupSlice;

/**
 * Item in *Footer → Items*
 */
export interface FooterDocumentDataItemItem {
  /**
   * name field in *Footer → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.item[].name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;

  /**
   * Link field in *Footer → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.item[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Type field in *Footer → Items*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.item[].type
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  type: prismic.SelectField<'Link' | 'Text'>;

  /**
   * Prefetch field in *Footer → Items*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: true
   * - **API ID Path**: footer.item[].prefetch
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  prefetch: prismic.BooleanField;
}

/**
 * Content for Footer documents
 */
interface FooterDocumentData {
  /**
   * Image field in *Footer*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.image
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Image Link field in *Footer*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.image_link
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  image_link: prismic.LinkField;

  /**
   * Group Title Color field in *Footer*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.group_title_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  group_title_color: prismic.ColorField;

  /**
   * Group Link Color field in *Footer*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.group_link_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  group_link_color: prismic.ColorField;

  /**
   * Group Link Hover Color field in *Footer*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.group_link_hover_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  group_link_hover_color: prismic.ColorField;

  /**
   * Signup Group Title field in *Footer*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.signup_group_title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  signup_group_title: prismic.KeyTextField;

  /**
   * Signup Label field in *Footer*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.signup_label
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  signup_label: prismic.KeyTextField;

  /**
   * Signup Placeholder field in *Footer*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.signup_placeholder
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  signup_placeholder: prismic.KeyTextField;

  /**
   * Signup Button Text field in *Footer*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.signup_button_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  signup_button_text: prismic.KeyTextField;

  /**
   * Signup Label Color field in *Footer*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.signup_label_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  signup_label_color: prismic.ColorField;

  /**
   * Button Background Color field in *Footer*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.button_background_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  button_background_color: prismic.ColorField;

  /**
   * Button Background Hover Color field in *Footer*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.button_background_hover_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  button_background_hover_color: prismic.ColorField;

  /**
   * Button Text Color field in *Footer*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.button_text_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  button_text_color: prismic.ColorField;

  /**
   * Button Text Hover Color field in *Footer*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.button_text_hover_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  button_text_hover_color: prismic.ColorField;

  /**
   * Submitting Text field in *Footer*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.submitting_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  submitting_text: prismic.KeyTextField;

  /**
   * Submitted Text field in *Footer*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.submitted_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  submitted_text: prismic.KeyTextField;

  /**
   * Submission Error Text field in *Footer*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.submission_error_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  submission_error_text: prismic.KeyTextField;

  /**
   * Invalid Email Text field in *Footer*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.invalid_email_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  invalid_email_text: prismic.KeyTextField;

  /**
   * Success Color field in *Footer*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.success_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  success_color: prismic.ColorField;

  /**
   * Error Color field in *Footer*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.error_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  error_color: prismic.ColorField;

  /**
   * Slice Zone field in *Footer*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<FooterDocumentDataSlicesSlice> /**
   * Item Color field in *Footer*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.item_color
   * - **Tab**: Bottom Nav
   * - **Documentation**: https://prismic.io/docs/field#color
   */;
  item_color: prismic.ColorField;

  /**
   * Item Hover Color field in *Footer*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.item_hover_color
   * - **Tab**: Bottom Nav
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  item_hover_color: prismic.ColorField;

  /**
   * Items field in *Footer*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: footer.item[]
   * - **Tab**: Bottom Nav
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  item: prismic.GroupField<Simplify<FooterDocumentDataItemItem>>;
}

/**
 * Footer document from Prismic
 *
 * - **API ID**: `footer`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type FooterDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<
    Simplify<FooterDocumentData>,
    'footer',
    Lang
  >;

type FormDocumentDataSlicesSlice = FormSlice;

/**
 * Content for Form documents
 */
interface FormDocumentData {
  /**
   * Slice Zone field in *Form*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: form.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<FormDocumentDataSlicesSlice>;
}

/**
 * Form document from Prismic
 *
 * - **API ID**: `form`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type FormDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<Simplify<FormDocumentData>, 'form', Lang>;

/**
 * Content for Global Banner documents
 */
interface GlobalBannerDocumentData {
  /**
   * Background Color field in *Global Banner*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: global_banner.background_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color: prismic.ColorField;

  /**
   * Bottom Border Color field in *Global Banner*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: global_banner.bottom_border_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  bottom_border_color: prismic.ColorField;

  /**
   * Text Color field in *Global Banner*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: global_banner.text_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  text_color: prismic.ColorField;

  /**
   * Close X Color field in *Global Banner*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: global_banner.close_x_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  close_x_color: prismic.ColorField;

  /**
   * Icon field in *Global Banner*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: global_banner.icon
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  icon: prismic.ImageField<never>;

  /**
   * Text field in *Global Banner*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: global_banner.text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  text: prismic.RichTextField;

  /**
   * Dismissible field in *Global Banner*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: false
   * - **API ID Path**: global_banner.dismissible
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  dismissible: prismic.BooleanField;
}

/**
 * Global Banner document from Prismic
 *
 * - **API ID**: `global_banner`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type GlobalBannerDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<
    Simplify<GlobalBannerDocumentData>,
    'global_banner',
    Lang
  >;

/**
 * Item in *Help Article → Breadcrumbs*
 */
export interface HelpArticleDocumentDataBreadcrumbsItem {
  /**
   * Link field in *Help Article → Breadcrumbs*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: help_article.breadcrumbs[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Text field in *Help Article → Breadcrumbs*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: help_article.breadcrumbs[].text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  text: prismic.KeyTextField;
}

type HelpArticleDocumentDataSlicesSlice = HelpArticleSlice;

/**
 * Content for Help Article documents
 */
interface HelpArticleDocumentData {
  /**
   * Collection Tag field in *Help Article*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: help_article.collection_tag
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  collection_tag: prismic.KeyTextField;

  /**
   * Category field in *Help Article*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: help_article.category
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  category: prismic.KeyTextField;

  /**
   * Title field in *Help Article*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: help_article.title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Description field in *Help Article*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: help_article.description
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  description: prismic.KeyTextField;

  /**
   * Publication Date field in *Help Article*
   *
   * - **Field Type**: Date
   * - **Placeholder**: *None*
   * - **API ID Path**: help_article.publication_date
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#date
   */
  publication_date: prismic.DateField;

  /**
   * Order field in *Help Article*
   *
   * - **Field Type**: Number
   * - **Placeholder**: *None*
   * - **API ID Path**: help_article.order
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#number
   */
  order: prismic.NumberField;

  /**
   * Breadcrumbs field in *Help Article*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: help_article.breadcrumbs[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  breadcrumbs: prismic.GroupField<
    Simplify<HelpArticleDocumentDataBreadcrumbsItem>
  >;

  /**
   * Slice Zone field in *Help Article*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: help_article.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<HelpArticleDocumentDataSlicesSlice> /**
   * Meta Description field in *Help Article*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: help_article.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *Help Article*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: help_article.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *Help Article*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: help_article.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * Help Article document from Prismic
 *
 * - **API ID**: `help_article`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type HelpArticleDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<HelpArticleDocumentData>,
    'help_article',
    Lang
  >;

/**
 * Item in *Help Collection → Breadcrumbs*
 */
export interface HelpCollectionDocumentDataBreadcrumbsItem {
  /**
   * Link field in *Help Collection → Breadcrumbs*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: help_collection.breadcrumbs[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Text field in *Help Collection → Breadcrumbs*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: help_collection.breadcrumbs[].text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  text: prismic.KeyTextField;
}

type HelpCollectionDocumentDataSlicesSlice = never;

/**
 * Content for Help Collection documents
 */
interface HelpCollectionDocumentData {
  /**
   * Title field in *Help Collection*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: help_collection.title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Description field in *Help Collection*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: help_collection.description
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  description: prismic.KeyTextField;

  /**
   * Image field in *Help Collection*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: help_collection.image
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Collection Tag field in *Help Collection*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: help_collection.collection_tag
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  collection_tag: prismic.KeyTextField;

  /**
   * Order field in *Help Collection*
   *
   * - **Field Type**: Number
   * - **Placeholder**: *None*
   * - **API ID Path**: help_collection.order
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#number
   */
  order: prismic.NumberField;

  /**
   * Breadcrumbs field in *Help Collection*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: help_collection.breadcrumbs[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  breadcrumbs: prismic.GroupField<
    Simplify<HelpCollectionDocumentDataBreadcrumbsItem>
  >;

  /**
   * Slice Zone field in *Help Collection*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: help_collection.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<HelpCollectionDocumentDataSlicesSlice> /**
   * Meta Description field in *Help Collection*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: help_collection.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *Help Collection*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: help_collection.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *Help Collection*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: help_collection.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * Help Collection document from Prismic
 *
 * - **API ID**: `help_collection`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type HelpCollectionDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<HelpCollectionDocumentData>,
    'help_collection',
    Lang
  >;

/**
 * Item in *Help Footer → Links*
 */
export interface HelpFooterDocumentDataLinksItem {
  /**
   * Link field in *Help Footer → Links*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: help_footer.links[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Link Text field in *Help Footer → Links*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: help_footer.links[].link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  link_text: prismic.KeyTextField;
}

/**
 * Item in *Help Footer → Socials*
 */
export interface HelpFooterDocumentDataSocialsItem {
  /**
   * Social Icon field in *Help Footer → Socials*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: help_footer.socials[].social_icon
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  social_icon: prismic.ImageField<never>;

  /**
   * Social Link field in *Help Footer → Socials*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: help_footer.socials[].social_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  social_link: prismic.LinkField;
}

type HelpFooterDocumentDataSlicesSlice = never;

/**
 * Content for Help Footer documents
 */
interface HelpFooterDocumentData {
  /**
   * Logo field in *Help Footer*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: help_footer.logo
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  logo: prismic.ImageField<never>;

  /**
   * Logo Link field in *Help Footer*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: help_footer.logo_link
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  logo_link: prismic.LinkField;

  /**
   * Links field in *Help Footer*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: help_footer.links[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  links: prismic.GroupField<Simplify<HelpFooterDocumentDataLinksItem>>;

  /**
   * Socials field in *Help Footer*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: help_footer.socials[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  socials: prismic.GroupField<Simplify<HelpFooterDocumentDataSocialsItem>>;

  /**
   * Slice Zone field in *Help Footer*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: help_footer.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<HelpFooterDocumentDataSlicesSlice>;
}

/**
 * Help Footer document from Prismic
 *
 * - **API ID**: `help_footer`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type HelpFooterDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<HelpFooterDocumentData>,
    'help_footer',
    Lang
  >;

type HelpHeaderDocumentDataSlicesSlice = never;

/**
 * Content for Help Header documents
 */
interface HelpHeaderDocumentData {
  /**
   * Logo field in *Help Header*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: help_header.logo
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  logo: prismic.ImageField<never>;

  /**
   * Logo Link field in *Help Header*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: help_header.logo_link
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  logo_link: prismic.LinkField;

  /**
   * App Link field in *Help Header*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: help_header.app_link
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  app_link: prismic.LinkField;

  /**
   * App Link Text field in *Help Header*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: help_header.app_link_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  app_link_text: prismic.KeyTextField;

  /**
   * Title field in *Help Header*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: help_header.title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Slice Zone field in *Help Header*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: help_header.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<HelpHeaderDocumentDataSlicesSlice>;
}

/**
 * Help Header document from Prismic
 *
 * - **API ID**: `help_header`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type HelpHeaderDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<HelpHeaderDocumentData>,
    'help_header',
    Lang
  >;

type HelpHomeDocumentDataSlicesSlice = never;

/**
 * Content for Help Home documents
 */
interface HelpHomeDocumentData {
  /**
   * Title field in *Help Home*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: help_home.title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Slice Zone field in *Help Home*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: help_home.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<HelpHomeDocumentDataSlicesSlice> /**
   * Meta Description field in *Help Home*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: help_home.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *Help Home*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: help_home.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *Help Home*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: help_home.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * Help Home document from Prismic
 *
 * - **API ID**: `help_home`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type HelpHomeDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<
    Simplify<HelpHomeDocumentData>,
    'help_home',
    Lang
  >;

type HomeDocumentDataSlicesSlice =
  | StepsSectionSlice
  | BoxedImageWithContentSlice
  | BeforeAfterImagesSlice
  | TextAreaSlice
  | HeroCarouselSlice
  | IncentivesSlice
  | StatsBannerSlice
  | HeroSectionSlice
  | LargeQuoteSlice
  | CtaSectionSlice
  | FaqsSlice
  | LogoCloudSlice
  | TestimonialsSlice
  | VerticalTimelineSlice
  | ComparisonChartSlice;

/**
 * Content for Home documents
 */
interface HomeDocumentData {
  /**
   * body_class field in *Home*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: home.body_class
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  body_class: prismic.KeyTextField;

  /**
   * Show Navigation Header field in *Home*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: false
   * - **API ID Path**: home.show_navigation_header
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  show_navigation_header: prismic.BooleanField;

  /**
   * Initial Header Theme field in *Home*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: home.initial_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  initial_header_theme: prismic.ContentRelationshipField<'navigation'>;

  /**
   * Scroll Header Theme field in *Home*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: home.scroll_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  scroll_header_theme: prismic.ContentRelationshipField<'navigation'>;

  /**
   * Slice Zone field in *Home*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: home.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<HomeDocumentDataSlicesSlice> /**
   * Meta Description field in *Home*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: home.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *Home*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: home.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *Home*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: home.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * Home document from Prismic
 *
 * - **API ID**: `home`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type HomeDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<Simplify<HomeDocumentData>, 'home', Lang>;

type MessagingpageDocumentDataSlicesSlice = never;

/**
 * Content for MessagingPage documents
 */
interface MessagingpageDocumentData {
  /**
   * title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Case Selector All Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.case_selector_all_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  case_selector_all_text: prismic.KeyTextField;

  /**
   * Search Placeholder field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.search_placeholder
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  search_placeholder: prismic.KeyTextField;

  /**
   * Search No Results field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.search_no_results
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  search_no_results: prismic.KeyTextField;

  /**
   * Search Error Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.search_error_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  search_error_text: prismic.KeyTextField;

  /**
   * Slice Zone field in *MessagingPage*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<MessagingpageDocumentDataSlicesSlice> /**
   * Meta Description field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: messagingpage.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *MessagingPage*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: messagingpage.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField /**
   * Upload Modal Title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.upload_modal_title
   * - **Tab**: Upload Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  upload_modal_title: prismic.KeyTextField;

  /**
   * Upload Modal Description field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.upload_modal_description
   * - **Tab**: Upload Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  upload_modal_description: prismic.KeyTextField;

  /**
   * Upload Dropzone CTA Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.upload_dropzone_cta_text
   * - **Tab**: Upload Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  upload_dropzone_cta_text: prismic.KeyTextField;

  /**
   * Upload Dropzone Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.upload_dropzone_text
   * - **Tab**: Upload Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  upload_dropzone_text: prismic.KeyTextField;

  /**
   * Upload Dropzone Limits Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.upload_dropzone_limits_text
   * - **Tab**: Upload Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  upload_dropzone_limits_text: prismic.KeyTextField;

  /**
   * Upload Modal Cancel Button Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.upload_modal_cancel_button_text
   * - **Tab**: Upload Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  upload_modal_cancel_button_text: prismic.KeyTextField;

  /**
   * Upload Modal Attach Button Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.upload_modal_attach_button_text
   * - **Tab**: Upload Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  upload_modal_attach_button_text: prismic.KeyTextField;

  /**
   * Upload Failed Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.upload_failed_text
   * - **Tab**: Upload Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  upload_failed_text: prismic.KeyTextField;

  /**
   * Upload Retry Button Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.upload_retry_button_text
   * - **Tab**: Upload Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  upload_retry_button_text: prismic.KeyTextField;

  /**
   * Attach Media Error Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.attach_media_error_text
   * - **Tab**: Upload Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  attach_media_error_text: prismic.KeyTextField;

  /**
   * Upload Dropzone Invalid File Type field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.upload_dropzone_invalid_file_type
   * - **Tab**: Upload Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  upload_dropzone_invalid_file_type: prismic.KeyTextField /**
   * Message Input Placeholder field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.message_input_placeholder
   * - **Tab**: Message Input
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  message_input_placeholder: prismic.KeyTextField;

  /**
   * Message Send Error Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.message_send_error_text
   * - **Tab**: Message Input
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  message_send_error_text: prismic.KeyTextField;

  /**
   * Message Remove Media Error Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.message_remove_media_error_text
   * - **Tab**: Message Input
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  message_remove_media_error_text: prismic.KeyTextField;

  /**
   * Closed Chat Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.closed_chat_text
   * - **Tab**: Message Input
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  closed_chat_text: prismic.KeyTextField;

  /**
   * Closed Chat CTA Button Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.closed_chat_cta_button_text
   * - **Tab**: Message Input
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  closed_chat_cta_button_text: prismic.KeyTextField;

  /**
   * Access Expiring Text field in *MessagingPage*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.access_expiring_text
   * - **Tab**: Message Input
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  access_expiring_text: prismic.RichTextField;

  /**
   * Access Expiring CTA field in *MessagingPage*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.access_expiring_cta
   * - **Tab**: Message Input
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  access_expiring_cta: prismic.LinkField;

  /**
   * Access Expiring CTA Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.access_expiring_cta_text
   * - **Tab**: Message Input
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  access_expiring_cta_text: prismic.KeyTextField;

  /**
   * Access Expired Text field in *MessagingPage*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.access_expired_text
   * - **Tab**: Message Input
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  access_expired_text: prismic.RichTextField;

  /**
   * Access Expired CTA field in *MessagingPage*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.access_expired_cta
   * - **Tab**: Message Input
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  access_expired_cta: prismic.LinkField;

  /**
   * Access Expired CTA Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.access_expired_cta_text
   * - **Tab**: Message Input
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  access_expired_cta_text: prismic.KeyTextField /**
   * Error Loading Messages Title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.error_loading_messages_title
   * - **Tab**: Messages
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  error_loading_messages_title: prismic.KeyTextField;

  /**
   * Error Loading Messages Description field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.error_loading_messages_description
   * - **Tab**: Messages
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  error_loading_messages_description: prismic.KeyTextField;

  /**
   * Error Loading Messages CTA Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.error_loading_messages_cta_text
   * - **Tab**: Messages
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  error_loading_messages_cta_text: prismic.KeyTextField;

  /**
   * Fetching Next Messages Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.fetching_next_messages_text
   * - **Tab**: Messages
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  fetching_next_messages_text: prismic.KeyTextField;

  /**
   * No More Messages Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.no_more_messages_text
   * - **Tab**: Messages
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_more_messages_text: prismic.KeyTextField;

  /**
   * Media Failed To Load Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.media_failed_to_load_text
   * - **Tab**: Messages
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  media_failed_to_load_text: prismic.KeyTextField;

  /**
   * Support Message List Header field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.support_message_list_header
   * - **Tab**: Messages
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  support_message_list_header: prismic.KeyTextField;

  /**
   * Support Message Name field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.support_message_name
   * - **Tab**: Messages
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  support_message_name: prismic.KeyTextField;

  /**
   * No Messages Title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.no_messages_title
   * - **Tab**: Messages
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_messages_title: prismic.KeyTextField;

  /**
   * No Messages Support Description field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.no_messages_support_description
   * - **Tab**: Messages
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_messages_support_description: prismic.KeyTextField;

  /**
   * No Messages Medical Description field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.no_messages_medical_description
   * - **Tab**: Messages
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_messages_medical_description: prismic.KeyTextField /**
   * Select Case Modal Title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.select_case_modal_title
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  select_case_modal_title: prismic.KeyTextField;

  /**
   * Select Case Modal Description field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.select_case_modal_description
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  select_case_modal_description: prismic.KeyTextField;

  /**
   * Select Case Modal Placeholder field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.select_case_modal_placeholder
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  select_case_modal_placeholder: prismic.KeyTextField;

  /**
   * New Modal Title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.new_modal_title
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  new_modal_title: prismic.KeyTextField;

  /**
   * New Modal Description field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.new_modal_description
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  new_modal_description: prismic.KeyTextField;

  /**
   * New Modal Support CTA Title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.new_modal_support_cta_title
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  new_modal_support_cta_title: prismic.KeyTextField;

  /**
   * New Modal Support CTA Description field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.new_modal_support_cta_description
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  new_modal_support_cta_description: prismic.KeyTextField;

  /**
   * New Modal Medical CTA Link field in *MessagingPage*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.new_modal_medical_cta_link
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  new_modal_medical_cta_link: prismic.LinkField;

  /**
   * New Modal Medical CTA Title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.new_modal_medical_cta_title
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  new_modal_medical_cta_title: prismic.KeyTextField;

  /**
   * New Modal Medical CTA Description field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.new_modal_medical_cta_description
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  new_modal_medical_cta_description: prismic.KeyTextField;

  /**
   * Message Modal Support Title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.message_modal_support_title
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  message_modal_support_title: prismic.KeyTextField;

  /**
   * Message Modal Support Description field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.message_modal_support_description
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  message_modal_support_description: prismic.KeyTextField;

  /**
   * Message Modal Medical Title  field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.message_modal_medical_title
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  message_modal_medical_title: prismic.KeyTextField;

  /**
   * Message Modal Medical Description field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.message_modal_medical_description
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  message_modal_medical_description: prismic.KeyTextField;

  /**
   * Message Modal Placeholder field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.message_modal_placeholder
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  message_modal_placeholder: prismic.KeyTextField;

  /**
   * Message Modal Error Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.message_modal_error_text
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  message_modal_error_text: prismic.KeyTextField;

  /**
   * Message Modal Send Button Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.message_modal_send_button_text
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  message_modal_send_button_text: prismic.KeyTextField;

  /**
   * Message Modal Sending Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.message_modal_sending_text
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  message_modal_sending_text: prismic.KeyTextField;

  /**
   * New Message Button Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.new_message_button_text
   * - **Tab**: New Message Modal
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  new_message_button_text: prismic.KeyTextField /**
   * Threads List Header field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.threads_list_header
   * - **Tab**: Threads
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  threads_list_header: prismic.KeyTextField;

  /**
   * No Physician Thread Title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.no_physician_thread_title
   * - **Tab**: Threads
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_physician_thread_title: prismic.KeyTextField;

  /**
   * Support Thread Title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.support_thread_title
   * - **Tab**: Threads
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  support_thread_title: prismic.KeyTextField;

  /**
   * Last Message Text field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.last_message_text
   * - **Tab**: Threads
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  last_message_text: prismic.KeyTextField;

  /**
   * Support Thread Accordion Title  field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.support_thread_accordion_title
   * - **Tab**: Threads
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  support_thread_accordion_title: prismic.KeyTextField;

  /**
   * No Threads Video Link field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.no_threads_video_link
   * - **Tab**: Threads
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_threads_video_link: prismic.KeyTextField;

  /**
   * No Threads Title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.no_threads_title
   * - **Tab**: Threads
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_threads_title: prismic.KeyTextField;

  /**
   * No Threads Medical CTA field in *MessagingPage*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.no_threads_medical_cta
   * - **Tab**: Threads
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  no_threads_medical_cta: prismic.LinkField;

  /**
   * No Threads Medical CTA Title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.no_threads_medical_cta_title
   * - **Tab**: Threads
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_threads_medical_cta_title: prismic.KeyTextField;

  /**
   * No Threads Medical CTA Description field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.no_threads_medical_cta_description
   * - **Tab**: Threads
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_threads_medical_cta_description: prismic.KeyTextField;

  /**
   * No Threads Support CTA Title field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.no_threads_support_cta_title
   * - **Tab**: Threads
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_threads_support_cta_title: prismic.KeyTextField;

  /**
   * No Threads Support CTA Description field in *MessagingPage*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messagingpage.no_threads_support_cta_description
   * - **Tab**: Threads
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_threads_support_cta_description: prismic.KeyTextField;
}

/**
 * MessagingPage document from Prismic
 *
 * - **API ID**: `messagingpage`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type MessagingpageDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<MessagingpageDocumentData>,
    'messagingpage',
    Lang
  >;

type NavigationDocumentDataSlicesSlice = NavigationBarSlice;

/**
 * Content for Navigation documents
 */
interface NavigationDocumentData {
  /**
   * Background Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.background_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color: prismic.ColorField;

  /**
   * Logo field in *Navigation*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.logo
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  logo: prismic.ImageField<never>;

  /**
   * Link Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.link_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  link_color: prismic.ColorField;

  /**
   * Link Hover Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.link_hover_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  link_hover_color: prismic.ColorField;

  /**
   * Button Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.button_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  button_color: prismic.ColorField;

  /**
   * Button Hover Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.button_hover_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  button_hover_color: prismic.ColorField;

  /**
   * Button Text Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.button_text_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  button_text_color: prismic.ColorField;

  /**
   * Button Text Hover Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.button_text_hover_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  button_text_hover_color: prismic.ColorField;

  /**
   * Mobile Button Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.mobile_button_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  mobile_button_color: prismic.ColorField;

  /**
   * Mobile Button Hover Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.mobile_button_active_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  mobile_button_active_color: prismic.ColorField;

  /**
   * Mobile Button Text Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.mobile_button_text_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  mobile_button_text_color: prismic.ColorField;

  /**
   * Mobile Button Text Hover Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.mobile_button_text_hover_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  mobile_button_text_hover_color: prismic.ColorField;

  /**
   * Popover Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.popover_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  popover_color: prismic.ColorField;

  /**
   * Popover Hover Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.popover_hover_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  popover_hover_color: prismic.ColorField;

  /**
   * Popover Link Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.popover_link_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  popover_link_color: prismic.ColorField;

  /**
   * Popover Link Hover Color field in *Navigation*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.popover_link_hover_color
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  popover_link_hover_color: prismic.ColorField;

  /**
   * Slice Zone field in *Navigation*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<NavigationDocumentDataSlicesSlice>;
}

/**
 * Navigation document from Prismic
 *
 * - **API ID**: `navigation`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type NavigationDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<NavigationDocumentData>,
    'navigation',
    Lang
  >;

type OrderHistoryDocumentDataSlicesSlice = OrderHistorySlice;

/**
 * Content for Order History documents
 */
interface OrderHistoryDocumentData {
  /**
   * Slice Zone field in *Order History*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: order_history.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<OrderHistoryDocumentDataSlicesSlice>;
}

/**
 * Order History document from Prismic
 *
 * - **API ID**: `order_history`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type OrderHistoryDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<OrderHistoryDocumentData>,
    'order_history',
    Lang
  >;

type PageDocumentDataSlicesSlice =
  | FormSlice
  | CenteredProductCardsSlice
  | CenteredIconBulletListSlice
  | BoxedImageWithContentSlice
  | CenteredRichTextSlice
  | VideoHighlightSlice
  | TextBannerSlice
  | DiscoverTretinoinSlice
  | StepsSectionSlice
  | BeforeAfterImagesSlice
  | InfoTabsSlice
  | TextAreaSlice
  | HeroCarouselSlice
  | HeroSectionSlice
  | IncentivesSlice
  | StatsBannerSlice
  | LogoCloudSlice
  | FaqsSlice
  | LargeQuoteSlice
  | CtaSectionSlice
  | TestimonialsSlice
  | VerticalTimelineSlice
  | ComparisonChartSlice;

/**
 * Content for Page documents
 */
interface PageDocumentData {
  /**
   * Show Navigation Header field in *Page*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: false
   * - **API ID Path**: page.show_navigation_header
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  show_navigation_header: prismic.BooleanField;

  /**
   * Initial Header Theme field in *Page*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: page.initial_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  initial_header_theme: prismic.ContentRelationshipField<'navigation'>;

  /**
   * Scroll Header Theme field in *Page*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: page.scroll_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  scroll_header_theme: prismic.ContentRelationshipField<'navigation'>;

  /**
   * Slice Zone field in *Page*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: page.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<PageDocumentDataSlicesSlice> /**
   * Meta Description field in *Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: page.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *Page*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: page.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: page.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * Page document from Prismic
 *
 * - **API ID**: `page`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type PageDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<Simplify<PageDocumentData>, 'page', Lang>;

/**
 * Item in *Product Page → Breadcrumbs*
 */
export interface ProductPageDocumentDataBreadcrumbsItem {
  /**
   * Link field in *Product Page → Breadcrumbs*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.breadcrumbs[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Name field in *Product Page → Breadcrumbs*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.breadcrumbs[].name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;
}

/**
 * Item in *Product Page → Mobile Breadcrumbs*
 */
export interface ProductPageDocumentDataMobileBreadcrumbsItem {
  /**
   * Link field in *Product Page → Mobile Breadcrumbs*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.mobile_breadcrumbs[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Name field in *Product Page → Mobile Breadcrumbs*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.mobile_breadcrumbs[].name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;
}

/**
 * Item in *Product Page → Tags*
 */
export interface ProductPageDocumentDataTagsItem {
  /**
   * Tag field in *Product Page → Tags*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.tags[].tag
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  tag: prismic.KeyTextField;
}

type ProductPageDocumentDataSlicesSlice =
  | MessagingCtaSectionSlice
  | AccountQuoteSlice
  | SubscribeSectionSlice
  | ProductSuggestionsSlice
  | ContentSlice
  | IncentivesSlice
  | ProductSlice;

/**
 * Content for Product Page documents
 */
interface ProductPageDocumentData {
  /**
   * Product ID field in *Product Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.product_id
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  product_id: prismic.KeyTextField;

  /**
   * Dev Product ID field in *Product Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.dev_product_id
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  dev_product_id: prismic.KeyTextField;

  /**
   * Thumbnail field in *Product Page*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.thumbnail
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  thumbnail: prismic.ImageField<never>;

  /**
   * Name field in *Product Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.name
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;

  /**
   * Type field in *Product Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.type
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  type: prismic.KeyTextField;

  /**
   * Initial Header Theme field in *Product Page*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.initial_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  initial_header_theme: prismic.ContentRelationshipField<'navigation'>;

  /**
   * Scroll Header Theme field in *Product Page*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.scroll_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  scroll_header_theme: prismic.ContentRelationshipField<'navigation'>;

  /**
   * Page Title field in *Product Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.page_title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  page_title: prismic.KeyTextField;

  /**
   * Breadcrumbs field in *Product Page*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.breadcrumbs[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  breadcrumbs: prismic.GroupField<
    Simplify<ProductPageDocumentDataBreadcrumbsItem>
  >;

  /**
   * Mobile Breadcrumbs field in *Product Page*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.mobile_breadcrumbs[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  mobile_breadcrumbs: prismic.GroupField<
    Simplify<ProductPageDocumentDataMobileBreadcrumbsItem>
  >;

  /**
   * Tags field in *Product Page*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.tags[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  tags: prismic.GroupField<Simplify<ProductPageDocumentDataTagsItem>>;

  /**
   * Is Shop Product field in *Product Page*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: false
   * - **API ID Path**: product_page.is_shop_product
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  is_shop_product: prismic.BooleanField;

  /**
   * Slice Zone field in *Product Page*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<ProductPageDocumentDataSlicesSlice> /**
   * Meta Description field in *Product Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: product_page.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *Product Page*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: product_page.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *Product Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: product_page.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * Product Page document from Prismic
 *
 * - **API ID**: `product_page`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type ProductPageDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<ProductPageDocumentData>,
    'product_page',
    Lang
  >;

type ShopCartDocumentDataSlicesSlice = never;

/**
 * Content for Shop Cart documents
 */
interface ShopCartDocumentData {
  /**
   * Title field in *Shop Cart*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_cart.title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Quantity Text field in *Shop Cart*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_cart.quantity_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  quantity_text: prismic.KeyTextField;

  /**
   * Remove Button Text field in *Shop Cart*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_cart.remove_button_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  remove_button_text: prismic.KeyTextField;

  /**
   * Checkout Link field in *Shop Cart*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_cart.checkout_link
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  checkout_link: prismic.LinkField;

  /**
   * Checkout Link Text field in *Shop Cart*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_cart.checkout_link_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  checkout_link_text: prismic.KeyTextField;

  /**
   * Cart Update Error Text field in *Shop Cart*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_cart.cart_update_error_text
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cart_update_error_text: prismic.KeyTextField;

  /**
   * Slice Zone field in *Shop Cart*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_cart.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<ShopCartDocumentDataSlicesSlice>;
}

/**
 * Shop Cart document from Prismic
 *
 * - **API ID**: `shop_cart`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type ShopCartDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<
    Simplify<ShopCartDocumentData>,
    'shop_cart',
    Lang
  >;

/**
 * Item in *Shop Home → Breadcrumbs*
 */
export interface ShopHomeDocumentDataBreadcrumbsItem {
  /**
   * Link field in *Shop Home → Breadcrumbs*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_home.breadcrumbs[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Name field in *Shop Home → Breadcrumbs*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_home.breadcrumbs[].name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;
}

/**
 * Item in *Shop Home → Mobile Breadcrumbs*
 */
export interface ShopHomeDocumentDataMobileBreadcrumbsItem {
  /**
   * Link field in *Shop Home → Mobile Breadcrumbs*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_home.mobile_breadcrumbs[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Name field in *Shop Home → Mobile Breadcrumbs*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_home.mobile_breadcrumbs[].name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;
}

type ShopHomeDocumentDataSlicesSlice =
  | MessagingCtaSectionSlice
  | SubscribeSectionSlice
  | AccountQuoteSlice
  | IncentivesSlice
  | FeaturedCollectionSlice
  | CtaSectionSlice
  | AccountHeroSlice;

/**
 * Content for Shop Home documents
 */
interface ShopHomeDocumentData {
  /**
   * Initial Header Theme field in *Shop Home*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_home.initial_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  initial_header_theme: prismic.ContentRelationshipField<'navigation'>;

  /**
   * Scroll Header Theme field in *Shop Home*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_home.scroll_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  scroll_header_theme: prismic.ContentRelationshipField<'navigation'>;

  /**
   * Page Title field in *Shop Home*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_home.page_title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  page_title: prismic.KeyTextField;

  /**
   * Breadcrumbs field in *Shop Home*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_home.breadcrumbs[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  breadcrumbs: prismic.GroupField<
    Simplify<ShopHomeDocumentDataBreadcrumbsItem>
  >;

  /**
   * Mobile Breadcrumbs field in *Shop Home*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_home.mobile_breadcrumbs[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  mobile_breadcrumbs: prismic.GroupField<
    Simplify<ShopHomeDocumentDataMobileBreadcrumbsItem>
  >;

  /**
   * Slice Zone field in *Shop Home*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_home.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<ShopHomeDocumentDataSlicesSlice> /**
   * Meta Description field in *Shop Home*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: shop_home.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *Shop Home*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_home.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *Shop Home*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: shop_home.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * Shop Home document from Prismic
 *
 * - **API ID**: `shop_home`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type ShopHomeDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<
    Simplify<ShopHomeDocumentData>,
    'shop_home',
    Lang
  >;

/**
 * Item in *Shop Page → Breadcrumbs*
 */
export interface ShopPageDocumentDataBreadcrumbsItem {
  /**
   * Link field in *Shop Page → Breadcrumbs*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_page.breadcrumbs[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Name field in *Shop Page → Breadcrumbs*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_page.breadcrumbs[].name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;
}

/**
 * Item in *Shop Page → Mobile Breadcrumbs*
 */
export interface ShopPageDocumentDataMobileBreadcrumbsItem {
  /**
   * Link field in *Shop Page → Mobile Breadcrumbs*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_page.mobile_breadcrumbs[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Name field in *Shop Page → Mobile Breadcrumbs*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_page.mobile_breadcrumbs[].name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;
}

type ShopPageDocumentDataSlicesSlice =
  | OrderConfirmationSlice
  | CheckoutSlice
  | SubscribeSectionSlice
  | AccountQuoteSlice
  | AccountHeroSlice
  | IncentivesSlice
  | ProductsListSlice;

/**
 * Content for Shop Page documents
 */
interface ShopPageDocumentData {
  /**
   * Initial Header Theme field in *Shop Page*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_page.initial_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  initial_header_theme: prismic.ContentRelationshipField<'navigation'>;

  /**
   * Scroll Header Theme field in *Shop Page*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_page.scroll_header_theme
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  scroll_header_theme: prismic.ContentRelationshipField<'navigation'>;

  /**
   * Page Title field in *Shop Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_page.page_title
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  page_title: prismic.KeyTextField;

  /**
   * Breadcrumbs field in *Shop Page*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_page.breadcrumbs[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  breadcrumbs: prismic.GroupField<
    Simplify<ShopPageDocumentDataBreadcrumbsItem>
  >;

  /**
   * Mobile Breadcrumbs field in *Shop Page*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_page.mobile_breadcrumbs[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  mobile_breadcrumbs: prismic.GroupField<
    Simplify<ShopPageDocumentDataMobileBreadcrumbsItem>
  >;

  /**
   * Slice Zone field in *Shop Page*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_page.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<ShopPageDocumentDataSlicesSlice> /**
   * Meta Description field in *Shop Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: shop_page.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *Shop Page*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: shop_page.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *Shop Page*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: shop_page.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * Shop Page document from Prismic
 *
 * - **API ID**: `shop_page`
 * - **Repeatable**: `true`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type ShopPageDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<ShopPageDocumentData>,
    'shop_page',
    Lang
  >;

/**
 * Item in *Signin → Partner*
 */
export interface SigninDocumentDataPartnerDataItem {
  /**
   * Partner Name field in *Signin → Partner*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.partner_data[].partner_name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  partner_name: prismic.KeyTextField;

  /**
   * Partner Banner Text field in *Signin → Partner*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.partner_data[].partner_banner_text
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  partner_banner_text: prismic.RichTextField;

  /**
   * Partner Banner Background field in *Signin → Partner*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.partner_data[].partner_banner_background
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  partner_banner_background: prismic.ColorField;

  /**
   * Partner Banner Text Color field in *Signin → Partner*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.partner_data[].partner_banner_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  partner_banner_text_color: prismic.ColorField;

  /**
   * Partner Hero Image field in *Signin → Partner*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.partner_data[].partner_hero_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  partner_hero_image: prismic.ImageField<never>;
}

/**
 * Item in *Signin → Hero Images*
 */
export interface SigninDocumentDataHeroImagesItem {
  /**
   * Hero Image field in *Signin → Hero Images*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.hero_images[].hero_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  hero_image: prismic.ImageField<never>;
}

type SigninDocumentDataSlicesSlice = never;

/**
 * Content for Signin documents
 */
interface SigninDocumentData {
  /**
   * Partner field in *Signin*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.partner_data[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  partner_data: prismic.GroupField<Simplify<SigninDocumentDataPartnerDataItem>>;

  /**
   * Hero Images field in *Signin*
   *
   * - **Field Type**: Group
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.hero_images[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#group
   */
  hero_images: prismic.GroupField<Simplify<SigninDocumentDataHeroImagesItem>>;

  /**
   * Button: Login field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.button_login
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  button_login: prismic.KeyTextField;

  /**
   * Button: Signup field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.button_signup
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  button_signup: prismic.KeyTextField;

  /**
   * Button: Signin with Google field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.button_signin_with_google
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  button_signin_with_google: prismic.KeyTextField;

  /**
   * Button: Forgot Password field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.button_forgot_password
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  button_forgot_password: prismic.KeyTextField;

  /**
   * Button: Confirm Account field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.button_confirm_account
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  button_confirm_account: prismic.KeyTextField;

  /**
   * Button: Reset Password field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.button_reset_password
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  button_reset_password: prismic.KeyTextField;

  /**
   * Button: Request New Code field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.button_request_new_code
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  button_request_new_code: prismic.KeyTextField;

  /**
   * Button: Request Password Reset Code field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.button_request_password_reset_code
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  button_request_password_reset_code: prismic.KeyTextField;

  /**
   * Button: Back to Signin field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.button_back_to_signin
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  button_back_to_signin: prismic.KeyTextField;

  /**
   * Label: Email address field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.label_email_address
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  label_email_address: prismic.KeyTextField;

  /**
   * Label: Password field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.label_password
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  label_password: prismic.KeyTextField;

  /**
   * Label: Confirm Password field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.label_confirm_password
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  label_confirm_password: prismic.KeyTextField;

  /**
   * Label: Confirmation Code field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.label_confirmation_code
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  label_confirmation_code: prismic.KeyTextField;

  /**
   * Slice Zone field in *Signin*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<SigninDocumentDataSlicesSlice> /**
   * Meta Description field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A brief summary of the page
   * - **API ID Path**: signin.meta_description
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */;
  meta_description: prismic.KeyTextField;

  /**
   * Meta Image field in *Signin*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: signin.meta_image
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  meta_image: prismic.ImageField<never>;

  /**
   * Meta Title field in *Signin*
   *
   * - **Field Type**: Text
   * - **Placeholder**: A title of the page used for social media and search engines
   * - **API ID Path**: signin.meta_title
   * - **Tab**: SEO & Metadata
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  meta_title: prismic.KeyTextField;
}

/**
 * Signin document from Prismic
 *
 * - **API ID**: `signin`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type SigninDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithoutUID<
    Simplify<SigninDocumentData>,
    'signin',
    Lang
  >;

type SubscriptionsDocumentDataSlicesSlice = SubscriptionPlanSlice;

/**
 * Content for Subscriptions documents
 */
interface SubscriptionsDocumentData {
  /**
   * Slice Zone field in *Subscriptions*
   *
   * - **Field Type**: Slice Zone
   * - **Placeholder**: *None*
   * - **API ID Path**: subscriptions.slices[]
   * - **Tab**: Main
   * - **Documentation**: https://prismic.io/docs/field#slices
   */
  slices: prismic.SliceZone<SubscriptionsDocumentDataSlicesSlice>;
}

/**
 * Subscriptions document from Prismic
 *
 * - **API ID**: `subscriptions`
 * - **Repeatable**: `false`
 * - **Documentation**: https://prismic.io/docs/custom-types
 *
 * @typeParam Lang - Language API ID of the document.
 */
export type SubscriptionsDocument<Lang extends string = string> =
  prismic.PrismicDocumentWithUID<
    Simplify<SubscriptionsDocumentData>,
    'subscriptions',
    Lang
  >;

export type AllDocumentTypes =
  | AccountNavigationDocument
  | AccountNextStepsSectionDocument
  | AccounthomeDocument
  | AccountpageDocument
  | BillingDocument
  | BlogAdCardDocument
  | BlogAuthorDocument
  | BlogNewsletterDocument
  | BlogSearchDocument
  | BlogTagDocument
  | BlogauthorDocument
  | BlogcategoryDocument
  | BloghomeDocument
  | BlogpostDocument
  | CasesPageDocument
  | ConciergeaccountpageDocument
  | EstheticianPageDocument
  | FooterDocument
  | FormDocument
  | GlobalBannerDocument
  | HelpArticleDocument
  | HelpCollectionDocument
  | HelpFooterDocument
  | HelpHeaderDocument
  | HelpHomeDocument
  | HomeDocument
  | MessagingpageDocument
  | NavigationDocument
  | OrderHistoryDocument
  | PageDocument
  | ProductPageDocument
  | ShopCartDocument
  | ShopHomeDocument
  | ShopPageDocument
  | SigninDocument
  | SubscriptionsDocument;

/**
 * Primary content in *AccountHero → Primary*
 */
export interface AccountHeroSliceDefaultPrimary {
  /**
   * Header field in *AccountHero → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_hero.primary.header
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  header: prismic.KeyTextField;

  /**
   * Subheader field in *AccountHero → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_hero.primary.subheader
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subheader: prismic.KeyTextField;

  /**
   * Image Female field in *AccountHero → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: account_hero.primary.image_female
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image_female: prismic.ImageField<never>;

  /**
   * Image Male field in *AccountHero → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: account_hero.primary.image_male
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image_male: prismic.ImageField<never>;
}

/**
 * Default variation for AccountHero Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type AccountHeroSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<AccountHeroSliceDefaultPrimary>,
  never
>;

/**
 * Primary content in *AccountHero → Primary*
 */
export interface AccountHeroSliceHeroCenteredTitlePrimary {
  /**
   * Header field in *AccountHero → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_hero.primary.header
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  header: prismic.KeyTextField;

  /**
   * Image field in *AccountHero → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: account_hero.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;
}

/**
 * HeroCenteredTitle variation for AccountHero Slice
 *
 * - **API ID**: `heroCenteredTitle`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type AccountHeroSliceHeroCenteredTitle = prismic.SharedSliceVariation<
  'heroCenteredTitle',
  Simplify<AccountHeroSliceHeroCenteredTitlePrimary>,
  never
>;

/**
 * Primary content in *AccountHero → Primary*
 */
export interface AccountHeroSliceHeroImageTitlePrimary {
  /**
   * Title Image field in *AccountHero → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: account_hero.primary.title_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  title_image: prismic.ImageField<never>;

  /**
   * Image field in *AccountHero → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: account_hero.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;
}

/**
 * HeroImageTitle variation for AccountHero Slice
 *
 * - **API ID**: `heroImageTitle`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type AccountHeroSliceHeroImageTitle = prismic.SharedSliceVariation<
  'heroImageTitle',
  Simplify<AccountHeroSliceHeroImageTitlePrimary>,
  never
>;

/**
 * Slice variation for *AccountHero*
 */
type AccountHeroSliceVariation =
  | AccountHeroSliceDefault
  | AccountHeroSliceHeroCenteredTitle
  | AccountHeroSliceHeroImageTitle;

/**
 * AccountHero Shared Slice
 *
 * - **API ID**: `account_hero`
 * - **Description**: AccountHero
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type AccountHeroSlice = prismic.SharedSlice<
  'account_hero',
  AccountHeroSliceVariation
>;

/**
 * Primary content in *AccountNotifications → Primary*
 */
export interface AccountNotificationsSliceDefaultPrimary {
  /**
   * Title field in *AccountNotifications → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_notifications.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;
}

/**
 * Default variation for AccountNotifications Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type AccountNotificationsSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<AccountNotificationsSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *AccountNotifications*
 */
type AccountNotificationsSliceVariation = AccountNotificationsSliceDefault;

/**
 * AccountNotifications Shared Slice
 *
 * - **API ID**: `account_notifications`
 * - **Description**: AccountNotifications
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type AccountNotificationsSlice = prismic.SharedSlice<
  'account_notifications',
  AccountNotificationsSliceVariation
>;

/**
 * Primary content in *AccountQuote → Primary*
 */
export interface AccountQuoteSliceDefaultPrimary {
  /**
   * Quote field in *AccountQuote → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_quote.primary.quote
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  quote: prismic.KeyTextField;

  /**
   * Name field in *AccountQuote → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: account_quote.primary.name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;
}

/**
 * Default variation for AccountQuote Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type AccountQuoteSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<AccountQuoteSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *AccountQuote*
 */
type AccountQuoteSliceVariation = AccountQuoteSliceDefault;

/**
 * AccountQuote Shared Slice
 *
 * - **API ID**: `account_quote`
 * - **Description**: AccountQuote
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type AccountQuoteSlice = prismic.SharedSlice<
  'account_quote',
  AccountQuoteSliceVariation
>;

/**
 * Primary content in *BeforeAfterImages → Primary*
 */
export interface BeforeAfterImagesSliceDefaultPrimary {
  /**
   * Title field in *BeforeAfterImages → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Stat 1 Title field in *BeforeAfterImages → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.primary.stat_1_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  stat_1_title: prismic.KeyTextField;

  /**
   * Stat 1 Subtitle field in *BeforeAfterImages → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.primary.stat_1_subtitle
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  stat_1_subtitle: prismic.KeyTextField;

  /**
   * Stat 2 Title field in *BeforeAfterImages → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.primary.stat_2_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  stat_2_title: prismic.KeyTextField;

  /**
   * Stat 2 Subtitle field in *BeforeAfterImages → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.primary.stat_2_subtitle
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  stat_2_subtitle: prismic.KeyTextField;

  /**
   * Stat 3 Title field in *BeforeAfterImages → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.primary.stat_3_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  stat_3_title: prismic.KeyTextField;

  /**
   * Stat 3 Subtitle field in *BeforeAfterImages → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.primary.stat_3_subtitle
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  stat_3_subtitle: prismic.KeyTextField;
}

/**
 * Primary content in *BeforeAfterImages → Items*
 */
export interface BeforeAfterImagesSliceDefaultItem {
  /**
   * Before Image field in *BeforeAfterImages → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.items[].before_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  before_image: prismic.ImageField<never>;

  /**
   * After Image field in *BeforeAfterImages → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.items[].after_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  after_image: prismic.ImageField<never>;
}

/**
 * Default variation for BeforeAfterImages Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type BeforeAfterImagesSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<BeforeAfterImagesSliceDefaultPrimary>,
  Simplify<BeforeAfterImagesSliceDefaultItem>
>;

/**
 * Primary content in *BeforeAfterImages → Primary*
 */
export interface BeforeAfterImagesSliceTretinoinPrimary {
  /**
   * Title field in *BeforeAfterImages → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.primary.title
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  title: prismic.RichTextField;

  /**
   * Title Image field in *BeforeAfterImages → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.primary.title_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  title_image: prismic.ImageField<never>;

  /**
   * Content field in *BeforeAfterImages → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * CTA Link field in *BeforeAfterImages → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Link Text field in *BeforeAfterImages → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.primary.cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_link_text: prismic.KeyTextField;
}

/**
 * Primary content in *BeforeAfterImages → Items*
 */
export interface BeforeAfterImagesSliceTretinoinItem {
  /**
   * Before Image field in *BeforeAfterImages → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.items[].before_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  before_image: prismic.ImageField<never>;

  /**
   * After Image field in *BeforeAfterImages → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: before_after_images.items[].after_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  after_image: prismic.ImageField<never>;
}

/**
 * Tretinoin variation for BeforeAfterImages Slice
 *
 * - **API ID**: `tretinoin`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type BeforeAfterImagesSliceTretinoin = prismic.SharedSliceVariation<
  'tretinoin',
  Simplify<BeforeAfterImagesSliceTretinoinPrimary>,
  Simplify<BeforeAfterImagesSliceTretinoinItem>
>;

/**
 * Slice variation for *BeforeAfterImages*
 */
type BeforeAfterImagesSliceVariation =
  | BeforeAfterImagesSliceDefault
  | BeforeAfterImagesSliceTretinoin;

/**
 * BeforeAfterImages Shared Slice
 *
 * - **API ID**: `before_after_images`
 * - **Description**: BeforeAfterImages
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type BeforeAfterImagesSlice = prismic.SharedSlice<
  'before_after_images',
  BeforeAfterImagesSliceVariation
>;

/**
 * Primary content in *BillingHistory → Primary*
 */
export interface BillingHistorySliceDefaultPrimary {
  /**
   * Title field in *BillingHistory → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: billing_history.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Description field in *BillingHistory → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: billing_history.primary.description
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  description: prismic.KeyTextField;

  /**
   * Table Heading 1 field in *BillingHistory → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: billing_history.primary.table_heading_1
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  table_heading_1: prismic.KeyTextField;

  /**
   * Table Heading 2 field in *BillingHistory → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: billing_history.primary.table_heading_2
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  table_heading_2: prismic.KeyTextField;

  /**
   * Table Heading 3 field in *BillingHistory → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: billing_history.primary.table_heading_3
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  table_heading_3: prismic.KeyTextField;

  /**
   * Table Heading 4 field in *BillingHistory → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: billing_history.primary.table_heading_4
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  table_heading_4: prismic.KeyTextField;

  /**
   * Previous Button Text field in *BillingHistory → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: billing_history.primary.previous_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  previous_button_text: prismic.KeyTextField;

  /**
   * Next Button Text field in *BillingHistory → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: billing_history.primary.next_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  next_button_text: prismic.KeyTextField;

  /**
   * No History Title field in *BillingHistory → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: billing_history.primary.no_history_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_history_title: prismic.KeyTextField;

  /**
   * No History Description field in *BillingHistory → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: billing_history.primary.no_history_description
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_history_description: prismic.KeyTextField;

  /**
   * Pagination Results Text field in *BillingHistory → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: billing_history.primary.pagination_results_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  pagination_results_text: prismic.KeyTextField;
}

/**
 * Default variation for BillingHistory Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type BillingHistorySliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<BillingHistorySliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *BillingHistory*
 */
type BillingHistorySliceVariation = BillingHistorySliceDefault;

/**
 * BillingHistory Shared Slice
 *
 * - **API ID**: `billing_history`
 * - **Description**: BillingHistory
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type BillingHistorySlice = prismic.SharedSlice<
  'billing_history',
  BillingHistorySliceVariation
>;

/**
 * Primary content in *BlogArticle → Primary*
 */
export interface BlogArticleSliceDefaultPrimary {
  /**
   * Hero Image field in *BlogArticle → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_article.primary.hero_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  hero_image: prismic.ImageField<never>;

  /**
   * Content field in *BlogArticle → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_article.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;
}

/**
 * Default variation for BlogArticle Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type BlogArticleSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<BlogArticleSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *BlogArticle*
 */
type BlogArticleSliceVariation = BlogArticleSliceDefault;

/**
 * BlogArticle Shared Slice
 *
 * - **API ID**: `blog_article`
 * - **Description**: BlogArticle
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type BlogArticleSlice = prismic.SharedSlice<
  'blog_article',
  BlogArticleSliceVariation
>;

/**
 * Primary content in *BlogCategorySection → Primary*
 */
export interface BlogCategorySectionSliceDefaultPrimary {
  /**
   * Category field in *BlogCategorySection → Primary*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_category_section.primary.category
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  category: prismic.ContentRelationshipField<'blogcategory'>;

  /**
   * Background Color field in *BlogCategorySection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_category_section.primary.background_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color: prismic.ColorField;
}

/**
 * Primary content in *BlogCategorySection → Items*
 */
export interface BlogCategorySectionSliceDefaultItem {
  /**
   * Content Card field in *BlogCategorySection → Items*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_category_section.items[].content_card
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  content_card: prismic.ContentRelationshipField<
    'blogpost' | 'blog_ad_card' | 'blog_newsletter'
  >;
}

/**
 * Default variation for BlogCategorySection Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type BlogCategorySectionSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<BlogCategorySectionSliceDefaultPrimary>,
  Simplify<BlogCategorySectionSliceDefaultItem>
>;

/**
 * Slice variation for *BlogCategorySection*
 */
type BlogCategorySectionSliceVariation = BlogCategorySectionSliceDefault;

/**
 * BlogCategorySection Shared Slice
 *
 * - **API ID**: `blog_category_section`
 * - **Description**: BlogCategorySection
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type BlogCategorySectionSlice = prismic.SharedSlice<
  'blog_category_section',
  BlogCategorySectionSliceVariation
>;

/**
 * Primary content in *BlogCtaBanner → Primary*
 */
export interface BlogCtaBannerSliceDefaultPrimary {
  /**
   * Image field in *BlogCtaBanner → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_cta_banner.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Text field in *BlogCtaBanner → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_cta_banner.primary.text
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  text: prismic.RichTextField;

  /**
   * CTA Link field in *BlogCtaBanner → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_cta_banner.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Link Text field in *BlogCtaBanner → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_cta_banner.primary.cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_link_text: prismic.KeyTextField;

  /**
   * Background Color field in *BlogCtaBanner → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_cta_banner.primary.background_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color: prismic.ColorField;

  /**
   * CTA Button Color field in *BlogCtaBanner → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_cta_banner.primary.cta_button_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_color: prismic.ColorField;

  /**
   * CTA Link Color field in *BlogCtaBanner → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_cta_banner.primary.cta_link_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_link_color: prismic.ColorField;

  /**
   * Text Color field in *BlogCtaBanner → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_cta_banner.primary.text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  text_color: prismic.ColorField;
}

/**
 * Default variation for BlogCtaBanner Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type BlogCtaBannerSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<BlogCtaBannerSliceDefaultPrimary>,
  never
>;

/**
 * Primary content in *BlogCtaBanner → Primary*
 */
export interface BlogCtaBannerSliceImageBannerPrimary {
  /**
   * Image field in *BlogCtaBanner → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_cta_banner.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Mobile Image field in *BlogCtaBanner → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_cta_banner.primary.mobile_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  mobile_image: prismic.ImageField<never>;

  /**
   * CTA Link field in *BlogCtaBanner → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: blog_cta_banner.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;
}

/**
 * ImageBanner variation for BlogCtaBanner Slice
 *
 * - **API ID**: `imageBanner`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type BlogCtaBannerSliceImageBanner = prismic.SharedSliceVariation<
  'imageBanner',
  Simplify<BlogCtaBannerSliceImageBannerPrimary>,
  never
>;

/**
 * Slice variation for *BlogCtaBanner*
 */
type BlogCtaBannerSliceVariation =
  | BlogCtaBannerSliceDefault
  | BlogCtaBannerSliceImageBanner;

/**
 * BlogCtaBanner Shared Slice
 *
 * - **API ID**: `blog_cta_banner`
 * - **Description**: BlogCtaBanner
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type BlogCtaBannerSlice = prismic.SharedSlice<
  'blog_cta_banner',
  BlogCtaBannerSliceVariation
>;

/**
 * Primary content in *BoxedImageWithContent → Primary*
 */
export interface BoxedImageWithContentSliceDefaultPrimary {
  /**
   * Box Color field in *BoxedImageWithContent → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: boxed_image_with_content.primary.box_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  box_color: prismic.ColorField;

  /**
   * Image Alignment field in *BoxedImageWithContent → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: boxed_image_with_content.primary.image_alignment
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  image_alignment: prismic.SelectField<'right' | 'left'>;

  /**
   * Title field in *BoxedImageWithContent → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: boxed_image_with_content.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Content field in *BoxedImageWithContent → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: boxed_image_with_content.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * CTA Link field in *BoxedImageWithContent → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: boxed_image_with_content.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Link Text field in *BoxedImageWithContent → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: boxed_image_with_content.primary.cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_link_text: prismic.KeyTextField;

  /**
   * Image field in *BoxedImageWithContent → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: boxed_image_with_content.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;
}

/**
 * Default variation for BoxedImageWithContent Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type BoxedImageWithContentSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<BoxedImageWithContentSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *BoxedImageWithContent*
 */
type BoxedImageWithContentSliceVariation = BoxedImageWithContentSliceDefault;

/**
 * BoxedImageWithContent Shared Slice
 *
 * - **API ID**: `boxed_image_with_content`
 * - **Description**: BoxedImageWithContent
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type BoxedImageWithContentSlice = prismic.SharedSlice<
  'boxed_image_with_content',
  BoxedImageWithContentSliceVariation
>;

/**
 * Primary content in *CalendlyScheduler → Primary*
 */
export interface CalendlySchedulerSliceDefaultPrimary {
  /**
   * URL field in *CalendlyScheduler → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: calendly_scheduler.primary.url
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  url: prismic.KeyTextField;
}

/**
 * Default variation for CalendlyScheduler Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CalendlySchedulerSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<CalendlySchedulerSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *CalendlyScheduler*
 */
type CalendlySchedulerSliceVariation = CalendlySchedulerSliceDefault;

/**
 * CalendlyScheduler Shared Slice
 *
 * - **API ID**: `calendly_scheduler`
 * - **Description**: CalendlyScheduler
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CalendlySchedulerSlice = prismic.SharedSlice<
  'calendly_scheduler',
  CalendlySchedulerSliceVariation
>;

/**
 * Primary content in *CenteredIconBulletList → Primary*
 */
export interface CenteredIconBulletListSliceDefaultPrimary {
  /**
   * Title field in *CenteredIconBulletList → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_icon_bullet_list.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Background Color Start field in *CenteredIconBulletList → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_icon_bullet_list.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CenteredIconBulletList → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_icon_bullet_list.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;
}

/**
 * Primary content in *CenteredIconBulletList → Items*
 */
export interface CenteredIconBulletListSliceDefaultItem {
  /**
   * Icon field in *CenteredIconBulletList → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_icon_bullet_list.items[].icon
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  icon: prismic.ImageField<never>;

  /**
   * Header field in *CenteredIconBulletList → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_icon_bullet_list.items[].header
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  header: prismic.KeyTextField;

  /**
   * Subheader field in *CenteredIconBulletList → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_icon_bullet_list.items[].subheader
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subheader: prismic.KeyTextField;
}

/**
 * Default variation for CenteredIconBulletList Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CenteredIconBulletListSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<CenteredIconBulletListSliceDefaultPrimary>,
  Simplify<CenteredIconBulletListSliceDefaultItem>
>;

/**
 * Slice variation for *CenteredIconBulletList*
 */
type CenteredIconBulletListSliceVariation = CenteredIconBulletListSliceDefault;

/**
 * CenteredIconBulletList Shared Slice
 *
 * - **API ID**: `centered_icon_bullet_list`
 * - **Description**: CenteredIconBulletList
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CenteredIconBulletListSlice = prismic.SharedSlice<
  'centered_icon_bullet_list',
  CenteredIconBulletListSliceVariation
>;

/**
 * Primary content in *CenteredProductCards → Primary*
 */
export interface CenteredProductCardsSliceDefaultPrimary {
  /**
   * Background Color Start field in *CenteredProductCards → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CenteredProductCards → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Divider Text field in *CenteredProductCards → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.primary.divider_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  divider_text: prismic.KeyTextField;

  /**
   * Divider Color field in *CenteredProductCards → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.primary.divider_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  divider_color: prismic.ColorField;

  /**
   * Show Card Footers field in *CenteredProductCards → Primary*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: false
   * - **API ID Path**: centered_product_cards.primary.show_card_footers
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  show_card_footers: prismic.BooleanField;
}

/**
 * Primary content in *CenteredProductCards → Items*
 */
export interface CenteredProductCardsSliceDefaultItem {
  /**
   * Header Text field in *CenteredProductCards → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.items[].header_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  header_text: prismic.KeyTextField;

  /**
   * Eyebrow field in *CenteredProductCards → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.items[].eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Title Image field in *CenteredProductCards → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.items[].title_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  title_image: prismic.ImageField<never>;

  /**
   * Description field in *CenteredProductCards → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.items[].description
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  description: prismic.KeyTextField;

  /**
   * Description Subtext field in *CenteredProductCards → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.items[].description_subtext
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  description_subtext: prismic.KeyTextField;

  /**
   * Price field in *CenteredProductCards → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.items[].price
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  price: prismic.KeyTextField;

  /**
   * Price Units field in *CenteredProductCards → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.items[].price_units
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  price_units: prismic.KeyTextField;

  /**
   * Price Callout field in *CenteredProductCards → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.items[].price_callout
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  price_callout: prismic.KeyTextField;

  /**
   * CTA Link Style field in *CenteredProductCards → Items*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.items[].cta_link_style
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  cta_link_style: prismic.SelectField<'solid-accent' | 'solid-primary'>;

  /**
   * CTA Link field in *CenteredProductCards → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.items[].cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Link Text field in *CenteredProductCards → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.items[].cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_link_text: prismic.KeyTextField;

  /**
   * CTA Action field in *CenteredProductCards → Items*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_product_cards.items[].cta_action
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  cta_action: prismic.SelectField<
    'ADD_CONCIERGE_MONTHLY' | 'ADD_CONCIERGE_YEARLY' | 'LINK'
  >;
}

/**
 * Default variation for CenteredProductCards Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CenteredProductCardsSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<CenteredProductCardsSliceDefaultPrimary>,
  Simplify<CenteredProductCardsSliceDefaultItem>
>;

/**
 * Slice variation for *CenteredProductCards*
 */
type CenteredProductCardsSliceVariation = CenteredProductCardsSliceDefault;

/**
 * CenteredProductCards Shared Slice
 *
 * - **API ID**: `centered_product_cards`
 * - **Description**: CenteredProductCards
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CenteredProductCardsSlice = prismic.SharedSlice<
  'centered_product_cards',
  CenteredProductCardsSliceVariation
>;

/**
 * Primary content in *CenteredRichText → Primary*
 */
export interface CenteredRichTextSliceDefaultPrimary {
  /**
   * Content field in *CenteredRichText → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: centered_rich_text.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;
}

/**
 * Default variation for CenteredRichText Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CenteredRichTextSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<CenteredRichTextSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *CenteredRichText*
 */
type CenteredRichTextSliceVariation = CenteredRichTextSliceDefault;

/**
 * CenteredRichText Shared Slice
 *
 * - **API ID**: `centered_rich_text`
 * - **Description**: CenteredRichText
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CenteredRichTextSlice = prismic.SharedSlice<
  'centered_rich_text',
  CenteredRichTextSliceVariation
>;

/**
 * Primary content in *Checkout → Primary*
 */
export interface CheckoutSliceDefaultPrimary {
  /**
   * Summary Title field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.summary_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  summary_title: prismic.KeyTextField;

  /**
   * Quantity Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.quantity_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  quantity_text: prismic.KeyTextField;

  /**
   * Remove Button Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.remove_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  remove_button_text: prismic.KeyTextField;

  /**
   * Update Cart Error Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.update_cart_error_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  update_cart_error_text: prismic.KeyTextField;

  /**
   * Submit Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.submit_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  submit_text: prismic.KeyTextField;

  /**
   * Submitting Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.submitting_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  submitting_text: prismic.KeyTextField;

  /**
   * Submit Error Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.submit_error_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  submit_error_text: prismic.KeyTextField;

  /**
   * Subtotal Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.subtotal_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subtotal_text: prismic.KeyTextField;

  /**
   * Promo Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.promo_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  promo_text: prismic.KeyTextField;

  /**
   * Shipping Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.shipping_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  shipping_text: prismic.KeyTextField;

  /**
   * Shipping Fee field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.shipping_fee
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  shipping_fee: prismic.KeyTextField;

  /**
   * Discount Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.discount_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  discount_text: prismic.KeyTextField;

  /**
   * Tax Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.tax_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  tax_text: prismic.KeyTextField;

  /**
   * Total Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.total_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  total_text: prismic.KeyTextField;

  /**
   * Promo Input Placeholder field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.promo_input_placeholder
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  promo_input_placeholder: prismic.KeyTextField;

  /**
   * Add Promo Code Button Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.add_promo_code_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  add_promo_code_button_text: prismic.KeyTextField;

  /**
   * Add Promo Error Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.add_promo_error_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  add_promo_error_text: prismic.KeyTextField;

  /**
   * Remove Promo Error Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.remove_promo_error_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  remove_promo_error_text: prismic.KeyTextField;

  /**
   * No Items Title field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.no_items_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_items_title: prismic.KeyTextField;

  /**
   * No Items Description field in *Checkout → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.no_items_description
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  no_items_description: prismic.RichTextField;

  /**
   * No Items CTA Link field in *Checkout → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.no_items_cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  no_items_cta_link: prismic.LinkField;

  /**
   * No Items CTA Link Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.no_items_cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_items_cta_link_text: prismic.KeyTextField;

  /**
   * On Submit Redirect Link field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.on_submit_redirect_link
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  on_submit_redirect_link: prismic.KeyTextField;

  /**
   * Concierge Discount Text field in *Checkout → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: checkout.primary.concierge_discount_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  concierge_discount_text: prismic.KeyTextField;
}

/**
 * Default variation for Checkout Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CheckoutSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<CheckoutSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *Checkout*
 */
type CheckoutSliceVariation = CheckoutSliceDefault;

/**
 * Checkout Shared Slice
 *
 * - **API ID**: `checkout`
 * - **Description**: Checkout
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CheckoutSlice = prismic.SharedSlice<
  'checkout',
  CheckoutSliceVariation
>;

/**
 * Primary content in *ComparisonChart → Primary*
 */
export interface ComparisonChartSliceDefaultPrimary {
  /**
   * Background Color Start field in *ComparisonChart → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *ComparisonChart → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Tier 1 Logo field in *ComparisonChart → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.primary.Tier_1_logo
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  Tier_1_logo: prismic.ImageField<never>;

  /**
   * Tier 1 Background Color field in *ComparisonChart → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.primary.tier_1_background_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  tier_1_background_color: prismic.ColorField;

  /**
   * Tier 2 Title field in *ComparisonChart → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.primary.tier_2_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  tier_2_title: prismic.KeyTextField;

  /**
   * Tier 3 Title field in *ComparisonChart → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.primary.tier_3_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  tier_3_title: prismic.KeyTextField;

  /**
   * Tier Title Color field in *ComparisonChart → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.primary.tier_title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  tier_title_color: prismic.ColorField;

  /**
   * Slide Dot Inactive field in *ComparisonChart → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.primary.slide_dot_inactive
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  slide_dot_inactive: prismic.ColorField;

  /**
   * Slide Dot Active field in *ComparisonChart → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.primary.slide_dot_active
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  slide_dot_active: prismic.ColorField;
}

/**
 * Primary content in *ComparisonChart → Items*
 */
export interface ComparisonChartSliceDefaultItem {
  /**
   * Category field in *ComparisonChart → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.items[].category
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  category: prismic.KeyTextField;

  /**
   * Category Color field in *ComparisonChart → Items*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.items[].category_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  category_color: prismic.ColorField;

  /**
   * Tier 1 Type field in *ComparisonChart → Items*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.items[].tier_1_type
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  tier_1_type: prismic.SelectField<'text' | 'check' | 'x-icon'>;

  /**
   * Tier 1 field in *ComparisonChart → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.items[].tier_1
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  tier_1: prismic.KeyTextField;

  /**
   * Tier 2 Type field in *ComparisonChart → Items*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.items[].tier_2_type
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  tier_2_type: prismic.SelectField<'text' | 'check' | 'x-icon'>;

  /**
   * Tier 2 field in *ComparisonChart → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.items[].tier_2
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  tier_2: prismic.KeyTextField;

  /**
   * Tier 3 Type field in *ComparisonChart → Items*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.items[].tier_3_type
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  tier_3_type: prismic.SelectField<'text' | 'check' | 'x-icon'>;

  /**
   * Tier 3 field in *ComparisonChart → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.items[].tier_3
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  tier_3: prismic.KeyTextField;

  /**
   * Tier 1 Content Color field in *ComparisonChart → Items*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.items[].category_1_content_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  category_1_content_color: prismic.ColorField;

  /**
   * Alt Tier Content Color field in *ComparisonChart → Items*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: comparison_chart.items[].alt_tier_content_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  alt_tier_content_color: prismic.ColorField;
}

/**
 * Default variation for ComparisonChart Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type ComparisonChartSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<ComparisonChartSliceDefaultPrimary>,
  Simplify<ComparisonChartSliceDefaultItem>
>;

/**
 * Slice variation for *ComparisonChart*
 */
type ComparisonChartSliceVariation = ComparisonChartSliceDefault;

/**
 * ComparisonChart Shared Slice
 *
 * - **API ID**: `comparison_chart`
 * - **Description**: ComparisonChart
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type ComparisonChartSlice = prismic.SharedSlice<
  'comparison_chart',
  ComparisonChartSliceVariation
>;

/**
 * Primary content in *ComplaintSelect → Primary*
 */
export interface ComplaintSelectSliceDefaultPrimary {
  /**
   * Header field in *ComplaintSelect → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: complaint_select.primary.header
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  header: prismic.KeyTextField;

  /**
   * Subheader field in *ComplaintSelect → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: complaint_select.primary.subheader
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  subheader: prismic.RichTextField;

  /**
   * Footer field in *ComplaintSelect → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: complaint_select.primary.footer
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  footer: prismic.RichTextField;

  /**
   * Section Title field in *ComplaintSelect → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: complaint_select.primary.section_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  section_title: prismic.KeyTextField;

  /**
   * Section Description field in *ComplaintSelect → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: complaint_select.primary.section_description
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  section_description: prismic.RichTextField;

  /**
   * Hide When Treatment Disallowed field in *ComplaintSelect → Primary*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: false
   * - **API ID Path**: complaint_select.primary.hide_when_treatment_disallowed
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  hide_when_treatment_disallowed: prismic.BooleanField;
}

/**
 * Primary content in *ComplaintSelect → Items*
 */
export interface ComplaintSelectSliceDefaultItem {
  /**
   * Link Text field in *ComplaintSelect → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: complaint_select.items[].link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  link_text: prismic.KeyTextField;

  /**
   * Link field in *ComplaintSelect → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: complaint_select.items[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Search Params field in *ComplaintSelect → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: complaint_select.items[].search_params
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  search_params: prismic.KeyTextField;
}

/**
 * Default variation for ComplaintSelect Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type ComplaintSelectSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<ComplaintSelectSliceDefaultPrimary>,
  Simplify<ComplaintSelectSliceDefaultItem>
>;

/**
 * Slice variation for *ComplaintSelect*
 */
type ComplaintSelectSliceVariation = ComplaintSelectSliceDefault;

/**
 * ComplaintSelect Shared Slice
 *
 * - **API ID**: `complaint_select`
 * - **Description**: ComplaintSelect
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type ComplaintSelectSlice = prismic.SharedSlice<
  'complaint_select',
  ComplaintSelectSliceVariation
>;

/**
 * Primary content in *ComplaintSelector → Primary*
 */
export interface ComplaintSelectorSliceDefaultPrimary {
  /**
   * Title field in *ComplaintSelector → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: complaint_selector.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Description field in *ComplaintSelector → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: complaint_selector.primary.description
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  description: prismic.RichTextField;
}

/**
 * Primary content in *ComplaintSelector → Items*
 */
export interface ComplaintSelectorSliceDefaultItem {
  /**
   * Link Text field in *ComplaintSelector → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: complaint_selector.items[].link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  link_text: prismic.KeyTextField;

  /**
   * Link field in *ComplaintSelector → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: complaint_selector.items[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;
}

/**
 * Default variation for ComplaintSelector Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type ComplaintSelectorSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<ComplaintSelectorSliceDefaultPrimary>,
  Simplify<ComplaintSelectorSliceDefaultItem>
>;

/**
 * Slice variation for *ComplaintSelector*
 */
type ComplaintSelectorSliceVariation = ComplaintSelectorSliceDefault;

/**
 * ComplaintSelector Shared Slice
 *
 * - **API ID**: `complaint_selector`
 * - **Description**: ComplaintSelector
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type ComplaintSelectorSlice = prismic.SharedSlice<
  'complaint_selector',
  ComplaintSelectorSliceVariation
>;

/**
 * Primary content in *Content → Primary*
 */
export interface ContentSliceDefaultPrimary {
  /**
   * Background Image field in *Content → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: content.primary.background_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  background_image: prismic.ImageField<never>;

  /**
   * Title field in *Content → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: content.primary.title
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  title: prismic.RichTextField;

  /**
   * Content field in *Content → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: content.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;
}

/**
 * Default variation for Content Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type ContentSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<ContentSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *Content*
 */
type ContentSliceVariation = ContentSliceDefault;

/**
 * Content Shared Slice
 *
 * - **API ID**: `content`
 * - **Description**: Content
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type ContentSlice = prismic.SharedSlice<
  'content',
  ContentSliceVariation
>;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceDefaultPrimary {
  /**
   * Background Color Start field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Title field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Content field in *CtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Content Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  content_color: prismic.ColorField;

  /**
   * CTA Box Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_box_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_box_color: prismic.ColorField;

  /**
   * CTA Box Title field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_box_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_box_title: prismic.KeyTextField;

  /**
   * CTA Box Title Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_box_title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_box_title_color: prismic.ColorField;

  /**
   * CTA Box Description field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_box_description
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_box_description: prismic.KeyTextField;

  /**
   * CTA Box Description Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_box_description_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_box_description_color: prismic.ColorField;

  /**
   * CTA Box Price field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_box_price
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_box_price: prismic.KeyTextField;

  /**
   * CTA Box Price Superscript field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_box_price_superscript
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_box_price_superscript: prismic.KeyTextField;

  /**
   * CTA Box Price Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_box_price_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_box_price_color: prismic.ColorField;

  /**
   * CTA Button Link field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_button_link: prismic.LinkField;

  /**
   * CTA Button Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_color: prismic.ColorField;

  /**
   * CTA Button Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_hover_color: prismic.ColorField;

  /**
   * CTA Button Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Button Text Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_color: prismic.ColorField;

  /**
   * CTA Button Text Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_hover_color: prismic.ColorField;

  /**
   * List Icon Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.list_icon_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  list_icon_color: prismic.ColorField;
}

/**
 * Primary content in *CtaSection → Items*
 */
export interface CtaSectionSliceDefaultItem {
  /**
   * name field in *CtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;
}

/**
 * Default variation for CtaSection Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<CtaSectionSliceDefaultPrimary>,
  Simplify<CtaSectionSliceDefaultItem>
>;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceRightAlignedVideoPrimary {
  /**
   * Background Color Start field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Eyebrow field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Eyebrow Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.eyebrow_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  eyebrow_color: prismic.ColorField;

  /**
   * Title field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Subtitle field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.subtitle
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subtitle: prismic.KeyTextField;

  /**
   * Subtitle Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.subtitle_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  subtitle_color: prismic.ColorField;

  /**
   * Content field in *CtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Content Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  content_color: prismic.ColorField;

  /**
   * CTA Button Link field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_button_link: prismic.LinkField;

  /**
   * CTA Button Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_color: prismic.ColorField;

  /**
   * CTA Button Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_hover_color: prismic.ColorField;

  /**
   * CTA Button Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Button Text Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_color: prismic.ColorField;

  /**
   * CTA Button Text Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_hover_color: prismic.ColorField;

  /**
   * Video field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.video
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  video: prismic.LinkField;

  /**
   * Include Video Frame field in *CtaSection → Primary*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: false
   * - **API ID Path**: cta_section.primary.include_video_frame
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  include_video_frame: prismic.BooleanField;
}

/**
 * Right-Aligned Video variation for CtaSection Slice
 *
 * - **API ID**: `rightAlignedVideo`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceRightAlignedVideo = prismic.SharedSliceVariation<
  'rightAlignedVideo',
  Simplify<CtaSectionSliceRightAlignedVideoPrimary>,
  never
>;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceLeftAlignedVideoPrimary {
  /**
   * Background Color Start field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Eyebrow field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Eyebrow Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.eyebrow_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  eyebrow_color: prismic.ColorField;

  /**
   * Title field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Subtitle field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.subtitle
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subtitle: prismic.KeyTextField;

  /**
   * Subtitle Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.subtitle_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  subtitle_color: prismic.ColorField;

  /**
   * Content field in *CtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Content Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  content_color: prismic.ColorField;

  /**
   * CTA Button Link field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_button_link: prismic.LinkField;

  /**
   * CTA Button Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_color: prismic.ColorField;

  /**
   * CTA Button Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_hover_color: prismic.ColorField;

  /**
   * CTA Button Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Button Text Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_color: prismic.ColorField;

  /**
   * CTA Button Text Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_hover_color: prismic.ColorField;

  /**
   * Video field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.video
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  video: prismic.LinkField;

  /**
   * Include Video Frame field in *CtaSection → Primary*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: false
   * - **API ID Path**: cta_section.primary.include_video_frame
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  include_video_frame: prismic.BooleanField;
}

/**
 * Left-Aligned Video variation for CtaSection Slice
 *
 * - **API ID**: `leftAlignedVideo`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceLeftAlignedVideo = prismic.SharedSliceVariation<
  'leftAlignedVideo',
  Simplify<CtaSectionSliceLeftAlignedVideoPrimary>,
  never
>;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceRightAlignedImagePrimary {
  /**
   * Background Color Start field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Eyebrow field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Eyebrow Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.eyebrow_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  eyebrow_color: prismic.ColorField;

  /**
   * Title field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Subtitle field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.subtitle
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subtitle: prismic.KeyTextField;

  /**
   * Subtitle Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.subtitle_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  subtitle_color: prismic.ColorField;

  /**
   * Content field in *CtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Content Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  content_color: prismic.ColorField;

  /**
   * CTA Button Link field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_button_link: prismic.LinkField;

  /**
   * CTA Button Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_color: prismic.ColorField;

  /**
   * CTA Button Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_hover_color: prismic.ColorField;

  /**
   * CTA Button Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Button Text Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_color: prismic.ColorField;

  /**
   * CTA Button Text Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_hover_color: prismic.ColorField;

  /**
   * List Item Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.list_item_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  list_item_color: prismic.ColorField;

  /**
   * Image field in *CtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;
}

/**
 * Right-Aligned Image variation for CtaSection Slice
 *
 * - **API ID**: `rightAlignedImage`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceRightAlignedImage = prismic.SharedSliceVariation<
  'rightAlignedImage',
  Simplify<CtaSectionSliceRightAlignedImagePrimary>,
  never
>;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceLeftAlignedImagePrimary {
  /**
   * Background Color Start field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Eyebrow field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Eyebrow Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.eyebrow_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  eyebrow_color: prismic.ColorField;

  /**
   * Title field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Subtitle field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.subtitle
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subtitle: prismic.KeyTextField;

  /**
   * Subtitle Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.subtitle_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  subtitle_color: prismic.ColorField;

  /**
   * Content field in *CtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Content Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  content_color: prismic.ColorField;

  /**
   * CTA Button Link field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_button_link: prismic.LinkField;

  /**
   * CTA Button Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_color: prismic.ColorField;

  /**
   * CTA Button Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_hover_color: prismic.ColorField;

  /**
   * CTA Button Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Button Text Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_color: prismic.ColorField;

  /**
   * CTA Button Text Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_hover_color: prismic.ColorField;

  /**
   * List Item Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.list_item_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  list_item_color: prismic.ColorField;

  /**
   * Image field in *CtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;
}

/**
 * Left-Aligned Image variation for CtaSection Slice
 *
 * - **API ID**: `leftAlignedImage`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceLeftAlignedImage = prismic.SharedSliceVariation<
  'leftAlignedImage',
  Simplify<CtaSectionSliceLeftAlignedImagePrimary>,
  never
>;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceCenteredTextWithLeftImagePrimary {
  /**
   * Background Color Start field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Eyebrow field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Eyebrow Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.eyebrow_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  eyebrow_color: prismic.ColorField;

  /**
   * Title field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Primary CTA field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.primary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  primary_cta: prismic.LinkField;

  /**
   * Primary CTA Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.primary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  primary_cta_text: prismic.KeyTextField;

  /**
   * Primary CTA Text Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.primary_cta_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  primary_cta_text_color: prismic.ColorField;

  /**
   * Primary CTA Text Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.primary_cta_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  primary_cta_text_hover_color: prismic.ColorField;

  /**
   * Image field in *CtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Secondary CTA field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.secondary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  secondary_cta: prismic.LinkField;

  /**
   * Secondary CTA Text  field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.secondary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  secondary_cta_text: prismic.KeyTextField;

  /**
   * Secondary CTA Text Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.secondary_cta_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  secondary_cta_text_color: prismic.ColorField;

  /**
   * Secondary CTA Text Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.secondary_cta_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  secondary_cta_text_hover_color: prismic.ColorField;
}

/**
 * CenteredTextWithLeftImage variation for CtaSection Slice
 *
 * - **API ID**: `centeredTextWithLeftImage`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceCenteredTextWithLeftImage =
  prismic.SharedSliceVariation<
    'centeredTextWithLeftImage',
    Simplify<CtaSectionSliceCenteredTextWithLeftImagePrimary>,
    never
  >;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceCenteredTextWithRightImagePrimary {
  /**
   * Background Color Start field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Eyebrow field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Eyebrow Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.eyebrow_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  eyebrow_color: prismic.ColorField;

  /**
   * Title field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Primary CTA field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.primary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  primary_cta: prismic.LinkField;

  /**
   * Primary CTA Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.primary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  primary_cta_text: prismic.KeyTextField;

  /**
   * Primary CTA Text Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.primary_cta_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  primary_cta_text_color: prismic.ColorField;

  /**
   * Primary CTA Text Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.primary_cta_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  primary_cta_text_hover_color: prismic.ColorField;

  /**
   * Image field in *CtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Secondary CTA field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.secondary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  secondary_cta: prismic.LinkField;

  /**
   * Secondary CTA Text  field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.secondary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  secondary_cta_text: prismic.KeyTextField;

  /**
   * Secondary CTA Text Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.secondary_cta_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  secondary_cta_text_color: prismic.ColorField;

  /**
   * Secondary CTA Text Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.secondary_cta_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  secondary_cta_text_hover_color: prismic.ColorField;
}

/**
 * CenteredTextWithRightImage variation for CtaSection Slice
 *
 * - **API ID**: `centeredTextWithRightImage`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceCenteredTextWithRightImage =
  prismic.SharedSliceVariation<
    'centeredTextWithRightImage',
    Simplify<CtaSectionSliceCenteredTextWithRightImagePrimary>,
    never
  >;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceButtonBannerPrimary {
  /**
   * Background Color Start field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * CTA Button Link field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_button_link: prismic.LinkField;

  /**
   * CTA Button Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_color: prismic.ColorField;

  /**
   * CTA Button Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_hover_color: prismic.ColorField;

  /**
   * CTA Button Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Button Text Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_color: prismic.ColorField;

  /**
   * CTA Button Text Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_hover_color: prismic.ColorField;
}

/**
 * Button Banner variation for CtaSection Slice
 *
 * - **API ID**: `buttonBanner`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceButtonBanner = prismic.SharedSliceVariation<
  'buttonBanner',
  Simplify<CtaSectionSliceButtonBannerPrimary>,
  never
>;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceCtaGridBoxesPrimary {
  /**
   * Background Color Start field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;
}

/**
 * Primary content in *CtaSection → Items*
 */
export interface CtaSectionSliceCtaGridBoxesItem {
  /**
   * CTA Box Color field in *CtaSection → Items*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].cta_box_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_box_color: prismic.ColorField;

  /**
   * Title field in *CtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *CtaSection → Items*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Description field in *CtaSection → Items*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].description
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  description: prismic.RichTextField;

  /**
   * Description Color field in *CtaSection → Items*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].description_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  description_color: prismic.ColorField;

  /**
   * CTA Button Link field in *CtaSection → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].cta_button_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_button_link: prismic.LinkField;

  /**
   * CTA Button Color field in *CtaSection → Items*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].cta_button_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_color: prismic.ColorField;

  /**
   * CTA Button Hover Color field in *CtaSection → Items*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].cta_button_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_hover_color: prismic.ColorField;

  /**
   * CTA Button Text field in *CtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Button Text Color field in *CtaSection → Items*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].cta_button_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_color: prismic.ColorField;

  /**
   * CTA Button Text Hover Color field in *CtaSection → Items*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].cta_button_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_hover_color: prismic.ColorField;
}

/**
 * CTA Grid Boxes variation for CtaSection Slice
 *
 * - **API ID**: `ctaGridBoxes`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceCtaGridBoxes = prismic.SharedSliceVariation<
  'ctaGridBoxes',
  Simplify<CtaSectionSliceCtaGridBoxesPrimary>,
  Simplify<CtaSectionSliceCtaGridBoxesItem>
>;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceImagesWithContentOverlayPrimary {
  /**
   * Left Image field in *CtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.left_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  left_image: prismic.ImageField<never>;

  /**
   * Right Image field in *CtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.right_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  right_image: prismic.ImageField<never>;

  /**
   * Content Header Image field in *CtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content_header_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  content_header_image: prismic.ImageField<never>;

  /**
   * Content field in *CtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Content Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  content_color: prismic.ColorField;

  /**
   * CTA Button Link field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_button_link: prismic.LinkField;

  /**
   * CTA Button Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_color: prismic.ColorField;

  /**
   * CTA Button Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_hover_color: prismic.ColorField;

  /**
   * CTA Button Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Button Text Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_color: prismic.ColorField;

  /**
   * CTA Button Text Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_hover_color: prismic.ColorField;

  /**
   * Closing Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.closing_text
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  closing_text: prismic.RichTextField;
}

/**
 * ImagesWithContentOverlay variation for CtaSection Slice
 *
 * - **API ID**: `imagesWithContentOverlay`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceImagesWithContentOverlay =
  prismic.SharedSliceVariation<
    'imagesWithContentOverlay',
    Simplify<CtaSectionSliceImagesWithContentOverlayPrimary>,
    never
  >;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceTwoColumnGridWithImagePrimary {
  /**
   * Background Color Start field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Title Image field in *CtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  title_image: prismic.ImageField<never>;

  /**
   * Content field in *CtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Content Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  content_color: prismic.ColorField;

  /**
   * CTA Button Link field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_button_link: prismic.LinkField;

  /**
   * CTA Button Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_color: prismic.ColorField;

  /**
   * CTA Button Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_hover_color: prismic.ColorField;

  /**
   * CTA Button Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Button Text Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_color: prismic.ColorField;

  /**
   * CTA Button Text Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_hover_color: prismic.ColorField;

  /**
   * Image field in *CtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Bottom Border Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.bottom_border_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  bottom_border_color: prismic.ColorField;
}

/**
 * TwoColumnGridWithImage variation for CtaSection Slice
 *
 * - **API ID**: `twoColumnGridWithImage`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceTwoColumnGridWithImage =
  prismic.SharedSliceVariation<
    'twoColumnGridWithImage',
    Simplify<CtaSectionSliceTwoColumnGridWithImagePrimary>,
    never
  >;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceCustomPrescriptionPrimary {
  /**
   * Background Color Start field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Title field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Content field in *CtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Image field in *CtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Bottom Content field in *CtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.bottom_content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  bottom_content: prismic.RichTextField;

  /**
   * CTA Button Link field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_button_link: prismic.LinkField;

  /**
   * CTA Button Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_color: prismic.ColorField;

  /**
   * CTA Button Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_hover_color: prismic.ColorField;

  /**
   * CTA Button Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Button Text Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_color: prismic.ColorField;

  /**
   * CTA Button Text Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_hover_color: prismic.ColorField;

  /**
   * H1 Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.h1_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  h1_color: prismic.ColorField;

  /**
   * H2 Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.h2_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  h2_color: prismic.ColorField;

  /**
   * P Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.p_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  p_color: prismic.ColorField;
}

/**
 * CustomPrescription variation for CtaSection Slice
 *
 * - **API ID**: `customPrescription`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceCustomPrescription = prismic.SharedSliceVariation<
  'customPrescription',
  Simplify<CtaSectionSliceCustomPrescriptionPrimary>,
  never
>;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceCtaListWithImagePrimary {
  /**
   * Background Color Start field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Title field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Content field in *CtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Content Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  content_color: prismic.ColorField;

  /**
   * CTA Button Link field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_button_link: prismic.LinkField;

  /**
   * CTA Button Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_color: prismic.ColorField;

  /**
   * CTA Button Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_hover_color: prismic.ColorField;

  /**
   * CTA Button Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Button Text Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_color: prismic.ColorField;

  /**
   * CTA Button Text Hover Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text_hover_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_button_text_hover_color: prismic.ColorField;

  /**
   * List Icon Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.list_icon_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  list_icon_color: prismic.ColorField;

  /**
   * List Header field in *CtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.list_header
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  list_header: prismic.RichTextField;

  /**
   * Image field in *CtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;
}

/**
 * Primary content in *CtaSection → Items*
 */
export interface CtaSectionSliceCtaListWithImageItem {
  /**
   * Name field in *CtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;

  /**
   * Modal Content field in *CtaSection → Items*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].modal_content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  modal_content: prismic.RichTextField;

  /**
   * Modal Image field in *CtaSection → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].modal_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  modal_image: prismic.ImageField<never>;

  /**
   * Modal CTA field in *CtaSection → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].modal_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  modal_cta: prismic.LinkField;

  /**
   * Modal CTA Text field in *CtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.items[].modal_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  modal_cta_text: prismic.KeyTextField;
}

/**
 * CTAListWithImage variation for CtaSection Slice
 *
 * - **API ID**: `ctaListWithImage`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceCtaListWithImage = prismic.SharedSliceVariation<
  'ctaListWithImage',
  Simplify<CtaSectionSliceCtaListWithImagePrimary>,
  Simplify<CtaSectionSliceCtaListWithImageItem>
>;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceImageTitleCtaPrimary {
  /**
   * Background Color Start field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Title Image field in *CtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  title_image: prismic.ImageField<never>;

  /**
   * Subheader field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.subheader
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subheader: prismic.KeyTextField;

  /**
   * Subheader Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.subheader_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  subheader_color: prismic.ColorField;

  /**
   * CTA Link Style field in *CtaSection → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_link_style
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  cta_link_style: prismic.SelectField<
    'solid-accent' | 'solid-primary' | 'solid-gray'
  >;

  /**
   * CTA Link field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Link Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_link_text: prismic.KeyTextField;

  /**
   * CTA Callout field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_callout
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_callout: prismic.KeyTextField;

  /**
   * CTA Callout Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_callout_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_callout_color: prismic.ColorField;

  /**
   * CTA Action field in *CtaSection → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_action
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  cta_action: prismic.SelectField<
    'ADD_CONCIERGE_MONTHLY' | 'ADD_CONCIERGE_YEARLY' | 'LINK'
  >;

  /**
   * Secondary CTA field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.secondary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  secondary_cta: prismic.LinkField;

  /**
   * Secondary CTA Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.secondary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  secondary_cta_text: prismic.KeyTextField;

  /**
   * Secondary CTA Link Style field in *CtaSection → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.secondary_cta_link_style
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  secondary_cta_link_style: prismic.SelectField<
    'solid-accent' | 'solid-primary' | 'solid-gray'
  >;
}

/**
 * Image Title CTA variation for CtaSection Slice
 *
 * - **API ID**: `imageTitleCta`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceImageTitleCta = prismic.SharedSliceVariation<
  'imageTitleCta',
  Simplify<CtaSectionSliceImageTitleCtaPrimary>,
  never
>;

/**
 * Primary content in *CtaSection → Primary*
 */
export interface CtaSectionSliceTwoColumnWithImagePrimary {
  /**
   * Background Color Start field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Alignment field in *CtaSection → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.alignment
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  alignment: prismic.SelectField<'image-right' | 'image-left'>;

  /**
   * Image field in *CtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Header Badge Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.header_badge_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  header_badge_text: prismic.KeyTextField;

  /**
   * Title field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Content field in *CtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Content Color field in *CtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.content_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  content_color: prismic.ColorField;

  /**
   * CTA Link Style field in *CtaSection → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_link_style
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  cta_link_style: prismic.SelectField<
    'solid-black' | 'solid-accent' | 'solid-gray'
  >;

  /**
   * CTA Link field in *CtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Button Text field in *CtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Action field in *CtaSection → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: cta_section.primary.cta_action
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  cta_action: prismic.SelectField<
    'ADD_CONCIERGE_MONTHLY' | 'ADD_CONCIERGE_YEARLY' | 'LINK'
  >;
}

/**
 * Two Column with Image variation for CtaSection Slice
 *
 * - **API ID**: `twoColumnWithImage`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSliceTwoColumnWithImage = prismic.SharedSliceVariation<
  'twoColumnWithImage',
  Simplify<CtaSectionSliceTwoColumnWithImagePrimary>,
  never
>;

/**
 * Slice variation for *CtaSection*
 */
type CtaSectionSliceVariation =
  | CtaSectionSliceDefault
  | CtaSectionSliceRightAlignedVideo
  | CtaSectionSliceLeftAlignedVideo
  | CtaSectionSliceRightAlignedImage
  | CtaSectionSliceLeftAlignedImage
  | CtaSectionSliceCenteredTextWithLeftImage
  | CtaSectionSliceCenteredTextWithRightImage
  | CtaSectionSliceButtonBanner
  | CtaSectionSliceCtaGridBoxes
  | CtaSectionSliceImagesWithContentOverlay
  | CtaSectionSliceTwoColumnGridWithImage
  | CtaSectionSliceCustomPrescription
  | CtaSectionSliceCtaListWithImage
  | CtaSectionSliceImageTitleCta
  | CtaSectionSliceTwoColumnWithImage;

/**
 * CtaSection Shared Slice
 *
 * - **API ID**: `cta_section`
 * - **Description**: CtaSection
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type CtaSectionSlice = prismic.SharedSlice<
  'cta_section',
  CtaSectionSliceVariation
>;

/**
 * Primary content in *DiscoverTretinoin → Primary*
 */
export interface DiscoverTretinoinSliceDefaultPrimary {
  /**
   * Image field in *DiscoverTretinoin → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: discover_tretinoin.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Eyebrow field in *DiscoverTretinoin → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: discover_tretinoin.primary.eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Title field in *DiscoverTretinoin → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: discover_tretinoin.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Content field in *DiscoverTretinoin → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: discover_tretinoin.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * CTA Link field in *DiscoverTretinoin → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: discover_tretinoin.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Link Text field in *DiscoverTretinoin → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: discover_tretinoin.primary.cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_link_text: prismic.KeyTextField;
}

/**
 * Default variation for DiscoverTretinoin Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type DiscoverTretinoinSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<DiscoverTretinoinSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *DiscoverTretinoin*
 */
type DiscoverTretinoinSliceVariation = DiscoverTretinoinSliceDefault;

/**
 * DiscoverTretinoin Shared Slice
 *
 * - **API ID**: `discover_tretinoin`
 * - **Description**: DiscoverTretinoin
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type DiscoverTretinoinSlice = prismic.SharedSlice<
  'discover_tretinoin',
  DiscoverTretinoinSliceVariation
>;

/**
 * Primary content in *Faqs → Primary*
 */
export interface FaqsSliceDefaultPrimary {
  /**
   * Title field in *Faqs → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: faqs.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *Faqs → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: faqs.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Background Color Start field in *Faqs → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: faqs.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *Faqs → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: faqs.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * FAQ Color field in *Faqs → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: faqs.primary.faq_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  faq_color: prismic.ColorField;
}

/**
 * Primary content in *Faqs → Items*
 */
export interface FaqsSliceDefaultItem {
  /**
   * Question field in *Faqs → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: faqs.items[].question
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  question: prismic.KeyTextField;

  /**
   * Answer field in *Faqs → Items*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: faqs.items[].answer
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  answer: prismic.RichTextField;
}

/**
 * Default variation for Faqs Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type FaqsSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<FaqsSliceDefaultPrimary>,
  Simplify<FaqsSliceDefaultItem>
>;

/**
 * Slice variation for *Faqs*
 */
type FaqsSliceVariation = FaqsSliceDefault;

/**
 * Faqs Shared Slice
 *
 * - **API ID**: `faqs`
 * - **Description**: Faqs
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type FaqsSlice = prismic.SharedSlice<'faqs', FaqsSliceVariation>;

/**
 * Primary content in *FeaturedBlogSection → Primary*
 */
export interface FeaturedBlogSectionSliceDefaultPrimary {
  /**
   * Background Color field in *FeaturedBlogSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: featured_blog_section.primary.background_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color: prismic.ColorField;
}

/**
 * Primary content in *FeaturedBlogSection → Items*
 */
export interface FeaturedBlogSectionSliceDefaultItem {
  /**
   * Content Card field in *FeaturedBlogSection → Items*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: featured_blog_section.items[].content_card
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  content_card: prismic.ContentRelationshipField<'blogpost'>;
}

/**
 * Default variation for FeaturedBlogSection Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type FeaturedBlogSectionSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<FeaturedBlogSectionSliceDefaultPrimary>,
  Simplify<FeaturedBlogSectionSliceDefaultItem>
>;

/**
 * Slice variation for *FeaturedBlogSection*
 */
type FeaturedBlogSectionSliceVariation = FeaturedBlogSectionSliceDefault;

/**
 * FeaturedBlogSection Shared Slice
 *
 * - **API ID**: `featured_blog_section`
 * - **Description**: FeaturedBlogSection
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type FeaturedBlogSectionSlice = prismic.SharedSlice<
  'featured_blog_section',
  FeaturedBlogSectionSliceVariation
>;

/**
 * Primary content in *FeaturedCollection → Primary*
 */
export interface FeaturedCollectionSliceDefaultPrimary {
  /**
   * Header field in *FeaturedCollection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: featured_collection.primary.header
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  header: prismic.KeyTextField;

  /**
   * Collection Tag field in *FeaturedCollection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: featured_collection.primary.collection_tag
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  collection_tag: prismic.KeyTextField;

  /**
   * Products Link field in *FeaturedCollection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: featured_collection.primary.products_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  products_link: prismic.LinkField;

  /**
   * Products Link Text field in *FeaturedCollection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: featured_collection.primary.products_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  products_link_text: prismic.KeyTextField;
}

/**
 * Default variation for FeaturedCollection Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type FeaturedCollectionSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<FeaturedCollectionSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *FeaturedCollection*
 */
type FeaturedCollectionSliceVariation = FeaturedCollectionSliceDefault;

/**
 * FeaturedCollection Shared Slice
 *
 * - **API ID**: `featured_collection`
 * - **Description**: FeaturedCollection
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type FeaturedCollectionSlice = prismic.SharedSlice<
  'featured_collection',
  FeaturedCollectionSliceVariation
>;

/**
 * Primary content in *FooterGroup → Primary*
 */
export interface FooterGroupSliceDefaultPrimary {
  /**
   * Title field in *FooterGroup → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: footer_group.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *FooterGroup → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: footer_group.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;
}

/**
 * Primary content in *FooterGroup → Items*
 */
export interface FooterGroupSliceDefaultItem {
  /**
   * Link field in *FooterGroup → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: footer_group.items[].link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Link_Text field in *FooterGroup → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: footer_group.items[].link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  link_text: prismic.KeyTextField;

  /**
   * Link Icon field in *FooterGroup → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: footer_group.items[].link_icon
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  link_icon: prismic.ImageField<never>;

  /**
   * Prefetch field in *FooterGroup → Items*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: true
   * - **API ID Path**: footer_group.items[].prefetch
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  prefetch: prismic.BooleanField;
}

/**
 * Default variation for FooterGroup Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type FooterGroupSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<FooterGroupSliceDefaultPrimary>,
  Simplify<FooterGroupSliceDefaultItem>
>;

/**
 * Slice variation for *FooterGroup*
 */
type FooterGroupSliceVariation = FooterGroupSliceDefault;

/**
 * FooterGroup Shared Slice
 *
 * - **API ID**: `footer_group`
 * - **Description**: FooterGroup
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type FooterGroupSlice = prismic.SharedSlice<
  'footer_group',
  FooterGroupSliceVariation
>;

/**
 * Primary content in *Form → Primary*
 */
export interface FormSliceDefaultPrimary {
  /**
   * Form ID field in *Form → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: form.primary.form_id
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  form_id: prismic.KeyTextField;

  /**
   * Dev Form ID field in *Form → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: form.primary.dev_form_id
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  dev_form_id: prismic.KeyTextField;
}

/**
 * Primary content in *Form → Items*
 */
export interface FormSliceDefaultItem {
  /**
   * Form ID field in *Form → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: form.items[].form_id
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  form_id: prismic.KeyTextField;

  /**
   * Key field in *Form → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: form.items[].key
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  key: prismic.KeyTextField;

  /**
   * Environment field in *Form → Items*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: form.items[].environment
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  environment: prismic.SelectField<'production' | 'development'>;
}

/**
 * Default variation for Form Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type FormSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<FormSliceDefaultPrimary>,
  Simplify<FormSliceDefaultItem>
>;

/**
 * Slice variation for *Form*
 */
type FormSliceVariation = FormSliceDefault;

/**
 * Form Shared Slice
 *
 * - **API ID**: `form`
 * - **Description**: Form
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type FormSlice = prismic.SharedSlice<'form', FormSliceVariation>;

/**
 * Primary content in *HelpArticle → Primary*
 */
export interface HelpArticleSliceDefaultPrimary {
  /**
   * Content field in *HelpArticle → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: help_article.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;
}

/**
 * Default variation for HelpArticle Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type HelpArticleSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<HelpArticleSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *HelpArticle*
 */
type HelpArticleSliceVariation = HelpArticleSliceDefault;

/**
 * HelpArticle Shared Slice
 *
 * - **API ID**: `help_article`
 * - **Description**: HelpArticle
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type HelpArticleSlice = prismic.SharedSlice<
  'help_article',
  HelpArticleSliceVariation
>;

/**
 * Primary content in *HeroCarousel → Items*
 */
export interface HeroCarouselSliceDefaultItem {
  /**
   * title field in *HeroCarousel → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_carousel.items[].title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * subtitle field in *HeroCarousel → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_carousel.items[].subtitle
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subtitle: prismic.KeyTextField;

  /**
   * primary_link field in *HeroCarousel → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_carousel.items[].primary_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  primary_link: prismic.LinkField;

  /**
   * primary_link_text field in *HeroCarousel → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_carousel.items[].primary_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  primary_link_text: prismic.KeyTextField;

  /**
   * secondary_link field in *HeroCarousel → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_carousel.items[].secondary_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  secondary_link: prismic.LinkField;

  /**
   * secondary_link_text field in *HeroCarousel → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_carousel.items[].secondary_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  secondary_link_text: prismic.KeyTextField;

  /**
   * bg_color_start field in *HeroCarousel → Items*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_carousel.items[].bg_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  bg_color_start: prismic.ColorField;

  /**
   * bg_color_stop field in *HeroCarousel → Items*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_carousel.items[].bg_color_stop
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  bg_color_stop: prismic.ColorField;

  /**
   * bg_image field in *HeroCarousel → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_carousel.items[].bg_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  bg_image: prismic.ImageField<never>;

  /**
   * bg_video field in *HeroCarousel → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_carousel.items[].bg_video
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  bg_video: prismic.LinkField;
}

/**
 * Default variation for HeroCarousel Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type HeroCarouselSliceDefault = prismic.SharedSliceVariation<
  'default',
  Record<string, never>,
  Simplify<HeroCarouselSliceDefaultItem>
>;

/**
 * Slice variation for *HeroCarousel*
 */
type HeroCarouselSliceVariation = HeroCarouselSliceDefault;

/**
 * HeroCarousel Shared Slice
 *
 * - **API ID**: `hero_carousel`
 * - **Description**: HeroCarousel
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type HeroCarouselSlice = prismic.SharedSlice<
  'hero_carousel',
  HeroCarouselSliceVariation
>;

/**
 * Primary content in *HeroSection → Primary*
 */
export interface HeroSectionSliceDefaultPrimary {
  /**
   * Eyebrow field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Eyebrow Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.eyebrow_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  eyebrow_color: prismic.ColorField;

  /**
   * Title field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Subtitle field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.subtitle
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subtitle: prismic.KeyTextField;

  /**
   * Subtitle Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.subtitle_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  subtitle_color: prismic.ColorField;

  /**
   * Primary CTA field in *HeroSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  primary_cta: prismic.LinkField;

  /**
   * Primary CTA Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  primary_cta_color: prismic.ColorField;

  /**
   * Primary CTA Text field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  primary_cta_text: prismic.KeyTextField;

  /**
   * Primary CTA Text Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  primary_cta_text_color: prismic.ColorField;

  /**
   * Secondary CTA field in *HeroSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.secondary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  secondary_cta: prismic.LinkField;

  /**
   * Secondary CTA Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.secondary_cta_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  secondary_cta_color: prismic.ColorField;

  /**
   * Secondary CTA Text  field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.secondary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  secondary_cta_text: prismic.KeyTextField;

  /**
   * Secondary CTA Text Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.secondary_cta_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  secondary_cta_text_color: prismic.ColorField;

  /**
   * Background Image field in *HeroSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.background_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  background_image: prismic.ImageField<never>;

  /**
   * Background Image Mobile field in *HeroSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.background_image_mobile
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  background_image_mobile: prismic.ImageField<never>;
}

/**
 * Default variation for HeroSection Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type HeroSectionSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<HeroSectionSliceDefaultPrimary>,
  never
>;

/**
 * Primary content in *HeroSection → Primary*
 */
export interface HeroSectionSliceLeftAlignedPrimary {
  /**
   * Title field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * List Header field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.list_header
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  list_header: prismic.KeyTextField;

  /**
   * List Header Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.list_header_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  list_header_color: prismic.ColorField;

  /**
   * Primary CTA field in *HeroSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  primary_cta: prismic.LinkField;

  /**
   * Primary CTA Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  primary_cta_color: prismic.ColorField;

  /**
   * Primary CTA Text field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  primary_cta_text: prismic.KeyTextField;

  /**
   * Primary CTA Text Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  primary_cta_text_color: prismic.ColorField;

  /**
   * Secondary CTA field in *HeroSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.secondary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  secondary_cta: prismic.LinkField;

  /**
   * Secondary CTA Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.secondary_cta_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  secondary_cta_color: prismic.ColorField;

  /**
   * Secondary CTA Text  field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.secondary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  secondary_cta_text: prismic.KeyTextField;

  /**
   * Secondary CTA Text Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.secondary_cta_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  secondary_cta_text_color: prismic.ColorField;

  /**
   * Background Image field in *HeroSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.background_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  background_image: prismic.ImageField<never>;

  /**
   * Background Image Mobile field in *HeroSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.background_image_mobile
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  background_image_mobile: prismic.ImageField<never>;

  /**
   * List Item Icon field in *HeroSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.list_item_icon
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  list_item_icon: prismic.ImageField<never>;

  /**
   * List Item Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.list_item_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  list_item_color: prismic.ColorField;
}

/**
 * Primary content in *HeroSection → Items*
 */
export interface HeroSectionSliceLeftAlignedItem {
  /**
   * List Item field in *HeroSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.items[].list_item
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  list_item: prismic.KeyTextField;
}

/**
 * Left Aligned variation for HeroSection Slice
 *
 * - **API ID**: `leftAligned`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type HeroSectionSliceLeftAligned = prismic.SharedSliceVariation<
  'leftAligned',
  Simplify<HeroSectionSliceLeftAlignedPrimary>,
  Simplify<HeroSectionSliceLeftAlignedItem>
>;

/**
 * Primary content in *HeroSection → Primary*
 */
export interface HeroSectionSliceHeroWithVideoPrimary {
  /**
   * Eyebrow field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Eyebrow Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.eyebrow_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  eyebrow_color: prismic.ColorField;

  /**
   * Title field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Subtitle field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.subtitle
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subtitle: prismic.KeyTextField;

  /**
   * Subtitle Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.subtitle_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  subtitle_color: prismic.ColorField;

  /**
   * Primary CTA field in *HeroSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  primary_cta: prismic.LinkField;

  /**
   * Primary CTA Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  primary_cta_color: prismic.ColorField;

  /**
   * Primary CTA Text field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  primary_cta_text: prismic.KeyTextField;

  /**
   * Primary CTA Text Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  primary_cta_text_color: prismic.ColorField;

  /**
   * Secondary CTA field in *HeroSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.secondary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  secondary_cta: prismic.LinkField;

  /**
   * Secondary CTA Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.secondary_cta_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  secondary_cta_color: prismic.ColorField;

  /**
   * Secondary CTA Text  field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.secondary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  secondary_cta_text: prismic.KeyTextField;

  /**
   * Secondary CTA Text Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.secondary_cta_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  secondary_cta_text_color: prismic.ColorField;

  /**
   * Background Video field in *HeroSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.background_video
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  background_video: prismic.LinkField;
}

/**
 * Hero with Video variation for HeroSection Slice
 *
 * - **API ID**: `heroWithVideo`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type HeroSectionSliceHeroWithVideo = prismic.SharedSliceVariation<
  'heroWithVideo',
  Simplify<HeroSectionSliceHeroWithVideoPrimary>,
  never
>;

/**
 * Primary content in *HeroSection → Primary*
 */
export interface HeroSectionSliceHeroWithCenteredImagePrimary {
  /**
   * Primary CTA field in *HeroSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  primary_cta: prismic.LinkField;

  /**
   * Primary CTA Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  primary_cta_color: prismic.ColorField;

  /**
   * Primary CTA Text field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  primary_cta_text: prismic.KeyTextField;

  /**
   * Primary CTA Text Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  primary_cta_text_color: prismic.ColorField;

  /**
   * Background Color Start field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Center Image field in *HeroSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.center_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  center_image: prismic.ImageField<never>;

  /**
   * Center Image Mobile field in *HeroSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.center_image_mobile
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  center_image_mobile: prismic.ImageField<never>;
}

/**
 * Hero with Centered Image variation for HeroSection Slice
 *
 * - **API ID**: `heroWithCenteredImage`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type HeroSectionSliceHeroWithCenteredImage =
  prismic.SharedSliceVariation<
    'heroWithCenteredImage',
    Simplify<HeroSectionSliceHeroWithCenteredImagePrimary>,
    never
  >;

/**
 * Primary content in *HeroSection → Primary*
 */
export interface HeroSectionSliceRightAlignedImageHeroPrimary {
  /**
   * Background Color Start field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Content field in *HeroSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Primary CTA field in *HeroSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  primary_cta: prismic.LinkField;

  /**
   * Primary CTA Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  primary_cta_color: prismic.ColorField;

  /**
   * Primary CTA Text field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  primary_cta_text: prismic.KeyTextField;

  /**
   * Primary CTA Text Color field in *HeroSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.primary_cta_text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  primary_cta_text_color: prismic.ColorField;

  /**
   * Image field in *HeroSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<'mobile'>;
}

/**
 * Right Aligned Image Hero variation for HeroSection Slice
 *
 * - **API ID**: `rightAlignedImageHero`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type HeroSectionSliceRightAlignedImageHero =
  prismic.SharedSliceVariation<
    'rightAlignedImageHero',
    Simplify<HeroSectionSliceRightAlignedImageHeroPrimary>,
    never
  >;

/**
 * Primary content in *HeroSection → Primary*
 */
export interface HeroSectionSliceTretinoinHeroPrimary {
  /**
   * Background Image field in *HeroSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.background_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  background_image: prismic.ImageField<never>;

  /**
   * Desktop Image Right field in *HeroSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.desktop_image_right
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  desktop_image_right: prismic.ImageField<never>;

  /**
   * Desktop Image Left field in *HeroSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.desktop_image_left
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  desktop_image_left: prismic.ImageField<never>;

  /**
   * Quote field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.quote
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  quote: prismic.KeyTextField;

  /**
   * CTA Link field in *HeroSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Link Text field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_link_text: prismic.KeyTextField;

  /**
   * Small Text field in *HeroSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.small_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  small_text: prismic.KeyTextField;

  /**
   * Mobile Image field in *HeroSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: hero_section.primary.mobile_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  mobile_image: prismic.ImageField<never>;
}

/**
 * TretinoinHero variation for HeroSection Slice
 *
 * - **API ID**: `tretinoinHero`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type HeroSectionSliceTretinoinHero = prismic.SharedSliceVariation<
  'tretinoinHero',
  Simplify<HeroSectionSliceTretinoinHeroPrimary>,
  never
>;

/**
 * Slice variation for *HeroSection*
 */
type HeroSectionSliceVariation =
  | HeroSectionSliceDefault
  | HeroSectionSliceLeftAligned
  | HeroSectionSliceHeroWithVideo
  | HeroSectionSliceHeroWithCenteredImage
  | HeroSectionSliceRightAlignedImageHero
  | HeroSectionSliceTretinoinHero;

/**
 * HeroSection Shared Slice
 *
 * - **API ID**: `hero_section`
 * - **Description**: HeroSection
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type HeroSectionSlice = prismic.SharedSlice<
  'hero_section',
  HeroSectionSliceVariation
>;

/**
 * Primary content in *IconBulletList → Primary*
 */
export interface IconBulletListSliceDefaultPrimary {
  /**
   * Title field in *IconBulletList → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: icon_bullet_list.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Background Color Start field in *IconBulletList → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: icon_bullet_list.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *IconBulletList → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: icon_bullet_list.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;
}

/**
 * Primary content in *IconBulletList → Items*
 */
export interface IconBulletListSliceDefaultItem {
  /**
   * Icon field in *IconBulletList → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: icon_bullet_list.items[].icon
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  icon: prismic.ImageField<never>;

  /**
   * Header field in *IconBulletList → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: icon_bullet_list.items[].header
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  header: prismic.KeyTextField;

  /**
   * Subheader field in *IconBulletList → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: icon_bullet_list.items[].subheader
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subheader: prismic.KeyTextField;
}

/**
 * Default variation for IconBulletList Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type IconBulletListSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<IconBulletListSliceDefaultPrimary>,
  Simplify<IconBulletListSliceDefaultItem>
>;

/**
 * Slice variation for *IconBulletList*
 */
type IconBulletListSliceVariation = IconBulletListSliceDefault;

/**
 * IconBulletList Shared Slice
 *
 * - **API ID**: `icon_bullet_list`
 * - **Description**: IconBulletList
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type IconBulletListSlice = prismic.SharedSlice<
  'icon_bullet_list',
  IconBulletListSliceVariation
>;

/**
 * Primary content in *Incentives → Primary*
 */
export interface IncentivesSliceDefaultPrimary {
  /**
   * Title field in *Incentives → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: incentives.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *Incentives → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: incentives.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Name Color field in *Incentives → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: incentives.primary.name_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  name_color: prismic.ColorField;

  /**
   * Description Color field in *Incentives → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: incentives.primary.description_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  description_color: prismic.ColorField;

  /**
   * Background Color field in *Incentives → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: incentives.primary.background_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color: prismic.ColorField;
}

/**
 * Primary content in *Incentives → Items*
 */
export interface IncentivesSliceDefaultItem {
  /**
   * Name field in *Incentives → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: incentives.items[].name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;

  /**
   * Image field in *Incentives → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: incentives.items[].image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Description field in *Incentives → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: incentives.items[].description
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  description: prismic.KeyTextField;
}

/**
 * Default variation for Incentives Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type IncentivesSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<IncentivesSliceDefaultPrimary>,
  Simplify<IncentivesSliceDefaultItem>
>;

/**
 * Primary content in *Incentives → Primary*
 */
export interface IncentivesSliceListWithIconsPrimary {
  /**
   * Description Color field in *Incentives → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: incentives.primary.description_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  description_color: prismic.ColorField;

  /**
   * Background Color field in *Incentives → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: incentives.primary.background_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color: prismic.ColorField;
}

/**
 * Primary content in *Incentives → Items*
 */
export interface IncentivesSliceListWithIconsItem {
  /**
   * Name field in *Incentives → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: incentives.items[].name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;

  /**
   * Image field in *Incentives → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: incentives.items[].image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Description field in *Incentives → Items*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: incentives.items[].description
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  description: prismic.RichTextField;
}

/**
 * ListWithIcons variation for Incentives Slice
 *
 * - **API ID**: `listWithIcons`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type IncentivesSliceListWithIcons = prismic.SharedSliceVariation<
  'listWithIcons',
  Simplify<IncentivesSliceListWithIconsPrimary>,
  Simplify<IncentivesSliceListWithIconsItem>
>;

/**
 * Slice variation for *Incentives*
 */
type IncentivesSliceVariation =
  | IncentivesSliceDefault
  | IncentivesSliceListWithIcons;

/**
 * Incentives Shared Slice
 *
 * - **API ID**: `incentives`
 * - **Description**: Incentives
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type IncentivesSlice = prismic.SharedSlice<
  'incentives',
  IncentivesSliceVariation
>;

/**
 * Primary content in *InfoPopover → Primary*
 */
export interface InfoPopoverSliceDefaultPrimary {
  /**
   * Image field in *InfoPopover → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: info_popover.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Title field in *InfoPopover → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: info_popover.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Content field in *InfoPopover → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: info_popover.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Primary CTA Link field in *InfoPopover → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: info_popover.primary.primary_cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  primary_cta_link: prismic.LinkField;

  /**
   * Primary CTA Type field in *InfoPopover → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: info_popover.primary.primary_cta_type
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  primary_cta_type: prismic.SelectField<'Button' | 'Dependent Dropdown'>;

  /**
   * Primary CTA Text field in *InfoPopover → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: info_popover.primary.primary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  primary_cta_text: prismic.KeyTextField;

  /**
   * Primary CTA Style field in *InfoPopover → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: info_popover.primary.primary_cta_style
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  primary_cta_style: prismic.SelectField<
    'solid-black' | 'solid-accent' | 'solid-gray' | 'outline-gray'
  >;

  /**
   * Secondary CTA Link field in *InfoPopover → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: info_popover.primary.secondary_cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  secondary_cta_link: prismic.LinkField;

  /**
   * Secondary CTA Type field in *InfoPopover → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: info_popover.primary.secondary_cta_type
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  secondary_cta_type: prismic.SelectField<'Button' | 'Dependent Dropdown'>;

  /**
   * Secondary CTA Text field in *InfoPopover → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: info_popover.primary.secondary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  secondary_cta_text: prismic.KeyTextField;

  /**
   * Secondary CTA Style field in *InfoPopover → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: info_popover.primary.secondary_cta_style
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  secondary_cta_style: prismic.SelectField<
    'solid-black' | 'solid-accent' | 'solid-gray' | 'outline-gray'
  >;
}

/**
 * Default variation for InfoPopover Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type InfoPopoverSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<InfoPopoverSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *InfoPopover*
 */
type InfoPopoverSliceVariation = InfoPopoverSliceDefault;

/**
 * InfoPopover Shared Slice
 *
 * - **API ID**: `info_popover`
 * - **Description**: InfoPopover
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type InfoPopoverSlice = prismic.SharedSlice<
  'info_popover',
  InfoPopoverSliceVariation
>;

/**
 * Primary content in *InfoTabs → Primary*
 */
export interface InfoTabsSliceDefaultPrimary {
  /**
   * Title field in *InfoTabs → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: info_tabs.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Description field in *InfoTabs → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: info_tabs.primary.description
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  description: prismic.RichTextField;

  /**
   * CTA Link field in *InfoTabs → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: info_tabs.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Link Text field in *InfoTabs → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: info_tabs.primary.cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_link_text: prismic.KeyTextField;
}

/**
 * Primary content in *InfoTabs → Items*
 */
export interface InfoTabsSliceDefaultItem {
  /**
   * Tab Name field in *InfoTabs → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: info_tabs.items[].tab_name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  tab_name: prismic.KeyTextField;

  /**
   * Image field in *InfoTabs → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: info_tabs.items[].image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Content field in *InfoTabs → Items*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: info_tabs.items[].content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;
}

/**
 * Default variation for InfoTabs Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type InfoTabsSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<InfoTabsSliceDefaultPrimary>,
  Simplify<InfoTabsSliceDefaultItem>
>;

/**
 * Slice variation for *InfoTabs*
 */
type InfoTabsSliceVariation = InfoTabsSliceDefault;

/**
 * InfoTabs Shared Slice
 *
 * - **API ID**: `info_tabs`
 * - **Description**: InfoTabs
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type InfoTabsSlice = prismic.SharedSlice<
  'info_tabs',
  InfoTabsSliceVariation
>;

/**
 * Primary content in *LargeQuote → Primary*
 */
export interface LargeQuoteSliceDefaultPrimary {
  /**
   * Quote field in *LargeQuote → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.quote
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  quote: prismic.KeyTextField;

  /**
   * Quote Color field in *LargeQuote → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.quote_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  quote_color: prismic.ColorField;

  /**
   * Profile Image field in *LargeQuote → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.profile_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  profile_image: prismic.ImageField<never>;

  /**
   * Name field in *LargeQuote → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;

  /**
   * Name Color field in *LargeQuote → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.name_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  name_color: prismic.ColorField;

  /**
   * Job Title field in *LargeQuote → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.job_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  job_title: prismic.KeyTextField;

  /**
   * Job Title Color field in *LargeQuote → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.job_title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  job_title_color: prismic.ColorField;
}

/**
 * Primary content in *LargeQuote → Items*
 */
export interface LargeQuoteSliceDefaultItem {
  /**
   * Social Icon field in *LargeQuote → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.items[].social_icon
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  social_icon: prismic.ImageField<never>;
}

/**
 * Default variation for LargeQuote Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type LargeQuoteSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<LargeQuoteSliceDefaultPrimary>,
  Simplify<LargeQuoteSliceDefaultItem>
>;

/**
 * Primary content in *LargeQuote → Primary*
 */
export interface LargeQuoteSliceLeftAlignedProfileImagePrimary {
  /**
   * Image field in *LargeQuote → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Quote Title field in *LargeQuote → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.quote_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  quote_title: prismic.KeyTextField;

  /**
   * Quote Title Color field in *LargeQuote → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.quote_title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  quote_title_color: prismic.ColorField;

  /**
   * Quote field in *LargeQuote → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.quote
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  quote: prismic.KeyTextField;

  /**
   * Quote Color field in *LargeQuote → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.quote_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  quote_color: prismic.ColorField;

  /**
   * Name field in *LargeQuote → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;

  /**
   * Name Color field in *LargeQuote → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.name_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  name_color: prismic.ColorField;

  /**
   * Job Title field in *LargeQuote → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.job_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  job_title: prismic.KeyTextField;

  /**
   * Job Title Color field in *LargeQuote → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.job_title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  job_title_color: prismic.ColorField;
}

/**
 * Primary content in *LargeQuote → Items*
 */
export interface LargeQuoteSliceLeftAlignedProfileImageItem {
  /**
   * Social Icon field in *LargeQuote → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.items[].social_icon
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  social_icon: prismic.ImageField<never>;
}

/**
 * Left-Aligned Profile Image variation for LargeQuote Slice
 *
 * - **API ID**: `leftAlignedProfileImage`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type LargeQuoteSliceLeftAlignedProfileImage =
  prismic.SharedSliceVariation<
    'leftAlignedProfileImage',
    Simplify<LargeQuoteSliceLeftAlignedProfileImagePrimary>,
    Simplify<LargeQuoteSliceLeftAlignedProfileImageItem>
  >;

/**
 * Primary content in *LargeQuote → Primary*
 */
export interface LargeQuoteSliceLeftAlignedVideoPrimary {
  /**
   * Video Link field in *LargeQuote → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.video_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  video_link: prismic.LinkField;

  /**
   * Include Background Box Decoration field in *LargeQuote → Primary*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: false
   * - **API ID Path**: large_quote.primary.include_background_box_decoration
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  include_background_box_decoration: prismic.BooleanField;

  /**
   * Quote Title field in *LargeQuote → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.quote_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  quote_title: prismic.KeyTextField;

  /**
   * Quote Title Color field in *LargeQuote → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.quote_title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  quote_title_color: prismic.ColorField;

  /**
   * Quote field in *LargeQuote → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.quote
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  quote: prismic.KeyTextField;

  /**
   * Quote Color field in *LargeQuote → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.quote_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  quote_color: prismic.ColorField;

  /**
   * Name field in *LargeQuote → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;

  /**
   * Name Color field in *LargeQuote → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.name_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  name_color: prismic.ColorField;

  /**
   * Job Title field in *LargeQuote → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.job_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  job_title: prismic.KeyTextField;

  /**
   * Job Title Color field in *LargeQuote → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.primary.job_title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  job_title_color: prismic.ColorField;
}

/**
 * Primary content in *LargeQuote → Items*
 */
export interface LargeQuoteSliceLeftAlignedVideoItem {
  /**
   * Social Icon field in *LargeQuote → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: large_quote.items[].social_icon
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  social_icon: prismic.ImageField<never>;
}

/**
 * Left-Aligned Video variation for LargeQuote Slice
 *
 * - **API ID**: `leftAlignedVideo`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type LargeQuoteSliceLeftAlignedVideo = prismic.SharedSliceVariation<
  'leftAlignedVideo',
  Simplify<LargeQuoteSliceLeftAlignedVideoPrimary>,
  Simplify<LargeQuoteSliceLeftAlignedVideoItem>
>;

/**
 * Slice variation for *LargeQuote*
 */
type LargeQuoteSliceVariation =
  | LargeQuoteSliceDefault
  | LargeQuoteSliceLeftAlignedProfileImage
  | LargeQuoteSliceLeftAlignedVideo;

/**
 * LargeQuote Shared Slice
 *
 * - **API ID**: `large_quote`
 * - **Description**: LargeQuote
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type LargeQuoteSlice = prismic.SharedSlice<
  'large_quote',
  LargeQuoteSliceVariation
>;

/**
 * Primary content in *LogoCloud → Primary*
 */
export interface LogoCloudSliceDefaultPrimary {
  /**
   * Title field in *LogoCloud → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: logo_cloud.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *LogoCloud → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: logo_cloud.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Background Color Start field in *LogoCloud → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: logo_cloud.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *LogoCloud → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: logo_cloud.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;
}

/**
 * Primary content in *LogoCloud → Items*
 */
export interface LogoCloudSliceDefaultItem {
  /**
   * Logo field in *LogoCloud → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: logo_cloud.items[].logo
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  logo: prismic.ImageField<never>;
}

/**
 * Default variation for LogoCloud Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type LogoCloudSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<LogoCloudSliceDefaultPrimary>,
  Simplify<LogoCloudSliceDefaultItem>
>;

/**
 * Slice variation for *LogoCloud*
 */
type LogoCloudSliceVariation = LogoCloudSliceDefault;

/**
 * LogoCloud Shared Slice
 *
 * - **API ID**: `logo_cloud`
 * - **Description**: LogoCloud
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type LogoCloudSlice = prismic.SharedSlice<
  'logo_cloud',
  LogoCloudSliceVariation
>;

/**
 * Primary content in *AccountCtaSection → Primary*
 */
export interface MessagingCtaSectionSliceDefaultPrimary {
  /**
   * Eyebrow field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Title field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Content field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * CTA Button Text field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Link field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;
}

/**
 * Default variation for AccountCtaSection Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type MessagingCtaSectionSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<MessagingCtaSectionSliceDefaultPrimary>,
  never
>;

/**
 * Primary content in *AccountCtaSection → Primary*
 */
export interface MessagingCtaSectionSliceCtaWithImagePrimary {
  /**
   * Image field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Eyebrow field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Content field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * CTA Button Text field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Link field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;
}

/**
 * CtaWithImage variation for AccountCtaSection Slice
 *
 * - **API ID**: `ctaWithImage`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type MessagingCtaSectionSliceCtaWithImage = prismic.SharedSliceVariation<
  'ctaWithImage',
  Simplify<MessagingCtaSectionSliceCtaWithImagePrimary>,
  never
>;

/**
 * Primary content in *AccountCtaSection → Items*
 */
export interface MessagingCtaSectionSliceTwoColumnGridItem {
  /**
   * Eyebrow field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Title field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Content field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * CTA Button Text field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Link field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * Concierge CTA Link field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].concierge_cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  concierge_cta_link: prismic.LinkField;

  /**
   * Concierge CTA Link Text field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].concierge_cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  concierge_cta_link_text: prismic.KeyTextField;
}

/**
 * TwoColumnGrid variation for AccountCtaSection Slice
 *
 * - **API ID**: `twoColumnGrid`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type MessagingCtaSectionSliceTwoColumnGrid =
  prismic.SharedSliceVariation<
    'twoColumnGrid',
    Record<string, never>,
    Simplify<MessagingCtaSectionSliceTwoColumnGridItem>
  >;

/**
 * Primary content in *AccountCtaSection → Primary*
 */
export interface MessagingCtaSectionSliceTwoColumnWithImagePrimary {
  /**
   * Background Color Start field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Alignment field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.alignment
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  alignment: prismic.SelectField<'image-left' | 'image-right'>;

  /**
   * Image field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Header Badge Text field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.header_badge_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  header_badge_text: prismic.KeyTextField;

  /**
   * Title field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Content field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Content Color field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.content_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  content_color: prismic.ColorField;

  /**
   * CTA Link Style field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_link_style
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  cta_link_style: prismic.SelectField<
    'solid-black' | 'solid-accent' | 'solid-gray'
  >;

  /**
   * CTA Link field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Button Text field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Action field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_action
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  cta_action: prismic.SelectField<
    'ADD_CONCIERGE_MONTHLY' | 'ADD_CONCIERGE_YEARLY' | 'LINK'
  >;
}

/**
 * Two Column with Image variation for AccountCtaSection Slice
 *
 * - **API ID**: `twoColumnWithImage`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type MessagingCtaSectionSliceTwoColumnWithImage =
  prismic.SharedSliceVariation<
    'twoColumnWithImage',
    Simplify<MessagingCtaSectionSliceTwoColumnWithImagePrimary>,
    never
  >;

/**
 * Primary content in *AccountCtaSection → Primary*
 */
export interface MessagingCtaSectionSliceProductCardsPrimary {
  /**
   * Background Color Start field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Divider Text field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.divider_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  divider_text: prismic.KeyTextField;

  /**
   * Divider Color field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.divider_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  divider_color: prismic.ColorField;
}

/**
 * Primary content in *AccountCtaSection → Items*
 */
export interface MessagingCtaSectionSliceProductCardsItem {
  /**
   * Header Text field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].header_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  header_text: prismic.KeyTextField;

  /**
   * Eyebrow field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Title Image field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].title_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  title_image: prismic.ImageField<never>;

  /**
   * Description field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].description
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  description: prismic.KeyTextField;

  /**
   * Description Subtext field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].description_subtext
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  description_subtext: prismic.KeyTextField;

  /**
   * Price field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].price
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  price: prismic.KeyTextField;

  /**
   * Price Units field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].price_units
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  price_units: prismic.KeyTextField;

  /**
   * Price Callout field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].price_callout
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  price_callout: prismic.KeyTextField;

  /**
   * CTA Link Style field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].cta_link_style
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  cta_link_style: prismic.SelectField<'solid-primary' | 'solid-accent'>;

  /**
   * CTA Link field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Link Text field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_link_text: prismic.KeyTextField;

  /**
   * CTA Action field in *AccountCtaSection → Items*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.items[].cta_action
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  cta_action: prismic.SelectField<
    'ADD_CONCIERGE_MONTHLY' | 'ADD_CONCIERGE_YEARLY' | 'LINK'
  >;
}

/**
 * Product Cards variation for AccountCtaSection Slice
 *
 * - **API ID**: `productCards`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type MessagingCtaSectionSliceProductCards = prismic.SharedSliceVariation<
  'productCards',
  Simplify<MessagingCtaSectionSliceProductCardsPrimary>,
  Simplify<MessagingCtaSectionSliceProductCardsItem>
>;

/**
 * Primary content in *AccountCtaSection → Primary*
 */
export interface MessagingCtaSectionSliceImageTitleCtaPrimary {
  /**
   * Background Color Start field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Title Image field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.title_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  title_image: prismic.ImageField<never>;

  /**
   * Subheader field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.subheader
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  subheader: prismic.KeyTextField;

  /**
   * Subheader Color field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.subheader_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  subheader_color: prismic.ColorField;

  /**
   * CTA Link Style field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_link_style
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  cta_link_style: prismic.SelectField<
    'solid-primary' | 'solid-accent' | 'solid-gray'
  >;

  /**
   * CTA Link field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Link Text field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_link_text: prismic.KeyTextField;

  /**
   * CTA Callout field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_callout
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_callout: prismic.KeyTextField;

  /**
   * CTA Callout Color field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_callout_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  cta_callout_color: prismic.ColorField;

  /**
   * CTA Action field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_action
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  cta_action: prismic.SelectField<
    'ADD_CONCIERGE_MONTHLY' | 'ADD_CONCIERGE_YEARLY' | 'LINK'
  >;

  /**
   * Secondary CTA field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.secondary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  secondary_cta: prismic.LinkField;

  /**
   * Secondary CTA Text  field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.secondary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  secondary_cta_text: prismic.KeyTextField;

  /**
   * Secondary CTA Link Style field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.secondary_cta_link_style
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  secondary_cta_link_style: prismic.SelectField<
    'solid-primary' | 'solid-accent' | 'solid-gray'
  >;
}

/**
 * Image Title CTA variation for AccountCtaSection Slice
 *
 * - **API ID**: `imageTitleCta`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type MessagingCtaSectionSliceImageTitleCta =
  prismic.SharedSliceVariation<
    'imageTitleCta',
    Simplify<MessagingCtaSectionSliceImageTitleCtaPrimary>,
    never
  >;

/**
 * Primary content in *AccountCtaSection → Primary*
 */
export interface MessagingCtaSectionSliceProductListCtaPrimary {
  /**
   * Background Color Start field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Image field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Logo field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.logo
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  logo: prismic.ImageField<never>;

  /**
   * Product Logo field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.product_logo
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  product_logo: prismic.ImageField<never>;

  /**
   * Content field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Content Color field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.content_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  content_color: prismic.ColorField;

  /**
   * CTA Link Style field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_link_style
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  cta_link_style: prismic.SelectField<'solid-black' | 'solid-accent'>;

  /**
   * CTA Link field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Button Text field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;
}

/**
 * ProductListCTA variation for AccountCtaSection Slice
 *
 * - **API ID**: `productListCta`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type MessagingCtaSectionSliceProductListCta =
  prismic.SharedSliceVariation<
    'productListCta',
    Simplify<MessagingCtaSectionSliceProductListCtaPrimary>,
    never
  >;

/**
 * Primary content in *AccountCtaSection → Primary*
 */
export interface MessagingCtaSectionSliceFeaturedImagePrimary {
  /**
   * Eyebrow field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  eyebrow: prismic.KeyTextField;

  /**
   * Title field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Content field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * CTA Button Text field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_button_text: prismic.KeyTextField;

  /**
   * CTA Link field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * Image field in *AccountCtaSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: messaging_cta_section.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;
}

/**
 * FeaturedImage variation for AccountCtaSection Slice
 *
 * - **API ID**: `featuredImage`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type MessagingCtaSectionSliceFeaturedImage =
  prismic.SharedSliceVariation<
    'featuredImage',
    Simplify<MessagingCtaSectionSliceFeaturedImagePrimary>,
    never
  >;

/**
 * Slice variation for *AccountCtaSection*
 */
type MessagingCtaSectionSliceVariation =
  | MessagingCtaSectionSliceDefault
  | MessagingCtaSectionSliceCtaWithImage
  | MessagingCtaSectionSliceTwoColumnGrid
  | MessagingCtaSectionSliceTwoColumnWithImage
  | MessagingCtaSectionSliceProductCards
  | MessagingCtaSectionSliceImageTitleCta
  | MessagingCtaSectionSliceProductListCta
  | MessagingCtaSectionSliceFeaturedImage;

/**
 * AccountCtaSection Shared Slice
 *
 * - **API ID**: `messaging_cta_section`
 * - **Description**: MessagingCtaSection
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type MessagingCtaSectionSlice = prismic.SharedSlice<
  'messaging_cta_section',
  MessagingCtaSectionSliceVariation
>;

/**
 * Primary content in *NavigationItem → Primary*
 */
export interface NavigationBarSliceDefaultPrimary {
  /**
   * Name field in *NavigationItem → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation_bar.primary.name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;

  /**
   * Link field in *NavigationItem → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation_bar.primary.link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Header Position field in *NavigationItem → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **Default Value**: Left
   * - **API ID Path**: navigation_bar.primary.header_position
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  header_position: prismic.SelectField<'Left' | 'Right', 'filled'>;

  /**
   * Prefetch field in *NavigationItem → Primary*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: true
   * - **API ID Path**: navigation_bar.primary.prefetch
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  prefetch: prismic.BooleanField;
}

/**
 * Primary content in *NavigationItem → Items*
 */
export interface NavigationBarSliceDefaultItem {
  /**
   * Child Name field in *NavigationItem → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation_bar.items[].child_name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  child_name: prismic.KeyTextField;

  /**
   * Child Link field in *NavigationItem → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation_bar.items[].child_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  child_link: prismic.LinkField;

  /**
   * Prefetch field in *NavigationItem → Items*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: true
   * - **API ID Path**: navigation_bar.items[].prefetch
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  prefetch: prismic.BooleanField;
}

/**
 * Default variation for NavigationItem Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type NavigationBarSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<NavigationBarSliceDefaultPrimary>,
  Simplify<NavigationBarSliceDefaultItem>
>;

/**
 * Primary content in *NavigationItem → Primary*
 */
export interface NavigationBarSliceButtonPrimary {
  /**
   * Name field in *NavigationItem → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation_bar.primary.name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;

  /**
   * Link field in *NavigationItem → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation_bar.primary.link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Header Position field in *NavigationItem → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation_bar.primary.header_position
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  header_position: prismic.SelectField<'Left' | 'Right'>;

  /**
   * Prefetch field in *NavigationItem → Primary*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: true
   * - **API ID Path**: navigation_bar.primary.prefetch
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  prefetch: prismic.BooleanField;
}

/**
 * Button variation for NavigationItem Slice
 *
 * - **API ID**: `button`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type NavigationBarSliceButton = prismic.SharedSliceVariation<
  'button',
  Simplify<NavigationBarSliceButtonPrimary>,
  never
>;

/**
 * Primary content in *NavigationItem → Primary*
 */
export interface NavigationBarSliceAccountNavigationItemPrimary {
  /**
   * Icon field in *NavigationItem → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation_bar.primary.icon
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  icon: prismic.SelectField<
    | 'home'
    | 'message'
    | 'bell'
    | 'line-chart-up'
    | 'user-group'
    | 'settings'
    | 'support'
    | 'logout'
    | 'concierge-c'
    | 'medical-circle'
    | 'droplets'
    | 'user'
    | 'package'
  >;

  /**
   * Name field in *NavigationItem → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation_bar.primary.name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;

  /**
   * Link field in *NavigationItem → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation_bar.primary.link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  link: prismic.LinkField;

  /**
   * Position field in *NavigationItem → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation_bar.primary.position
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  position: prismic.SelectField<'Main' | 'Secondary'>;

  /**
   * Status Badge field in *NavigationItem → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: navigation_bar.primary.status_badge
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  status_badge: prismic.KeyTextField;

  /**
   * Has Divider Below field in *NavigationItem → Primary*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: false
   * - **API ID Path**: navigation_bar.primary.has_divider_below
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  has_divider_below: prismic.BooleanField;

  /**
   * Prefetch field in *NavigationItem → Primary*
   *
   * - **Field Type**: Boolean
   * - **Placeholder**: *None*
   * - **Default Value**: true
   * - **API ID Path**: navigation_bar.primary.prefetch
   * - **Documentation**: https://prismic.io/docs/field#boolean
   */
  prefetch: prismic.BooleanField;
}

/**
 * Account Navigation Item variation for NavigationItem Slice
 *
 * - **API ID**: `accountNavigationItem`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type NavigationBarSliceAccountNavigationItem =
  prismic.SharedSliceVariation<
    'accountNavigationItem',
    Simplify<NavigationBarSliceAccountNavigationItemPrimary>,
    never
  >;

/**
 * Slice variation for *NavigationItem*
 */
type NavigationBarSliceVariation =
  | NavigationBarSliceDefault
  | NavigationBarSliceButton
  | NavigationBarSliceAccountNavigationItem;

/**
 * NavigationItem Shared Slice
 *
 * - **API ID**: `navigation_bar`
 * - **Description**: NavigationBar
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type NavigationBarSlice = prismic.SharedSlice<
  'navigation_bar',
  NavigationBarSliceVariation
>;

/**
 * Primary content in *OrderConfirmation → Primary*
 */
export interface OrderConfirmationSliceDefaultPrimary {
  /**
   * Auth Eyebrow field in *OrderConfirmation → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: order_confirmation.primary.auth_eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  auth_eyebrow: prismic.KeyTextField;

  /**
   * Auth Title field in *OrderConfirmation → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: order_confirmation.primary.auth_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  auth_title: prismic.KeyTextField;

  /**
   * Auth Description field in *OrderConfirmation → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: order_confirmation.primary.auth_description
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  auth_description: prismic.RichTextField;

  /**
   * Auth Primary CTA field in *OrderConfirmation → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: order_confirmation.primary.auth_primary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  auth_primary_cta: prismic.LinkField;

  /**
   * Auth Primary CTA Text field in *OrderConfirmation → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: order_confirmation.primary.auth_primary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  auth_primary_cta_text: prismic.KeyTextField;

  /**
   * Auth Secondary CTA field in *OrderConfirmation → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: order_confirmation.primary.auth_secondary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  auth_secondary_cta: prismic.LinkField;

  /**
   * Auth Secondary CTA Text field in *OrderConfirmation → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: order_confirmation.primary.auth_secondary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  auth_secondary_cta_text: prismic.KeyTextField;

  /**
   * Unauth Eyebrow field in *OrderConfirmation → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: order_confirmation.primary.unauth_eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  unauth_eyebrow: prismic.KeyTextField;

  /**
   * Unauth Title field in *OrderConfirmation → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: order_confirmation.primary.unauth_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  unauth_title: prismic.KeyTextField;

  /**
   * Unauth Description field in *OrderConfirmation → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: order_confirmation.primary.unauth_description
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  unauth_description: prismic.RichTextField;

  /**
   * Unauth Primary CTA field in *OrderConfirmation → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: order_confirmation.primary.unauth_primary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  unauth_primary_cta: prismic.LinkField;

  /**
   * Unauth Primary CTA Text field in *OrderConfirmation → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: order_confirmation.primary.unauth_primary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  unauth_primary_cta_text: prismic.KeyTextField;

  /**
   * Unauth Secondary CTA field in *OrderConfirmation → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: order_confirmation.primary.unauth_secondary_cta
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  unauth_secondary_cta: prismic.LinkField;

  /**
   * Unauth Secondary CTA Text field in *OrderConfirmation → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: order_confirmation.primary.unauth_secondary_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  unauth_secondary_cta_text: prismic.KeyTextField;
}

/**
 * Default variation for OrderConfirmation Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type OrderConfirmationSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<OrderConfirmationSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *OrderConfirmation*
 */
type OrderConfirmationSliceVariation = OrderConfirmationSliceDefault;

/**
 * OrderConfirmation Shared Slice
 *
 * - **API ID**: `order_confirmation`
 * - **Description**: OrderConfirmation
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type OrderConfirmationSlice = prismic.SharedSlice<
  'order_confirmation',
  OrderConfirmationSliceVariation
>;

/**
 * Primary content in *OrderHistory → Primary*
 */
export interface OrderHistorySliceDefaultPrimary {
  /**
   * Orders Title field in *OrderHistory → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: order_history.primary.orders_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  orders_title: prismic.KeyTextField;

  /**
   * No Orders Title field in *OrderHistory → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: order_history.primary.no_orders_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_orders_title: prismic.KeyTextField;

  /**
   * No Orders Description field in *OrderHistory → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: order_history.primary.no_orders_description
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_orders_description: prismic.KeyTextField;
}

/**
 * Default variation for OrderHistory Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type OrderHistorySliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<OrderHistorySliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *OrderHistory*
 */
type OrderHistorySliceVariation = OrderHistorySliceDefault;

/**
 * OrderHistory Shared Slice
 *
 * - **API ID**: `order_history`
 * - **Description**: OrderHistory
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type OrderHistorySlice = prismic.SharedSlice<
  'order_history',
  OrderHistorySliceVariation
>;

/**
 * Primary content in *OrdersSection → Primary*
 */
export interface OrdersSectionSliceDefaultPrimary {
  /**
   * Orders Eyebrow field in *OrdersSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: orders_section.primary.orders_eyebrow
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  orders_eyebrow: prismic.KeyTextField;

  /**
   * Orders CTA Link field in *OrdersSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: orders_section.primary.orders_cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  orders_cta_link: prismic.LinkField;

  /**
   * Orders CTA Link Text field in *OrdersSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: orders_section.primary.orders_cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  orders_cta_link_text: prismic.KeyTextField;
}

/**
 * Default variation for OrdersSection Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type OrdersSectionSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<OrdersSectionSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *OrdersSection*
 */
type OrdersSectionSliceVariation = OrdersSectionSliceDefault;

/**
 * OrdersSection Shared Slice
 *
 * - **API ID**: `orders_section`
 * - **Description**: OrdersSection
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type OrdersSectionSlice = prismic.SharedSlice<
  'orders_section',
  OrdersSectionSliceVariation
>;

/**
 * Primary content in *PaymentMethods → Primary*
 */
export interface PaymentMethodsSliceDefaultPrimary {
  /**
   * Title field in *PaymentMethods → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: payment_methods.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Description field in *PaymentMethods → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: payment_methods.primary.description
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  description: prismic.KeyTextField;

  /**
   * Add Button Text field in *PaymentMethods → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: payment_methods.primary.add_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  add_button_text: prismic.KeyTextField;

  /**
   * Set Default Button Text field in *PaymentMethods → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: payment_methods.primary.set_default_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  set_default_button_text: prismic.KeyTextField;

  /**
   * No Methods Button Text field in *PaymentMethods → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: payment_methods.primary.no_methods_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  no_methods_button_text: prismic.KeyTextField;

  /**
   * Add Modal Title field in *PaymentMethods → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: payment_methods.primary.add_modal_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  add_modal_title: prismic.KeyTextField;

  /**
   * Add Modal Cancel Button Text field in *PaymentMethods → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: payment_methods.primary.add_modal_cancel_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  add_modal_cancel_button_text: prismic.KeyTextField;

  /**
   * Add Modal Save Button Text field in *PaymentMethods → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: payment_methods.primary.add_modal_save_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  add_modal_save_button_text: prismic.KeyTextField;

  /**
   * Add Modal Saving Button Text field in *PaymentMethods → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: payment_methods.primary.add_modal_saving_button_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  add_modal_saving_button_text: prismic.KeyTextField;

  /**
   * Set Default Error Text field in *PaymentMethods → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: payment_methods.primary.add_error_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  add_error_text: prismic.KeyTextField;

  /**
   * Card Descriptor field in *PaymentMethods → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: payment_methods.primary.card_descriptor
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  card_descriptor: prismic.KeyTextField;

  /**
   * Expiry Text field in *PaymentMethods → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: payment_methods.primary.expiry_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  expiry_text: prismic.KeyTextField;
}

/**
 * Default variation for PaymentMethods Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type PaymentMethodsSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<PaymentMethodsSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *PaymentMethods*
 */
type PaymentMethodsSliceVariation = PaymentMethodsSliceDefault;

/**
 * PaymentMethods Shared Slice
 *
 * - **API ID**: `payment_methods`
 * - **Description**: PaymentMethods
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type PaymentMethodsSlice = prismic.SharedSlice<
  'payment_methods',
  PaymentMethodsSliceVariation
>;

/**
 * Primary content in *PerksList → Primary*
 */
export interface PerksListSliceDefaultPrimary {
  /**
   * Background Color Start field in *PerksList → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: perks_list.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *PerksList → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: perks_list.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * logo field in *PerksList → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: perks_list.primary.logo
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  logo: prismic.ImageField<never>;

  /**
   * image field in *PerksList → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: perks_list.primary.image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Divider Text field in *PerksList → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: perks_list.primary.divider_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  divider_text: prismic.KeyTextField;

  /**
   * Divider Color field in *PerksList → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: perks_list.primary.divider_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  divider_color: prismic.ColorField;

  /**
   * Icon Box Color field in *PerksList → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: perks_list.primary.icon_box_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  icon_box_color: prismic.ColorField;
}

/**
 * Primary content in *PerksList → Items*
 */
export interface PerksListSliceDefaultItem {
  /**
   * Text field in *PerksList → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: perks_list.items[].text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  text: prismic.KeyTextField;

  /**
   * Text Color field in *PerksList → Items*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: perks_list.items[].text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  text_color: prismic.ColorField;
}

/**
 * Default variation for PerksList Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type PerksListSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<PerksListSliceDefaultPrimary>,
  Simplify<PerksListSliceDefaultItem>
>;

/**
 * Slice variation for *PerksList*
 */
type PerksListSliceVariation = PerksListSliceDefault;

/**
 * PerksList Shared Slice
 *
 * - **API ID**: `perks_list`
 * - **Description**: PerksList
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type PerksListSlice = prismic.SharedSlice<
  'perks_list',
  PerksListSliceVariation
>;

/**
 * Default variation for PrimaryUserContextSwitch Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type PrimaryUserContextSwitchSliceDefault = prismic.SharedSliceVariation<
  'default',
  Record<string, never>,
  never
>;

/**
 * Slice variation for *PrimaryUserContextSwitch*
 */
type PrimaryUserContextSwitchSliceVariation =
  PrimaryUserContextSwitchSliceDefault;

/**
 * PrimaryUserContextSwitch Shared Slice
 *
 * - **API ID**: `primary_user_context_switch`
 * - **Description**: PrimaryUserContextSwitch
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type PrimaryUserContextSwitchSlice = prismic.SharedSlice<
  'primary_user_context_switch',
  PrimaryUserContextSwitchSliceVariation
>;

/**
 * Primary content in *Product → Primary*
 */
export interface ProductSliceDefaultPrimary {
  /**
   * Title field in *Product → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Description field in *Product → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product.primary.description
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  description: prismic.RichTextField;

  /**
   * Feature 1 Title field in *Product → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product.primary.feature_1_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  feature_1_title: prismic.KeyTextField;

  /**
   * Feature 1 Content field in *Product → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product.primary.feature_1_content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  feature_1_content: prismic.RichTextField;

  /**
   * Feature 2 Title field in *Product → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product.primary.feature_2_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  feature_2_title: prismic.KeyTextField;

  /**
   * Feature 2 Content field in *Product → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product.primary.feature_2_content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  feature_2_content: prismic.RichTextField;

  /**
   * Feature 3 Title field in *Product → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product.primary.feature_3_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  feature_3_title: prismic.KeyTextField;

  /**
   * Feature 3 Content field in *Product → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product.primary.feature_3_content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  feature_3_content: prismic.RichTextField;

  /**
   * Error Text field in *Product → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product.primary.error_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  error_text: prismic.KeyTextField;
}

/**
 * Primary content in *Product → Items*
 */
export interface ProductSliceDefaultItem {
  /**
   * Images field in *Product → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: product.items[].image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;
}

/**
 * Default variation for Product Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type ProductSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<ProductSliceDefaultPrimary>,
  Simplify<ProductSliceDefaultItem>
>;

/**
 * Slice variation for *Product*
 */
type ProductSliceVariation = ProductSliceDefault;

/**
 * Product Shared Slice
 *
 * - **API ID**: `product`
 * - **Description**: Product
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type ProductSlice = prismic.SharedSlice<
  'product',
  ProductSliceVariation
>;

/**
 * Primary content in *ProductSuggestions → Primary*
 */
export interface ProductSuggestionsSliceDefaultPrimary {
  /**
   * Title field in *ProductSuggestions → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: product_suggestions.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;
}

/**
 * Default variation for ProductSuggestions Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type ProductSuggestionsSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<ProductSuggestionsSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *ProductSuggestions*
 */
type ProductSuggestionsSliceVariation = ProductSuggestionsSliceDefault;

/**
 * ProductSuggestions Shared Slice
 *
 * - **API ID**: `product_suggestions`
 * - **Description**: ProductSuggestions
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type ProductSuggestionsSlice = prismic.SharedSlice<
  'product_suggestions',
  ProductSuggestionsSliceVariation
>;

/**
 * Primary content in *ProductsList → Primary*
 */
export interface ProductsListSliceDefaultPrimary {
  /**
   * Type Filter Heading field in *ProductsList → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: products_list.primary.type_filter_heading
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  type_filter_heading: prismic.KeyTextField;

  /**
   * Price Filter Heading field in *ProductsList → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: products_list.primary.price_filter_heading
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  price_filter_heading: prismic.KeyTextField;
}

/**
 * Primary content in *ProductsList → Items*
 */
export interface ProductsListSliceDefaultItem {
  /**
   * Filter Tag field in *ProductsList → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: products_list.items[].filter_tag
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  filter_tag: prismic.KeyTextField;
}

/**
 * Default variation for ProductsList Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type ProductsListSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<ProductsListSliceDefaultPrimary>,
  Simplify<ProductsListSliceDefaultItem>
>;

/**
 * Slice variation for *ProductsList*
 */
type ProductsListSliceVariation = ProductsListSliceDefault;

/**
 * ProductsList Shared Slice
 *
 * - **API ID**: `products_list`
 * - **Description**: ProductsList
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type ProductsListSlice = prismic.SharedSlice<
  'products_list',
  ProductsListSliceVariation
>;

/**
 * Primary content in *Redirect → Items*
 */
export interface RedirectSliceDefaultItem {
  /**
   * State field in *Redirect → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: redirect.items[].state
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  state: prismic.KeyTextField;

  /**
   * Redirect Link field in *Redirect → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: redirect.items[].redirect_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  redirect_link: prismic.LinkField;
}

/**
 * Default variation for Redirect Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type RedirectSliceDefault = prismic.SharedSliceVariation<
  'default',
  Record<string, never>,
  Simplify<RedirectSliceDefaultItem>
>;

/**
 * Slice variation for *Redirect*
 */
type RedirectSliceVariation = RedirectSliceDefault;

/**
 * Redirect Shared Slice
 *
 * - **API ID**: `redirect`
 * - **Description**: Redirect
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type RedirectSlice = prismic.SharedSlice<
  'redirect',
  RedirectSliceVariation
>;

/**
 * Primary content in *RelatedBlogArticles → Primary*
 */
export interface RelatedBlogArticlesSliceDefaultPrimary {
  /**
   * Title field in *RelatedBlogArticles → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: related_blog_articles.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;
}

/**
 * Default variation for RelatedBlogArticles Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type RelatedBlogArticlesSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<RelatedBlogArticlesSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *RelatedBlogArticles*
 */
type RelatedBlogArticlesSliceVariation = RelatedBlogArticlesSliceDefault;

/**
 * RelatedBlogArticles Shared Slice
 *
 * - **API ID**: `related_blog_articles`
 * - **Description**: RelatedBlogArticles
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type RelatedBlogArticlesSlice = prismic.SharedSlice<
  'related_blog_articles',
  RelatedBlogArticlesSliceVariation
>;

/**
 * Primary content in *SettingsTab → Primary*
 */
export interface SettingsTabSliceDefaultPrimary {
  /**
   * Title field in *SettingsTab → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: settings_tab.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Family Selector Label field in *SettingsTab → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: settings_tab.primary.family_selector_label
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  family_selector_label: prismic.KeyTextField;

  /**
   * Add Family Link field in *SettingsTab → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: settings_tab.primary.add_family_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  add_family_link: prismic.LinkField;

  /**
   * Add Family Link Text field in *SettingsTab → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: settings_tab.primary.add_family_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  add_family_link_text: prismic.KeyTextField;

  /**
   * Edit Family Link field in *SettingsTab → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: settings_tab.primary.edit_family_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  edit_family_link: prismic.LinkField;

  /**
   * Edit Family Link Text field in *SettingsTab → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: settings_tab.primary.edit_family_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  edit_family_link_text: prismic.KeyTextField;

  /**
   * Add Family Title field in *SettingsTab → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: settings_tab.primary.add_family_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  add_family_title: prismic.KeyTextField;

  /**
   * Add Family Description field in *SettingsTab → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: settings_tab.primary.add_family_description
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  add_family_description: prismic.KeyTextField;
}

/**
 * Primary content in *SettingsTab → Items*
 */
export interface SettingsTabSliceDefaultItem {
  /**
   * Tab Name field in *SettingsTab → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: settings_tab.items[].tab_name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  tab_name: prismic.KeyTextField;

  /**
   * Linked Item field in *SettingsTab → Items*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: settings_tab.items[].linked_item
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  linked_item: prismic.ContentRelationshipField<
    'billing' | 'form' | 'subscriptions' | 'order_history'
  >;

  /**
   * Show When field in *SettingsTab → Items*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **Default Value**: ALWAYS
   * - **API ID Path**: settings_tab.items[].show_when
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  show_when: prismic.SelectField<'ALWAYS' | 'HAS_CONCIERGE', 'filled'>;
}

/**
 * Default variation for SettingsTab Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type SettingsTabSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<SettingsTabSliceDefaultPrimary>,
  Simplify<SettingsTabSliceDefaultItem>
>;

/**
 * Slice variation for *SettingsTab*
 */
type SettingsTabSliceVariation = SettingsTabSliceDefault;

/**
 * SettingsTab Shared Slice
 *
 * - **API ID**: `settings_tab`
 * - **Description**: SettingsTab
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type SettingsTabSlice = prismic.SharedSlice<
  'settings_tab',
  SettingsTabSliceVariation
>;

/**
 * Primary content in *StartPopover → Items*
 */
export interface StartPopoverSliceDefaultItem {
  /**
   * Content Type field in *StartPopover → Items*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: start_popover.items[].content_type
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  content_type: prismic.SelectField<
    'Default' | 'Default Family Disallowed' | 'Custom Employer'
  >;

  /**
   * Employer ID field in *StartPopover → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: start_popover.items[].employer_id
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  employer_id: prismic.KeyTextField;

  /**
   * Image field in *StartPopover → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: start_popover.items[].image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Video Link field in *StartPopover → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: start_popover.items[].video_link
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  video_link: prismic.KeyTextField;

  /**
   * Header field in *StartPopover → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: start_popover.items[].header
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  header: prismic.KeyTextField;

  /**
   * Content field in *StartPopover → Items*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: start_popover.items[].content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Self CTA Text field in *StartPopover → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: start_popover.items[].self_cta_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  self_cta_text: prismic.KeyTextField;

  /**
   * Self CTA Link field in *StartPopover → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: start_popover.items[].self_cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  self_cta_link: prismic.LinkField;

  /**
   * Family Selector Label field in *StartPopover → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: start_popover.items[].family_selector_label
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  family_selector_label: prismic.KeyTextField;

  /**
   * Family CTA Link field in *StartPopover → Items*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: start_popover.items[].family_cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  family_cta_link: prismic.LinkField;
}

/**
 * Default variation for StartPopover Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type StartPopoverSliceDefault = prismic.SharedSliceVariation<
  'default',
  Record<string, never>,
  Simplify<StartPopoverSliceDefaultItem>
>;

/**
 * Slice variation for *StartPopover*
 */
type StartPopoverSliceVariation = StartPopoverSliceDefault;

/**
 * StartPopover Shared Slice
 *
 * - **API ID**: `start_popover`
 * - **Description**: StartPopover
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type StartPopoverSlice = prismic.SharedSlice<
  'start_popover',
  StartPopoverSliceVariation
>;

/**
 * Primary content in *StatsBanner → Primary*
 */
export interface StatsBannerSliceDefaultPrimary {
  /**
   * Background Color Start field in *StatsBanner → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: stats_banner.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *StatsBanner → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: stats_banner.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Text Color field in *StatsBanner → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: stats_banner.primary.text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  text_color: prismic.ColorField;

  /**
   * Text Size field in *StatsBanner → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: stats_banner.primary.text_size
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  text_size: prismic.SelectField<'small' | 'large'>;

  /**
   * Alignment field in *StatsBanner → Primary*
   *
   * - **Field Type**: Select
   * - **Placeholder**: *None*
   * - **API ID Path**: stats_banner.primary.alignment
   * - **Documentation**: https://prismic.io/docs/field#select
   */
  alignment: prismic.SelectField<'start' | 'center'>;
}

/**
 * Primary content in *StatsBanner → Items*
 */
export interface StatsBannerSliceDefaultItem {
  /**
   * Icon Image field in *StatsBanner → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: stats_banner.items[].icon_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  icon_image: prismic.ImageField<never>;

  /**
   * Name field in *StatsBanner → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: stats_banner.items[].name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;
}

/**
 * Default variation for StatsBanner Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type StatsBannerSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<StatsBannerSliceDefaultPrimary>,
  Simplify<StatsBannerSliceDefaultItem>
>;

/**
 * Slice variation for *StatsBanner*
 */
type StatsBannerSliceVariation = StatsBannerSliceDefault;

/**
 * StatsBanner Shared Slice
 *
 * - **API ID**: `stats_banner`
 * - **Description**: StatsBanner
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type StatsBannerSlice = prismic.SharedSlice<
  'stats_banner',
  StatsBannerSliceVariation
>;

/**
 * Primary content in *StepsSection → Primary*
 */
export interface StepsSectionSliceDefaultPrimary {
  /**
   * Title field in *StepsSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: steps_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Subheader field in *StepsSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: steps_section.primary.subheader
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  subheader: prismic.RichTextField;

  /**
   * Disclaimer Text field in *StepsSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: steps_section.primary.disclaimer_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  disclaimer_text: prismic.KeyTextField;

  /**
   * Footer field in *StepsSection → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: steps_section.primary.footer
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  footer: prismic.RichTextField;

  /**
   * CTA Link field in *StepsSection → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: steps_section.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Link Text field in *StepsSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: steps_section.primary.cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_link_text: prismic.KeyTextField;
}

/**
 * Primary content in *StepsSection → Items*
 */
export interface StepsSectionSliceDefaultItem {
  /**
   * Image field in *StepsSection → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: steps_section.items[].image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Content field in *StepsSection → Items*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: steps_section.items[].content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;
}

/**
 * Default variation for StepsSection Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type StepsSectionSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<StepsSectionSliceDefaultPrimary>,
  Simplify<StepsSectionSliceDefaultItem>
>;

/**
 * Slice variation for *StepsSection*
 */
type StepsSectionSliceVariation = StepsSectionSliceDefault;

/**
 * StepsSection Shared Slice
 *
 * - **API ID**: `steps_section`
 * - **Description**: StepsSection
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type StepsSectionSlice = prismic.SharedSlice<
  'steps_section',
  StepsSectionSliceVariation
>;

/**
 * Primary content in *SubscribeSection → Primary*
 */
export interface SubscribeSectionSliceDefaultPrimary {
  /**
   * Background Image field in *SubscribeSection → Primary*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: subscribe_section.primary.background_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  background_image: prismic.ImageField<never>;

  /**
   * Title field in *SubscribeSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscribe_section.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Description field in *SubscribeSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscribe_section.primary.description
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  description: prismic.KeyTextField;

  /**
   * Label Text field in *SubscribeSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscribe_section.primary.label_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  label_text: prismic.KeyTextField;

  /**
   * Input Placeholder field in *SubscribeSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscribe_section.primary.input_placeholder
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  input_placeholder: prismic.KeyTextField;

  /**
   * Submit Text field in *SubscribeSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscribe_section.primary.submit_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  submit_text: prismic.KeyTextField;

  /**
   * Submitting Text field in *SubscribeSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscribe_section.primary.submitting_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  submitting_text: prismic.KeyTextField;

  /**
   * Submitted Text field in *SubscribeSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscribe_section.primary.submitted_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  submitted_text: prismic.KeyTextField;

  /**
   * Invalid Email Text field in *SubscribeSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscribe_section.primary.invalid_email_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  invalid_email_text: prismic.KeyTextField;

  /**
   * Submission Error Text field in *SubscribeSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscribe_section.primary.submission_error_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  submission_error_text: prismic.KeyTextField;

  /**
   * API Endpoint field in *SubscribeSection → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscribe_section.primary.api_endpoint
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  api_endpoint: prismic.KeyTextField;
}

/**
 * Default variation for SubscribeSection Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type SubscribeSectionSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<SubscribeSectionSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *SubscribeSection*
 */
type SubscribeSectionSliceVariation = SubscribeSectionSliceDefault;

/**
 * SubscribeSection Shared Slice
 *
 * - **API ID**: `subscribe_section`
 * - **Description**: SubscribeSection
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type SubscribeSectionSlice = prismic.SharedSlice<
  'subscribe_section',
  SubscribeSectionSliceVariation
>;

/**
 * Primary content in *SubscriptionPlan → Primary*
 */
export interface SubscriptionPlanSliceDefaultPrimary {
  /**
   * Cancel Text field in *SubscriptionPlan → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscription_plan.primary.cancel_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cancel_text: prismic.KeyTextField;

  /**
   * Cancel Link field in *SubscriptionPlan → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: subscription_plan.primary.cancel_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cancel_link: prismic.LinkField;

  /**
   * Add to Cart Text field in *SubscriptionPlan → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscription_plan.primary.add_to_cart_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  add_to_cart_text: prismic.KeyTextField;

  /**
   * Add to Cart Error field in *SubscriptionPlan → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscription_plan.primary.add_to_cart_error
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  add_to_cart_error: prismic.KeyTextField;

  /**
   * Switch Plan Text field in *SubscriptionPlan → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscription_plan.primary.switch_plan_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  switch_plan_text: prismic.KeyTextField;

  /**
   * Benefits Active Text field in *SubscriptionPlan → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscription_plan.primary.benefits_active_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  benefits_active_text: prismic.KeyTextField;
}

/**
 * Primary content in *SubscriptionPlan → Items*
 */
export interface SubscriptionPlanSliceDefaultItem {
  /**
   * Title field in *SubscriptionPlan → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscription_plan.items[].title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Description field in *SubscriptionPlan → Items*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscription_plan.items[].description
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  description: prismic.RichTextField;

  /**
   * Billing Schedule field in *SubscriptionPlan → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscription_plan.items[].billing_schedule
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  billing_schedule: prismic.KeyTextField;

  /**
   * Price field in *SubscriptionPlan → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscription_plan.items[].price
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  price: prismic.KeyTextField;

  /**
   * Product ID field in *SubscriptionPlan → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscription_plan.items[].product_id
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  product_id: prismic.KeyTextField;

  /**
   * Dev Product ID field in *SubscriptionPlan → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: subscription_plan.items[].dev_product_id
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  dev_product_id: prismic.KeyTextField;
}

/**
 * Default variation for SubscriptionPlan Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type SubscriptionPlanSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<SubscriptionPlanSliceDefaultPrimary>,
  Simplify<SubscriptionPlanSliceDefaultItem>
>;

/**
 * Slice variation for *SubscriptionPlan*
 */
type SubscriptionPlanSliceVariation = SubscriptionPlanSliceDefault;

/**
 * SubscriptionPlan Shared Slice
 *
 * - **API ID**: `subscription_plan`
 * - **Description**: SubscriptionPlan
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type SubscriptionPlanSlice = prismic.SharedSlice<
  'subscription_plan',
  SubscriptionPlanSliceVariation
>;

/**
 * Primary content in *Testimonials → Primary*
 */
export interface TestimonialsSliceDefaultPrimary {
  /**
   * Background Color Start field in *Testimonials → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: testimonials.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *Testimonials → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: testimonials.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Title field in *Testimonials → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: testimonials.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *Testimonials → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: testimonials.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Card Color field in *Testimonials → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: testimonials.primary.card_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  card_color: prismic.ColorField;

  /**
   * Content Color field in *Testimonials → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: testimonials.primary.content_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  content_color: prismic.ColorField;

  /**
   * Name Color field in *Testimonials → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: testimonials.primary.name_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  name_color: prismic.ColorField;

  /**
   * Location Color field in *Testimonials → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: testimonials.primary.location_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  location_color: prismic.ColorField;
}

/**
 * Primary content in *Testimonials → Items*
 */
export interface TestimonialsSliceDefaultItem {
  /**
   * Quote field in *Testimonials → Items*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: testimonials.items[].quote
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  quote: prismic.RichTextField;

  /**
   * Name field in *Testimonials → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: testimonials.items[].name
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  name: prismic.KeyTextField;

  /**
   * Location field in *Testimonials → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: testimonials.items[].location
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  location: prismic.KeyTextField;
}

/**
 * Default variation for Testimonials Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type TestimonialsSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<TestimonialsSliceDefaultPrimary>,
  Simplify<TestimonialsSliceDefaultItem>
>;

/**
 * Slice variation for *Testimonials*
 */
type TestimonialsSliceVariation = TestimonialsSliceDefault;

/**
 * Testimonials Shared Slice
 *
 * - **API ID**: `testimonials`
 * - **Description**: Testimonials
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type TestimonialsSlice = prismic.SharedSlice<
  'testimonials',
  TestimonialsSliceVariation
>;

/**
 * Primary content in *TextArea → Primary*
 */
export interface TextAreaSliceDefaultPrimary {
  /**
   * Text field in *TextArea → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: text_area.primary.text
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  text: prismic.RichTextField;
}

/**
 * Default variation for TextArea Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type TextAreaSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<TextAreaSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *TextArea*
 */
type TextAreaSliceVariation = TextAreaSliceDefault;

/**
 * TextArea Shared Slice
 *
 * - **API ID**: `text_area`
 * - **Description**: TextArea
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type TextAreaSlice = prismic.SharedSlice<
  'text_area',
  TextAreaSliceVariation
>;

/**
 * Primary content in *TextBanner → Primary*
 */
export interface TextBannerSliceDefaultPrimary {
  /**
   * Text field in *TextBanner → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: text_banner.primary.text
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  text: prismic.RichTextField;

  /**
   * Background Color field in *TextBanner → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: text_banner.primary.background_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color: prismic.ColorField;

  /**
   * Text Color field in *TextBanner → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: text_banner.primary.text_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  text_color: prismic.ColorField;
}

/**
 * Default variation for TextBanner Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type TextBannerSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<TextBannerSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *TextBanner*
 */
type TextBannerSliceVariation = TextBannerSliceDefault;

/**
 * TextBanner Shared Slice
 *
 * - **API ID**: `text_banner`
 * - **Description**: TextBanner
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type TextBannerSlice = prismic.SharedSlice<
  'text_banner',
  TextBannerSliceVariation
>;

/**
 * Primary content in *UserOverview → Primary*
 */
export interface UserOverviewSliceDefaultPrimary {
  /**
   * Content Link field in *UserOverview → Primary*
   *
   * - **Field Type**: Content Relationship
   * - **Placeholder**: *None*
   * - **API ID Path**: user_overview.primary.content_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  content_link: prismic.ContentRelationshipField<'account_next_steps_section'>;
}

/**
 * Default variation for UserOverview Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type UserOverviewSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<UserOverviewSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *UserOverview*
 */
type UserOverviewSliceVariation = UserOverviewSliceDefault;

/**
 * UserOverview Shared Slice
 *
 * - **API ID**: `user_overview`
 * - **Description**: UserOverview
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type UserOverviewSlice = prismic.SharedSlice<
  'user_overview',
  UserOverviewSliceVariation
>;

/**
 * Primary content in *VerticalTimeline → Primary*
 */
export interface VerticalTimelineSliceDefaultPrimary {
  /**
   * Background Color Start field in *VerticalTimeline → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: vertical_timeline.primary.background_color_start
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_start: prismic.ColorField;

  /**
   * Background Color End field in *VerticalTimeline → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: vertical_timeline.primary.background_color_end
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  background_color_end: prismic.ColorField;

  /**
   * Title field in *VerticalTimeline → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: vertical_timeline.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Title Color field in *VerticalTimeline → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: vertical_timeline.primary.title_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  title_color: prismic.ColorField;

  /**
   * Heading Color field in *VerticalTimeline → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: vertical_timeline.primary.heading_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  heading_color: prismic.ColorField;

  /**
   * Description Color field in *VerticalTimeline → Primary*
   *
   * - **Field Type**: Color
   * - **Placeholder**: *None*
   * - **API ID Path**: vertical_timeline.primary.description_color
   * - **Documentation**: https://prismic.io/docs/field#color
   */
  description_color: prismic.ColorField;
}

/**
 * Primary content in *VerticalTimeline → Items*
 */
export interface VerticalTimelineSliceDefaultItem {
  /**
   * Image field in *VerticalTimeline → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: vertical_timeline.items[].image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  image: prismic.ImageField<never>;

  /**
   * Small Image field in *VerticalTimeline → Items*
   *
   * - **Field Type**: Image
   * - **Placeholder**: *None*
   * - **API ID Path**: vertical_timeline.items[].small_image
   * - **Documentation**: https://prismic.io/docs/field#image
   */
  small_image: prismic.ImageField<never>;

  /**
   * Heading field in *VerticalTimeline → Items*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: vertical_timeline.items[].heading
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  heading: prismic.KeyTextField;

  /**
   * Description field in *VerticalTimeline → Items*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: vertical_timeline.items[].description
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  description: prismic.RichTextField;
}

/**
 * Default variation for VerticalTimeline Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type VerticalTimelineSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<VerticalTimelineSliceDefaultPrimary>,
  Simplify<VerticalTimelineSliceDefaultItem>
>;

/**
 * Slice variation for *VerticalTimeline*
 */
type VerticalTimelineSliceVariation = VerticalTimelineSliceDefault;

/**
 * VerticalTimeline Shared Slice
 *
 * - **API ID**: `vertical_timeline`
 * - **Description**: VerticalTimeline
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type VerticalTimelineSlice = prismic.SharedSlice<
  'vertical_timeline',
  VerticalTimelineSliceVariation
>;

/**
 * Primary content in *VideoHighlight → Primary*
 */
export interface VideoHighlightSliceDefaultPrimary {
  /**
   * Title field in *VideoHighlight → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: video_highlight.primary.title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  title: prismic.KeyTextField;

  /**
   * Content field in *VideoHighlight → Primary*
   *
   * - **Field Type**: Rich Text
   * - **Placeholder**: *None*
   * - **API ID Path**: video_highlight.primary.content
   * - **Documentation**: https://prismic.io/docs/field#rich-text-title
   */
  content: prismic.RichTextField;

  /**
   * Iframe Title field in *VideoHighlight → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: video_highlight.primary.iframe_title
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  iframe_title: prismic.KeyTextField;

  /**
   * Video Link field in *VideoHighlight → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: video_highlight.primary.video_link
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  video_link: prismic.KeyTextField;

  /**
   * CTA Link field in *VideoHighlight → Primary*
   *
   * - **Field Type**: Link
   * - **Placeholder**: *None*
   * - **API ID Path**: video_highlight.primary.cta_link
   * - **Documentation**: https://prismic.io/docs/field#link-content-relationship
   */
  cta_link: prismic.LinkField;

  /**
   * CTA Link Text field in *VideoHighlight → Primary*
   *
   * - **Field Type**: Text
   * - **Placeholder**: *None*
   * - **API ID Path**: video_highlight.primary.cta_link_text
   * - **Documentation**: https://prismic.io/docs/field#key-text
   */
  cta_link_text: prismic.KeyTextField;
}

/**
 * Default variation for VideoHighlight Slice
 *
 * - **API ID**: `default`
 * - **Description**: Default
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type VideoHighlightSliceDefault = prismic.SharedSliceVariation<
  'default',
  Simplify<VideoHighlightSliceDefaultPrimary>,
  never
>;

/**
 * Slice variation for *VideoHighlight*
 */
type VideoHighlightSliceVariation = VideoHighlightSliceDefault;

/**
 * VideoHighlight Shared Slice
 *
 * - **API ID**: `video_highlight`
 * - **Description**: VideoHighlight
 * - **Documentation**: https://prismic.io/docs/slice
 */
export type VideoHighlightSlice = prismic.SharedSlice<
  'video_highlight',
  VideoHighlightSliceVariation
>;

declare module '@prismicio/client' {
  interface CreateClient {
    (
      repositoryNameOrEndpoint: string,
      options?: prismic.ClientConfig
    ): prismic.Client<AllDocumentTypes>;
  }

  namespace Content {
    export type {
      AccountNavigationDocument,
      AccountNavigationDocumentData,
      AccountNavigationDocumentDataDropdownLinksItem,
      AccountNavigationDocumentDataSlicesSlice,
      AccountNextStepsSectionDocument,
      AccountNextStepsSectionDocumentData,
      AccountNextStepsSectionDocumentDataSlicesSlice,
      AccountNextStepsSectionDocumentDataStatusContentItem,
      AccounthomeDocument,
      AccounthomeDocumentData,
      AccounthomeDocumentDataSlicesSlice,
      AccountpageDocument,
      AccountpageDocumentData,
      AccountpageDocumentDataSlicesSlice,
      BillingDocument,
      BillingDocumentData,
      BillingDocumentDataSlicesSlice,
      BlogAdCardDocument,
      BlogAdCardDocumentData,
      BlogAdCardDocumentDataSlicesSlice,
      BlogAuthorDocument,
      BlogAuthorDocumentData,
      BlogAuthorDocumentDataSlicesSlice,
      BlogNewsletterDocument,
      BlogNewsletterDocumentData,
      BlogNewsletterDocumentDataSlicesSlice,
      BlogSearchDocument,
      BlogSearchDocumentData,
      BlogSearchDocumentDataLinksItem,
      BlogSearchDocumentDataSlicesSlice,
      BlogTagDocument,
      BlogTagDocumentData,
      BlogTagDocumentDataLinksItem,
      BlogTagDocumentDataSlicesSlice,
      BlogauthorDocument,
      BlogauthorDocumentData,
      BlogauthorDocumentDataSlicesSlice,
      BlogcategoryDocument,
      BlogcategoryDocumentData,
      BlogcategoryDocumentDataSlicesSlice,
      BloghomeDocument,
      BloghomeDocumentData,
      BloghomeDocumentDataLinksItem,
      BloghomeDocumentDataSlicesSlice,
      BlogpostDocument,
      BlogpostDocumentData,
      BlogpostDocumentDataCategoriesItem,
      BlogpostDocumentDataSlicesSlice,
      CasesPageDocument,
      CasesPageDocumentData,
      CasesPageDocumentDataSlicesSlice,
      ConciergeaccountpageDocument,
      ConciergeaccountpageDocumentData,
      ConciergeaccountpageDocumentDataSlicesSlice,
      ConciergeaccountpageDocumentDataSlices2Slice,
      EstheticianPageDocument,
      EstheticianPageDocumentData,
      EstheticianPageDocumentDataSlicesSlice,
      EstheticianPageDocumentDataSlices2Slice,
      FooterDocument,
      FooterDocumentData,
      FooterDocumentDataSlicesSlice,
      FooterDocumentDataItemItem,
      FormDocument,
      FormDocumentData,
      FormDocumentDataSlicesSlice,
      GlobalBannerDocument,
      GlobalBannerDocumentData,
      HelpArticleDocument,
      HelpArticleDocumentData,
      HelpArticleDocumentDataBreadcrumbsItem,
      HelpArticleDocumentDataSlicesSlice,
      HelpCollectionDocument,
      HelpCollectionDocumentData,
      HelpCollectionDocumentDataBreadcrumbsItem,
      HelpCollectionDocumentDataSlicesSlice,
      HelpFooterDocument,
      HelpFooterDocumentData,
      HelpFooterDocumentDataLinksItem,
      HelpFooterDocumentDataSocialsItem,
      HelpFooterDocumentDataSlicesSlice,
      HelpHeaderDocument,
      HelpHeaderDocumentData,
      HelpHeaderDocumentDataSlicesSlice,
      HelpHomeDocument,
      HelpHomeDocumentData,
      HelpHomeDocumentDataSlicesSlice,
      HomeDocument,
      HomeDocumentData,
      HomeDocumentDataSlicesSlice,
      MessagingpageDocument,
      MessagingpageDocumentData,
      MessagingpageDocumentDataSlicesSlice,
      NavigationDocument,
      NavigationDocumentData,
      NavigationDocumentDataSlicesSlice,
      OrderHistoryDocument,
      OrderHistoryDocumentData,
      OrderHistoryDocumentDataSlicesSlice,
      PageDocument,
      PageDocumentData,
      PageDocumentDataSlicesSlice,
      ProductPageDocument,
      ProductPageDocumentData,
      ProductPageDocumentDataBreadcrumbsItem,
      ProductPageDocumentDataMobileBreadcrumbsItem,
      ProductPageDocumentDataTagsItem,
      ProductPageDocumentDataSlicesSlice,
      ShopCartDocument,
      ShopCartDocumentData,
      ShopCartDocumentDataSlicesSlice,
      ShopHomeDocument,
      ShopHomeDocumentData,
      ShopHomeDocumentDataBreadcrumbsItem,
      ShopHomeDocumentDataMobileBreadcrumbsItem,
      ShopHomeDocumentDataSlicesSlice,
      ShopPageDocument,
      ShopPageDocumentData,
      ShopPageDocumentDataBreadcrumbsItem,
      ShopPageDocumentDataMobileBreadcrumbsItem,
      ShopPageDocumentDataSlicesSlice,
      SigninDocument,
      SigninDocumentData,
      SigninDocumentDataPartnerDataItem,
      SigninDocumentDataHeroImagesItem,
      SigninDocumentDataSlicesSlice,
      SubscriptionsDocument,
      SubscriptionsDocumentData,
      SubscriptionsDocumentDataSlicesSlice,
      AllDocumentTypes,
      AccountHeroSlice,
      AccountHeroSliceDefaultPrimary,
      AccountHeroSliceHeroCenteredTitlePrimary,
      AccountHeroSliceHeroImageTitlePrimary,
      AccountHeroSliceVariation,
      AccountHeroSliceDefault,
      AccountHeroSliceHeroCenteredTitle,
      AccountHeroSliceHeroImageTitle,
      AccountNotificationsSlice,
      AccountNotificationsSliceDefaultPrimary,
      AccountNotificationsSliceVariation,
      AccountNotificationsSliceDefault,
      AccountQuoteSlice,
      AccountQuoteSliceDefaultPrimary,
      AccountQuoteSliceVariation,
      AccountQuoteSliceDefault,
      BeforeAfterImagesSlice,
      BeforeAfterImagesSliceDefaultPrimary,
      BeforeAfterImagesSliceDefaultItem,
      BeforeAfterImagesSliceTretinoinPrimary,
      BeforeAfterImagesSliceTretinoinItem,
      BeforeAfterImagesSliceVariation,
      BeforeAfterImagesSliceDefault,
      BeforeAfterImagesSliceTretinoin,
      BillingHistorySlice,
      BillingHistorySliceDefaultPrimary,
      BillingHistorySliceVariation,
      BillingHistorySliceDefault,
      BlogArticleSlice,
      BlogArticleSliceDefaultPrimary,
      BlogArticleSliceVariation,
      BlogArticleSliceDefault,
      BlogCategorySectionSlice,
      BlogCategorySectionSliceDefaultPrimary,
      BlogCategorySectionSliceDefaultItem,
      BlogCategorySectionSliceVariation,
      BlogCategorySectionSliceDefault,
      BlogCtaBannerSlice,
      BlogCtaBannerSliceDefaultPrimary,
      BlogCtaBannerSliceImageBannerPrimary,
      BlogCtaBannerSliceVariation,
      BlogCtaBannerSliceDefault,
      BlogCtaBannerSliceImageBanner,
      BoxedImageWithContentSlice,
      BoxedImageWithContentSliceDefaultPrimary,
      BoxedImageWithContentSliceVariation,
      BoxedImageWithContentSliceDefault,
      CalendlySchedulerSlice,
      CalendlySchedulerSliceDefaultPrimary,
      CalendlySchedulerSliceVariation,
      CalendlySchedulerSliceDefault,
      CenteredIconBulletListSlice,
      CenteredIconBulletListSliceDefaultPrimary,
      CenteredIconBulletListSliceDefaultItem,
      CenteredIconBulletListSliceVariation,
      CenteredIconBulletListSliceDefault,
      CenteredProductCardsSlice,
      CenteredProductCardsSliceDefaultPrimary,
      CenteredProductCardsSliceDefaultItem,
      CenteredProductCardsSliceVariation,
      CenteredProductCardsSliceDefault,
      CenteredRichTextSlice,
      CenteredRichTextSliceDefaultPrimary,
      CenteredRichTextSliceVariation,
      CenteredRichTextSliceDefault,
      CheckoutSlice,
      CheckoutSliceDefaultPrimary,
      CheckoutSliceVariation,
      CheckoutSliceDefault,
      ComparisonChartSlice,
      ComparisonChartSliceDefaultPrimary,
      ComparisonChartSliceDefaultItem,
      ComparisonChartSliceVariation,
      ComparisonChartSliceDefault,
      ComplaintSelectSlice,
      ComplaintSelectSliceDefaultPrimary,
      ComplaintSelectSliceDefaultItem,
      ComplaintSelectSliceVariation,
      ComplaintSelectSliceDefault,
      ComplaintSelectorSlice,
      ComplaintSelectorSliceDefaultPrimary,
      ComplaintSelectorSliceDefaultItem,
      ComplaintSelectorSliceVariation,
      ComplaintSelectorSliceDefault,
      ContentSlice,
      ContentSliceDefaultPrimary,
      ContentSliceVariation,
      ContentSliceDefault,
      CtaSectionSlice,
      CtaSectionSliceDefaultPrimary,
      CtaSectionSliceDefaultItem,
      CtaSectionSliceRightAlignedVideoPrimary,
      CtaSectionSliceLeftAlignedVideoPrimary,
      CtaSectionSliceRightAlignedImagePrimary,
      CtaSectionSliceLeftAlignedImagePrimary,
      CtaSectionSliceCenteredTextWithLeftImagePrimary,
      CtaSectionSliceCenteredTextWithRightImagePrimary,
      CtaSectionSliceButtonBannerPrimary,
      CtaSectionSliceCtaGridBoxesPrimary,
      CtaSectionSliceCtaGridBoxesItem,
      CtaSectionSliceImagesWithContentOverlayPrimary,
      CtaSectionSliceTwoColumnGridWithImagePrimary,
      CtaSectionSliceCustomPrescriptionPrimary,
      CtaSectionSliceCtaListWithImagePrimary,
      CtaSectionSliceCtaListWithImageItem,
      CtaSectionSliceImageTitleCtaPrimary,
      CtaSectionSliceTwoColumnWithImagePrimary,
      CtaSectionSliceVariation,
      CtaSectionSliceDefault,
      CtaSectionSliceRightAlignedVideo,
      CtaSectionSliceLeftAlignedVideo,
      CtaSectionSliceRightAlignedImage,
      CtaSectionSliceLeftAlignedImage,
      CtaSectionSliceCenteredTextWithLeftImage,
      CtaSectionSliceCenteredTextWithRightImage,
      CtaSectionSliceButtonBanner,
      CtaSectionSliceCtaGridBoxes,
      CtaSectionSliceImagesWithContentOverlay,
      CtaSectionSliceTwoColumnGridWithImage,
      CtaSectionSliceCustomPrescription,
      CtaSectionSliceCtaListWithImage,
      CtaSectionSliceImageTitleCta,
      CtaSectionSliceTwoColumnWithImage,
      DiscoverTretinoinSlice,
      DiscoverTretinoinSliceDefaultPrimary,
      DiscoverTretinoinSliceVariation,
      DiscoverTretinoinSliceDefault,
      FaqsSlice,
      FaqsSliceDefaultPrimary,
      FaqsSliceDefaultItem,
      FaqsSliceVariation,
      FaqsSliceDefault,
      FeaturedBlogSectionSlice,
      FeaturedBlogSectionSliceDefaultPrimary,
      FeaturedBlogSectionSliceDefaultItem,
      FeaturedBlogSectionSliceVariation,
      FeaturedBlogSectionSliceDefault,
      FeaturedCollectionSlice,
      FeaturedCollectionSliceDefaultPrimary,
      FeaturedCollectionSliceVariation,
      FeaturedCollectionSliceDefault,
      FooterGroupSlice,
      FooterGroupSliceDefaultPrimary,
      FooterGroupSliceDefaultItem,
      FooterGroupSliceVariation,
      FooterGroupSliceDefault,
      FormSlice,
      FormSliceDefaultPrimary,
      FormSliceDefaultItem,
      FormSliceVariation,
      FormSliceDefault,
      HelpArticleSlice,
      HelpArticleSliceDefaultPrimary,
      HelpArticleSliceVariation,
      HelpArticleSliceDefault,
      HeroCarouselSlice,
      HeroCarouselSliceDefaultItem,
      HeroCarouselSliceVariation,
      HeroCarouselSliceDefault,
      HeroSectionSlice,
      HeroSectionSliceDefaultPrimary,
      HeroSectionSliceLeftAlignedPrimary,
      HeroSectionSliceLeftAlignedItem,
      HeroSectionSliceHeroWithVideoPrimary,
      HeroSectionSliceHeroWithCenteredImagePrimary,
      HeroSectionSliceRightAlignedImageHeroPrimary,
      HeroSectionSliceTretinoinHeroPrimary,
      HeroSectionSliceVariation,
      HeroSectionSliceDefault,
      HeroSectionSliceLeftAligned,
      HeroSectionSliceHeroWithVideo,
      HeroSectionSliceHeroWithCenteredImage,
      HeroSectionSliceRightAlignedImageHero,
      HeroSectionSliceTretinoinHero,
      IconBulletListSlice,
      IconBulletListSliceDefaultPrimary,
      IconBulletListSliceDefaultItem,
      IconBulletListSliceVariation,
      IconBulletListSliceDefault,
      IncentivesSlice,
      IncentivesSliceDefaultPrimary,
      IncentivesSliceDefaultItem,
      IncentivesSliceListWithIconsPrimary,
      IncentivesSliceListWithIconsItem,
      IncentivesSliceVariation,
      IncentivesSliceDefault,
      IncentivesSliceListWithIcons,
      InfoPopoverSlice,
      InfoPopoverSliceDefaultPrimary,
      InfoPopoverSliceVariation,
      InfoPopoverSliceDefault,
      InfoTabsSlice,
      InfoTabsSliceDefaultPrimary,
      InfoTabsSliceDefaultItem,
      InfoTabsSliceVariation,
      InfoTabsSliceDefault,
      LargeQuoteSlice,
      LargeQuoteSliceDefaultPrimary,
      LargeQuoteSliceDefaultItem,
      LargeQuoteSliceLeftAlignedProfileImagePrimary,
      LargeQuoteSliceLeftAlignedProfileImageItem,
      LargeQuoteSliceLeftAlignedVideoPrimary,
      LargeQuoteSliceLeftAlignedVideoItem,
      LargeQuoteSliceVariation,
      LargeQuoteSliceDefault,
      LargeQuoteSliceLeftAlignedProfileImage,
      LargeQuoteSliceLeftAlignedVideo,
      LogoCloudSlice,
      LogoCloudSliceDefaultPrimary,
      LogoCloudSliceDefaultItem,
      LogoCloudSliceVariation,
      LogoCloudSliceDefault,
      MessagingCtaSectionSlice,
      MessagingCtaSectionSliceDefaultPrimary,
      MessagingCtaSectionSliceCtaWithImagePrimary,
      MessagingCtaSectionSliceTwoColumnGridItem,
      MessagingCtaSectionSliceTwoColumnWithImagePrimary,
      MessagingCtaSectionSliceProductCardsPrimary,
      MessagingCtaSectionSliceProductCardsItem,
      MessagingCtaSectionSliceImageTitleCtaPrimary,
      MessagingCtaSectionSliceProductListCtaPrimary,
      MessagingCtaSectionSliceFeaturedImagePrimary,
      MessagingCtaSectionSliceVariation,
      MessagingCtaSectionSliceDefault,
      MessagingCtaSectionSliceCtaWithImage,
      MessagingCtaSectionSliceTwoColumnGrid,
      MessagingCtaSectionSliceTwoColumnWithImage,
      MessagingCtaSectionSliceProductCards,
      MessagingCtaSectionSliceImageTitleCta,
      MessagingCtaSectionSliceProductListCta,
      MessagingCtaSectionSliceFeaturedImage,
      NavigationBarSlice,
      NavigationBarSliceDefaultPrimary,
      NavigationBarSliceDefaultItem,
      NavigationBarSliceButtonPrimary,
      NavigationBarSliceAccountNavigationItemPrimary,
      NavigationBarSliceVariation,
      NavigationBarSliceDefault,
      NavigationBarSliceButton,
      NavigationBarSliceAccountNavigationItem,
      OrderConfirmationSlice,
      OrderConfirmationSliceDefaultPrimary,
      OrderConfirmationSliceVariation,
      OrderConfirmationSliceDefault,
      OrderHistorySlice,
      OrderHistorySliceDefaultPrimary,
      OrderHistorySliceVariation,
      OrderHistorySliceDefault,
      OrdersSectionSlice,
      OrdersSectionSliceDefaultPrimary,
      OrdersSectionSliceVariation,
      OrdersSectionSliceDefault,
      PaymentMethodsSlice,
      PaymentMethodsSliceDefaultPrimary,
      PaymentMethodsSliceVariation,
      PaymentMethodsSliceDefault,
      PerksListSlice,
      PerksListSliceDefaultPrimary,
      PerksListSliceDefaultItem,
      PerksListSliceVariation,
      PerksListSliceDefault,
      PrimaryUserContextSwitchSlice,
      PrimaryUserContextSwitchSliceVariation,
      PrimaryUserContextSwitchSliceDefault,
      ProductSlice,
      ProductSliceDefaultPrimary,
      ProductSliceDefaultItem,
      ProductSliceVariation,
      ProductSliceDefault,
      ProductSuggestionsSlice,
      ProductSuggestionsSliceDefaultPrimary,
      ProductSuggestionsSliceVariation,
      ProductSuggestionsSliceDefault,
      ProductsListSlice,
      ProductsListSliceDefaultPrimary,
      ProductsListSliceDefaultItem,
      ProductsListSliceVariation,
      ProductsListSliceDefault,
      RedirectSlice,
      RedirectSliceDefaultItem,
      RedirectSliceVariation,
      RedirectSliceDefault,
      RelatedBlogArticlesSlice,
      RelatedBlogArticlesSliceDefaultPrimary,
      RelatedBlogArticlesSliceVariation,
      RelatedBlogArticlesSliceDefault,
      SettingsTabSlice,
      SettingsTabSliceDefaultPrimary,
      SettingsTabSliceDefaultItem,
      SettingsTabSliceVariation,
      SettingsTabSliceDefault,
      StartPopoverSlice,
      StartPopoverSliceDefaultItem,
      StartPopoverSliceVariation,
      StartPopoverSliceDefault,
      StatsBannerSlice,
      StatsBannerSliceDefaultPrimary,
      StatsBannerSliceDefaultItem,
      StatsBannerSliceVariation,
      StatsBannerSliceDefault,
      StepsSectionSlice,
      StepsSectionSliceDefaultPrimary,
      StepsSectionSliceDefaultItem,
      StepsSectionSliceVariation,
      StepsSectionSliceDefault,
      SubscribeSectionSlice,
      SubscribeSectionSliceDefaultPrimary,
      SubscribeSectionSliceVariation,
      SubscribeSectionSliceDefault,
      SubscriptionPlanSlice,
      SubscriptionPlanSliceDefaultPrimary,
      SubscriptionPlanSliceDefaultItem,
      SubscriptionPlanSliceVariation,
      SubscriptionPlanSliceDefault,
      TestimonialsSlice,
      TestimonialsSliceDefaultPrimary,
      TestimonialsSliceDefaultItem,
      TestimonialsSliceVariation,
      TestimonialsSliceDefault,
      TextAreaSlice,
      TextAreaSliceDefaultPrimary,
      TextAreaSliceVariation,
      TextAreaSliceDefault,
      TextBannerSlice,
      TextBannerSliceDefaultPrimary,
      TextBannerSliceVariation,
      TextBannerSliceDefault,
      UserOverviewSlice,
      UserOverviewSliceDefaultPrimary,
      UserOverviewSliceVariation,
      UserOverviewSliceDefault,
      VerticalTimelineSlice,
      VerticalTimelineSliceDefaultPrimary,
      VerticalTimelineSliceDefaultItem,
      VerticalTimelineSliceVariation,
      VerticalTimelineSliceDefault,
      VideoHighlightSlice,
      VideoHighlightSliceDefaultPrimary,
      VideoHighlightSliceVariation,
      VideoHighlightSliceDefault,
    };
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/prismicio.ts

import * as prismic from '@prismicio/client';
import * as prismicNext from '@prismicio/next';
import { PrismicPageType } from '@utils/prismic/enums';

import config from '../slicemachine.config.json';

/**
 * The project's Prismic repository name.
 */
export const repositoryName = config.repositoryName;

/**
 * A list of Route Resolver objects that define how a document's `url` field is resolved.
 *
 * {@link https://prismic.io/docs/route-resolver#route-resolver}
 */
// TODO: Update the routes array to match your project's route structure.
const routes: prismic.ClientConfig['routes'] = [
  {
    type: PrismicPageType.HOME,
    path: '/',
  },
  {
    type: PrismicPageType.PAGE,
    path: '/:uid',
  },
  {
    type: PrismicPageType.BLOG_HOME,
    path: '/blog',
  },
  {
    type: PrismicPageType.BLOG_SEARCH,
    path: '/blog/search',
  },
  {
    type: PrismicPageType.BLOG_POST,
    path: '/blog/:uid',
  },
  {
    type: PrismicPageType.SHOP_HOME,
    path: '/shop',
  },
  {
    type: PrismicPageType.SHOP_PAGE,
    path: '/shop/:uid',
  },
  {
    type: PrismicPageType.PRODUCT_PAGE,
    path: '/shop/products/:uid',
  },
  {
    type: PrismicPageType.BLOG_CATEGORY,
    path: '/blog/tags',
  },
  {
    type: PrismicPageType.BLOG_AUTHOR,
    path: '/blog/author/:uid',
  },
  {
    type: PrismicPageType.ACCOUNT_HOME,
    path: '/account',
  },
  {
    type: PrismicPageType.MESSAGING_PAGE,
    path: '/account/messaging',
  },
  {
    type: PrismicPageType.CONCIERGE_PAGE,
    path: '/account/concierge',
  },
  {
    type: PrismicPageType.ESTHETICIAN_PAGE,
    path: '/account/esthetician',
  },
  {
    type: PrismicPageType.ACCOUNT_PAGE,
    path: '/account/:uid',
  },
  {
    type: PrismicPageType.HELP_HOME,
    path: '/help',
  },
  {
    type: PrismicPageType.HELP_COLLECTION,
    path: '/help/collections/:uid',
  },
  {
    type: PrismicPageType.HELP_ARTICLE,
    path: '/help/articles/:uid',
  },
];

/**
 * Creates a Prismic client for the project's repository. The client is used to
 * query content from the Prismic API.
 *
 * @param config - Configuration for the Prismic client.
 */
export const createClient = (config: prismicNext.CreateClientConfig = {}) => {
  const client = prismic.createClient(repositoryName, {
    routes,
    fetchOptions: {
      next: {
        tags: ['prismic'],
        revalidate: process.env.ENVIRONMENT_NAME === 'production' ? 300 : 60,
      },
    },
    ...config,
  });

  prismicNext.enableAutoPreviews({
    client,
    previewData: config.previewData,
    req: config.req,
  });

  return client;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/index.ts

// Code generated by Slice Machine. DO NOT EDIT.
import dynamic from 'next/dynamic';

export const components = {
  account_hero: dynamic(() => import('./AccountHero')),
  account_notifications: dynamic(() => import('./AccountNotifications')),
  account_quote: dynamic(() => import('./AccountQuote')),
  before_after_images: dynamic(() => import('./BeforeAfterImages')),
  billing_history: dynamic(() => import('./BillingHistory')),
  blog_article: dynamic(() => import('./BlogArticle')),
  blog_category_section: dynamic(() => import('./BlogCategorySection')),
  blog_cta_banner: dynamic(() => import('./BlogCtaBanner')),
  boxed_image_with_content: dynamic(() => import('./BoxedImageWithContent')),
  calendly_scheduler: dynamic(() => import('./CalendlyScheduler')),
  centered_icon_bullet_list: dynamic(() => import('./CenteredIconBulletList')),
  centered_product_cards: dynamic(() => import('./CenteredProductCards')),
  centered_rich_text: dynamic(() => import('./CenteredRichText')),
  checkout: dynamic(() => import('./Checkout')),
  comparison_chart: dynamic(() => import('./ComparisonChart')),
  complaint_select: dynamic(() => import('./ComplaintSelect')),
  complaint_selector: dynamic(() => import('./ComplaintSelector')),
  content: dynamic(() => import('./Content')),
  cta_section: dynamic(() => import('./CtaSection')),
  discover_tretinoin: dynamic(() => import('./DiscoverTretinoin')),
  faqs: dynamic(() => import('./Faqs')),
  featured_blog_section: dynamic(() => import('./FeaturedBlogSection')),
  featured_collection: dynamic(() => import('./FeaturedCollection')),
  footer_group: dynamic(() => import('./FooterGroup')),
  form: dynamic(() => import('./Form')),
  help_article: dynamic(() => import('./HelpArticle')),
  hero_carousel: dynamic(() => import('./HeroCarousel')),
  hero_section: dynamic(() => import('./HeroSection')),
  icon_bullet_list: dynamic(() => import('./IconBulletList')),
  incentives: dynamic(() => import('./Incentives')),
  info_popover: dynamic(() => import('./InfoPopover')),
  info_tabs: dynamic(() => import('./InfoTabs')),
  large_quote: dynamic(() => import('./LargeQuote')),
  logo_cloud: dynamic(() => import('./LogoCloud')),
  messaging_cta_section: dynamic(() => import('./AccountCtaSection')),
  navigation_bar: dynamic(() => import('./NavigationItem')),
  order_confirmation: dynamic(() => import('./OrderConfirmation')),
  order_history: dynamic(() => import('./OrderHistory')),
  orders_section: dynamic(() => import('./OrdersSection')),
  payment_methods: dynamic(() => import('./PaymentMethods')),
  perks_list: dynamic(() => import('./PerksList')),
  primary_user_context_switch: dynamic(
    () => import('./PrimaryUserContextSwitch')
  ),
  product: dynamic(() => import('./Product')),
  product_suggestions: dynamic(() => import('./ProductSuggestions')),
  products_list: dynamic(() => import('./ProductsList')),
  redirect: dynamic(() => import('./Redirect')),
  related_blog_articles: dynamic(() => import('./RelatedBlogArticles')),
  settings_tab: dynamic(() => import('./SettingsTab')),
  start_popover: dynamic(() => import('./StartPopover')),
  stats_banner: dynamic(() => import('./StatsBanner')),
  steps_section: dynamic(() => import('./StepsSection')),
  subscribe_section: dynamic(() => import('./SubscribeSection')),
  subscription_plan: dynamic(() => import('./SubscriptionPlan')),
  testimonials: dynamic(() => import('./Testimonials')),
  text_area: dynamic(() => import('./TextArea')),
  text_banner: dynamic(() => import('./TextBanner')),
  user_overview: dynamic(() => import('./UserOverview')),
  vertical_timeline: dynamic(() => import('./VerticalTimeline')),
  video_highlight: dynamic(() => import('./VideoHighlight')),
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BillingHistory/index.tsx

import { cookies } from 'next/headers';
import { Suspense } from 'react';

import TableLoadingSkeleton from '@/app/shared/components/data-table/table-loading-skeleton';
import { getBaseUrl } from '@/utils/getBaseUrl';
import { IBillingCharge } from '@/utils/payments/types';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import BillingList from './components/BillingList';

/**
 * Props for `BillingHistory`.
 */
export type BillingHistoryProps =
  SliceComponentProps<Content.BillingHistorySlice>;

const getBillingHistory = async () => {
  const res = await fetch(`${getBaseUrl()}/api/payments/billing`, {
    headers: { Cookie: cookies().toString() },
  });
  return (await res.json()) as IBillingCharge[];
};

/**
 * Component for "BillingHistory" Slices.
 */
const BillingHistorySection = async ({
  slice,
}: BillingHistoryProps): Promise<JSX.Element> => {
  const billing = await getBillingHistory();

  return <BillingList paymentIntents={billing} slice={slice} />;
};

const BillingHistory = async (p: BillingHistoryProps): Promise<JSX.Element> => {
  return (
    <section
      data-slice-type={p.slice.slice_type}
      data-slice-variation={p.slice.variation}
    >
      <div className="mx-6 mb-14">
        <div className="sm:flex sm:items-center">
          <div className="sm:flex-auto">
            <p className="text-lg font-semibold text-gray-900">
              {p.slice.primary.title}
            </p>
            <p className="text-base text-gray-600">
              {p.slice.primary.description}
            </p>
          </div>
        </div>
        <Suspense fallback={<TableLoadingSkeleton />}>
          <BillingHistorySection {...p} />
        </Suspense>
      </div>
    </section>
  );
};

export default BillingHistory;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BillingHistory/components/NoPaymentsView.tsx

import React from 'react';

import { Content } from '@prismicio/client';
import { CurrencyDollar } from '@untitled-ui/icons-react';

const NoPaymentsView: React.FC<{ slice: Content.BillingHistorySlice }> = ({
  slice,
}) => {
  return (
    <div className="my-4 bg-white border border-gray-200 rounded-lg">
      <div className="p-8 flex flex-col items-center justify-center">
        <div className="bg-accent-50 p-2.5 rounded-full">
          <div className="bg-accent-100 p-2.5 rounded-full">
            <CurrencyDollar
              className="h-6 w-6 text-accent-700"
              viewBox="0 0 24 24"
            />
          </div>
        </div>
        <div className="mt-2 text-center">
          <p className="font-dmsans text-gray-900 text-base font-semibold">
            {slice.primary.no_history_title}
          </p>
          <p className="font-dmsans text-gray-600 text-sm">
            {slice.primary.no_history_description}
          </p>
        </div>
      </div>
    </div>
  );
};

export default NoPaymentsView;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BillingHistory/components/BillingListItem.tsx

import dayjs from 'dayjs';
import React from 'react';

import { IBillingCharge } from '@/utils/payments/types';
import { DownloadCloud02 } from '@untitled-ui/icons-react';

import PaymentStatus from './PaymentStatus';

interface IBillingListItemProps {
  item: IBillingCharge;
}

const BillingListItem: React.FC<IBillingListItemProps> = ({ item }) => {
  const createdDate = React.useMemo(
    () => dayjs.unix(item.created).format('MMM D, YYYY'),
    [item.created]
  );

  const amount = React.useMemo(
    () =>
      `${item.currency.toUpperCase()} ${(item.amount / 100).toLocaleString(
        'en-US',
        {
          style: 'currency',
          currency: item.currency,
        }
      )}`,
    [item.currency, item.amount]
  );

  return (
    <tr>
      <td className="w-full max-w-0 py-4 pl-4 pr-3 text-sm font-medium text-gray-900 sm:w-auto sm:max-w-none">
        <p className="truncate">{item.id}</p>
        <dl className="font-normal lg:hidden">
          <dt className="sr-only">Amount</dt>
          <dd className="mt-1 truncate text-gray-600">{amount}</dd>
          <dt className="sr-only sm:hidden">Created</dt>
          <dd className="mt-1 truncate text-gray-600 sm:hidden">
            {createdDate}
          </dd>
          {item.receipt && (
            <>
              <dt className="sr-only sm:hidden">Download</dt>
              <dd className="mt-2 truncate text-gray-600 sm:hidden">
                <a
                  href={item.receipt}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="hover:text-gray-600"
                >
                  <DownloadCloud02
                    className="h-5 w-5 text-gray-500"
                    viewBox="0 0 24 24"
                  />
                </a>
              </dd>
            </>
          )}
        </dl>
      </td>
      <td className="hidden px-3 py-4 text-sm text-gray-600 lg:table-cell">
        {amount}
      </td>
      <td className="hidden px-3 py-4 text-sm text-gray-600 sm:table-cell">
        {createdDate}
      </td>
      <td className="px-3 py-4 text-sm text-gray-500 align-top sm:align-middle">
        <PaymentStatus status={item.status} />
      </td>
      <td className="hidden py-4 pl-3 pr-4 text-center text-sm font-medium sm:table-cell">
        {item.receipt && (
          <a
            href={item.receipt}
            target="_blank"
            rel="noopener noreferrer"
            className="hover:text-gray-600"
          >
            <DownloadCloud02
              className="h-5 w-5 text-gray-500"
              viewBox="0 0 24 24"
            />
          </a>
        )}
      </td>
    </tr>
  );
};

export default BillingListItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BillingHistory/components/BillingList.tsx

'use client';

import React from 'react';

import ButtonOutline from '@/app/shared/components/buttons/button-outline';
import { IBillingCharge } from '@/utils/payments/types';
import { Content } from '@prismicio/client';

import BillingListItem from './BillingListItem';
import NoPaymentsView from './NoPaymentsView';

interface IBillingListProps {
  paymentIntents: IBillingCharge[];
  slice: Content.BillingHistorySlice;
}

const BillingList: React.FC<IBillingListProps> = ({
  paymentIntents,
  slice,
}) => {
  const [page, setPage] = React.useState({
    skip: 0,
    take: 5,
  });

  const handleNext = () => {
    setPage((prevState) => ({
      ...prevState,
      skip: prevState.skip + prevState.take,
    }));
  };

  const handlePrevious = () => {
    setPage((prevState) => ({
      ...prevState,
      skip: prevState.skip - prevState.take,
    }));
  };

  const { start, end, total } = React.useMemo(() => {
    const { skip, take } = page;
    const start = skip + 1;
    const end =
      skip + take > paymentIntents.length ? paymentIntents.length : skip + take;
    const total = paymentIntents.length;
    return { start, end, total };
  }, [paymentIntents.length, page]);

  const resultText = slice.primary.pagination_results_text
    ?.replace('{{ start }}', start.toString())
    ?.replace('{{ end }}', end.toString())
    ?.replace('{{ total }}', total.toString());

  const { skip, take } = page;

  return (
    <div>
      {paymentIntents.length === 0 ? (
        <NoPaymentsView slice={slice} />
      ) : (
        <div className="flow-root">
          <div className="-my-2 overflow-x-auto -mx-2 lg:-mx-2">
            <div className="inline-block min-w-full py-2 align-middle px-2 lg:px-2">
              <div className="overflow-hidden shadow ring-1 ring-gray-200 rounded-lg mt-6 -mx-0">
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th
                        scope="col"
                        className="py-3.5 pl-4 pr-3 text-left font-dmsans text-xs font-medium text-gray-600"
                      >
                        {slice.primary.table_heading_1}
                      </th>
                      <th
                        scope="col"
                        className="hidden px-3 py-3.5 text-left  font-dmsans text-xs font-medium text-gray-600 lg:table-cell"
                      >
                        {slice.primary.table_heading_2}
                      </th>
                      <th
                        scope="col"
                        className="hidden px-3 py-3.5 text-left  font-dmsans text-xs font-medium text-gray-600 sm:table-cell"
                      >
                        {slice.primary.table_heading_3}
                      </th>
                      <th
                        scope="col"
                        className="px-3 py-3.5 text-left font-dmsans text-xs font-medium text-gray-600"
                      >
                        {slice.primary.table_heading_4}
                      </th>
                      <th
                        scope="col"
                        className="relative hidden py-3.5 pl-3 pr-4 sm:table-cell"
                      >
                        <span className="sr-only">Download</span>
                      </th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-gray-200 bg-white">
                    {paymentIntents
                      .slice(skip, skip + take)
                      .map((paymentIntent) => (
                        <BillingListItem
                          key={paymentIntent.id}
                          item={paymentIntent}
                        />
                      ))}
                  </tbody>
                  <tfoot>
                    <tr>
                      <td colSpan={5}>
                        <nav
                          className="flex items-center justify-betweenbg-white px-4 py-3 sm:px-6"
                          aria-label="Pagination"
                        >
                          <div className="hidden sm:block">
                            <p className="text-sm text-gray-700">
                              {resultText}
                            </p>
                          </div>
                          <div className="flex flex-1 justify-between sm:justify-end">
                            <ButtonOutline
                              variant="gray"
                              onClick={handlePrevious}
                              className="px-3 py-2 "
                              disabled={page.skip - page.take < 0}
                            >
                              {slice.primary.previous_button_text}
                            </ButtonOutline>
                            <ButtonOutline
                              onClick={handleNext}
                              variant="gray"
                              className="ml-3 px-3 py-2"
                              disabled={
                                page.skip + page.take >= paymentIntents.length
                              }
                            >
                              {slice.primary.next_button_text}
                            </ButtonOutline>
                          </div>
                        </nav>
                      </td>
                    </tr>
                  </tfoot>
                </table>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default BillingList;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BillingHistory/components/PaymentStatus.tsx

import React from 'react';
import Stripe from 'stripe';

import { XMarkIcon } from '@heroicons/react/24/outline';
import { Check, RefreshCw05 } from '@untitled-ui/icons-react';

interface IPaymentStatusProps {
  status: Stripe.Charge.Status;
}

const PaymentStatus: React.FC<IPaymentStatusProps> = ({ status }) => {
  switch (status) {
    case 'pending':
      return (
        <span className="inline-flex items-center rounded-full bg-warning-50 px-2 py-1 font-dmsans text-xs font-medium text-warning-700 ring-1 ring-inset ring-warning-600/20">
          <RefreshCw05 className="h-3 w-3 mr-1" viewBox="0 0 24 24" />
          Pending
        </span>
      );
    case 'failed':
      return (
        <span className="inline-flex items-center rounded-full bg-error-50 px-2 py-1 font-dmsans text-xs font-medium text-error-700 ring-1 ring-inset ring-error-600/20">
          <XMarkIcon className="h-3 w-3 mr-1" viewBox="0 0 24 24" />
          Failed
        </span>
      );
    case 'succeeded':
      return (
        <span className="inline-flex items-center rounded-full bg-success-50 px-2 py-1 font-dmsans text-xs font-medium text-success-700 ring-1 ring-inset ring-success-600/20">
          <Check className="h-3 w-3 mr-1" viewBox="0 0 24 24" />
          Paid
        </span>
      );
    default:
      return null;
  }
};

export default PaymentStatus;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/RelatedBlogArticles/index.tsx

import { BlogpostDocument } from 'prismicio-types';
import React from 'react';

import { BlogArticleContext } from '@/app/(non-account)/blog/[uid]/page';
import PostCardAlt from '@/app/shared/components/blog/post-card/post-card-alt';
import { BlogPostRelatedData } from '@/app/shared/components/blog/types';
import { createClient } from '@/prismicio';
import { PrismicPageType } from '@/utils/prismic/enums';
import { Content, filter } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `RelatedBlogArticles`.
 */
export type RelatedBlogArticlesProps = SliceComponentProps<
  Content.RelatedBlogArticlesSlice,
  BlogArticleContext
>;

/**
 * Component for "RelatedBlogArticles" Slices.
 */
const RelatedBlogArticles = async ({
  slice,
  context,
}: RelatedBlogArticlesProps): Promise<JSX.Element> => {
  const tags = context.page.tags;
  const blogPosts = await getRelatedPosts(context.page.id, tags);
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="px-6 py-10"
    >
      <div className="mx-auto max-w-2xl lg:max-w-7xl">
        <p className="mb-8 text-center font-dmsans text-3xl leading-6 text-[#263a61] font-semibold">
          {slice.primary.title}
        </p>
        <div className="grid grid-cols-1 gap-x-4 gap-y-6 lg:grid-cols-3">
          {blogPosts.map((item) => (
            <React.Fragment key={item?.id}>
              <PostCardAlt post={item} />
            </React.Fragment>
          ))}
        </div>
      </div>
    </section>
  );
};

const getRelatedPosts = async (id: string, tags: string[]) => {
  const client = createClient();
  const queryResult = await client
    .getByType<BlogpostDocument>(PrismicPageType.BLOG_POST, {
      filters: [
        filter.not('document.id', id),
        filter.any('document.tags', tags),
      ],
      orderings: [{ field: 'my.blogpost.publication_date', direction: 'desc' }],
      pageSize: 3,
      fetch: [
        'blogpost.title',
        'blogpost.thumbnail',
        'blogpost.short_description',
        'blogpost.publication_date',
      ],
    })
    .catch(() => []);

  return 'results' in queryResult
    ? queryResult.results
    : ([] as BlogPostRelatedData[]);
};

export default RelatedBlogArticles;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BlogCategorySection/index.tsx

import get from 'lodash.get';
import { BlogpostDocument } from 'prismicio-types';
import React from 'react';

import BlogAdCard from '@/app/shared/components/blog/blog-ad-card';
import BlogNewsletter from '@/app/shared/components/blog/blog-newsletter';
import PostCard from '@/app/shared/components/blog/post-card/post-card';
import { createClient } from '@/prismicio';
import { PrismicCustomType, PrismicPageType } from '@/utils/prismic/enums';
import { convertStringToKebabCase } from '@/utils/utils';
import {
  BlogAdCardRelatedData,
  BlogNewsletterRelatedData,
  BlogPostRelatedData,
  getTypedRelatedBlogPost,
  getTypedRelatedCategory,
} from '@components/blog/types';
import {
  Content,
  FilledContentRelationshipField,
  filter,
} from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `BlogCategorySection`.
 */
export type BlogCategorySectionProps =
  SliceComponentProps<Content.BlogCategorySectionSlice>;

/**
 * Component for "BlogCategorySection" Slices.
 */
const BlogCategorySection = async ({
  slice,
}: BlogCategorySectionProps): Promise<JSX.Element> => {
  // Check if content links where manually added in Prismic
  let blogPosts = slice.items.map((item) =>
    getTypedRelatedBlogPost(item.content_card)
  );

  const categoryData = getTypedRelatedCategory(slice.primary.category);

  if (!blogPosts || (blogPosts && blogPosts.length === 0)) {
    if (!categoryData) return <></>;

    // If not manually added, fetch latest blog posts by category
    blogPosts = await getLatestByCategory(categoryData);
  }

  const sectionId = `blog-category-${convertStringToKebabCase(
    categoryData?.data.category_name
  )}`;

  return (
    <section
      id={sectionId}
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="px-6 py-8"
      style={{
        backgroundColor: get(slice, 'primary.background_color', '#ffffff'),
      }}
    >
      <div className="mx-auto max-w-2xl lg:max-w-7xl">
        <h2 className="mb-6 font-dmsans text-2xl leading-6 text-[#585858] font-semibold">
          {categoryData?.data.category_name?.toUpperCase?.()}
        </h2>
        <div className="grid grid-cols-1 gap-x-4 gap-y-6 lg:grid-cols-3">
          {blogPosts.map((item) => (
            <React.Fragment key={item?.id}>
              {getComponentForRelation(item)}
            </React.Fragment>
          ))}
        </div>
      </div>
    </section>
  );
};

const getComponentForRelation = (
  relatedItem:
    | BlogPostRelatedData
    | BlogAdCardRelatedData
    | BlogNewsletterRelatedData
    | null
) => {
  if (!relatedItem) return null;

  switch (relatedItem.type) {
    case PrismicPageType.BLOG_POST:
      return <PostCard post={relatedItem} />;
    case PrismicCustomType.BLOG_AD_CARD:
      return <BlogAdCard card={relatedItem} />;
    case PrismicCustomType.BLOG_NEWSLETTER:
      return <BlogNewsletter content={relatedItem} />;
    default:
      return null;
  }
};

const getLatestByCategory = async (
  category: FilledContentRelationshipField<PrismicPageType.BLOG_CATEGORY>
) => {
  if (!category) return [] as any;

  const client = createClient();
  const queryResult = await client
    .getByType<BlogpostDocument>(PrismicPageType.BLOG_POST, {
      filters: [filter.at('my.blogpost.categories.category', category.id)],
      orderings: [{ field: 'my.blogpost.publication_date', direction: 'desc' }],
      pageSize: 3,
      fetch: [
        'blogpost.title',
        'blogpost.thumbnail',
        'blogpost.short_description',
        'blogpost.publication_date',
      ],
    })
    .catch(() => []);

  return 'results' in queryResult
    ? queryResult.results
    : ([] as BlogPostRelatedData[]);
};

export default BlogCategorySection;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/NavigationItem/index.tsx

import PrismicNextLink from '@components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `NavigationItem`.
 */
export type NavigationBarProps =
  SliceComponentProps<Content.NavigationBarSlice>;

/**
 * Component for "NavigationItem" Slices.
 */
const NavigationItem = ({ slice }: NavigationBarProps): JSX.Element => {
  return (
    <PrismicNextLink
      field={slice.primary.link}
      className="text-sm font-semibold leading-6 rounded-lg p-1 text-primary-950 focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-gray-200"
    >
      {slice.primary.name}
    </PrismicNextLink>
  );
};

export default NavigationItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/NavigationItem/variants/navigation-item.tsx

import { NavigationBarSlice, NavigationDocument } from 'prismicio-types';
import { Fragment } from 'react';
import { twMerge } from 'tailwind-merge';

import PrismicNextLink from '@components/buttons/custom-prismic-link';
import { Popover, Transition } from '@headlessui/react';
import { ChevronDownIcon } from '@heroicons/react/20/solid';

import { useStyles } from '../../../app/shared/components/navigation/useStyles';

const NavigationItem: React.FC<{
  item: NavigationBarSlice;
  navigation: NavigationDocument;
}> = ({ item, navigation }) => {
  const { classes } = useStyles({ nav: navigation });

  if (item.variation === 'button') {
    return (
      <PrismicNextLink
        field={item.primary.link}
        className={twMerge(
          'px-3 py-2 rounded-lg text-sm font-semibold leading-6 focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-gray-200',
          classes.navButton
        )}
        prefetch={item.primary.prefetch}
      >
        {item.primary.name}
      </PrismicNextLink>
    );
  }

  return item.items.length > 0 ? (
    <Popover.Group>
      <Popover className="relative z-50">
        <Popover.Button
          className={twMerge(
            'flex items-center gap-x-1 text-sm font-semibold leading-6 rounded-lg p-1 focus:outline-none focus:ring-0',
            classes.navLink
          )}
        >
          {item.primary.name}
          <ChevronDownIcon className="h-5 w-5 flex-none" aria-hidden="true" />
        </Popover.Button>

        <Transition
          as={Fragment}
          enter="transition ease-out duration-200"
          enterFrom="opacity-0 translate-y-1"
          enterTo="opacity-100 translate-y-0"
          leave="transition ease-in duration-150"
          leaveFrom="opacity-100 translate-y-0"
          leaveTo="opacity-0 translate-y-1"
        >
          <Popover.Panel
            className={twMerge(
              'absolute -left-8 top-full z-10 mt-4 w-screen max-w-md overflow-hidden rounded-3xl shadow-lg',
              classes.navPopover
            )}
          >
            <div className="p-4">
              {item.items.map((child_item) => (
                <div
                  key={child_item.child_name}
                  className={twMerge(
                    'group relative flex gap-x-6 rounded-lg p-4 text-sm leading-6 focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-gray-200',
                    classes.navPopoverLink
                  )}
                >
                  <div className="flex-auto">
                    <PrismicNextLink
                      field={child_item.child_link}
                      className="text-sm font-semibold leading-6'"
                      prefetch={child_item.prefetch}
                    >
                      {child_item.child_name}
                      <span className="absolute inset-0" />
                    </PrismicNextLink>
                  </div>
                </div>
              ))}
            </div>
          </Popover.Panel>
        </Transition>
      </Popover>
    </Popover.Group>
  ) : (
    <PrismicNextLink
      field={item.primary.link}
      className={twMerge(
        'text-sm font-semibold leading-6 rounded-lg p-1 focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-gray-200',
        classes.navLink
      )}
      prefetch={item.primary.prefetch}
    >
      {item.primary.name}
    </PrismicNextLink>
  );
};

export default NavigationItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/NavigationItem/variants/mobile-navigation-item.tsx

import { NavigationBarSlice, NavigationDocument } from 'prismicio-types';
import { twMerge } from 'tailwind-merge';

import PrismicNextLink from '@components/buttons/custom-prismic-link';
import { Disclosure } from '@headlessui/react';
import { ChevronDownIcon } from '@heroicons/react/20/solid';

import { useStyles } from '../../../app/shared/components/navigation/useStyles';

const MobileNavigationItem: React.FC<{
  item: NavigationBarSlice;
  navigation: NavigationDocument;
}> = ({ item, navigation }) => {
  const { classes } = useStyles({ nav: navigation });
  if (item.variation === 'button') {
    return (
      <PrismicNextLink
        field={item.primary.link}
        className={twMerge(
          '-mx-3 flex w-full text-center justify-center items-center rounded-lg px-3 py-2 text-base font-semibold leading-7',
          classes.navButton
        )}
        prefetch={item.primary.prefetch}
      >
        {item.primary.name}
      </PrismicNextLink>
    );
  }
  if (item.items.length < 1) {
    return (
      <PrismicNextLink
        key={item.primary.name}
        field={item.primary.link}
        className={twMerge(
          '-mx-3 block rounded-lg px-3 py-2 text-base leading-7',
          classes.navPopoverLink
        )}
        prefetch={item.primary.prefetch}
      >
        {item.primary.name}
      </PrismicNextLink>
    );
  }
  return (
    <Disclosure as="div" className="-mx-3">
      {({ open }) => (
        <>
          <Disclosure.Button
            className={twMerge(
              'flex w-full items-center justify-between rounded-lg py-2 pl-3 pr-3.5 text-base leading-7',
              classes.navPopoverLink
            )}
          >
            {item.primary.name}
            <ChevronDownIcon
              className={twMerge(open ? 'rotate-180' : '', 'h-5 w-5 flex-none')}
              aria-hidden="true"
            />
          </Disclosure.Button>
          <Disclosure.Panel className="mt-2 space-y-2">
            {item.items.map((item) => (
              <PrismicNextLink
                key={item.child_name}
                field={item.child_link}
                className={twMerge(
                  'block rounded-lg py-2 pl-6 pr-3 text-sm font-semibold leading-7',
                  classes.navPopoverLink
                )}
                prefetch={item.prefetch}
              >
                {item.child_name}
              </PrismicNextLink>
            ))}
          </Disclosure.Panel>
        </>
      )}
    </Disclosure>
  );
};

export default MobileNavigationItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/SubscriptionPlan/index.tsx

import React from 'react';

import { AccountPageContext } from '@/app/shared/types';
import { getUserAttributes } from '@/utils/helpers/helpers';
import { getSelectedDependentOrPrimaryUser } from '@/utils/utils';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import SubscriptionCards from './components/SubscriptionCards';

/**
 * Props for `SubscriptionPlan`.
 */
export type SubscriptionPlanProps = SliceComponentProps<
  Content.SubscriptionPlanSlice,
  AccountPageContext
>;

/**
 * Component for "SubscriptionPlan" Slices.
 */
const SubscriptionPlanWrapper: React.FC<SubscriptionPlanProps> = async (p) => {
  const userId = p.context.searchParams?.mid as string;
  const user =
    p.context.user && userId
      ? getSelectedDependentOrPrimaryUser(p.context.user, userId)
      : p.context.user;

  const userWithAttributes = user ? await getUserAttributes(user) : undefined;

  return (
    <section
      data-slice-type={p.slice.slice_type}
      data-slice-variation={p.slice.variation}
    >
      <div className="max-w-6xl mx-auto lg:mx-0 px-4 pt-6 sm:px-8 pb-10">
        <div className="mb-8 grid grid-cols-1 gap-6">
          {user?.firstName && (
            <h2 className="font-dmsans text-2xl text-gray-700">
              {user?.firstName} {user?.lastName}
            </h2>
          )}
          {p.slice.items.map((plan) => (
            <SubscriptionCards
              key={plan.title}
              plan={plan}
              {...p}
              user={userWithAttributes}
            />
          ))}
        </div>
      </div>
    </section>
  );
};

export default SubscriptionPlanWrapper;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/SubscriptionPlan/components/CardsSkeleton.tsx

const CardsSkeleton = () => {
  return (
    <div className="max-w-6xl mx-auto lg:mx-0 px-4 pt-10 sm:px-8 pb-10">
      <div className="mb-8 grid grid-cols-1 gap-6">
        {[...Array(2)].map((_e, i) => (
          <div
            key={`card-${i}`}
            className="border border-gray-200 rounded-xl max-w-3xl"
          >
            <div className="border-b rounded-t-xl p-2 bg-white border-gray-200">
              <div className="flex items-center space-x-3">
                <div className="flex-shrink-0">
                  <div className="h-7 w-7 rounded-full bg-gray-200" />
                </div>
                <div className="min-w-0 flex-1">
                  <div className="rounded bg-gray-200 h-4 w-1/3" />
                </div>
              </div>
            </div>
            <div className="p-4">
              <div className="font-dmsans text-3xl text-gray-700 font-semibold flex items-baseline">
                <div className="bg-gray-200 h-6 w-20 rounded" />
                <div className="text-gray-600 text-sm font-normal ml-1 bg-gray-200 w-10 rounded" />
              </div>
              <div className="my-3 flex flex-col gap-2">
                <div className="bg-gray-200 h-4 w-3/4 rounded" />
                <div className="bg-gray-200 h-4 w-3/4 rounded" />
                <div className="bg-gray-200 h-4 w-3/4 rounded" />
                <div className="bg-gray-200 h-4 w-1/2 rounded" />
              </div>
            </div>
            <div className="flex border-t border-gray-200 rounded-b-xl justify-end mx-3">
              <div className="font-dmsans text-gray-500 text-sm my-2 bg-gray-200 h-4 w-20 rounded" />
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default CardsSkeleton;

{
  /* <div
        className={twMerge(
          'border border-gray-200 rounded-xl max-w-3xl',
          isCurrentPlan && 'border-2 border-accent-600'
        )}
      >
        <div
          className={twMerge(
            'border-b rounded-t-xl p-2',
            isCurrentPlan
              ? 'border-b-2 bg-accent-50 border-accent-600'
              : 'bg-white border-gray-200'
          )}
        >
          <div className="flex items-center space-x-3">
            <div className="flex-shrink-0">
              <Image
                className="h-7 w-7 rounded-full"
                src="/assets/icons/subscription-icon.svg"
                alt=""
                width={40}
                height={40}
              />
            </div>
            <div className="min-w-0 flex-1">
              <p
                className={twMerge(
                  'font-dmsans text-base font-semibold',
                  isCurrentPlan ? 'text-accent-800' : 'text-gray-700'
                )}
              >
                {plan.title}
              </p>
            </div>
            {isCurrentPlan && (
              <div className="flex flex-shrink-0 self-center pr-2">
                <Image
                  className="h-4 w-4 rounded-full"
                  src="/assets/icons/green-check-circle.svg"
                  alt=""
                  width={16}
                  height={16}
                />
              </div>
            )}
          </div>
        </div>
        <div className="p-4">
          <p className="font-dmsans text-3xl text-gray-700 font-semibold flex items-baseline">
            ${plan.price}
            <span className="text-gray-600 text-sm font-normal ml-1">
              {plan.billing_schedule}
            </span>
          </p>
          <div className="my-2 ">
            <RichText
              field={plan.description}
              className="font-dmsans text-sm text-gray-600 [&_ul]:list-disc [&_ul]:space-y-1"
            />
          </div>
        </div>
        <div className="flex border-t border-gray-200 rounded-b-xl justify-end mx-3">
          {isCurrentPlan && (
            <ButtonBase variant="gray" size="base">
              Cancel Subscription
            </ButtonBase>
          )}
          {hasConcierge && !isCurrentPlan && (
            <div className="font-dmsans text-gray-500 text-sm p-2">
              To switch plans, you must cancel your current subscription
            </div>
          )}
          {!hasConcierge && (
            <ButtonSolid
              className="m-2 py-1.5 min-w-[150px] flex items-center justify-center"
              variant="accent"
              size="sm"
              onClick={handleAddToCart}
              disabled={adding}
            >
              {adding ? (
                <LoadingSpinner fillClass="fill-accent-500" size="sm" />
              ) : (
                'Add to Cart'
              )}
            </ButtonSolid>
          )}
        </div>
      </div> */
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/SubscriptionPlan/components/SubscriptionCards.tsx

import { SubscriptionPlanSliceDefaultItem } from 'prismicio-types';
import React from 'react';

import { ExtendedUserAttributes } from '@/app/shared/types';
import { getPrismicProductId } from '@/utils/get-prismic-product-id';
import { User } from '@prisma/client';

import { SubscriptionPlanProps } from '..';
import SubscriptionCard from './SubscriptionCard';

type ISubscriptionCardProps = SubscriptionPlanProps & {
  plan: SubscriptionPlanSliceDefaultItem;
  user?: User & ExtendedUserAttributes;
};

/**
 * Component for "SubscriptionPlan" Slices.
 */
const SubscriptionCards: React.FC<ISubscriptionCardProps> = async ({
  slice,
  plan,
  user,
}) => {
  const subscription = (user?.activeConciergeSubscriptions ?? []).find(
    (sub) => sub.subscriptionProductId === getPrismicProductId(plan)
  );

  return (
    <SubscriptionCard
      key={plan.title}
      slice={slice}
      plan={plan}
      subscription={subscription}
      hasConcierge={!!user?.hasConcierge}
    />
  );
};

export default SubscriptionCards;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/SubscriptionPlan/components/SubscriptionCard.tsx

'use client';

import dayjs from 'dayjs';
import Image from 'next/image';
import { useRouter } from 'next/navigation';
import { SubscriptionPlanSlice } from 'prismicio-types';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import ButtonSolid from '@/app/shared/components/buttons/button-solid';
import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import ErrorToast from '@/app/shared/components/error-toast';
import LoadingSpinner from '@/app/shared/components/loading-indicators/loading-spinner';
import { RichText } from '@/app/shared/components/text/rich-text';
import { useCartSliderContext } from '@/app/shared/hooks/use-cart-slider-context';
import { getPrismicProductId } from '@/utils/get-prismic-product-id';
import { UserSubscription } from '@prisma/client';
import { Content } from '@prismicio/client';

interface ISubscriptionCardProps {
  slice: SubscriptionPlanSlice;
  plan: Content.SubscriptionPlanSliceDefaultItem;
  subscription?: UserSubscription;
  hasConcierge: boolean;
}

const addConciergeToCart = async (productId: string) => {
  try {
    const res = await fetch(
      `/api/ecommerce/subscription-product/${productId}/cart`,
      {
        method: 'POST',
        body: JSON.stringify({ setAbsoluteAmount: true, amount: 1 }),
      }
    );

    if (!res.ok) {
      throw new Error('Could not add subscription product to cart');
    }

    return { success: true };
  } catch (error) {
    return { success: false };
  }
};
//TODO: Fix the subscription ended but active logic
const SubscriptionCard = ({
  slice,
  plan,
  subscription,
  hasConcierge,
}: ISubscriptionCardProps): JSX.Element => {
  const [adding, setAdding] = React.useState(false);
  const [error, setError] = React.useState(false);
  const router = useRouter();
  const { startTransition, setShowCart } = useCartSliderContext();

  const onErrorToastClose = () => {
    setError(false);
  };

  const handleAddToCart = async () => {
    setAdding(true);
    const productId = getPrismicProductId(plan);
    const { success } = await addConciergeToCart(productId as string);
    if (success) {
      startTransition(() => {
        router.refresh();
      });
      setShowCart(true);
    } else {
      setError(true);
    }
    setAdding(false);
  };

  const hasCurrentPlan = subscription !== undefined;

  return (
    <>
      <div
        className={twMerge(
          'bg-white border border-gray-200 rounded-xl max-w-3xl',
          hasCurrentPlan && 'border-2 border-accent-600'
        )}
      >
        <div
          className={twMerge(
            'border-b rounded-t-xl p-2',
            hasCurrentPlan
              ? 'border-b-2 bg-accent-50 border-accent-600'
              : 'bg-white border-gray-200'
          )}
        >
          <div className="flex items-center space-x-3">
            <div className="flex-shrink-0">
              <Image
                className="h-7 w-7 rounded-full"
                src="/assets/icons/subscription-icon.svg"
                alt=""
                width={40}
                height={40}
              />
            </div>
            <div className="min-w-0 flex-1">
              <p
                className={twMerge(
                  'font-dmsans text-base font-semibold',
                  hasCurrentPlan ? 'text-accent-800' : 'text-gray-700'
                )}
              >
                {plan.title}
              </p>
            </div>
            {hasCurrentPlan && (
              <div className="flex flex-shrink-0 self-center pr-2">
                <Image
                  className="h-4 w-4 rounded-full"
                  src="/assets/icons/green-check-circle.svg"
                  alt=""
                  width={16}
                  height={16}
                />
              </div>
            )}
          </div>
        </div>
        <div className="p-4">
          <p className="font-dmsans text-3xl text-gray-700 font-semibold flex items-baseline">
            ${plan.price}
            <span className="text-gray-600 text-sm font-normal ml-1">
              {plan.billing_schedule}
            </span>
          </p>
          <div className="my-2 ">
            <RichText
              field={plan.description}
              className="font-dmsans text-sm text-gray-600 [&_ul]:list-disc [&_ul]:space-y-1"
            />
          </div>
        </div>
        <div className="flex border-t border-gray-200 rounded-b-xl justify-end mx-3">
          {subscription?.endDate && (
            <div className="font-dmsans text-gray-500 text-sm p-2">
              {slice.primary.benefits_active_text?.replace(
                '{{ endDate }}',
                dayjs(subscription?.endDate).format('MMM DD, YYYY')
              )}
            </div>
          )}
          {hasCurrentPlan && !subscription?.endDate && (
            <CustomPrismicLink
              field={slice.primary.cancel_link}
              className="text-gray-600 text-sm font-dmsans font-semibold p-2"
            >
              {slice.primary.cancel_text}
            </CustomPrismicLink>
          )}
          {hasConcierge && !hasCurrentPlan && (
            <div className="font-dmsans text-gray-500 text-sm p-2">
              {slice.primary.switch_plan_text}
            </div>
          )}
          {!hasConcierge && (
            <ButtonSolid
              className="m-2 py-1.5 min-w-[150px] flex items-center justify-center"
              variant="accent"
              size="sm"
              onClick={handleAddToCart}
              disabled={adding}
            >
              {adding ? (
                <LoadingSpinner fillClass="fill-accent-500" size="sm" />
              ) : (
                slice.primary.add_to_cart_text
              )}
            </ButtonSolid>
          )}
        </div>
      </div>
      <ErrorToast
        show={error}
        position="fixed"
        text={slice.primary.add_to_cart_error ?? ''}
        onClose={onErrorToastClose}
      />
    </>
  );
};

export default SubscriptionCard;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/ProductSuggestions/index.tsx

import React from 'react';

import { ProductWithContent } from '@/app/shared/types';
import { User } from '@prisma/client';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import ProductSlider from './components/ProductSlider';

/**
 * Props for `ProductSuggestions`.
 */
export type ProductSuggestionsProps =
  SliceComponentProps<Content.ProductSuggestionsSlice>;

/**
 * Component for "ProductSuggestions" Slices.
 */
const ProductSuggestions: React.FC<ProductSuggestionsProps> = async (p) => {
  const { products } = p.context as {
    user: User;
    products: ProductWithContent[];
  };

  return (
    <section
      data-slice-type={p.slice.slice_type}
      data-slice-variation={p.slice.variation}
    >
      <div className="px-6 mx-auto max-w-5xl pt-4 pb-12">
        <div className="font-dmsans text-black text-4xl md:text-5xl font-semibold mb-10">
          {p.slice.primary.title}
        </div>
        <div className="hidden md:block">
          <ProductSlider {...p} products={products} slides={3} />
        </div>
        <div className="hidden sm:block md:hidden">
          <ProductSlider {...p} products={products} slides={2} />
        </div>
        <div className="block sm:hidden">
          <ProductSlider {...p} products={products} slides={1} />
        </div>
      </div>
    </section>
  );
};

export default ProductSuggestions;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/ProductSuggestions/components/ProductSlider.tsx

'use client';

import 'swiper/css';
import 'swiper/css/navigation';
import 'swiper/css/pagination';
import { Navigation } from 'swiper/modules';
import { Swiper, SwiperSlide } from 'swiper/react';

import { ProductWithContent } from '@/app/shared/types';
import { formatCurrency } from '@/utils/utils';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';
import { ArrowLeft, ArrowRight } from '@untitled-ui/icons-react';

import { ProductSuggestionsProps } from '..';

/**
 * Props for `ProductSuggestions`.
 */
interface IProductSliderProps extends ProductSuggestionsProps {
  products: ProductWithContent[];
  slides: number;
}

/**
 * Component for "ProductSuggestions".
 */
const ProductSlider = ({
  products,
  slides,
}: IProductSliderProps): JSX.Element => {
  return (
    <div className="flex flex-row justify-center items-center">
      <button
        id="prev"
        className="bg-accent-200 text-accent-700 rounded-full p-2 hover:bg-accent-300 disabled:bg-white disabled:text-gray-600 disabled:border disabled:border-gray-100 disabled:shadow-md disabled:hover:bg-white"
      >
        <ArrowLeft className="w-5 h-5" viewBox="0 0 24 24" />
      </button>
      <Swiper
        slidesPerView={slides}
        spaceBetween={20}
        pagination={{
          clickable: true,
        }}
        navigation={{
          prevEl: '#prev',
          nextEl: '#next',
        }}
        modules={[Navigation]}
        className="w-full h-full"
      >
        {products.map((product) => (
          <SwiperSlide key={product.uid}>
            <PrismicNextLink
              key={product.uid}
              document={product}
              className="block group font-dmsans max-w-[300px] mx-auto"
            >
              <div className="aspect-square w-full max-w-[300px]  overflow-hidden rounded-lg bg-white">
                <PrismicNextImage
                  field={product.data.thumbnail}
                  className="w-full h-full object-cover object-center group-hover:opacity-75"
                />
              </div>
              <div className="p-6">
                <p className="text-base font-medium text-gray-600">
                  {product.data.type}
                </p>
                <p className="mt-2 text-2xl font-medium text-gray-900">
                  {product.data.name}
                </p>
                <p className="mt-2 text-lg font-semibold text-gray-900">
                  {formatCurrency(product.price)}
                </p>
              </div>
            </PrismicNextLink>
          </SwiperSlide>
        ))}
      </Swiper>
      <button
        id="next"
        className="bg-accent-200 text-accent-700 rounded-full p-2 hover:bg-accent-300 disabled:bg-white disabled:text-gray-600 disabled:border disabled:border-gray-100 disabled:shadow-md disabled:hover:bg-white"
      >
        <ArrowRight className="w-5 h-5" viewBox="0 0 24 24" />
      </button>
    </div>
  );
};

export default ProductSlider;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Form/index.tsx

import { Suspense } from 'react';

import { AccountPageContext } from '@/app/shared/types';
import { FORM_KEYS } from '@/utils/enums';
import { getIsProd } from '@/utils/get-is-prod';
import { PartnerData } from '@/utils/get-partner';
import { getUserAllergiesAndMedications } from '@/utils/helpers/helpers';
import { getUserFromDependents } from '@/utils/utils';
import DermiForm from '@form/components/form';
import Loading from '@form/components/loading';
import { User } from '@prisma/client';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

const isProd = getIsProd();

// Extend the existing context type with your custom properties
interface CustomContext {
  searchParams?: { [key: string]: string | string[] | undefined };
  user?: User;
  allergiesAndMedications?: unknown;
  selectedUser?: User;
  addNewFamilyMember?: boolean;
  partner?: PartnerData | null;
}

// Update the FormProps to include the new context type
export type FormProps = SliceComponentProps<
  Content.FormSlice,
  AccountPageContext
>;

const Form = async (p: FormProps): Promise<JSX.Element> => {
  const searchedTab = JSON.stringify((p.context as any)?.searchParams);
  return (
    <div className="w-full flex flex-col flex-1 bg-gray-100 pb-16">
      <Suspense key={searchedTab} fallback={<Loading />}>
        <FormSlice {...p} />
      </Suspense>
    </div>
  );
};

const getFormId = (slice: Content.FormSlice, formKey?: string) => {
  const formIds = slice.items.filter((item) => item.key === formKey);

  if (formIds.length > 0) {
    const formIdForEnvironment = formIds.find(
      (item) => item.environment === process.env.ENVIRONMENT_NAME
    );

    if (formIdForEnvironment) {
      return formIdForEnvironment.form_id;
    }
  }

  return !isProd ? slice.primary.dev_form_id : slice.primary.form_id;
};

const FormSlice = async ({
  slice,
  context,
}: FormProps): Promise<JSX.Element> => {
  // Get intention from search params
  const selectedUserId =
    typeof context.searchParams?.mid === 'string'
      ? context.searchParams?.mid
      : undefined;
  const addingNewUser = selectedUserId ? false : true;

  // Switch form based on selected user: dependent (special case) or guardian (default)
  let formId;
  if (
    addingNewUser ||
    (selectedUserId && selectedUserId !== context.user?.id)
  ) {
    formId = getFormId(slice, FORM_KEYS.DEPENDENT_FORM);
  } else {
    formId = getFormId(slice, FORM_KEYS.DEFAULT_FORM);
  }

  // console.log('slice');
  // console.log(JSON.stringify(slice, null, 2));
  // console.log('formId', formId);

  if (!formId) return <></>;

  let newContext: CustomContext = {
    ...context,
  };

  // Get allergies and medications for the user
  let allergiesAndMedications = undefined;
  if (context?.user?.dosespotId !== null) {
    allergiesAndMedications = await getUserAllergiesAndMedications(
      context?.user?.id
    );
  }

  if (allergiesAndMedications !== undefined) {
    newContext = {
      ...newContext,
      allergiesAndMedications,
    };
  }

  // Add the selected user to context (undefined if attempting to add a new family member)
  const selectedUser = getUserFromDependents(
    context.user as any,
    selectedUserId
  );

  newContext = {
    ...newContext,
    selectedUser: addingNewUser ? undefined : selectedUser,
    addNewFamilyMember: addingNewUser,
  };

  // Log Form Context
  // console.log('newContext');
  // console.log(JSON.stringify(newContext, null, 2));

  return (
    <Suspense key={`${formId}-${context.user?.id}`} fallback={<Loading />}>
      <DermiForm id={formId} locale="en" context={{ ...newContext }} />
    </Suspense>
  );
};

export default Form;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/ComplaintSelector/index.tsx

'use client';

import { useRouter } from 'next/navigation';
import { useSearchParams } from 'next/navigation';
import { useEffect, useState } from 'react';

import LoadingCircles from '@components/loading-indicators/loading-circles';
import { Content } from '@prismicio/client';
import { PrismicNextLink } from '@prismicio/next';
import { PrismicRichText, SliceComponentProps } from '@prismicio/react';

/**
 * Props for `ComplaintSelector`.
 */
export type ComplaintSelectorProps =
  SliceComponentProps<Content.ComplaintSelectorSlice>;

/**
 * Component for "ComplaintSelector" Slices.
 */
const ComplaintSelector = ({ slice }: ComplaintSelectorProps): JSX.Element => {
  const [showLoadingCircles, setShowLoadingCircles] = useState(true);

  const router = useRouter();
  const searchParams = useSearchParams();
  const condition = searchParams.get('condition');

  useEffect(() => {
    if (!condition) {
      setShowLoadingCircles(false);
      return;
    } // If there's no condition, do nothing.

    // Find a complaint that matches the condition.
    const matchingComplaint = slice.items.find(
      (complaint) =>
        complaint.link_text?.toLowerCase() ===
        condition.toString().toLowerCase()
    );

    // If a matching complaint is found, navigate to its link.
    if (
      matchingComplaint &&
      'url' in matchingComplaint.link &&
      matchingComplaint.link.url
    ) {
      const queryString = searchParams.toString();
      const urlWithQuery = `${matchingComplaint.link.url}?${queryString}`;
      router.push(urlWithQuery as string);
    } else {
      setShowLoadingCircles(false);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [condition, slice.items, router]);

  if (showLoadingCircles) {
    return <LoadingCircles />;
  } else {
    return (
      <section
        data-slice-type={slice.slice_type}
        data-slice-variation={slice.variation}
        className="w-full h-screen bg-gray-100"
      >
        <div className="flex flex-col justify-center w-full pb-10 pt-24  max-w-[800px] mx-auto">
          <h1 className="font-financier text-gray-700 text-4xl font-semibold mb-3">
            {slice.primary.title}
          </h1>
          <div className="font-dmsans text-base text-gray-600 font-medium">
            <PrismicRichText field={slice.primary.description} />
          </div>
          <div className="flex flex-row gap-2 items-center flex-wrap my-5">
            {slice.items.map((complaint) => (
              <PrismicNextLink
                key={complaint.link_text}
                field={complaint.link}
                className="inline-flex items-center justify-center px-[18px] py-2.5 rounded-lg bg-white border border-gray-300 cursor-pointer font-dmsans text-base text-gray-700 peer-focus:ring-1 font-semibold peer-focus:ring-accent-200 peer-checked:border-accent-400 peer-checked:text-accent-700 peer-checked:bg-accent-50 peer-enabled:hover:text-accent-700 peer-enabled:hover:border-accent-300 peer-enabled:hover:bg-accent-100 peer-disabled:cursor-not-allowed peer-disabled:bg-gray-100"
              >
                {complaint.link_text}
              </PrismicNextLink>
            ))}
          </div>
        </div>
      </section>
    );
  }
};

export default ComplaintSelector;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BlogCtaBanner/index.tsx

import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import BlogCtaBannerDefault from './variants/BlogCtaBannerDefault';
import ImageBanner from './variants/ImageBanner';

/**
 * Props for `BlogCtaBanner`.
 */
export type BlogCtaBannerProps =
  SliceComponentProps<Content.BlogCtaBannerSlice>;

/**
 * Component for "BlogCtaBanner" Slices.
 */
const BlogCtaBanner = ({ slice }: BlogCtaBannerProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="px-6 py-6"
    >
      <div className="max-w-7xl mx-auto">
        {slice.variation === 'imageBanner' ? (
          <ImageBanner slice={slice} />
        ) : (
          <BlogCtaBannerDefault slice={slice} />
        )}
      </div>
    </section>
  );
};

export default BlogCtaBanner;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BlogCtaBanner/variants/BlogCtaBannerDefault.tsx

import get from 'lodash.get';

import { Content } from '@prismicio/client';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';
import { PrismicRichText } from '@prismicio/react';

interface BlogCtaBannerDefaultProps {
  slice: Content.BlogCtaBannerSliceDefault;
}

const BlogCtaBannerDefault: React.FC<BlogCtaBannerDefaultProps> = ({
  slice,
}) => {
  return (
    <div
      style={{
        backgroundColor: get(slice, 'primary.background_color', '#9b6222'),
      }}
      className="grid grid-cols-1 sm:grid-cols-3 md:grid-cols-4 py-4 gap-4 items-center rounded-[20px] px-10 lg:px-16"
    >
      <PrismicNextImage
        field={slice.primary.image}
        className="hidden md:block w-full h-auto"
      />
      <div
        style={{
          color: get(slice, 'primary.text_color', '#FFFFFF'),
        }}
        className="font-dmsans col-span-1 sm:col-span-2"
      >
        <PrismicRichText
          field={slice.primary.text}
          components={{
            paragraph: ({ children }) => (
              <p className="text-2xl leading-10 font-light">{children}</p>
            ),
          }}
        />
      </div>
      <PrismicNextLink
        field={slice.primary.cta_link}
        style={{
          backgroundColor: get(slice, 'primary.cta_button_color', '#9b6222'),
          color: get(slice, 'primary.cta_link_color', '#FFFFFF'),
        }}
        className="text-center text-base rounded-[22px] font-dmsans p-2.5 font-medium max-w-[240px] hover:opactity-80 transition-all duration-300 ease-in-out"
      >
        {slice.primary.cta_link_text}
      </PrismicNextLink>
    </div>
  );
};

export default BlogCtaBannerDefault;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BlogCtaBanner/variants/ImageBanner.tsx

import { Content } from '@prismicio/client';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';

interface ImageBannerProps {
  slice: Content.BlogCtaBannerSliceImageBanner;
}

const ImageBanner: React.FC<ImageBannerProps> = ({ slice }) => {
  return (
    <PrismicNextLink field={slice.primary.cta_link} className="group">
      <PrismicNextImage
        field={slice.primary.image}
        className="hidden sm:block w-full h-auto rounded-[20px] group-hover:shadow-lg"
      />
      <PrismicNextImage
        field={slice.primary.mobile_image}
        className="block sm:hidden w-full h-auto rounded-[20px] group-hover:shadow-lg"
      />
    </PrismicNextLink>
  );
};

export default ImageBanner;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/FeaturedBlogSection/index.tsx

import LargeBlogPostCard from '@components/blog/post-card/large-post-card';
import SmallBlogPostCard from '@components/blog/post-card/small-post-card';
import { getTypedBlogPost } from '@components/blog/types';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `FeaturedBlogSection`.
 */
export type FeaturedBlogSectionProps =
  SliceComponentProps<Content.FeaturedBlogSectionSlice>;

/**
 * Component for "FeaturedBlogSection" Slices.
 */
const FeaturedBlogSection = ({
  slice,
}: FeaturedBlogSectionProps): JSX.Element => {
  if (!slice.items || (slice.items && slice.items.length === 0)) return <></>;

  const posts = slice.items.map((post) => getTypedBlogPost(post.content_card));

  const [lgPost, ...smPosts] = posts;
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="py-8 px-6"
    >
      <div className="mt-6 mx-auto max-w-7xl grid grid-cols-1 gap-y-6 lg:grid-cols-3 lg:gap-x-6 lg:gap-8">
        <div className="lg:col-span-2">
          <LargeBlogPostCard post={lgPost} />
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-1 gap-6 lg:auto-rows-fr">
          {smPosts.map((item, index) => (
            <SmallBlogPostCard key={index} post={item} />
          ))}
        </div>
      </div>
    </section>
  );
};

export default FeaturedBlogSection;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Testimonials/index.tsx

'use client';

import React from 'react';

import { useBreakpoints } from '@hooks/useBreakpoints';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import CardSection from './CardSection';

/**
 * Props for `Testimonials`.
 */
export type TestimonialsProps = SliceComponentProps<Content.TestimonialsSlice>;

/**
 * Component for "Testimonials" Slices.
 */
const Testimonials: React.FC<TestimonialsProps> = (p) => {
  const { isSm, isLg } = useBreakpoints();

  // Number of cards to display on a slide at each breakpoint
  let range = 1;
  if (isSm) range = 2;
  if (isLg) range = 3;

  return <CardSection key={`testimonal-cards-${range}`} {...p} range={range} />;
};

export default Testimonials;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Testimonials/CardSection.tsx

'use client';

import { AnimatePresence, motion } from 'framer-motion';
import get from 'lodash.get';
import React from 'react';

import { useInterval } from '@hooks/useInterval';
import { PrismicRichText } from '@prismicio/react';

import { type TestimonialsProps } from '.';
import SliderButtons from './SliderButtons';

interface ICardSection extends TestimonialsProps {
  range: number;
}

const CardSection: React.FC<ICardSection> = ({ slice, range }) => {
  const [index, setIndex] = React.useState(0);
  const [delay, setDelay] = React.useState<number | null>(4000);

  // Autoplay slideshow
  useInterval(() => {
    setIndex((index) => {
      if (index + range < slice.items.length) {
        return index + range;
      }

      return 0;
    });
  }, delay);

  const handleClick = (page: number) => {
    // Go to page selection and disable autoplay
    setIndex(page * range);
    setDelay(null);
  };

  const items = slice.items?.slice(index, index + range);

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="overflow-hidden"
      style={{
        backgroundImage: `linear-gradient(${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
      }}
    >
      <div className="pt-8 pb-12">
        <div className="mx-auto max-w-5xl px-3 lg:px-8">
          <div className="mx-auto max-w-xl text-center">
            <p
              className="font-financier text-4xl font-bold tracking-tight sm:text-6xl"
              style={{ color: get(slice, 'primary.title_color', '#263A61') }}
            >
              {slice.primary.title}
            </p>
          </div>
          <div className="mx-auto mt-8 flow-root max-w-2xl sm:mt-8 lg:mx-0 lg:max-w-none min-h-[350px]">
            <AnimatePresence mode="wait">
              <motion.div
                initial={{ x: '100%' }}
                animate={{
                  x: '0%',
                  transition: { duration: 0.5, ease: 'easeOut' },
                }}
                exit={{
                  x: '-100%',
                  transition: {
                    duration: 0.5,
                    ease: 'easeIn',
                  },
                }}
                style={{ fontSize: 100 }}
                key={index}
              >
                <div
                  className="-mt-8 sm:-mx-4 grid"
                  style={{
                    gridTemplateColumns: `repeat(${range}, minmax(0, 1fr))`,
                  }}
                >
                  {items.map((testimonial) => (
                    <div
                      key={testimonial.name}
                      className="pt-8 sm:w-full sm:px-4"
                    >
                      <figure
                        className="rounded-2xl h-full min-h-[318px] max-w-[300px] mx-auto p-8 text-sm leading-6"
                        style={{
                          backgroundColor: get(
                            slice,
                            'primary.card_color',
                            '#F8F8F8'
                          ),
                        }}
                      >
                        <blockquote
                          className="font-dmsans text-base leading-7"
                          style={{
                            color: get(
                              slice,
                              'primary.content_color',
                              '#212121'
                            ),
                          }}
                        >
                          <PrismicRichText field={testimonial.quote} />
                        </blockquote>
                        <div className="w-[25%] h-[3px] bg-[#b2d6e0] mt-4" />
                        <figcaption className="mt-5 flex items-center gap-x-4">
                          <div>
                            <div
                              className="font-dmsans text-base font-semibold"
                              style={{
                                color: get(
                                  slice,
                                  'primary.name_color',
                                  '#212121'
                                ),
                              }}
                            >
                              {testimonial.name}
                            </div>
                            <div
                              className="text-sm"
                              style={{
                                color: get(
                                  slice,
                                  'primary.location_color',
                                  '#757575'
                                ),
                              }}
                            >
                              {testimonial.location}
                            </div>
                          </div>
                        </figcaption>
                      </figure>
                    </div>
                  ))}
                </div>
              </motion.div>
            </AnimatePresence>
          </div>
          <SliderButtons
            slice={slice}
            range={range}
            currentIndex={index}
            onClick={handleClick}
          />
        </div>
      </div>
    </section>
  );
};

export default CardSection;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Testimonials/SliderButtons.tsx

'use client';

import React from 'react';
import { twMerge } from 'tailwind-merge';

import { Content } from '@prismicio/client';

interface ISliderButtons {
  slice: Content.TestimonialsSlice;
  range: number;
  currentIndex: number;
  onClick: (index: number) => void;
}

const SliderButtons: React.FC<ISliderButtons> = ({
  slice,
  range,
  currentIndex,
  onClick,
}) => {
  const totalSlides = Math.ceil(slice.items.length / range);

  return totalSlides > 1 ? (
    <div className="mt-10 flex flex-row items-center justify-center gap-1">
      {[...Array(totalSlides)].map((_e, i) => (
        <button
          key={i}
          className={twMerge(
            'rounded-full',
            currentIndex === i * range
              ? 'bg-[#5B8AB5] w-4 h-4'
              : 'bg-gray-200 w-3.5 h-3.5 hover:bg-gray-300'
          )}
          onClick={() => onClick(i)}
        />
      ))}
    </div>
  ) : null;
};

export default SliderButtons;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/SubscribeSection/index.tsx

import Signup from '@components/signup';
import { User } from '@prisma/client';
import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `SubscribeSection`.
 */
export type SubscribeSectionProps =
  SliceComponentProps<Content.SubscribeSectionSlice>;

/**
 * Component for "SubscribeSection" Slices.
 */
const SubscribeSection = ({
  slice,
  context,
}: SubscribeSectionProps): JSX.Element => {
  const ctx = context as { user: User | null };

  if (ctx.user && ctx.user.email) {
    return <></>;
  }

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="relative isolate overflow-hidden">
        <PrismicNextImage
          field={slice.primary.background_image}
          alt=""
          className="absolute inset-0 -z-10 h-full w-full object-cover"
        />
        <div
          className="absolute inset-0 -z-10 overflow-hidden bg-[#121F30] opacity-80"
          aria-hidden="true"
        />
        <div className="mx-auto max-w-3xl py-28">
          <div className="text-center px-4">
            <p className="text-4xl font-bold text-white sm:text-5xl">
              {slice.primary.title}
            </p>
            <p className="mt-6 text-base font-medium text-white">
              {slice.primary.description}
            </p>
            <Signup
              invalid_email_text={slice.primary.invalid_email_text}
              api_endpoint={slice.primary.api_endpoint}
              label_text={slice.primary.label_text}
              input_placeholder={slice.primary.input_placeholder}
              submit_text={slice.primary.submit_text}
              submitting_text={slice.primary.submitting_text}
              submitted_text={slice.primary.submitted_text}
              showLabel={false}
              className="flex-col gap-1 mt-4"
            />
          </div>
        </div>
      </div>
    </section>
  );
};

export default SubscribeSection;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/ProductsList/index.tsx

import { ProductWithContent } from '@/app/shared/types';
import { User } from '@prisma/client';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import ProductLinksList from './components/ProductLinksList';

/**
 * Props for `ProductsList`.
 */
export type ProductsListProps = SliceComponentProps<Content.ProductsListSlice>;

/**
 * Component for "ProductsList" Slices.
 */
const ProductsList: React.FC<ProductsListProps> = async (p) => {
  const ctx = p.context as { user: User; products: ProductWithContent[] };

  return (
    <section
      data-slice-type={p.slice.slice_type}
      data-slice-variation={p.slice.variation}
      aria-labelledby="products-heading"
      className="mx-auto max-w-2xl px-4 pb-16 pt-6 sm:px-6 sm:pb-24 lg:max-w-5xl lg:px-8"
    >
      <ProductLinksList {...p} products={ctx.products} />
    </section>
  );
};

export default ProductsList;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/ProductsList/components/ProductLinksList.tsx

'use client';

import React from 'react';

import CheckboxGroup from '@/app/shared/components/form-controls/checkboxes/checkbox-group';
import RadioButtonGroup from '@/app/shared/components/form-controls/radio-group/radio-group';
import { ProductWithContent } from '@/app/shared/types';
import { formatCurrency } from '@/utils/utils';
import { Disclosure } from '@headlessui/react';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';
import { ChevronDown, ChevronUp } from '@untitled-ui/icons-react';

import { ProductsListProps } from '..';

interface IProductLinksListProps extends ProductsListProps {
  products: ProductWithContent[];
}

const priceOptions = [
  { display: 'Any Price', value: 9999999 },
  { display: 'Under $100', value: 10000 },
  { display: 'Under $200', value: 20000 },
  { display: 'Under $300', value: 30000 },
];

const allTagsKey = 'All';

const filterByPrice = (items: ProductWithContent[], priceFilter: string) => {
  if (!priceFilter.length) return items;

  const priceOption =
    priceOptions.find((option) => option.display === priceFilter)?.value ??
    9999999;

  return items.filter((item) => {
    return item.price < priceOption;
  });
};

const filterByTag = (items: ProductWithContent[], filterKeys: string[]) => {
  if (!filterKeys.length) return items;

  if (filterKeys.includes(allTagsKey)) return items;

  return items.filter((item) => {
    return item.data.tags.some((tag) => filterKeys.includes(tag.tag ?? ''));
  });
};

const ProductLinksList: React.FC<IProductLinksListProps> = ({
  slice,
  products,
}) => {
  const [typeFilter, setTypeFilter] = React.useState<string[]>([]);
  const [priceFilter, setPriceFilter] = React.useState<string>(
    priceOptions[0].display
  );
  const [filteredProducts, setFilteredProducts] =
    React.useState<ProductWithContent[]>(products);

  React.useEffect(() => {
    const filteredByPrice = filterByPrice(products, priceFilter);
    const filtered = filterByTag(filteredByPrice, typeFilter);
    setFilteredProducts(filtered);
  }, [typeFilter, priceFilter, products]);

  const handleTypeFilterChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { value } = e.target;
    setTypeFilter((prevState) => {
      if (prevState.includes(value)) {
        if (value === allTagsKey) return [];
        return prevState.filter((v) => v !== value);
      }

      if (value === allTagsKey)
        return [
          allTagsKey,
          ...slice.items.map((item) => item.filter_tag as string),
        ];
      return [...prevState, value];
    });
  };

  return (
    <>
      <div className="flex flex-col md:flex-row gap-6 items-start mb-8">
        <div className="w-full max-w-sm border border-gray-200 rounded-lg">
          <Disclosure as="div" defaultOpen>
            {({ open }) => (
              <>
                <div>
                  <Disclosure.Button className="flex w-full items-start justify-between text-left text-gray-900 px-4 py-3 sm:px-6">
                    <span className="text-lg font-semibold text-gray-900">
                      {slice.primary.type_filter_heading}
                    </span>
                    <span className="ml-6 flex h-7 items-center">
                      {open ? (
                        <ChevronUp
                          className="h-6 w-6 text-accent-500"
                          aria-hidden="true"
                          viewBox="0 0 24 24"
                        />
                      ) : (
                        <ChevronDown
                          className="h-6 w-6 text-accent-500"
                          aria-hidden="true"
                          viewBox="0 0 24 24"
                        />
                      )}
                    </span>
                  </Disclosure.Button>
                </div>
                <Disclosure.Panel
                  as="div"
                  className="border-t border-gray-200 px-4 py-6 sm:px-6"
                >
                  <div>
                    <CheckboxGroup
                      name="typeFilter"
                      value={typeFilter}
                      onChange={handleTypeFilterChange}
                      options={[
                        allTagsKey,
                        ...slice.items
                          .filter((item) => item.filter_tag != null)
                          .map((item) => item.filter_tag as string),
                      ]}
                    />
                  </div>
                </Disclosure.Panel>
              </>
            )}
          </Disclosure>
        </div>
        <div className="w-full max-w-sm border border-gray-200 rounded-lg">
          <Disclosure as="div" defaultOpen>
            {({ open }) => (
              <>
                <div>
                  <Disclosure.Button className="flex w-full items-start justify-between text-left text-gray-900 px-4 py-3 sm:px-6">
                    <span className="text-lg font-semibold text-gray-900">
                      {slice.primary.price_filter_heading}
                    </span>
                    <span className="ml-6 flex h-7 items-center">
                      {open ? (
                        <ChevronUp
                          className="h-6 w-6 text-accent-500"
                          aria-hidden="true"
                          viewBox="0 0 24 24"
                        />
                      ) : (
                        <ChevronDown
                          className="h-6 w-6 text-accent-500"
                          aria-hidden="true"
                          viewBox="0 0 24 24"
                        />
                      )}
                    </span>
                  </Disclosure.Button>
                </div>
                <Disclosure.Panel
                  as="div"
                  className="border-t border-gray-200 px-4 py-6 sm:px-6"
                >
                  <div>
                    <RadioButtonGroup
                      name="priceFilter"
                      value={priceFilter}
                      onChange={(e) => setPriceFilter(e.target.value)}
                      options={priceOptions.map((option) => option.display)}
                    />
                  </div>
                </Disclosure.Panel>
              </>
            )}
          </Disclosure>
        </div>
      </div>

      <h2 id="products-heading" className="sr-only">
        List of Products
      </h2>

      <div className="grid grid-cols-1 gap-x-6 gap-y-10 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-3 xl:gap-x-8">
        {filteredProducts.map((product) => (
          <PrismicNextLink
            key={product.uid}
            document={product}
            className="group font-dmsans"
          >
            <div className="aspect-square w-full sm:w-[300px] overflow-hidden rounded-lg bg-white">
              <PrismicNextImage
                field={product.data.thumbnail}
                className="w-full h-full object-cover object-center group-hover:opacity-75"
              />
            </div>
            <div className="p-6">
              <p className="text-base font-medium text-gray-600">
                {product.data.type}
              </p>
              <p className="mt-2 text-2xl font-medium text-gray-900">
                {product.data.name}
              </p>
              <p className="mt-2 text-lg font-semibold text-gray-900">
                {formatCurrency(product.price)}
              </p>
            </div>
          </PrismicNextLink>
        ))}
      </div>
    </>
  );
};

export default ProductLinksList;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountQuote/index.tsx

import { StarIcon } from '@heroicons/react/20/solid';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `AccountQuote`.
 */
export type AccountQuoteProps = SliceComponentProps<Content.AccountQuoteSlice>;

/**
 * Component for "AccountQuote" Slices.
 */
const AccountQuote = ({ slice }: AccountQuoteProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="px-4 "
    >
      <div className="mx-auto my-10 bg-gray-50 rounded-2xl max-w-5xl py-12 px-4">
        <figure className="mx-auto max-w-3xl flex flex-col items-center text-center">
          <p className="sr-only">5 out of 5 stars</p>
          <div className="flex gap-x-1 text-warning-300">
            <StarIcon className="h-5 w-5 flex-none" aria-hidden="true" />
            <StarIcon className="h-5 w-5 flex-none" aria-hidden="true" />
            <StarIcon className="h-5 w-5 flex-none" aria-hidden="true" />
            <StarIcon className="h-5 w-5 flex-none" aria-hidden="true" />
            <StarIcon className="h-5 w-5 flex-none" aria-hidden="true" />
          </div>
          <blockquote className="mt-4 text-2xl font-semibold text-gray-900 sm:text-4xl">
            <p>{slice.primary.quote}</p>
          </blockquote>
          <figcaption className="mt-8 flex items-center gap-x-6">
            <div className="text-base">
              <div className="font-semibold text-gray-900">
                {slice.primary.name}
              </div>
            </div>
          </figcaption>
        </figure>
      </div>
    </section>
  );
};

export default AccountQuote;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CtaSection/index.tsx

'use client';

import get from 'lodash.get';
import { tss } from 'tss-react';

import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import ButtonBanner from './variants/ButtonBanner';
import CTAGridBoxes from './variants/CTAGridBoxes';
import CTAListWithImage from './variants/CTAListWithImage';
import CTASectionWithImage from './variants/CTASectionWithImage';
import CTASectionWithVideo from './variants/CTASectionWithVideo';
import CenteredTextWithImage from './variants/CenteredTextWithImage';
import CustomPrescription from './variants/CustomPrescription';
import DefaultCTASection from './variants/DefaultCTASection';
import ImageTitleCta from './variants/ImageTitleCta';
import ImagesWithContentOverlay from './variants/ImagesWithContentOverlay';
import TwoColumnGridWithImage from './variants/TwoColumnGridWithImage';
import TwoColumnWithImage from './variants/TwoColumnWithImage';

/**
 * Props for `CtaSection`.
 */
export type CtaSectionProps = SliceComponentProps<Content.CtaSectionSlice>;

/**
 * Dynamic Styles for CTASection
 */
export const useStyles = tss
  .withParams<{ slice: Content.CtaSectionSlice }>()
  .create(({ slice }) => ({
    ctaButton: {
      backgroundColor: get(slice, 'primary.cta_button_color', 'transparent'),
      color: get(slice, 'primary.cta_button_text_color', '#ffffff'),
      '&:hover': {
        backgroundColor: get(
          slice,
          'primary.cta_button_hover_color',
          'transparent'
        ),
        color: get(slice, 'primary.cta_button_text_hover_color', 'white'),
      },
    },
    primaryCTALink: {
      color: get(slice, 'primary.primary_cta_text_color', '#ffffff'),
      '&:hover': {
        color: get(slice, 'primary.primary_cta_text_hover_color', '#ffffff'),
      },
    },
    secondaryCTALink: {
      color: get(slice, 'primary.secondary_cta_text_color', '#ffffff'),
      '&:hover': {
        color: get(slice, 'primary.secondary_cta_text_hover_color', '#ffffff'),
      },
    },
  }));

const componentMap: { [variation: string]: any } = {
  default: DefaultCTASection,
  rightAlignedVideo: CTASectionWithVideo,
  leftAlignedVideo: CTASectionWithVideo,
  rightAlignedImage: CTASectionWithImage,
  leftAlignedImage: CTASectionWithImage,
  centeredTextWithRightImage: CenteredTextWithImage,
  centeredTextWithLeftImage: CenteredTextWithImage,
  buttonBanner: ButtonBanner,
  ctaGridBoxes: CTAGridBoxes,
  imagesWithContentOverlay: ImagesWithContentOverlay,
  twoColumnGridWithImage: TwoColumnGridWithImage,
  customPrescription: CustomPrescription,
  ctaListWithImage: CTAListWithImage,
  imageTitleCta: ImageTitleCta,
  twoColumnWithImage: TwoColumnWithImage,
};

/**
 * Component for "CtaSection" Slices.
 */
const CtaSection = ({ slice }: CtaSectionProps): JSX.Element => {
  const { classes } = useStyles({ slice });

  const Component = componentMap?.[slice.variation];

  if (Component) {
    return <Component {...slice} classes={classes} />;
  }
  return <></>;
};

export default CtaSection;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CtaSection/variants/DefaultCTASection.tsx

import get from 'lodash.get';
import { twMerge } from 'tailwind-merge';

import PrismicNextLink from '@/app/shared/components/buttons/custom-prismic-link';
import { ArrowRightCircleIcon } from '@heroicons/react/24/outline';
import { Content } from '@prismicio/client';
import { PrismicRichText } from '@prismicio/react';

/**
 * Props for `DefaultCTASection`.
 */
export type DefaultCTASectionProps = {
  slice_type: string;
  slice_label: string | null;
  classes: Record<'ctaButton' | 'primaryCTALink' | 'secondaryCTALink', string>;
  id?: string;
} & Content.CtaSectionSliceDefault;

/**
 * Component for "DefaultCTASection" Slices.
 */
const DefaultCTASection = (slice: DefaultCTASectionProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div
        className="py-20 sm:py-16"
        style={{
          backgroundImage: `linear-gradient(${get(
            slice,
            'primary.background_color_start',
            '#FFFFFF'
          )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
        }}
      >
        <div className="relative isolate">
          <div className="mx-auto max-w-7xl sm:px-6 lg:px-8">
            <div className="mx-auto flex max-w-2xl flex-col gap-8 sm:gap-16 px-6 sm:p-8 lg:mx-0 lg:max-w-none lg:flex-row lg:items-center xl:gap-x-20 xl:px-20">
              <div className="w-full flex-auto">
                <h2
                  className="font-financier text-5xl font-bold tracking-tight sm:text-6xl"
                  style={{
                    color: get(slice, 'primary.title_color', '#ffffff'),
                  }}
                >
                  {slice.primary.title}
                </h2>
                <div
                  className="font-dmsans mt-4 text-lg leading-8"
                  style={{
                    color: get(slice, 'primary.content_color', '#ffffff'),
                  }}
                >
                  <PrismicRichText field={slice.primary.content} />
                </div>
                <ul
                  role="list"
                  className="mt-8 grid grid-cols-1 sm:grid-cols-[minmax(auto,_200px)_auto] gap-x-6 gap-y-3 text-base leading-7 "
                  style={{
                    color: get(slice, 'primary.content_color', '#ffffff'),
                  }}
                >
                  {slice.items.map((item) => (
                    <li key={item.name} className="flex gap-x-3 font-bold">
                      <ArrowRightCircleIcon
                        className="h-7 w-5 flex-none "
                        aria-hidden="true"
                        style={{
                          color: get(
                            slice,
                            'primary.list_icon_color',
                            '#ffffff'
                          ),
                        }}
                      />
                      {item.name}
                    </li>
                  ))}
                </ul>
              </div>

              <div
                className="rounded-[20px] text-center p-8 sm:p-14 max-w-[430px] font-dmsans"
                style={{
                  backgroundColor: get(
                    slice,
                    'primary.cta_box_color',
                    '#ffffff'
                  ),
                }}
              >
                <p
                  className="font-bold text-3xl"
                  style={{
                    color: get(slice, 'primary.cta_box_title_color', '#ffffff'),
                  }}
                >
                  {slice.primary.cta_box_title}
                </p>
                <p
                  className="mt-2 text-lg"
                  style={{
                    color: get(
                      slice,
                      'primary.cta_box_description_color',
                      '#ffffff'
                    ),
                  }}
                >
                  {slice.primary.cta_box_description}
                </p>
                <div
                  className="flex justify-center gap-1"
                  style={{
                    color: get(slice, 'primary.cta_box_price_color', '#ffffff'),
                  }}
                >
                  <p className="font-medium text-5xl">
                    {slice.primary.cta_box_price}
                  </p>
                  <p className="font-medium mt-2 text-lg">
                    {slice.primary.cta_box_price_superscript}
                  </p>
                </div>
                <PrismicNextLink
                  field={slice.primary.cta_button_link}
                  className={twMerge(
                    'mt-4 flex justify-center text-base leading-4 font-bold items-center rounded-lg py-4',
                    slice.classes.ctaButton
                  )}
                >
                  {slice.primary.cta_button_text}
                </PrismicNextLink>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default DefaultCTASection;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CtaSection/variants/CustomPrescription.tsx

import get from 'lodash.get';
import { twMerge } from 'tailwind-merge';

import PrismicNextLink from '@components/buttons/custom-prismic-link';
import NumberSpinner from '@components/number-spinner/number-spinner';
import { Content } from '@prismicio/client';
import { JSXMapSerializer, PrismicImage } from '@prismicio/react';
import { PrismicRichText } from '@prismicio/react';

/**
 * Props for `CustomPrescription`.
 */
export type CustomPrescriptionProps = {
  slice_type: string;
  slice_label: string | null;
  classes: Record<'ctaButton' | 'primaryCTALink' | 'secondaryCTALink', string>;
  id?: string;
} & Content.CtaSectionSliceCustomPrescription;

/**
 * Component for "CenteredTextWithImage" Slices.
 */
const CustomPrescription = (slice: CustomPrescriptionProps): JSX.Element => {
  const richTextComponents: JSXMapSerializer = {
    heading1: ({ children }) => (
      <p
        className="font-financier text-[40px] leading-10 md:text-6xl font-semibold mb-6"
        style={{ color: slice.primary.h1_color ?? '#FFFFFF' }}
      >
        {children}
      </p>
    ),
    heading2: ({ children }) => (
      <p
        className="font-dmsans text-2xl font-bold"
        style={{ color: slice.primary.h2_color ?? '#FFFFFF' }}
      >
        {children}
      </p>
    ),
    paragraph: ({ children }) => (
      <p
        className="font-dmsans text-lg max-w-[700px]"
        style={{ color: slice.primary.p_color ?? '#FFFFFF' }}
      >
        {children}
      </p>
    ),
  };

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div
        className="pt-14 pb-8 sm:pt-10"
        style={{
          backgroundImage: `linear-gradient(${get(
            slice,
            'primary.background_color_start',
            '#FFFFFF'
          )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
        }}
      >
        <div className="relative isolate">
          <div className="mx-auto max-w-7xl px-6 lg:px-8">
            <div className="flex flex-col jusify-center items-center text-center">
              {slice.primary.title && (
                <h2
                  className="font-financier text-[40px] leading-10 md:text-6xl font-semibold mb-6"
                  style={{
                    color: get(slice, 'primary.title_color', '#ffffff'),
                  }}
                >
                  {slice.primary.title}
                </h2>
              )}

              <div>
                <PrismicRichText
                  field={slice.primary.content}
                  components={richTextComponents}
                />
              </div>

              <div className="mt-10 max-w-none justify-center items-center flex flex-shrink-0 sm:mb-0 sm:mr-4">
                <PrismicImage
                  field={slice.primary.image}
                  className="w-full h-auto"
                  style={{
                    maxWidth: slice.primary.image.dimensions?.width,
                    maxHeight: slice.primary.image.dimensions?.height,
                  }}
                />
              </div>

              <div className="mt-10">
                <PrismicRichText
                  field={slice.primary.bottom_content}
                  components={richTextComponents}
                />
              </div>

              <div className="py-4 text-white font-dmsans text-lg">
                <span>
                  Tretinoin <NumberSpinner to={0.08} from={0.0} precision={2} />
                  %
                </span>
                {', '}
                <span>
                  Clindamycin <NumberSpinner to={1.6} from={0} precision={1} />%
                </span>
                {', '}
                <span>
                  Niacinamide <NumberSpinner to={6} from={0} />%
                </span>
                {', '}
                <span>
                  Metronidazole{' '}
                  <NumberSpinner to={1.3} from={0.0} precision={1} />%
                </span>
                {', '}
                <span>
                  Azelaic Acid <NumberSpinner to={7} from={0} />%
                </span>
              </div>

              <div className="flex flex-col sm:flex-row justify-center items-center gap-8 sm:gap-14 mt-2 mb-4">
                <PrismicNextLink
                  field={slice.primary.cta_button_link}
                  className={twMerge(
                    'mt-6 flex justify-center text-base leading-4 font-bold items-center rounded-lg py-4 px-6 text-center',
                    slice.classes.ctaButton
                  )}
                >
                  {slice.primary.cta_button_text}
                </PrismicNextLink>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default CustomPrescription;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CtaSection/variants/CTAListWithImage.tsx

'use client';

import get from 'lodash.get';
import React from 'react';

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import Modal from '@/app/shared/components/overlays/modal';
import { ArrowRightCircleIcon } from '@heroicons/react/24/outline';
import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import { JSXMapSerializer, PrismicRichText } from '@prismicio/react';

/**
 * Props for `DefaultCTASection`.
 */
export type CTAListWithImageProps = {
  slice_type: string;
  slice_label: string | null;
  classes: Record<'ctaButton' | 'primaryCTALink' | 'secondaryCTALink', string>;
  id?: string;
} & Content.CtaSectionSliceCtaListWithImage;

const modalTextComponents: JSXMapSerializer = {
  heading1: ({ children }) => (
    <p className="font-dmserif text-[#202939] text-3xl">{children}</p>
  ),
  paragraph: ({ children }) => (
    <p className="mt-4 font-dmsans text-base text-[#344054]">{children}</p>
  ),
};

const ListItem = ({
  slice,
  item,
}: {
  slice: Content.CtaSectionSliceCtaListWithImage;
  item: Content.CtaSectionSliceCtaListWithImageItem;
}) => {
  const [show, setShow] = React.useState(false);

  const handleModalClose = () => {
    setShow(false);
  };

  return (
    <>
      <li className="relative flex gap-x-3 font-medium items-start">
        <ArrowRightCircleIcon
          className="h-7 w-5 flex-none "
          aria-hidden="true"
          style={{
            color: get(slice, 'primary.list_icon_color', '#ffffff'),
          }}
        />
        <button
          className="text-left text-[15px] text-black font-dmsans"
          onClick={() => setShow(true)}
        >
          {item.name}
          <span className="absolute inset-0" />
        </button>
      </li>
      <Modal
        show={show}
        onClose={handleModalClose}
        contentRenderer={() => {
          return (
            <div className="flex flex-col items-center justify-center text-center">
              <PrismicNextImage
                field={item.modal_image}
                className="mx-aut0 h-36 w-36 rounded-full"
                alt=""
              />
              <div className="mt-6">
                <PrismicRichText
                  field={item.modal_content}
                  components={modalTextComponents}
                />
              </div>
              <CustomPrismicLink
                field={item.modal_cta}
                variant="solid-accent"
                className="my-6 w-full max-w-xs"
              >
                {item.modal_cta_text}
              </CustomPrismicLink>
            </div>
          );
        }}
      />
    </>
  );
};

/**
 * Component for "DefaultCTASection" Slices.
 */
const CTAListWithImage = (slice: CTAListWithImageProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div
        className="py-20 sm:py-16"
        style={{
          backgroundImage: `linear-gradient(${get(
            slice,
            'primary.background_color_start',
            '#FFFFFF'
          )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
        }}
      >
        <div className="relative isolate">
          <div className="mx-auto max-w-7xl sm:px-6 lg:px-8">
            <div className="mx-auto flex max-w-2xl flex-col-reverse gap-8 sm:gap-16 px-6 sm:p-8 lg:mx-0 lg:max-w-none lg:flex-row lg:items-center xl:gap-x-20 xl:px-20">
              <div className="w-full flex-auto">
                <h2
                  className="font-dmserif text-4xl"
                  style={{
                    color: get(slice, 'primary.title_color', '#ffffff'),
                  }}
                >
                  {slice.primary.title}
                </h2>
                <div
                  className="font-dmsans mt-4 text-lg"
                  style={{
                    color: get(slice, 'primary.content_color', '#ffffff'),
                  }}
                >
                  <PrismicRichText field={slice.primary.content} />
                </div>
                <CustomPrismicLink
                  field={slice.primary.cta_button_link}
                  variant="solid-accent"
                  className="my-6 px-2 max-w-[240px]"
                >
                  {slice.primary.cta_button_text}
                </CustomPrismicLink>
                <div className="font-dmsans mt-4 text-base text-[#475467]">
                  <PrismicRichText field={slice.primary.list_header} />
                </div>
                <ul
                  role="list"
                  className="mt-4 grid grid-cols-1 sm:grid-cols-[minmax(auto,_200px)_auto] gap-x-6 gap-y-3 text-base leading-7 "
                  style={{
                    color: get(slice, 'primary.content_color', '#ffffff'),
                  }}
                >
                  {slice.items.map((item) => (
                    <ListItem key={item.name} slice={slice} item={item} />
                  ))}
                </ul>
              </div>

              {/* Image Column */}
              <div className="mb-4 max-w-none flex-shrink-0 sm:mb-0 sm:mr-4 lg:w-2/5">
                <PrismicNextImage
                  field={slice.primary.image}
                  className="w-full h-auto"
                  style={{
                    maxWidth: slice.primary.image.dimensions?.width,
                    maxHeight: slice.primary.image.dimensions?.height,
                  }}
                />
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default CTAListWithImage;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CtaSection/variants/TwoColumnWithImage.tsx

import get from 'lodash.get';
import { twMerge } from 'tailwind-merge';

import CustomCTA from '@/slices/AccountCtaSection/variants/CustomCTA';
import { Content } from '@prismicio/client';
import { PrismicImage, PrismicRichText } from '@prismicio/react';

/**
 * Props for `ImageTitleCta`.
 */
export type TwoColumnWithImageProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.CtaSectionSliceTwoColumnWithImage;

const TwoColumnWithImage = (slice: TwoColumnWithImageProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      style={{
        backgroundImage: `linear-gradient(${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
      }}
    >
      <div className="max-w-6xl mx-auto">
        <div
          className={twMerge(
            'max-w-5xl mx-auto flex py-16 px-8 flex-col-reverse gap-x-10 gap-y-8 items-center md:justify-between',
            slice.primary.alignment === 'image-right'
              ? 'md:flex-row'
              : 'md:flex-row-reverse'
          )}
        >
          <div className="w-full flex-auto max-w-md text-center justify-center md:text-start md:justify-start">
            {slice.primary.header_badge_text && (
              <div className="mb-2 inline-flex items-center rounded-full bg-accent-50 px-3 py-1.5 text-xs font-semibold text-accent-700 ring-1 ring-inset ring-accent-200">
                {slice.primary.header_badge_text}
              </div>
            )}
            <h2
              className="font-dmsans text-2xl font-semibold tracking-tight sm:text-2xl"
              style={{
                color: get(slice, 'primary.title_color', '#ffffff'),
                lineHeight: '2.5rem',
              }}
            >
              {slice.primary.title}
            </h2>
            <div
              className="font-dmsans mt-2 text-lg leading-8 [&_strong]:text-black [&_strong]:text-2xl [&_strong]:-mb-4 [&_strong]:font-normal [&_strong]:block"
              style={{
                color: get(slice, 'primary.content_color', '#ffffff'),
              }}
            >
              <PrismicRichText field={slice.primary.content} />
            </div>
            {slice.primary.cta_button_text && (
              <CustomCTA
                actionType={slice.primary.cta_action}
                text={slice.primary.cta_button_text}
                link={slice.primary.cta_link}
                linkStyle={slice.primary.cta_link_style}
                className="mt-4 px-4 max-w-[320px] mx-auto md:mx-0 md:px-4"
              />
            )}
          </div>

          {/* Image Column */}
          <div
            className={twMerge(
              'mb-4 max-w-none flex-shrink-0 sm:mb-0 sm:mr-4',
              slice.primary.alignment === 'image-right' ? '' : 'md:-ml-6'
            )}
          >
            <PrismicImage
              field={slice.primary.image}
              className="w-full h-auto"
              style={{
                maxWidth: slice.primary.image.dimensions?.width,
                maxHeight: slice.primary.image.dimensions?.height,
              }}
            />
          </div>
        </div>
      </div>
    </section>
  );
};

export default TwoColumnWithImage;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CtaSection/variants/ImageTitleCta.tsx

import get from 'lodash.get';
import React from 'react';

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import CustomCTA from '@/slices/AccountCtaSection/variants/CustomCTA';
import { Content, isFilled } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';

/**
 * Props for `ImageTitleCta`.
 */
export type ImageTitleCtaProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.CtaSectionSliceImageTitleCta;

const ImageTitleCta: React.FC<ImageTitleCtaProps> = (slice) => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      style={{
        backgroundImage: `linear-gradient(91deg, ${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )} 0.54%, ${get(
          slice,
          'primary.background_color_end',
          '#FFFFFF'
        )} 99.54%)`,
      }}
    >
      <div className="max-w-6xl mx-auto">
        <div className="max-w-5xl mx-auto flex flex-col md:flex-row py-20 sm:pt-40 sm:pb-28 px-8 gap-x-16 sm:px-10 md:justify-between">
          <div className="">
            <PrismicNextImage field={slice.primary.title_image} />
            <p
              className="font-dmsans mt-4 text-xl sm:text-[28px] sm:leading-[160%] "
              style={{
                color: get(slice, 'primary.subheader_color', '#ffffff'),
              }}
            >
              {slice.primary.subheader}
            </p>
          </div>
          <div className="mt-6 flex flex-col justify-center gap-y-3 md:items-center max-w-[220px]">
            <CustomCTA
              actionType={slice.primary.cta_action}
              text={slice.primary.cta_link_text}
              link={slice.primary.cta_link}
              linkStyle={slice.primary.cta_link_style}
            />
            {isFilled.link(slice.primary.secondary_cta) && (
              <CustomPrismicLink
                field={slice.primary.secondary_cta}
                variant={
                  slice.primary.secondary_cta_link_style ?? 'solid-accent'
                }
                className="w-full"
              >
                {slice.primary.secondary_cta_text}
              </CustomPrismicLink>
            )}
            <p
              className="font-dmsans text-xs"
              style={{
                color: get(slice, 'primary.subheader_color', '#ffffff'),
              }}
            >
              {slice.primary.cta_callout}
            </p>
          </div>
        </div>
      </div>
    </section>
  );
};

export default ImageTitleCta;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CtaSection/variants/CenteredTextWithImage.tsx

import get from 'lodash.get';
import { twMerge } from 'tailwind-merge';

import PrismicNextLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicImage } from '@prismicio/react';

/**
 * Props for `CenteredTextWithImage`.
 */
export type CenteredTextWithImageProps = {
  slice_type: string;
  slice_label: string | null;
  classes: Record<'ctaButton' | 'primaryCTALink' | 'secondaryCTALink', string>;
  id?: string;
} & (
  | Content.CtaSectionSliceCenteredTextWithLeftImage
  | Content.CtaSectionSliceCenteredTextWithRightImage
);

/**
 * Component for "CenteredTextWithImage" Slices.
 */
const CenteredTextWithImage = (
  slice: CenteredTextWithImageProps
): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div
        className="pt-16 sm:pt-10"
        style={{
          backgroundImage: `linear-gradient(${get(
            slice,
            'primary.background_color_start',
            '#FFFFFF'
          )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
        }}
      >
        <div className="relative isolate">
          <div className="mx-auto max-w-7xl sm:px-6 lg:px-8">
            <div
              className={twMerge(
                'mx-auto flex max-w-2xl flex-col gap-8 sm:gap-16 px-6 lg:mx-0 lg:max-w-none lg:items-center xl:gap-x-10',
                slice.variation === 'centeredTextWithRightImage'
                  ? 'lg:flex-row'
                  : 'lg:flex-row-reverse'
              )}
            >
              <div className="w-full flex-auto justify-center text-center">
                <p
                  className="font-dmsans font-bold text-lg tracking-widest mb-6"
                  style={{
                    color: get(slice, 'primary.eyebrow_color', '#ffffff'),
                  }}
                >
                  {slice.primary.eyebrow}
                </p>
                <h2
                  className="font-dmsans text-4xl font-semibold tracking-tight sm:text-5xl mb-3"
                  style={{
                    color: get(slice, 'primary.title_color', '#ffffff'),
                    lineHeight: '3rem',
                  }}
                >
                  {slice.primary.title}
                </h2>
                <div className="flex flex-col sm:flex-row justify-center items-center gap-8 sm:gap-14 mt-8 mb-4">
                  <PrismicNextLink
                    field={slice.primary.primary_cta}
                    className={twMerge(
                      'text-lg underline underline-offset-8',
                      slice.classes.primaryCTALink
                    )}
                  >
                    {slice.primary.primary_cta_text}
                  </PrismicNextLink>
                  <PrismicNextLink
                    field={slice.primary.secondary_cta}
                    className={twMerge(
                      'text-lg underline underline-offset-8',
                      slice.classes.secondaryCTALink
                    )}
                  >
                    {slice.primary.secondary_cta_text}
                  </PrismicNextLink>
                </div>
              </div>

              {/* Image Column */}
              <div className="max-w-none justify-center items-center flex flex-shrink-0 sm:mb-0 sm:mr-4">
                <PrismicImage
                  field={slice.primary.image}
                  className="w-full h-auto"
                  style={{
                    maxWidth: slice.primary.image.dimensions?.width,
                    maxHeight: slice.primary.image.dimensions?.height,
                  }}
                />
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default CenteredTextWithImage;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CtaSection/variants/ImagesWithContentOverlay.tsx

import get from 'lodash.get';
import { twMerge } from 'tailwind-merge';

import PrismicNextLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicImage, PrismicRichText } from '@prismicio/react';

/**
 * Props for `ImagesWithContentOverlay`.
 */
export type ImagesWithContentOverlayProps = {
  slice_type: string;
  slice_label: string | null;
  classes: Record<'ctaButton' | 'primaryCTALink' | 'secondaryCTALink', string>;
  id?: string;
} & Content.CtaSectionSliceImagesWithContentOverlay;

/**
 * Component for "ImagesWithContentOverlay" Slices.
 */
const ImagesWithContentOverlay = (
  slice: ImagesWithContentOverlayProps
): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div
        className="py-0 sm:py-10"
        style={{
          backgroundImage: `linear-gradient(${get(
            slice,
            'primary.background_color_start',
            '#FFFFFF'
          )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
        }}
      >
        <div className="relative isolate">
          <div className="mx-auto max-w-7xl sm:px-6 lg:px-8">
            <div className="grid grid-cols-1 lg:grid-cols-5">
              <div
                className="flex items-center py-8 px-4 w-full col-span-2 max-h-[500px] order-2 lg:order-1"
                style={{
                  backgroundImage: `url(${slice.primary.left_image?.url})`,
                  backgroundPosition: '50%',
                  backgroundRepeat: 'no-repeat,repeat',
                  backgroundSize: 'cover',
                }}
              >
                <div className="w-full max-w-[250px] mx-auto">
                  <PrismicImage
                    field={slice.primary.content_header_image}
                    className="max-w-[150px] sm:max-w-[200px] w-full h-auto mx-auto"
                  />
                  <div
                    className="font-dmsans mt-6 text-xs"
                    style={{
                      color: get(slice, 'primary.content_color', '#ffffff'),
                    }}
                  >
                    <PrismicRichText field={slice.primary.content} />
                  </div>
                  <PrismicNextLink
                    field={slice.primary.cta_button_link}
                    className={twMerge(
                      'mt-6 flex justify-center text-base leading-4 font-bold items-center rounded-lg py-3 max-w-[240px]',
                      slice.classes.ctaButton
                    )}
                  >
                    {slice.primary.cta_button_text}
                  </PrismicNextLink>
                </div>
              </div>
              <div className="w-full col-span-1 order-1 max-h-[500px] lg:col-span-3 lg:order-2">
                <PrismicImage
                  field={slice.primary.right_image}
                  className="w-full h-full object-cover"
                />
              </div>
            </div>
            <div className="mt-4">
              <div className="text-center text-[#585858] text-xs px-4">
                <PrismicRichText field={slice.primary.closing_text} />
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default ImagesWithContentOverlay;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CtaSection/variants/CTASectionWithImage.tsx

import get from 'lodash.get';
import { twMerge } from 'tailwind-merge';

import PrismicNextLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content, isFilled } from '@prismicio/client';
import { PrismicImage, PrismicRichText } from '@prismicio/react';

/**
 * Props for `CTASectionWithImage`.
 */
export type CTASectionWithImageProps = {
  slice_type: string;
  slice_label: string | null;
  classes: Record<'ctaButton' | 'primaryCTALink' | 'secondaryCTALink', string>;
  id?: string;
} & (
  | Content.CtaSectionSliceLeftAlignedImage
  | Content.CtaSectionSliceRightAlignedImage
);

/**
 * Component for "CTASectionWithImage" Slices.
 */
const CTASectionWithImage = (slice: CTASectionWithImageProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div
        className="py-20 sm:py-16"
        style={{
          backgroundImage: `linear-gradient(${get(
            slice,
            'primary.background_color_start',
            '#FFFFFF'
          )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
        }}
      >
        <div className="relative isolate">
          <div className="mx-auto max-w-7xl sm:px-6 lg:px-8">
            <div
              className={twMerge(
                'mx-auto flex max-w-2xl flex-col gap-8 sm:gap-16 px-6 sm:p-8 lg:mx-0 lg:max-w-none lg:items-center xl:gap-x-10 xl:px-20',
                slice.variation === 'rightAlignedImage'
                  ? 'lg:flex-row'
                  : 'lg:flex-row-reverse'
              )}
            >
              <div className="w-full flex-auto">
                <p
                  className="font-dmsans text-sm tracking-widest mb-3"
                  style={{
                    color: get(slice, 'primary.eyebrow_color', '#ffffff'),
                  }}
                >
                  {slice.primary.eyebrow}
                </p>
                <h2
                  className="font-financier text-5xl  font-semibold tracking-tight sm:text-5xl mb-3"
                  style={{
                    color: get(slice, 'primary.title_color', '#ffffff'),
                    lineHeight: '2.5rem',
                  }}
                >
                  {slice.primary.title}
                </h2>
                <p
                  className="font-financier text-5xl font-semibold tracking-tight sm:text-5xl"
                  style={{
                    color: get(slice, 'primary.subtitle_color', '#ffffff'),
                    lineHeight: '2.5rem',
                  }}
                >
                  {slice.primary.subtitle}
                </p>
                <div
                  className="font-dmsans mt-6 text-lg leading-8"
                  style={{
                    color: get(slice, 'primary.content_color', '#ffffff'),
                  }}
                >
                  <PrismicRichText field={slice.primary.content} />
                </div>
                {isFilled.link(slice.primary.cta_button_link) && (
                  <PrismicNextLink
                    field={slice.primary.cta_button_link}
                    className={twMerge(
                      'mt-6 flex justify-center text-base leading-4 font-bold items-center rounded-lg py-4 max-w-[240px]',
                      slice.classes.ctaButton
                    )}
                  >
                    {slice.primary.cta_button_text}
                  </PrismicNextLink>
                )}
              </div>

              {/* Image Column */}
              <div className="mb-4 max-w-none flex-shrink-0 sm:mb-0 sm:mr-4">
                <PrismicImage
                  field={slice.primary.image}
                  className="w-full h-auto"
                  style={{
                    maxWidth: slice.primary.image.dimensions?.width,
                    maxHeight: slice.primary.image.dimensions?.height,
                  }}
                />
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default CTASectionWithImage;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CtaSection/variants/CTASectionWithVideo.tsx

import get from 'lodash.get';
import { twMerge } from 'tailwind-merge';

import PrismicNextLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicRichText } from '@prismicio/react';

/**
 * Props for `CTASectionWithVideo`.
 */
export type CTASectionWithVideoProps = {
  slice_type: string;
  slice_label: string | null;
  classes: Record<'ctaButton' | 'primaryCTALink' | 'secondaryCTALink', string>;
  id?: string;
} & (
  | Content.CtaSectionSliceRightAlignedVideo
  | Content.CtaSectionSliceLeftAlignedVideo
);

/**
 * Component for "CTASectionWithVideo" Slices.
 */
const CTASectionWithVideo = (slice: CTASectionWithVideoProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div
        className="py-20 sm:py-16"
        style={{
          backgroundImage: `linear-gradient(${get(
            slice,
            'primary.background_color_start',
            '#FFFFFF'
          )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
        }}
      >
        <div className="relative isolate">
          <div className="mx-auto max-w-7xl sm:px-6 lg:px-8">
            <div
              className={twMerge(
                'mx-auto flex max-w-2xl flex-col gap-8 sm:gap-16 px-6 sm:p-8 lg:mx-0 lg:max-w-none lg:items-center xl:gap-x-10 xl:px-20',
                slice.variation === 'rightAlignedVideo'
                  ? 'lg:flex-row'
                  : 'lg:flex-row-reverse'
              )}
            >
              <div className="w-full flex-auto">
                <p
                  className="font-dmsans text-sm tracking-widest mb-3"
                  style={{
                    color: get(slice, 'primary.eyebrow_color', '#ffffff'),
                  }}
                >
                  {slice.primary.eyebrow}
                </p>
                <h2
                  className="font-financier text-5xl  font-semibold tracking-tight sm:text-5xl mb-3"
                  style={{
                    color: get(slice, 'primary.title_color', '#ffffff'),
                    lineHeight: '2.5rem',
                  }}
                >
                  {slice.primary.title}
                </h2>
                <p
                  className="font-financier text-5xl font-semibold tracking-tight sm:text-5xl"
                  style={{
                    color: get(slice, 'primary.subtitle_color', '#ffffff'),
                    lineHeight: '2.5rem',
                  }}
                >
                  {slice.primary.subtitle}
                </p>
                <div
                  className="font-dmsans mt-6 text-lg leading-8"
                  style={{
                    color: get(slice, 'primary.content_color', '#ffffff'),
                  }}
                >
                  <PrismicRichText field={slice.primary.content} />
                </div>
                <PrismicNextLink
                  field={slice.primary.cta_button_link}
                  className={twMerge(
                    'mt-6 flex justify-center text-base leading-4 font-bold items-center rounded-lg py-4 max-w-[240px]',
                    slice.classes.ctaButton
                  )}
                >
                  {slice.primary.cta_button_text}
                </PrismicNextLink>
              </div>
              {/* Video Column */}
              <div
                className={twMerge(
                  'relative h-[350px] w-full max-w-[375px]',
                  slice.primary.include_video_frame
                    ? 'h-[350px] w-full max-w-[375px]'
                    : 'h-[500px] w-full max-w-[430px]'
                )}
              >
                {slice.primary.include_video_frame && (
                  <div
                    className={twMerge(
                      'absolute -bottom-3 right-3 lg:-bottom-5 lg:-right-5 -z-10 bg-gradient-to-bl from-[#D8F0F6] to-[#E9E7E8] rounded-4xl h-40 w-32 lg:h-60 lg:w-48',
                      slice.variation === 'rightAlignedVideo'
                        ? 'right-3 lg:-right-5'
                        : 'left-3 lg:-left-5'
                    )}
                  />
                )}
                <div className="relative h-full w-full overflow-hidden rounded-3xl sm:aspect-h-1 sm:aspect-w-2 lg:aspect-h-1 lg:aspect-w-1">
                  <video
                    className={twMerge(
                      'h-full w-full',
                      slice.primary.include_video_frame
                        ? 'object-cover object-center'
                        : ''
                    )}
                    src={get(slice, 'primary.video.url', '')}
                    autoPlay
                    controls={false}
                    playsInline
                    loop
                    muted
                  />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default CTASectionWithVideo;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CtaSection/variants/TwoColumnGridWithImage.tsx

import get from 'lodash.get';
import { twMerge } from 'tailwind-merge';

import PrismicNextLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import {
  JSXMapSerializer,
  PrismicImage,
  PrismicRichText,
} from '@prismicio/react';

/**
 * Props for `CTASectionWithImage`.
 */
export type TwoColumnGridWithImageProps = {
  slice_type: string;
  slice_label: string | null;
  classes: Record<'ctaButton' | 'primaryCTALink' | 'secondaryCTALink', string>;
  id?: string;
} & Content.CtaSectionSliceTwoColumnGridWithImage;

/**
 * Component for "CTASectionWithImage" Slices.
 */
const TwoColumnGridWithImage = (
  slice: TwoColumnGridWithImageProps
): JSX.Element => {
  const richTextComponents: JSXMapSerializer = {
    paragraph: ({ children }) => (
      <p
        className="font-dmsans text-lg text-white"
        style={{ color: slice.primary.content_color ?? '#FFFFFF' }}
      >
        {children}
      </p>
    ),
  };

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div
        className="relative border-b-[6px] my-6"
        style={{
          backgroundImage: `linear-gradient(${get(
            slice,
            'primary.background_color_start',
            '#FFFFFF'
          )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
          borderColor: get(slice, 'primary.bottom_border_color', '#FFFFFF'),
        }}
      >
        <div className="hidden overflow-hidden absolute right-0 h-full w-1/2 lg:block">
          <PrismicImage
            field={slice.primary.image}
            className="h-full w-full object-cover object-[0_0]"
            alt=""
          />
        </div>
        <div className="relative mx-auto max-w-7xl px-8 py-12">
          <div className="pl-6 pr-6 lg:w-1/2 lg:pr-12">
            <PrismicImage
              field={slice.primary.title_image}
              className="h-[51px] w-auto"
            />
            <div className="mt-6">
              <PrismicRichText
                field={slice.primary.content}
                components={richTextComponents}
              />
            </div>
            <div className="mt-8">
              <PrismicNextLink
                field={slice.primary.cta_button_link}
                className={twMerge(
                  'font-dmsans mt-6 flex justify-center text-base leading-4 font-semibold items-center rounded-lg py-4 max-w-[240px]',
                  slice.classes.ctaButton
                )}
              >
                {slice.primary.cta_button_text}
              </PrismicNextLink>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default TwoColumnGridWithImage;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CtaSection/variants/ButtonBanner.tsx

import get from 'lodash.get';
import { twMerge } from 'tailwind-merge';

import PrismicNextLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';

/**
 * Props for `ButtonBanner`.
 */
export type ButtonBannerProps = {
  slice_type: string;
  slice_label: string | null;
  classes: Record<'ctaButton' | 'primaryCTALink' | 'secondaryCTALink', string>;
  id?: string;
} & Content.CtaSectionSliceButtonBanner;

/**
 * Component for "ButtonBanner" Slices.
 */
const ButtonBanner = (slice: ButtonBannerProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div
        className="pt-6 pb-12 flex justify-center items-center"
        style={{
          backgroundImage: `linear-gradient(${get(
            slice,
            'primary.background_color_start',
            '#FFFFFF'
          )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
        }}
      >
        <PrismicNextLink
          field={slice.primary.cta_button_link}
          className={twMerge(
            'flex justify-center text-base leading-4 font-bold items-center rounded-lg py-4 max-w-[234px] w-full',
            slice.classes.ctaButton
          )}
        >
          {slice.primary.cta_button_text}
        </PrismicNextLink>
      </div>
    </section>
  );
};

export default ButtonBanner;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CtaSection/variants/CTAGridBoxes.tsx

import get from 'lodash.get';
import { twMerge } from 'tailwind-merge';
import { tss } from 'tss-react';

import PrismicNextLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicRichText } from '@prismicio/react';

/**
 * Props for `CTAGridBoxes`.
 */
export type CTAGridBoxesProps = {
  slice_type: string;
  slice_label: string | null;
  classes: Record<'ctaButton' | 'primaryCTALink' | 'secondaryCTALink', string>;
  id?: string;
} & Content.CtaSectionSliceCtaGridBoxes;

/**
 * Dynamic Styles for CTASection
 */
export const useStyles = tss
  .withParams<{ p: { cta: Content.CtaSectionSliceCtaGridBoxesItem } }>()
  .create(({ p }) => ({
    ctaButton: {
      backgroundColor: get(p, 'cta.cta_button_color', 'transparent'),
      color: get(p, 'cta.cta_button_text_color', '#ffffff'),
      '&:hover': {
        backgroundColor: get(p, 'cta.cta_button_hover_color', 'transparent'),
        color: get(p, 'cta.cta_button_text_hover_color', 'white'),
      },
    },
  }));

const CTABox = (p: { cta: Content.CtaSectionSliceCtaGridBoxesItem }) => {
  const { classes } = useStyles({ p });

  return (
    <li
      className="col-span-1 flex flex-col divide-y rounded-2xl text-center shadow-2xl max-w-[435px]"
      style={{
        backgroundColor: get(p, 'cta.cta_box_color', '#FFFFFF'),
      }}
    >
      <div className="flex flex-1 flex-col p-8">
        <div
          className="mt-3 font-dmsans text-3xl font-bold"
          style={{ color: get(p, 'cta.title_color', '#FFFFFF') }}
        >
          {p.cta.title}
        </div>
        <div className="mt-3 flex flex-col gap-4 items-center">
          <div
            className="font-dmsans text-lg"
            style={{ color: get(p, 'cta.description_color', '#FFFFFF') }}
          >
            <PrismicRichText field={p.cta.description} />
          </div>
          <PrismicNextLink
            field={p.cta.cta_button_link}
            className={twMerge(
              'flex justify-center text-base leading-4 font-bold items-center rounded-lg py-4 max-w-[234px] w-full',
              classes.ctaButton
            )}
          >
            {p.cta.cta_button_text}
          </PrismicNextLink>
        </div>
      </div>
    </li>
  );
};

/**
 * Component for "CTAGridBoxes" Slices.
 */
const CTAGridBoxes = (slice: CTAGridBoxesProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div
        className="pb-20 pt-10 sm:pb-16"
        style={{
          backgroundImage: `linear-gradient(${get(
            slice,
            'primary.background_color_start',
            '#FFFFFF'
          )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
        }}
      >
        <div className="mx-auto max-w-7xl px-6 lg:px-44 xl:px-44">
          <ul
            role="list"
            className="grid grid-cols-1 justify-items-center gap-8 sm:grid-cols-2 sm:gap-4 md:gap-8 lg:gap-16 "
          >
            {slice.items.map((cta) => (
              <CTABox key={cta.title} cta={cta} />
            ))}
          </ul>
        </div>
      </div>
    </section>
  );
};

export default CTAGridBoxes;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Incentives/index.tsx

import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import DefaultIncentives from './variants/DefaultIncentives';
import ListWithIcons from './variants/ListWithIcons';

/**
 * Props for `Incentives`.
 */
export type IncentivesProps = SliceComponentProps<Content.IncentivesSlice>;

/**
 * Component for "Incentives" Slices.
 */
const Incentives = (p: IncentivesProps): JSX.Element => {
  const { slice } = p;

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div
        className="bg-gray-50 px-6 py-16 sm:p-16 "
        style={{ backgroundColor: slice.primary.background_color ?? '#F4F4F4' }}
      >
        <div className="max-w-xl lg:max-w-[1200px] mx-auto">
          {slice?.variation === 'listWithIcons' ? (
            <ListWithIcons slice={slice} context={p.context} />
          ) : (
            <DefaultIncentives slice={slice} context={p.context} />
          )}
        </div>
      </div>
    </section>
  );
};

export default Incentives;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Incentives/variants/ListWithIcons.tsx

import Image from 'next/image';

import { RichText } from '@/app/shared/components/text/rich-text';
import { Content } from '@prismicio/client';

interface IListWithIconsProps {
  slice: Content.IncentivesSliceListWithIcons;
  context: unknown;
}

/**
 * Component for "ListWithIcons" variation.
 */
const ListWithIcons = ({ slice }: IListWithIconsProps): JSX.Element => {
  return (
    <div className="mx-auto mt-6 grid max-w-sm grid-cols-1 gap-x-8 gap-y-10 sm:max-w-none lg:grid-cols-3">
      {slice.items.map((incentive) => (
        <div
          key={incentive.name}
          className="text-center sm:flex sm:text-left lg:block lg:text-center"
        >
          <div className="sm:flex-shrink-0">
            <div className="flow-root">
              {incentive.image.url && (
                <Image
                  className="mx-auto h-12 w-12"
                  src={incentive.image.url}
                  alt=""
                  width={incentive.image.dimensions?.width}
                  height={incentive.image.dimensions?.height}
                />
              )}
            </div>
          </div>
          <div className="mt-3 sm:ml-6 sm:mt-0 lg:ml-0 lg:mt-4">
            <p className="text-xl font-dmsans font-semibold text-gray-900">
              {incentive.name}
            </p>
            <RichText field={incentive.description} className="mt-2" />
          </div>
        </div>
      ))}
    </div>
  );
};

export default ListWithIcons;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Incentives/variants/DefaultIncentives.tsx

import Image from 'next/image';

import { Content } from '@prismicio/client';

interface IDefaultIncentivesProps {
  slice: Content.IncentivesSliceDefault;
  context: unknown;
}

/**
 * Component for "DefaultIncentives" variation.
 */
const DefaultIncentives = ({ slice }: IDefaultIncentivesProps): JSX.Element => {
  return (
    <>
      <div className="text-center">
        <h2
          className="font-financier text-6xl font-bold tracking-tight"
          style={{ color: slice.primary.title_color ?? '#263A61' }}
        >
          {slice.primary.title}
        </h2>
      </div>
      <div className="mx-auto mt-12 grid max-w-sm grid-cols-1 gap-x-8 gap-y-10 sm:max-w-none lg:grid-cols-3">
        {slice.items.map((incentive) => (
          <div
            key={incentive.name}
            className="text-center sm:flex sm:text-left lg:block lg:text-center"
          >
            <div className="sm:flex-shrink-0">
              <div className="flow-root">
                {incentive.image.url && (
                  <Image
                    className="mx-auto h-full w-full max-w-[270px] max-h-[220px]"
                    src={incentive.image.url}
                    alt=""
                    width={incentive.image.dimensions?.width}
                    height={incentive.image.dimensions?.height}
                  />
                )}
              </div>
            </div>
            <div className="mt-3 sm:ml-6 sm:mt-0 lg:ml-0 lg:mt-6">
              <h3
                className="text-2xl font-dmsans font-bold"
                style={{ color: slice.primary.name_color ?? '#263A61' }}
              >
                {incentive.name}
              </h3>
              <p
                className="mt-2 text-sm leading-6 font-dmsans"
                style={{
                  color: slice.primary.description_color ?? '#585858',
                }}
              >
                {incentive.description}
              </p>
            </div>
          </div>
        ))}
      </div>
    </>
  );
};

export default DefaultIncentives;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CenteredIconBulletList/index.tsx

import get from 'lodash.get';

import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `CenteredIconBulletList`.
 */
export type CenteredIconBulletListProps =
  SliceComponentProps<Content.CenteredIconBulletListSlice>;

/**
 * Component for "CenteredIconBulletList" Slices.
 */
const CenteredIconBulletList = ({
  slice,
}: CenteredIconBulletListProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      style={{
        backgroundImage: `linear-gradient(180deg, ${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )} 0%, ${get(slice, 'primary.background_color_end', '#FFFFFF')} 100%)`,
      }}
    >
      <div className="max-w-6xl mx-auto">
        <div className="max-w-5xl mx-auto px-6 pt-14 pb-20">
          <div className="mx-auto bg-[#ABEBD9] w-full max-w-[122px] h-1" />
          <h2 className="font-dmsans mt-6 text-2xl sm:text-4xl font-semibold tracking-tight text-center text-gray-900">
            {slice.primary.title}
          </h2>
          <div className="mt-16 flex flex-row flex-wrap gap-x-8 gap-y-12 item-center justify-center font-dmsans">
            {slice.items.map((item) => (
              <div
                key={item.header}
                className="flex flex-col items-center max-w-[289px] text-center"
              >
                <PrismicNextImage
                  className=""
                  field={item.icon}
                  alt=""
                  width={48}
                  height={48}
                  aria-hidden="true"
                />
                <h2 className="mt-3 text-gray-900 text-lg sm:text-xl font-semibold">
                  {item.header}
                </h2>
                <p className="mt-1 text-base text-gray-600">{item.subheader}</p>
              </div>
            ))}
          </div>
        </div>
      </div>
    </section>
  );
};

export default CenteredIconBulletList;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/StartPopover/index.tsx

import React from 'react';

import FixedInfoPopover from '@/app/shared/components/overlays/fixed-info-popover/fixed-info-popover';
import { AccountPageContext } from '@/app/shared/types';
import { Content, isFilled } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `StartPopover`.
 */
export type StartPopoverProps = SliceComponentProps<
  Content.StartPopoverSlice,
  AccountPageContext
>;

/**
 * Component for "StartPopover" Slices.
 */
const StartPopover = ({ slice, context }: StartPopoverProps): JSX.Element => {
  const { user, partner } = context;

  const content = React.useMemo(
    () => getContent(slice.items, partner),
    [slice.items, partner]
  );

  if (!content) return <></>;

  return content.familyAllowed ? (
    <FixedInfoPopover
      user={user}
      mediaType={content.mediaType}
      image={content.image}
      videoLink={content.videoLink}
      title={content.header}
      content={content.content}
      primaryCtaLink={content.selfCTALink}
      primaryCtaText={content.selfCTAText}
      primaryCtaType="Button"
      primaryCtaStyle="outline-gray"
      secondaryCtaLink={content.familyCTALink}
      secondaryCtaText={content.familySelectorLabel}
      secondaryCtaType="Dependent Dropdown"
      secondaryCtaStyle="outline-gray"
    />
  ) : (
    <FixedInfoPopover
      user={user}
      mediaType={content.mediaType}
      image={content.image}
      videoLink={content.videoLink}
      title={content.header}
      content={content.content}
      primaryCtaLink={content.selfCTALink}
      primaryCtaText={content.selfCTAText}
      primaryCtaType="Button"
      primaryCtaStyle="outline-gray"
    />
  );
};

const mergeDefaultAndEmployerContent = (
  defaultContent: Content.StartPopoverSliceDefaultItem,
  employerContent?: Content.StartPopoverSliceDefaultItem
) => {
  const defaultMediaType = isFilled.image(defaultContent.image)
    ? 'image'
    : 'video';
  if (!employerContent) {
    return {
      mediaType: defaultMediaType,
      image: defaultContent.image,
      videoLink: defaultContent.video_link,
      header: defaultContent.header,
      content: defaultContent.content,
      selfCTAText: defaultContent.self_cta_text,
      selfCTALink: defaultContent.self_cta_link,
      familySelectorLabel: defaultContent.family_selector_label,
      familyCTALink: defaultContent.family_cta_link,
    };
  }

  let employerMediaType = defaultMediaType;

  if (
    isFilled.image(employerContent.image) ||
    isFilled.keyText(employerContent.video_link)
  ) {
    employerMediaType = isFilled.image(employerContent.image)
      ? 'image'
      : 'video';
  }

  // Employer custom content should override default content
  return {
    mediaType: employerMediaType,
    image: isFilled.image(employerContent.image)
      ? employerContent.image
      : defaultContent.image,
    videoLink: isFilled.keyText(employerContent.video_link)
      ? employerContent.video_link
      : defaultContent.video_link,
    header: isFilled.keyText(employerContent.header)
      ? employerContent.header
      : defaultContent.header,
    content: isFilled.richText(employerContent.content)
      ? employerContent.content
      : defaultContent.content,
    selfCTAText: isFilled.keyText(employerContent.self_cta_text)
      ? employerContent.self_cta_text
      : defaultContent.self_cta_text,
    selfCTALink: isFilled.link(employerContent.self_cta_link)
      ? employerContent.self_cta_link
      : defaultContent.self_cta_link,
    familySelectorLabel: isFilled.keyText(employerContent.family_selector_label)
      ? employerContent.family_selector_label
      : defaultContent.family_selector_label,
    familyCTALink: isFilled.link(employerContent.family_cta_link)
      ? employerContent.family_cta_link
      : defaultContent.family_cta_link,
  };
};

const getContent = (
  items: Content.StartPopoverSliceDefaultItem[],
  partner?: AccountPageContext['partner']
) => {
  const familyDisallowed =
    partner &&
    partner.allowFamilyMembers != null &&
    !partner.allowFamilyMembers;

  const defaultContentType = familyDisallowed
    ? 'Default Family Disallowed'
    : 'Default';

  const defaultContent = items.find(
    (item) => item.content_type === defaultContentType
  );

  const employerContent = items.find(
    (item) => item.employer_id === partner?.partnerId
  );

  if (!defaultContent) return null;

  const mergedContent = mergeDefaultAndEmployerContent(
    defaultContent,
    employerContent
  );

  if (familyDisallowed) {
    return {
      ...mergedContent,
      familyAllowed: false,
    };
  }

  return { ...mergedContent, familyAllowed: true };
};

export default StartPopover;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/VerticalTimeline/index.tsx

import get from 'lodash.get';

import { Content } from '@prismicio/client';
import {
  PrismicImage,
  PrismicRichText,
  SliceComponentProps,
} from '@prismicio/react';

/**
 * Props for `VerticalTimeline`.
 */
export type VerticalTimelineProps =
  SliceComponentProps<Content.VerticalTimelineSlice>;

/**
 * Component for "VerticalTimeline" Slices.
 */
const VerticalTimeline = ({ slice }: VerticalTimelineProps): JSX.Element => {
  const [topImage, middleImage, bottomImage] = slice.items;

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      style={{
        backgroundImage: `linear-gradient(${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
      }}
    >
      <div className="py-16 sm:py-20">
        <div className="font-dmsans mx-auto max-w-5xl px-6 lg:px-8 flex flex-col gap-6 md:gap-0">
          <div className="mx-auto mb-10 max-w-xl text-center">
            <p
              className="mt-2 text-3xl font-semibold tracking-tight"
              style={{ color: get(slice, 'primary.title_color', '#263A61') }}
            >
              {slice.primary.title}
            </p>
          </div>

          {/* Top Image */}
          <div className="flex justify-start gap-4 items-start md:justify-end md:gap-3 md:ml-auto flex-row">
            <div className="mb-4 flex-shrink-0 md:mb-0 md:mr-4">
              <PrismicImage
                field={topImage.image}
                width={topImage.image.dimensions?.width}
                height={topImage.image.dimensions?.height}
                className="hidden md:block"
              />
              <PrismicImage
                field={topImage.small_image}
                className="block md:hidden max-w-[120px] w-full h-auto"
              />
            </div>
            <div className="mt-0 md:mt-14">
              <h4
                className="text-lg font-medium"
                style={{
                  color: get(slice, 'primary.heading_color', '#212121'),
                }}
              >
                {topImage.heading}
              </h4>
              <div
                className="mt-1 text-base"
                style={{
                  color: get(slice, 'primary.description_color', '#757575'),
                }}
              >
                <PrismicRichText field={topImage.description} />
              </div>
            </div>
          </div>

          {/* Middle Image */}
          <div className="mt-2 flex justify-start gap-4 items-start md:justify-end md:gap-3 flex-row md:mr-auto md:flex-row-reverse lg:-mt-6">
            <div className="mb-4 mr-0 flex-shrink-0 md:mb-0 md:mr-4">
              <PrismicImage
                field={middleImage.image}
                width={middleImage.image.dimensions?.width}
                height={middleImage.image.dimensions?.height}
                className="hidden md:block"
              />
              <PrismicImage
                field={middleImage.small_image}
                className="block md:hidden max-w-[120px] w-full h-auto"
              />
            </div>
            <div className="mt-0 md:mt-16">
              <h4
                className="text-lg font-medium"
                style={{
                  color: get(slice, 'primary.heading_color', '#212121'),
                }}
              >
                {middleImage.heading}
              </h4>
              <div
                className="mt-1 mr-0 text-base md:mr-4"
                style={{
                  color: get(slice, 'primary.description_color', '#757575'),
                }}
              >
                <PrismicRichText field={middleImage.description} />
              </div>
            </div>
          </div>

          {/* Bottom Image */}
          <div className="mt-2 flex justify-start gap-4 items-start md:justify-end md:gap-3 md:ml-auto flex-row lg:-mt-6">
            <div className="mb-4 flex-shrink-0 md:mb-0 md:mr-4">
              <PrismicImage
                field={bottomImage.image}
                width={bottomImage.image.dimensions?.width}
                height={bottomImage.image.dimensions?.height}
                className="hidden md:flex"
              />
              <PrismicImage
                field={bottomImage.small_image}
                className="flex md:hidden max-w-[120px] w-full h-auto"
              />
            </div>
            <div className="mt-0 md:mt-8">
              <h4
                className="text-lg font-medium"
                style={{
                  color: get(slice, 'primary.heading_color', '#212121'),
                }}
              >
                {bottomImage.heading}
              </h4>
              <div
                className="mt-1 text-base"
                style={{
                  color: get(slice, 'primary.description_color', '#757575'),
                }}
              >
                <PrismicRichText field={bottomImage.description} />
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default VerticalTimeline;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CenteredProductCards/index.tsx

import get from 'lodash.get';

import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import { SliceComponentProps } from '@prismicio/react';

import CustomCTA from '../AccountCtaSection/variants/CustomCTA';

/**
 * Props for `CenteredProductCards`.
 */
export type CenteredProductCardsProps =
  SliceComponentProps<Content.CenteredProductCardsSlice>;

/**
 * Component for "CenteredProductCards" Slices.
 */
const CenteredProductCards = ({
  slice,
}: CenteredProductCardsProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      style={{
        backgroundImage: `linear-gradient(180deg, ${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )} 0%, ${get(
          slice,
          'primary.background_color_end',
          '#FFFFFF'
        )} 123.83%)`,
      }}
    >
      <div className="max-w-6xl mx-auto">
        <div className="max-w-4xl mx-auto pt-8 px-8 pb-24">
          <div className="relative">
            <div
              className="absolute inset-0 flex items-center"
              aria-hidden="true"
            >
              <div className="w-full border-t border-gray-200" />
            </div>
            <div className="relative flex justify-center">
              <span
                className="font-dmsans px-3 text-xl sm:text-2xl font-semibold leading-6 text-black"
                style={{
                  color: get(slice, 'primary.divider_color', '#000000'),
                  backgroundColor: get(
                    slice,
                    'primary.background_color_start',
                    '#FFFFFF'
                  ),
                }}
              >
                {slice.primary.divider_text}
              </span>
            </div>
          </div>
          <div className="mx-auto justify-items-center grid max-w-2xl grid-cols-1 items-start gap-x-8 gap-y-16 pt-14 lg:mx-0 lg:max-w-none lg:grid-cols-2">
            {slice.items.map((card, index) => (
              <div
                key={`${card.header_text}-${index}`}
                className="w-full h-full flex max-w-lg flex-col items-start justify-between border border-gray-200 rounded-lg"
                style={{
                  boxShadow:
                    '0px 27.911px 55.822px -13.956px rgba(16, 24, 40, 0.18)',
                }}
              >
                <div className="flex items-center justify-center bg-black w-full rounded-tl-lg rounded-tr-lg">
                  <p className="font-dmsans text-md font-medium text-white py-3">
                    {card.header_text}
                  </p>
                </div>
                <div
                  className="rounded-bl-lg rounded-br-lg w-full flex flex-col h-full"
                  style={{
                    background:
                      'linear-gradient(180deg, rgba(255, 255, 255, 0.40) 37.7%, rgba(214, 235, 229, 0.40) 92.21%), #FFF',
                  }}
                >
                  <div className="group relative py-8 px-12 flex-1">
                    <p className="font-dmsans text-lg text-accent-950 tracking-[2.5px]">
                      {card.eyebrow}
                    </p>
                    <PrismicNextImage
                      field={card.title_image}
                      className="-ml-1"
                      width={231}
                      height={21}
                    />
                    <p className="mt-5 text-lg font-medium text-gray-600 font-dmsans">
                      {card.description}
                    </p>
                    <p className="text-sm text-gray-600 font-dmsans">
                      {card.description_subtext}
                    </p>
                    <div className="mt-6">
                      <p className="block sm:inline font-dmsans font-medium text-4xl text-black">
                        {card.price}
                        <span className="text-base">{card.price_units}</span>
                      </p>
                      <span className="sm:ml-3 font-dmsans text-base text-gray-600">
                        {card.price_callout}
                      </span>
                    </div>
                  </div>
                  {slice.primary.show_card_footers && (
                    <div className="flex items-center py-4 border-t border-gray-200 justify-center bg-transparent w-full">
                      <CustomCTA
                        actionType={card.cta_action}
                        text={card.cta_link_text}
                        link={card.cta_link}
                        linkStyle={card.cta_link_style}
                      />
                    </div>
                  )}
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </section>
  );
};

export default CenteredProductCards;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/InfoPopover/index.tsx

import FixedInfoPopover from '@/app/shared/components/overlays/fixed-info-popover/fixed-info-popover';
import { AccountPageContext } from '@/app/shared/types';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `InfoPopover`.
 */
export type InfoPopoverProps = SliceComponentProps<
  Content.InfoPopoverSlice,
  AccountPageContext
>;

/**
 * Component for "InfoPopover" Slices.
 */
const InfoPopover = ({ slice, context }: InfoPopoverProps): JSX.Element => {
  const { user } = context;
  return (
    <FixedInfoPopover
      user={user}
      image={slice.primary.image}
      title={slice.primary.title}
      content={slice.primary.content}
      primaryCtaLink={slice.primary.primary_cta_link}
      primaryCtaText={slice.primary.primary_cta_text}
      primaryCtaType={slice.primary.primary_cta_type}
      primaryCtaStyle={slice.primary.primary_cta_style}
      secondaryCtaLink={slice.primary.secondary_cta_link}
      secondaryCtaText={slice.primary.secondary_cta_text}
      secondaryCtaType={slice.primary.secondary_cta_type}
      secondaryCtaStyle={slice.primary.secondary_cta_style}
    />
  );
};

export default InfoPopover;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/OrderConfirmation/index.tsx

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { RichText } from '@/app/shared/components/text/rich-text';
import { isUserLoggedIn } from '@/utils/helpers/helpers';
import { User } from '@prisma/client';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `OrderConfirmation`.
 */
export type OrderConfirmationProps =
  SliceComponentProps<Content.OrderConfirmationSlice>;

/**
 * Component for "OrderConfirmation" Slices.
 */
const OrderConfirmation = ({
  slice,
  context,
}: OrderConfirmationProps): JSX.Element => {
  const { user } = context as { user: User };

  const isLoggedIn = isUserLoggedIn(user);

  const content = {
    eyebrow: slice.primary.unauth_eyebrow,
    title: slice.primary.unauth_title,
    description: slice.primary.unauth_description,
    primaryCTA: slice.primary.unauth_primary_cta,
    primaryCTAText: slice.primary.unauth_primary_cta_text,
    secondaryCTA: slice.primary.unauth_secondary_cta,
    secondaryCTAText: slice.primary.unauth_secondary_cta_text,
  };

  if (isLoggedIn) {
    content.eyebrow = slice.primary.auth_eyebrow;
    content.title = slice.primary.auth_title;
    content.description = slice.primary.auth_description;
    content.primaryCTA = slice.primary.auth_primary_cta;
    content.primaryCTAText = slice.primary.auth_primary_cta_text;
    content.secondaryCTA = slice.primary.auth_secondary_cta;
    content.secondaryCTAText = slice.primary.auth_secondary_cta_text;
  }

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="font-dmsans bg-white px-4 pb-24 pt-16 sm:px-6 sm:pt-24 lg:px-8 lg:py-32"
    >
      <div className="mx-auto max-w-3xl">
        <div className="max-w-xl">
          <h1 className="text-base font-medium text-accent-700">
            {content.eyebrow}
          </h1>
          <p className="mt-2 text-4xl font-bold tracking-tight">
            {content.title}
          </p>
          <RichText
            className="mt-2 text-base text-gray-500"
            field={content.description}
          />

          <div className="mt-6 flex flex-col sm:flex-row gap-3">
            <CustomPrismicLink
              variant="solid-accent"
              field={content.primaryCTA}
            >
              {content.primaryCTAText}
            </CustomPrismicLink>
            {content.secondaryCTAText && (
              <CustomPrismicLink
                variant="outline-gray"
                field={content.secondaryCTA}
              >
                {content.secondaryCTAText}
              </CustomPrismicLink>
            )}
          </div>
        </div>
      </div>
    </section>
  );
};

export default OrderConfirmation;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/UserOverview/index.tsx

import { notFound } from 'next/navigation';
import { AccountNextStepsSectionDocument, Simplify } from 'prismicio-types';
import React from 'react';

import { AccountHomeContext, CaseInclude } from '@/app/shared/types';
import { createClient } from '@/prismicio';
import { UserStatus } from '@/utils/enums';
import { getUserStatus } from '@/utils/get-user-state';
import { PrismicCustomType } from '@/utils/prismic/enums';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';
import { FilledContentRelationshipField } from '@prismicio/types';

import TwoColumnLayout from './components/TwoColumnLayout';

/**
 * Props for `UserOverview`.
 */
export type UserOverviewProps = SliceComponentProps<
  Content.UserOverviewSlice,
  AccountHomeContext
>;

export type ColumnProps =
  Simplify<Content.AccountNextStepsSectionDocumentData> & {
    context: AccountHomeContext;
    selectedCase?: CaseInclude | null;
    userStatus: UserStatus;
    hasConcierge?: boolean;
  };

/**
 * Component for "UserOverview" Slices.
 */
const UserOverview = async (p: UserOverviewProps): Promise<JSX.Element> => {
  const { slice, context } = p;

  const contentLink = slice.primary
    .content_link as FilledContentRelationshipField;

  if (!contentLink.uid) {
    return notFound();
  }

  const [content, userStatus] = await Promise.all([
    getContentRelation(contentLink.uid),
    getUserStatus(context?.user),
  ]);

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <TwoColumnLayout
        {...content.data}
        context={p.context}
        userStatus={userStatus}
        hasConcierge={context.user?.hasConcierge}
      />
    </section>
  );
};

const getContentRelation = async (uid: string) => {
  const client = createClient();
  return (await client
    .getByUID(PrismicCustomType.ACCOUNT_NEXT_STEPS, uid)
    .catch(() => notFound())) as AccountNextStepsSectionDocument;
};

export default UserOverview;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/UserOverview/components/TwoColumnLayout.tsx

'use client';

import { useRouter } from 'next/navigation';
import React from 'react';
import { useState, useEffect } from 'react';

import CasePicker from '@/app/shared/components/case-picker/case-picker';
import { CaseInclude } from '@/app/shared/types';
import { getDefaultCase } from '@/utils/utils';
import ButtonSolid from '@components/buttons/button-solid';

import { ColumnProps } from '..';
import Alert from './Alert';
import BasicCTA from './BasicCTA';
import ConciergeCTA from './ConciergeCTA';
import NextSteps from './NextSteps';
import Video from './Video';

const ColumnTwo = (p: ColumnProps): JSX.Element => {
  const { context } = p;

  const hasCases = context?.cases && context.cases.length > 0;

  if (!hasCases) {
    return <Video {...p} />;
  }

  if (p.hasConcierge) {
    return <BasicCTA {...p} />;
  }

  return <ConciergeCTA {...p} />;
};

const TwoColumnLayout = (p: ColumnProps): JSX.Element => {
  const { context } = p;
  const router = useRouter();

  const [selectedCase, setSelectedCase] = useState<CaseInclude | null>(null);

  const handleCaseChange = (newCase: CaseInclude) => {
    setSelectedCase(newCase);
  };

  useEffect(() => {
    const defaultCase = getDefaultCase<CaseInclude>(context?.cases);
    if (defaultCase) {
      setSelectedCase(defaultCase);
    }
  }, [context?.cases]);

  const hasCases = context?.cases && context.cases.length > 0;

  return (
    <>
      {hasCases && selectedCase !== null && (
        <div className="flex flex-col sm:flex-row items-end lg:items-center py-5 px-10 gap-4 border-b border-gray-200 max-w-none 2xl:max-w-7xl ">
          <div className="w-full sm:w-1/2">
            <CasePicker
              cases={context?.cases}
              currentCase={selectedCase}
              onCaseChange={handleCaseChange}
            />
          </div>
          <div className="w-full sm:w-1/2 flex justify-end">
            <ButtonSolid
              variant="accent"
              size="lg"
              className="py-2 px-7 w-full sm:w-auto"
              onClick={() => {
                router.push('/account/start');
              }}
            >
              New Consultation
            </ButtonSolid>
          </div>
        </div>
      )}
      <div className="max-w-5xl mx-auto lg:mx-0">
        <Alert {...p} />
        <div className="mx-3 my-2 sm:mx-5 md:grid md:grid-cols-2">
          <NextSteps {...p} selectedCase={selectedCase} />
          <ColumnTwo {...p} selectedCase={selectedCase} />
        </div>
      </div>
    </>
  );
};

export default TwoColumnLayout;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/UserOverview/components/BasicCTA.tsx

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { PrismicRichText } from '@prismicio/react';

import { ColumnProps } from '..';

/**
 * Component for "BasicCTA".
 */
const BasicCTA = (content: ColumnProps): JSX.Element => {
  return (
    <div className="p-6">
      <p className="font-dmsans text-accent-700 font-medium text-sm mb-3">
        {content.default_cta_eyebrow}
      </p>
      <h2 className="font-financier text-3xl font-semibold tracking-tight text-accent-950 sm:text-4xl mb-3">
        {content.default_cta_title}
      </h2>
      <div className="font-dmsans text-gray-600 text-lg">
        <PrismicRichText field={content.default_cta_content} />
      </div>
      <div className="mt-8 flex items-center gap-x-6">
        <CustomPrismicLink
          field={content.default_cta_link}
          className="border border-gray-300 font-dmsans py-2 px-4 bg-white rounded-lg text-base text-gray-700 font-semibold hover:bg-gray-50 transition duration-150 ease-in-out"
        >
          {content.default_cta_link_text}
        </CustomPrismicLink>
      </div>
    </div>
  );
};

export default BasicCTA;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/UserOverview/components/Toolbar.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import ButtonBase from '@/app/shared/components/buttons/button-base';
import FlyoutMenu, {
  IMenuItem,
} from '@components/overlays/flyout-menu/flyout-menu';
import { Menu, Transition } from '@headlessui/react';
import { Download02, Eye, FilterLines } from '@untitled-ui/icons-react';

import { ColumnProps } from '..';
import Alert from './Alert';

/**
 * Component for "Toolbar".
 */
const Toolbar = (
  p: ColumnProps & {
    selectedCase: any;
    handleCaseSelect: (item: IMenuItem) => void;
  }
): JSX.Element => {
  const { context, selectedCase, handleCaseSelect, ...content } = p;
  const ctx = context as any;

  const caseItems = React.useMemo(
    () =>
      ctx.cases.map((item: any) => ({
        id: item.id,
        name: item.complaint,
      })),
    [ctx.cases]
  );

  const handleView = () => {
    //TODO: View Consultation Report
  };

  const handleDownload = () => {
    //TODO: Download Consultation Report
  };

  const handlePrint = () => {
    //TODO: Print Consultation Report
  };

  return (
    <div className="max-w-none lg:max-w-5xl lg:pr-5">
      <div className="flex flex-row items-center border-b justify-between md:justify-start border-gray-200 py-4 pl-3 md:pl-10 pr-3">
        <div className="flex flex-row gap-2 items-center flex-1 md:flex-initial">
          <p className="hidden md:block font-dmsans text-lg font-medium text-gray-900 flex-shrink-0">
            {content.toolbar_title}
          </p>
          <div className="w-full md:min-w-[260px]">
            <FlyoutMenu
              items={caseItems}
              value={selectedCase?.complaint}
              onChange={handleCaseSelect}
              selectClassName="w-full rounded-lg border border-gray-300 w-full h-11 text-base font-medium text-gray-900"
              panelClassName="left-0 translate-x-0 mt-4 p-0"
            />
          </div>
        </div>

        <div>
          {/* Mobile */}
          <Menu as="div" className="block md:hidden relative">
            <div>
              <Menu.Button className=" flex items-center border border-gray-300 font-dmsans p-2 bg-white rounded-lg text-base text-gray-700 font-semibold hover:bg-gray-50 transition duration-150 ease-in-out">
                <span className="sr-only">Open options</span>
                <FilterLines className="h-6 w-6" aria-hidden="true" />
              </Menu.Button>
            </div>

            <Transition
              as={React.Fragment}
              enter="transition ease-out duration-100"
              enterFrom="transform opacity-0 scale-95"
              enterTo="transform opacity-100 scale-100"
              leave="transition ease-in duration-75"
              leaveFrom="transform opacity-100 scale-100"
              leaveTo="transform opacity-0 scale-95"
            >
              <Menu.Items className="absolute right-0 z-10 mt-2 w-36 origin-top-right rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none">
                <div className="py-1">
                  <Menu.Item>
                    {({ active }) => (
                      <button
                        onClick={handleView}
                        className={twMerge(
                          active
                            ? 'bg-gray-100 text-gray-900'
                            : 'text-gray-700',
                          'block px-4 py-2 text-sm'
                        )}
                      >
                        {content.view_button_text}
                      </button>
                    )}
                  </Menu.Item>
                  <Menu.Item>
                    {({ active }) => (
                      <button
                        onClick={handleDownload}
                        className={twMerge(
                          active
                            ? 'bg-gray-100 text-gray-900'
                            : 'text-gray-700',
                          'block px-4 py-2 text-sm'
                        )}
                      >
                        {content.download_button_text}
                      </button>
                    )}
                  </Menu.Item>
                  <Menu.Item>
                    {({ active }) => (
                      <button
                        onClick={handlePrint}
                        className={twMerge(
                          active
                            ? 'bg-gray-100 text-gray-900'
                            : 'text-gray-700',
                          'block px-4 py-2 text-sm'
                        )}
                      >
                        {content.print_button_text}
                      </button>
                    )}
                  </Menu.Item>
                </div>
              </Menu.Items>
            </Transition>
          </Menu>
          {/* Desktop */}
          <span className="hidden isolate md:inline-flex ml-2">
            <ButtonBase onClick={handleView} className="hover:bg-gray-50">
              <span className="sr-only">{content.view_button_text}</span>
              <Eye className="h-5 w-5 text-gray-500" viewBox="0 0 24 24" />
            </ButtonBase>
            <ButtonBase
              onClick={handleDownload}
              className="ml-2 hover:bg-gray-50"
            >
              <span className="sr-only">{content.download_button_text}</span>
              <Download02
                className="h-5 w-5 text-gray-500"
                viewBox="0 0 24 24"
              />
            </ButtonBase>
          </span>
        </div>
      </div>
      <Alert {...p} />
    </div>
  );
};

export default Toolbar;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/UserOverview/components/ProgressBar.tsx

import { twMerge } from 'tailwind-merge';

const STEPS = [
  'Register',
  'Start Case',
  'Awaiting Diagnosis',
  'Select Treatment',
];

// TODO: Map to real steps
const ProgressBar = ({ currentStep }: { currentStep: number }) => {
  return (
    <div className="relative">
      <div className="mb-4 flex h-3 overflow-hidden rounded-[64px] bg-gray-100 text-xs">
        {STEPS.map((step, index) => (
          <div
            key={step}
            className={twMerge([
              'flex flex-col justify-center items-end px-1 bg-gray-200 text-white',
              index < currentStep
                ? 'bg-accent-300 [&_div]:bg-white'
                : 'bg-gray-200 [&_div]:bg-accent-700',
              index === currentStep - 1 ? 'rounded-e-[64px]' : '',
            ])}
            style={{
              width: `${100 / STEPS.length}%`,
            }}
          >
            {index !== STEPS.length - 1 && (
              <div className="h-1 w-1 rounded-full" />
            )}
          </div>
        ))}
      </div>
    </div>
  );
};

export default ProgressBar;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/UserOverview/components/ConciergeCTA.tsx

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { PrismicNextImage } from '@prismicio/next';
import { PrismicRichText } from '@prismicio/react';

import { ColumnProps } from '..';

/**
 * Component for "ConciergeCTA".
 */
const ConciergeCTA = (content: ColumnProps): JSX.Element => {
  return (
    <div className="w-full md:max-w-md p-6">
      <p className="font-dmsans text-accent-700 font-medium text-sm mb-3">
        {content.concierge_eyebrow}
      </p>
      <div className="mb-3">
        <PrismicNextImage field={content.concierge_logo} className="w-72" />
      </div>
      <div className="flex flex-col items-center sm:flex-row gap-3 sm:items-center w-full font-dmsans text-gray-600 text-lg">
        <PrismicNextImage
          field={content.concierge_image}
          className="w-[144px] h-[155px]"
        />
        <PrismicRichText field={content.concierge_content} />
      </div>
      <div className="mt-8 flex items-center gap-x-6">
        <CustomPrismicLink
          field={content.concierge_cta_link}
          className="md:w-full text-center border border-gray-300 font-dmsans py-2 px-10 bg-white rounded-lg text-base text-gray-700 font-semibold hover:bg-gray-50 transition duration-150 ease-in-out"
        >
          {content.concierge_cta_link_text}
        </CustomPrismicLink>
      </div>
    </div>
  );
};

export default ConciergeCTA;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/UserOverview/components/Alert.tsx

import React from 'react';

import { PrismicNextLink } from '@prismicio/next';
import { PrismicRichText } from '@prismicio/react';

import { ColumnProps } from '..';

/**
 * Component for "Alert".
 */
const Alert: React.FC<ColumnProps> = (p: ColumnProps) => {
  return (
    <div
      className="p-3 lg:rounded-br-md"
      style={{ backgroundColor: p.alert_color ?? 'F0FDF9' }}
    >
      <div
        className="font-dmsans ml-3 md:ml-7 text-base [&_a]:underline"
        style={{ color: p.alert_text_color ?? '107569' }}
      >
        <PrismicRichText
          field={p.alert_content}
          components={{
            hyperlink: ({ children, node }) => (
              <PrismicNextLink field={node.data} className="underline">
                {children}
              </PrismicNextLink>
            ),
          }}
        />
      </div>
    </div>
  );
};

export default Alert;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/UserOverview/components/Video.tsx

import React from 'react';

import { ColumnProps } from '..';

/**
 * Component for "Video Column".
 */
const Video: React.FC<ColumnProps> = (p) => {
  return (
    p?.video_link && (
      <div className="p-3 md:p-6">
        <p className="font-dmsans text-accent-700 font-medium text-sm mb-4">
          {p.video_eyebrow}
        </p>
        <div
          className="relative overflow-hidden w-full aspect-video rounded-lg border border-white border-inset"
          style={{ paddingBottom: 'calc(56.25% - 1px)' }}
        >
          <iframe
            src={p.video_link}
            loading="lazy"
            title={p.video_title ?? 'Video'}
            allow="encrypted-media; fullscreen;"
            style={{
              position: 'absolute',
              width: '100%',
              height: '100%',
              top: 0,
              left: 0,
              bottom: 0,
              right: 0,
              border: 'none',
              padding: 0,
              margin: 0,
              overflow: 'hidden',
            }}
          ></iframe>
        </div>
      </div>
    )
  );
};

export default Video;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/UserOverview/components/NextSteps.tsx

import React from 'react';

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { UserStatus } from '@/utils/enums';
import { CaseStatus } from '@prisma/client';
import { PrismicRichText } from '@prismicio/react';

import { ColumnProps } from '..';
import ProgressBar from './ProgressBar';

const getNextStepContent = (
  p: ColumnProps,
  userStatus: UserStatus,
  caseStatus?: CaseStatus
) => {
  let content;
  const defaultContent = {
    progress: 0,
    eyebrow: p.start_eyebrow,
    header: p.start_header,
    title: p.start_title,
    content: p.start_content,
    cta_link: p.start_cta_link,
    cta_link_text: p.start_cta_link_text,
    secondary_link: p.start_secondary_cta_link,
    secondary_link_text: p.start_secondary_cta_link_text,
  };

  const prismicContent = p?.status_content ?? [];

  if (!caseStatus) {
    // If no case selected, show content according to user status
    content = prismicContent.find((c) => c?.case_status === userStatus);
  } else {
    // Otherwise, show content based on case status
    content = prismicContent.find((c) => c?.case_status === caseStatus);
  }

  return content ?? defaultContent;
};

/**
 * Component for "NextSteps" Section.
 */
const NextSteps = (p: ColumnProps): JSX.Element => {
  const { userStatus, selectedCase } = p;
  const nextStepContent = React.useMemo(
    () => getNextStepContent(p, userStatus, selectedCase?.status),
    [p, userStatus, selectedCase]
  );

  return (
    <div className="p-3 md:p-6">
      <p className="font-dmsans text-accent-700 font-medium text-sm mb-2">
        {nextStepContent.eyebrow}
      </p>
      <h2 className="font-financier text-3xl font-semibold tracking-tight text-accent-950 sm:text-4xl mb-3">
        {nextStepContent.header}
      </h2>
      <p className="font-dmsans text-gray-600 font-bold text-base mb-2">
        {nextStepContent.title?.replace(
          '{ caseName }',
          `${selectedCase?.user?.firstName}'s` ?? 'your'
        )}
      </p>
      <ProgressBar currentStep={nextStepContent.progress ?? 0} />
      <div className="font-dmsans text-gray-600 text-lg">
        <PrismicRichText field={nextStepContent.content} />
      </div>
      <div className="mt-8 flex flex-col items-start sm:flex-row sm:items-center gap-3 max-w-xs sm:max-w-none">
        <CustomPrismicLink
          field={nextStepContent.cta_link}
          className="border text-center border-accent-300 font-dmsans py-2 px-10 sm:px-4 bg-accent-200 rounded-lg text-base text-accent-700 font-semibold hover:bg-accent-100 transition duration-150 ease-in-out"
        >
          {nextStepContent.cta_link_text}
        </CustomPrismicLink>
        {nextStepContent.secondary_link_text && (
          <CustomPrismicLink
            field={nextStepContent.secondary_link}
            className="border text-center border-gray-300 font-dmsans py-2 px-10 sm:px-4 bg-white rounded-lg text-base text-gray-700 font-semibold hover:bg-gray-50 transition duration-150 ease-in-out"
          >
            {nextStepContent.secondary_link_text}
          </CustomPrismicLink>
        )}
      </div>
    </div>
  );
};

export default NextSteps;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/PerksList/index.tsx

import get from 'lodash.get';

import { CheckIcon } from '@heroicons/react/20/solid';
import { Content } from '@prismicio/client';
import { PrismicImage, SliceComponentProps } from '@prismicio/react';

/**
 * Props for `PerksList`.
 */
export type PerksListProps = SliceComponentProps<Content.PerksListSlice>;

/**
 * Component for "PerksList" Slices.
 */
const PerksList = ({ slice }: PerksListProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="lg:pl-2.5 xl:pl-10"
      style={{
        backgroundImage: `linear-gradient(${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
      }}
    >
      <div className="max-w-4xl mx-auto lg:mx-0 px-8 pt-20 sm:px-8 pb-10">
        <div className="mb-10">
          <PrismicImage
            field={slice.primary.logo}
            className="h-[30px] w-auto mx-auto"
          />
          <PrismicImage
            field={slice.primary.image}
            className="h-4 sm:h-8 w-auto mt-5 mx-auto"
          />
        </div>
        <div className="relative">
          <div
            className="absolute inset-0 flex items-center"
            aria-hidden="true"
          >
            <div className="w-full border-t border-gray-200" />
          </div>
          <div className="relative flex justify-center">
            <span
              className="font-dmsans px-3 text-xl sm:text-2xl font-semibold leading-6 text-black text-center"
              style={{
                color: get(slice, 'primary.divider_color', '#000000'),
                backgroundColor: get(
                  slice,
                  'primary.background_color_start',
                  '#FFFFFF'
                ),
              }}
            >
              {slice.primary.divider_text}
            </span>
          </div>
        </div>
        <div className="mt-10 relative py-3 max-w-sm mx-auto">
          <div className="absolute inset-0 h-full w-12 sm:w-20 bg-[#D8F7EA] rounded-lg" />
          <ul
            role="list"
            className="relative ml-3 mt-3 space-y-5 text-sm leading-6"
          >
            {slice.items.map((item) => (
              <li
                key={item.text}
                className="ml-1 flex gap-x-6 sm:ml-2.5 sm:gap-x-10 font-dmsans text-base sm:text-lg font-medium"
              >
                <CheckIcon
                  className="h-5 sm:h-10 flex-none text-[#134E48]"
                  aria-hidden="true"
                />
                {item.text}
              </li>
            ))}
          </ul>
        </div>
      </div>
    </section>
  );
};

export default PerksList;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/StatsBanner/index.tsx

'use client';

import { AnimatePresence, motion } from 'framer-motion';
import get from 'lodash.get';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `StatsBanner`.
 */
export type StatsBannerProps = SliceComponentProps<Content.StatsBannerSlice>;

const Slider = ({ slice }: { slice: Content.StatsBannerSlice }) => {
  const [index, setIndex] = React.useState(0);

  React.useEffect(() => {
    const interval = setInterval(() => {
      setIndex((index) => {
        if (index < slice.items.length - 1) {
          return index + 1;
        }

        return 0;
      });
    }, 5000);
    return () => clearInterval(interval);
  }, [slice.items.length]);

  const item = slice.items?.[index];

  return (
    <AnimatePresence mode="wait">
      <motion.div
        initial={{ x: '100%' }}
        animate={{ x: '0%', transition: { duration: 0.5, ease: 'easeOut' } }}
        exit={{
          x: '-100%',
          transition: {
            duration: 0.5,
            ease: 'easeIn',
          },
        }}
        className="App"
        style={{ fontSize: 100 }}
        key={index}
      >
        <div className="flex sm:w-auto items-center text-base font-medium text-inherit font-dmsans justify-center">
          <PrismicNextImage
            field={item.icon_image}
            className="mr-2 flex-none"
            aria-hidden="true"
            alt=""
            width={item.icon_image.dimensions?.width}
            height={item.icon_image.dimensions?.height}
          />
          <p>{item?.name}</p>
        </div>
      </motion.div>
    </AnimatePresence>
  );
};

/**
 * Component for "StatsBanner" Slices.
 */
const StatsBanner = ({ slice }: StatsBannerProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="overflow-hidden"
    >
      <div
        className="py-5"
        style={{
          backgroundImage: `linear-gradient(${get(
            slice,
            'primary.background_color_start',
            '#FFFFFF'
          )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
        }}
      >
        {/* Mobile View */}
        <div
          className="block lg:hidden"
          style={{ color: slice.primary.text_color ?? '#263A61' }}
        >
          <Slider slice={slice} />
        </div>
        {/* Desktop view */}
        <div
          className={twMerge(
            'hidden lg:flex overflow-x-auto',
            slice.primary.alignment === 'start' ? 'max-w-6xl' : 'max-w-none'
          )}
        >
          <div className="mx-auto flex space-x-12 whitespace-nowrap px-4 py-3 sm:px-6 lg:space-x-24 lg:px-8">
            {slice.items.map((stat) => (
              <div
                key={stat.name}
                className="flex sm:w-auto items-center text-base font-medium font-dmsans justify-center"
                style={{ color: slice.primary.text_color ?? '#263A61' }}
              >
                <PrismicNextImage
                  field={stat.icon_image}
                  className="mr-2 flex-none"
                  aria-hidden="true"
                  alt=""
                  width={stat.icon_image.dimensions?.width}
                  height={stat.icon_image.dimensions?.width}
                />
                <p
                  className={twMerge(
                    slice.primary.text_size === 'large'
                      ? 'text-base xl:text-lg font-bold'
                      : 'text-base'
                  )}
                >
                  {stat.name}
                </p>
              </div>
            ))}
          </div>
        </div>
      </div>
    </section>
  );
};

export default StatsBanner;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/InfoTabs/index.tsx

'use client';

import { useState } from 'react';
import { twMerge } from 'tailwind-merge';

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { PlusIcon } from '@heroicons/react/20/solid';
import { Content, isFilled } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import { PrismicRichText, SliceComponentProps } from '@prismicio/react';

/**
 * Props for `InfoTabs`.
 */
export type InfoTabsProps = SliceComponentProps<Content.InfoTabsSlice>;

/**
 * Component for "InfoTabs" Slices.
 */
const InfoTabs = ({ slice }: InfoTabsProps): JSX.Element => {
  const [selectedTab, setSelectedTab] = useState(slice.items[1]);
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="pt-11 pb-10 px-6"
    >
      <div className="mx-auto max-w-[730px] text-center">
        <h2 className="mb-11 font-financier font-semibold text-4xl md:text-6xl md:leading-[60px]">
          {slice.primary.title}
        </h2>
        <div className="font-dmsans text-lg text-black">
          <PrismicRichText field={slice.primary.description} />
        </div>
      </div>
      <div className="py-10">
        <div className="bg-[#E1F9F7] max-w-5xl rounded-2xl mx-auto">
          <div
            className="isolate flex divide-x divide-gray-200 rounded-t-2xl border-b border-black shadow"
            aria-label="Tabs"
          >
            {slice.items.map((tab, tabIdx) => (
              <button
                key={tab.tab_name}
                onClick={() => setSelectedTab(tab)}
                className={twMerge(
                  tab.tab_name === selectedTab.tab_name
                    ? 'text-gray-900 bg-[#CDEBE5]'
                    : 'text-gray-500 hover:text-gray-700',
                  tabIdx === 0 ? 'rounded-tl-lg' : '',
                  tabIdx === slice.items.length - 1 ? 'rounded-tr-2xl' : '',
                  'group relative min-w-0 flex-1 overflow-hidden flex items-center justify-center py-4 px-2 sm:py-7 sm:px-4 text-center text-sm lg:text-lg font-medium hover:bg-[#CDEBE5] focus:z-10'
                )}
              >
                <PlusIcon className="hidden sm:block h-6 md:w-6 text-black shrink-0" />
                <span className="ml-1 md:ml-2 font-dmsans text-black">
                  {tab.tab_name}
                </span>
                <span
                  aria-hidden="true"
                  className={twMerge(
                    tab.tab_name === selectedTab.tab_name
                      ? 'bg-[#CDEBE5]'
                      : 'bg-transparent',
                    'absolute inset-x-0 bottom-0 h-0.5'
                  )}
                />
              </button>
            ))}
          </div>
          <div className="py-11 max-w-[600px] mx-auto">
            <div className="px-3 flex flex-col items-center sm:items-start sm:flex-row gap-x-8 gap-y-4">
              {isFilled.image(selectedTab.image) && (
                <PrismicNextImage
                  field={selectedTab.image}
                  className="shrink-0"
                  alt=""
                />
              )}
              <div className="text-center sm:text-left font-dmsans text-lg md:text-xl md:leading-7 text-black font-medium">
                <PrismicRichText field={selectedTab.content} />
              </div>
            </div>
          </div>
        </div>
      </div>
      <div>
        <CustomPrismicLink
          field={slice.primary.cta_link}
          variant="solid-accent"
          className="mx-auto py-2.5 md:text-lg text-black border-0 max-w-xs w-full font-bold"
        >
          {slice.primary.cta_link_text}
        </CustomPrismicLink>
      </div>
    </section>
  );
};

export default InfoTabs;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/OrdersSection/index.tsx

import dayjs from 'dayjs';
import { cookies } from 'next/headers';
import Image from 'next/image';
import { ProductPageDocument } from 'prismicio-types';

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { OrderInclude } from '@/app/shared/types';
import { getPrismicProductId } from '@/utils/get-prismic-product-id';
import { getBaseUrl } from '@/utils/getBaseUrl';
import { getProductContentByIds } from '@/utils/helpers/helpers';
import { ProductCategories } from '@prisma/client';
import { Content, isFilled } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import { SliceComponentProps } from '@prismicio/react';

type ProductWithContent = {
  id: string;
  quantity: number;
  name: string;
  imageURL: string | null;
  content?: ProductPageDocument | null;
  orderDate: Date;
};

const isIncludedCategory = (category: ProductCategories) => {
  return (
    category === ProductCategories.OTC_MEDICATION ||
    category === ProductCategories.PRESCRIPTION_MEDICATION
  );
};

const getLatestOrder = async () => {
  try {
    const res = await fetch(`${getBaseUrl()}/api/ecommerce/order`, {
      method: 'GET',
      headers: { Cookie: cookies().toString() },
    });
    if (!res.ok) {
      throw new Error('Could not fetch orders');
    }
    const orders = (await res.json()) as OrderInclude[];

    const ordersWithProducts = orders.filter((order) => {
      const hasProducts = order.cartProducts.some((p) =>
        isIncludedCategory(p.product.category)
      );
      const hasSubscription = order.cartSubscriptionProducts.some((p) =>
        isIncludedCategory(p.subscriptionProduct.category)
      );

      return hasProducts || hasSubscription;
    });

    return ordersWithProducts.reduce((a, b) => {
      return new Date(a.createdAt) > new Date(b.createdAt) ? a : b;
    });
  } catch (error) {
    return undefined;
  }
};

const getProductsWithContent = async (order?: OrderInclude) => {
  if (!order) {
    return [];
  }

  const productsArray: ProductWithContent[] = [];

  order.cartProducts.forEach((p) => {
    if (isIncludedCategory(p.product.category)) {
      productsArray.push({
        id: p.product.id,
        quantity: p.quantity,
        name: p.product.name,
        imageURL: p.product.imageURL,
        orderDate: order.createdAt,
        content: null,
      });
    }
  });

  if (productsArray.length < 2) {
    order.cartSubscriptionProducts.forEach((p) => {
      if (isIncludedCategory(p.subscriptionProduct.category)) {
        productsArray.push({
          id: p.subscriptionProduct.id,
          quantity: p.quantity,
          name: p.subscriptionProduct.name,
          imageURL: p.subscriptionProduct.imageURL,
          orderDate: order.createdAt,
          content: null,
        });
      }
    });
  }

  const products = productsArray.slice(0, 3);
  const ids = products.map((product) => product.id);
  const content = await getProductContentByIds(ids);

  return products.map((product) => {
    return {
      ...product,
      content: content.find(
        (item) => getPrismicProductId(item.data) === product.id
      ),
    };
  });
};

const ProductImage = ({ item }: { item: ProductWithContent }) => {
  if (item.content && isFilled.image(item.content.data.thumbnail)) {
    return (
      <PrismicNextImage
        field={item.content.data.thumbnail}
        alt=""
        className="h-20 w-20 flex-none rounded-md object-cover object-center"
        width={80}
        height={80}
      />
    );
  }

  if (item.imageURL) {
    <Image
      src={item.imageURL}
      alt=""
      className="h-20 w-20 flex-none rounded-md object-cover object-center"
      width={80}
      height={80}
    />;
  }

  return null;
};

/**
 * Props for `OrdersSection`.
 */
export type OrdersSectionProps =
  SliceComponentProps<Content.OrdersSectionSlice>;

const OrdersSection: React.FC<OrdersSectionProps> = async ({ slice }) => {
  const latestOrder = await getLatestOrder();
  const products = latestOrder ? await getProductsWithContent(latestOrder) : [];

  return products.length > 0 ? (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="py-2 px-4 sm:px-7 lg:px-0"
    >
      <div className="max-w-[1000px] px-2 py-6 border-t border-b border-gray-200 mx-auto lg:mx-0 lg:pl-6 lg:pr-3">
        <p className="font-dmsans text-accent-700 font-medium text-sm">
          {slice.primary.orders_eyebrow}
        </p>
        <div className="flex flex-col gap-x-6 gap-y-4 md:flex-row md:justify-between md:flex-wrap lg:gap-x-10 ">
          <div className="flex flex-col gap-x-3 divide-y divide-gray-200 flex-1 md:flex-row md:justify-between md:divide-y-0">
            {products.map((product) => (
              <div
                key={product.id}
                className="font-dmsans flex items-start space-x-4 py-6"
              >
                <ProductImage item={product} />
                <div className="space-y-1">
                  <p className="text-md font-medium text-gray-900">
                    {product.name}
                  </p>
                  <p className="text-sm font-bold text-gray-500">
                    Quantity: {product.quantity}
                  </p>
                  <p className="text-sm text-gray-400">{`${
                    latestOrder?.createdAt &&
                    dayjs(latestOrder?.createdAt).format('MMM D, YYYY')
                  }`}</p>
                </div>
              </div>
            ))}
          </div>
          <div className="inline-flex items-center gap-x-6">
            <CustomPrismicLink
              field={slice.primary.orders_cta_link}
              className="text-center border border-gray-300 font-dmsans py-2 px-10 bg-white rounded-lg text-base text-gray-700 font-semibold hover:bg-gray-50 transition duration-150 ease-in-out"
            >
              {slice.primary.orders_cta_link_text}
            </CustomPrismicLink>
          </div>
        </div>
      </div>
    </section>
  ) : null;
};

export default OrdersSection;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/HeroCarousel/index.tsx

import { Container } from '@/app/shared/components/layout/container';
import PrismicNextLink from '@components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `HeroCarousel`.
 */
export type HeroCarouselProps = SliceComponentProps<Content.HeroCarouselSlice>;

/**
 * Component for "HeroCarousel" Slices.
 */
const HeroCarousel = ({ slice }: HeroCarouselProps): JSX.Element => {
  return (
    <>
      <Container
        data-slice-type={slice.slice_type}
        data-slice-variation={slice.variation}
      >
        <div className="bg-white">
          <div className="mx-auto max-w-8xl">
            {slice.items.map((item, index) => (
              <div
                key={index}
                className="relative isolate overflow-hidden bg-gray-900 px-6 py-24 text-center sm:px-16"
              >
                <h2 className="mx-auto max-w-2xl text-3xl font-bold tracking-tight text-white sm:text-4xl">
                  {item.title}
                </h2>
                <p className="mx-auto mt-6 max-w-xl text-lg leading-8 text-gray-300">
                  {item.subtitle}
                </p>
                <div className="mt-10 flex items-center justify-center gap-x-6">
                  <PrismicNextLink
                    field={item.primary_link}
                    className="rounded-md bg-white px-3.5 py-2.5 text-sm font-semibold text-gray-900 shadow-sm hover:bg-gray-100 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-white"
                  >
                    {item.primary_link_text}
                  </PrismicNextLink>
                  {item.secondary_link && (
                    <PrismicNextLink
                      field={item.secondary_link}
                      className="text-sm font-semibold leading-6 text-white"
                    >
                      {item.secondary_link_text}
                    </PrismicNextLink>
                  )}
                </div>
                <svg
                  viewBox="0 0 1024 1024"
                  className="absolute left-1/2 top-1/2 -z-10 h-[64rem] w-[64rem] -translate-x-1/2 [mask-image:radial-gradient(closest-side,white,transparent)]"
                  aria-hidden="true"
                >
                  <circle
                    cx={512}
                    cy={512}
                    r={512}
                    fill="url(#827591b1-ce8c-4110-b064-7cb85a0b1217)"
                    fillOpacity="0.7"
                  />
                  <defs>
                    <radialGradient id="827591b1-ce8c-4110-b064-7cb85a0b1217">
                      <stop stopColor={`${item.bg_color_start}`} />
                      <stop offset={1} stopColor={`${item.bg_color_stop}`} />
                    </radialGradient>
                  </defs>
                </svg>
              </div>
            ))}
          </div>
        </div>
      </Container>
    </>
  );
};

export default HeroCarousel;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Content/index.tsx

import { RichText } from '@/app/shared/components/text/rich-text';
import { Content as PrismicContent } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `Content`.
 */
export type ContentProps = SliceComponentProps<PrismicContent.ContentSlice>;

/**
 * Component for "Content" Slices.
 */
const Content = ({ slice }: ContentProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="relative isolate overflow-hidden py-24 sm:py-24">
        <PrismicNextImage
          field={slice.primary.background_image}
          alt=""
          className="absolute inset-0 -z-10 h-full w-full object-cover object-right md:object-center"
        />
        <div className="mx-auto max-w-7xl px-6 lg:px-8">
          <div className="mx-auto max-w-3xl text-center">
            <RichText
              field={slice.primary.title}
              className="mx-auto font-financier text-4xl max-w-2xl text-[42px] leading-[46px] text-primary-950"
            />
            <RichText
              field={slice.primary.content}
              className="mt-8 text-xl leading-[36px] text-gray-700"
            />
          </div>
        </div>
      </div>
    </section>
  );
};

export default Content;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BoxedImageWithContent/index.tsx

import get from 'lodash.get';
import { twMerge } from 'tailwind-merge';

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import { PrismicRichText, SliceComponentProps } from '@prismicio/react';

/**
 * Props for `BoxedImageWithContent`.
 */
export type BoxedImageWithContentProps =
  SliceComponentProps<Content.BoxedImageWithContentSlice>;

/**
 * Component for "BoxedImageWithContent" Slices.
 */
const BoxedImageWithContent = ({
  slice,
}: BoxedImageWithContentProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="bg-white py-8">
        <div className="relative isolate">
          <div className="mx-auto max-w-7xl sm:px-6 lg:px-8">
            <div
              className={twMerge(
                'mx-auto flex max-w-2xl items-center flex-col gap-8 px-6 py-12 sm:rounded-2xl sm:p-7 lg:gap-x-16 lg:mx-0 lg:max-w-none lg:flex-row lg:justify-center lg:py-8 xl:gap-x-24 xl:px-20',
                slice.primary.image_alignment === 'right'
                  ? 'lg:flex-row-reverse'
                  : 'lg:flex-row'
              )}
              style={{
                backgroundColor: get(slice, 'primary.box_color', '#FFFFFF'),
              }}
            >
              <PrismicNextImage
                className="h-auto w-80 flex-none lg:h-auto lg:w-full lg:max-w-[410px]"
                field={slice.primary.image}
                alt=""
              />
              <div className="text-center lg:text-left font-dmsans w-full flex-auto max-w-md lg:max-w-sm">
                <h2 className="mb-3 font-financier text-3xl font-bold tracking-tight text-gray-800 sm:text-4xl">
                  {slice.primary.title}
                </h2>
                <PrismicRichText
                  field={slice.primary.content}
                  components={{
                    paragraph: ({ children }) => (
                      <p className="text-base text-gray-700">{children}</p>
                    ),
                  }}
                />
                <div className="mt-6 flex justify-center lg:justify-start">
                  <CustomPrismicLink
                    field={slice.primary.cta_link}
                    variant="solid-accent"
                    className="font-bold text-accent-900 border-0 py-3 px-10"
                  >
                    {slice.primary.cta_link_text}
                  </CustomPrismicLink>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default BoxedImageWithContent;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/PaymentMethods/index.tsx

import { cookies } from 'next/headers';
import { Suspense } from 'react';

import { getBaseUrl } from '@/utils/getBaseUrl';
import { IPaymentMethod } from '@/utils/payments/types';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import Loading from './components/Loading';
import PaymentFormModal from './components/PaymentFormModal';
import PaymentMethodCards from './components/PaymentMethodCards';

/**
 * INCOMPLETE: This is a placeholder for the `PaymentMethods` slice.
 */

/**
 * Props for `PaymentMethods`.
 */
export type PaymentMethodsProps =
  SliceComponentProps<Content.PaymentMethodsSlice>;

const getPaymentMethods = async () => {
  const res = await fetch(
    `${getBaseUrl()}/api/ecommerce/customer-info/payment-method`,
    {
      headers: { Cookie: cookies().toString() },
    }
  );
  return (await res.json()) as IPaymentMethod[];
};

/**
 * Component for "PaymentMethods" Slices.
 */
const PaymentMethodsSection = async ({
  slice,
  context,
}: PaymentMethodsProps) => {
  const paymentMethods = await getPaymentMethods();

  const ctx = context as any;

  return (
    <>
      {paymentMethods.length > 0 && (
        <div className="mb-2 pt-2 max-w-xl">
          <PaymentMethodCards slice={slice} cards={paymentMethods} />
        </div>
      )}
      <PaymentFormModal
        user={ctx.user}
        hasMethods={paymentMethods.length > 0}
        slice={slice}
      />
    </>
  );
};

const PaymentMethods = async (p: PaymentMethodsProps) => {
  return (
    <section
      data-slice-type={p.slice.slice_type}
      data-slice-variation={p.slice.variation}
    >
      <div className="m-6 border-b border-gray-200 pb-2">
        <div className="border-b border-gray-200 pb-4">
          <p className="font-dmsans text-lg text-gray-900 font-semibold">
            {p.slice.primary.title}
          </p>
          <p className="font-dmsans text-base text-gray-600">
            {p.slice.primary.description}
          </p>
        </div>
        <Suspense fallback={<Loading />}>
          <PaymentMethodsSection {...p} />
        </Suspense>
      </div>
    </section>
  );
};

export default PaymentMethods;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/PaymentMethods/components/PaymentFormWrapper.tsx

'use client';

import React from 'react';

import { User } from '@prisma/client';
import { Content } from '@prismicio/client';
import { Elements } from '@stripe/react-stripe-js';
import { loadStripe } from '@stripe/stripe-js';

import PaymentMethodForm from './PaymentMethodForm';

// Make sure to call `loadStripe` outside of a component’s render to avoid
// recreating the `Stripe` object on every render.
const stripePromise = loadStripe(
  process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY as string
);

interface IPaymentFormWrapperProps {
  user: User;
  onCancel: () => void;
  slice: Content.PaymentMethodsSlice;
}

const PaymentFormWrapper: React.FC<IPaymentFormWrapperProps> = (p) => {
  const options = {
    // passing the SetupIntent's client secret
    mode: 'setup' as any,
    currency: 'usd',
    paymentMethodCreation: 'manual',
    // Fully customizable with appearance API.
    appearance: {
      /*...*/
    },
  };

  return (
    <Elements stripe={stripePromise} options={options}>
      <PaymentMethodForm user={p.user} onCancel={p.onCancel} slice={p.slice} />
    </Elements>
  );
};

export default PaymentFormWrapper;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/PaymentMethods/components/PaymentMethodCardTile.tsx

'use client';

import Image from 'next/image';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import { IPaymentMethod } from '@/utils/payments/types';
import { RadioGroup } from '@headlessui/react';
import { Content } from '@prismicio/client';

const cardBrandToImage: { [key: string]: string } = {
  amex: 'amex.png',
  diners: 'diners.png',
  discover: 'discover.png',
  eftpos_au: 'unknown.png',
  jcb: 'jcb.png',
  mastercard: 'mastercard.png',
  unionpay: 'unionpay.png',
  visa: 'visa.png',
  unknown: 'unknown.png',
};

const brandNameMap: { [key: string]: string } = {
  amex: 'American Express',
  diners: 'Diners Club',
  discover: 'Discover',
  eftpos_au: 'Eftpos Australia',
  jcb: 'Japan Credit Bureau (JCB)',
  mastercard: 'Mastercard',
  unionpay: 'UnionPay',
  visa: 'Visa',
  unknown: 'Credit card',
};

const PaymentMethodCardTile = ({
  card,
  checked,
  slice,
}: {
  card: IPaymentMethod;
  checked: boolean;
  slice: Content.PaymentMethodsSlice;
}) => {
  const brandName = React.useMemo(
    () => brandNameMap?.[card.brand] ?? 'Credit card',
    [card.brand]
  );

  const brandImage = React.useMemo(
    () => cardBrandToImage?.[card.brand] ?? 'unknown.png',
    [card.brand]
  );

  const cardDescriptor = slice.primary.card_descriptor
    ?.replace('{{ brand }}', brandName)
    .replace('{{ last4 }}', card.last4);

  const cardExpiry = slice.primary.expiry_text?.replace(
    '{{ expiry }}',
    `${card.expMonth.toString().padStart(2, '0')}/${card.expYear}`
  );

  return (
    <div className="flex flex-row gap-4 items-start">
      <div>
        <Image
          src={`/assets/icons/${brandImage}`}
          width={46}
          height={32}
          alt=""
        />
      </div>
      <div className="flex flex-col">
        <RadioGroup.Label
          as="p"
          className={twMerge(
            checked ? 'text-accent-800' : 'text-gray-800',
            'font-dmsans text-sm font-medium'
          )}
        >
          {cardDescriptor}
        </RadioGroup.Label>
        <RadioGroup.Description
          as="p"
          className={twMerge(
            checked ? 'text-accent-600' : 'text-gray-600',
            'font-dmsans  text-sm'
          )}
        >
          {cardExpiry}
        </RadioGroup.Description>
        <RadioGroup.Description
          as="p"
          className={twMerge(
            checked ? 'text-accent-500' : 'text-gray-600',
            'mt-2 font-dmsans font-semibold text-sm'
          )}
        >
          {slice.primary.set_default_button_text}
        </RadioGroup.Description>
      </div>
    </div>
  );
};

export default PaymentMethodCardTile;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/PaymentMethods/components/PaymentFormModal.tsx

'use client';

import React from 'react';

import ButtonBase from '@/app/shared/components/buttons/button-base';
import Modal from '@/app/shared/components/overlays/modal';
import { CreditCardIcon } from '@heroicons/react/24/outline';
import { User } from '@prisma/client';
import { Content } from '@prismicio/client';

import PaymentFormWrapper from './PaymentFormWrapper';

interface IPaymentFormWrapperProps {
  user: User;
  hasMethods?: boolean;
  slice: Content.PaymentMethodsSlice;
}

const PaymentFormModal: React.FC<IPaymentFormWrapperProps> = (p) => {
  const [show, setShow] = React.useState(false);

  return (
    <>
      {p.hasMethods ? (
        <ButtonBase variant="accent" className="" onClick={() => setShow(true)}>
          {p.slice.primary.add_button_text}
        </ButtonBase>
      ) : (
        <div className="my-4 max-w-xl">
          <button
            type="button"
            onClick={() => setShow(true)}
            className="relative block w-full text-accent-700 rounded-lg border-2 border-dashed border-gray-300 px-12 py-4 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-accent-600 focus:ring-offset-2"
          >
            <CreditCardIcon className="mx-auto h-7 w-7 text-accent-700" />
            <span className="mt-2 block text-sm font-semibold text-accent-700">
              {p.slice.primary.no_methods_button_text}
            </span>
          </button>
        </div>
      )}
      <Modal
        show={show}
        onClose={() => setShow(false)}
        title={p.slice.primary.add_modal_title as string}
        contentRenderer={() => (
          <PaymentFormWrapper
            user={p.user}
            onCancel={() => setShow(false)}
            slice={p.slice}
          />
        )}
      />
    </>
  );
};

export default PaymentFormModal;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/PaymentMethods/components/PaymentMethodCards.tsx

'use client';

import React from 'react';
import { twMerge } from 'tailwind-merge';

import LoadingSpinner from '@/app/shared/components/loading-indicators/loading-spinner';
import { IPaymentMethod } from '@/utils/payments/types';
// import { getFamilyMemberHeader } from '@/utils/utils';
import { RadioGroup } from '@headlessui/react';
import { CheckCircleIcon } from '@heroicons/react/20/solid';
import { Content } from '@prismicio/client';

import PaymentMethodCardTile from './PaymentMethodCardTile';

/**
 * INCOMPLETE: This is a placeholder for the `PaymentMethodCards` component.
 */

const setDefaultPaymentMethod = async (paymentMethodId: string) => {
  // const familyMemberHeader = getFamilyMemberHeader();

  // const headers = {
  //   'Content-Type': 'application/json',
  //   ...(familyMemberHeader ? familyMemberHeader : {}),
  // };

  // const res = await fetch(`/api/ecommerce/customer-info/payment-method/STRIPE/${paymentMethodId}`, {
  //   method: 'POST',
  //   headers,
  // });
  // return await res.json();
  return paymentMethodId;
};

const PaymentMethodCards: React.FC<{
  cards: IPaymentMethod[];
  slice: Content.PaymentMethodsSlice;
}> = ({ cards, slice }) => {
  const [selectedMethod, setSelectedMethod] = React.useState(
    cards.find((card) => card.default)
  );
  const [saving, setSaving] = React.useState<IPaymentMethod | undefined>(
    undefined
  );
  const [error, setError] = React.useState(false);

  const handleOnChange = async (card: IPaymentMethod) => {
    setSaving(card);

    try {
      await setDefaultPaymentMethod(card.id);
      setSelectedMethod(card);
      setSaving(undefined);
    } catch (e) {
      setError(true);
      setSaving(undefined);
    }
  };

  return (
    <>
      <RadioGroup value={selectedMethod} onChange={handleOnChange}>
        <RadioGroup.Label className="sr-only">
          Select Default Payment Method
        </RadioGroup.Label>
        <div className="mt-4 grid grid-cols-1 gap-y-6">
          {cards.map((card) => (
            <RadioGroup.Option
              key={card.id}
              value={card}
              className={({ checked }) =>
                twMerge(
                  checked
                    ? 'bg-accent-50 border-accent-600 ring-1 ring-accent-600'
                    : 'bg-white border-gray-200',
                  'relative flex cursor-pointer rounded-lg border p-4 shadow-sm focus:outline-none'
                )
              }
            >
              {({ checked, active }) => (
                <>
                  <span className="flex flex-1">
                    <PaymentMethodCardTile
                      card={card}
                      checked={checked}
                      slice={slice}
                    />
                  </span>
                  {saving?.id === card.id ? (
                    <LoadingSpinner size="sm" fillClass="fill-accent-700" />
                  ) : (
                    <>
                      {checked ? (
                        <CheckCircleIcon
                          className="h-5 w-5 text-accent-600"
                          aria-hidden="true"
                        />
                      ) : (
                        <div className="h-4 w-4 border border-gray-300 rounded-full" />
                      )}
                    </>
                  )}
                  <span
                    className={twMerge(
                      active ? 'border' : 'border',
                      checked ? 'border-accent-600' : 'border-transparent',
                      'pointer-events-none absolute -inset-px rounded-lg'
                    )}
                    aria-hidden="true"
                  />
                </>
              )}
            </RadioGroup.Option>
          ))}
        </div>
      </RadioGroup>
      {error && (
        <p className="mt-2 font-dmsans text-sm text-red-500">
          {slice.primary.add_error_text}
        </p>
      )}
    </>
  );
};

export default PaymentMethodCards;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/PaymentMethods/components/Loading.tsx

import React from 'react';

const SkeletonCard: React.FC = () => {
  return (
    <div className="relative flex flex-row gap-4 p-4 border border-gray-200 rounded-lg animate-pulse">
      <div className="w-[46px] h-8 bg-gray-200 rounded" />
      <div className="flex flex-col w-full">
        <div className="w-1/2 h-3 bg-gray-200 rounded" />
        <div className="w-1/4 h-3 mt-2 bg-gray-200 rounded" />

        <div className="mt-4 w-1/5 h-3 bg-gray-200 rounded" />
      </div>
      <div className="absolute top-4 right-4 w-4 h-4 border border-gray-200 rounded-full" />
    </div>
  );
};

const Loading: React.FC = () => {
  return (
    <div className="my-4 flex flex-col gap-6 max-w-xl">
      {[...Array(3)].map((_e, i) => (
        <SkeletonCard key={`skeleton-card-${i}`} />
      ))}
    </div>
  );
};

export default Loading;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/PaymentMethods/components/PaymentMethodForm.tsx

'use client';

import { usePathname } from 'next/navigation';
import React from 'react';

import ButtonOutline from '@/app/shared/components/buttons/button-outline';
import ButtonSolid from '@/app/shared/components/buttons/button-solid';
import { User } from '@prisma/client';
import { Content } from '@prismicio/client';
import {
  AddressElement,
  PaymentElement,
  useElements,
  useStripe,
} from '@stripe/react-stripe-js';

/**
 * INCOMPLETE: This is a placeholder for the `PaymentMethodForm` component.
 */

interface PaymentMethodFormProps {
  user: User;
  onCancel: () => void;
  slice: Content.PaymentMethodsSlice;
}

const PaymentMethodForm: React.FC<PaymentMethodFormProps> = (p) => {
  const stripe = useStripe();
  const elements = useElements();
  const pathname = usePathname();

  const [errorMessage, setErrorMessage] = React.useState('');
  const [loading, setLoading] = React.useState(false);

  if (!stripe || !elements) {
    // Stripe.js has not yet loaded.
    // Make sure to disable form submission until Stripe.js has loaded.
    return null;
  }

  const handleError = (error: any) => {
    setLoading(false);
    setErrorMessage(error.message);
  };

  const handleSubmit = async (event: any) => {
    // We don't want to let default form submission happen here,
    // which would refresh the page.
    event.preventDefault();

    if (!stripe) {
      // Stripe.js hasn't yet loaded.
      // Make sure to disable form submission until Stripe.js has loaded.
      return;
    }

    setLoading(true);

    // Trigger form validation and wallet collection
    const { error: submitError } = await elements.submit();
    if (submitError) {
      handleError(submitError);
      return;
    }

    // TODO: Handle payment method creation
    //
    // const res = await fetch('/api/ecommerce/customer-info/payment-method', {
    //   method: 'POST',
    //   headers: getFamilyMemberHeader(),
    //   body: JSON.stringify({
    //     paymentMethodId: 'payment-method-id',
    //   }),
    // });

    // const { client_secret: clientSecret } = await res.json();

    // Confirm the SetupIntent using the details collected by the Payment Element
    // const { error } = await stripe.confirmSetup({
    //   elements,
    //   clientSecret,
    //   confirmParams: {
    //     return_url: process.env.NEXT_PUBLIC_BASE_URL + pathname,
    //   },
    // });

    // if (error) {
    //   // This point is only reached if there's an immediate error when
    //   // confirming the setup. Show the error to your customer (for example, payment details incomplete)
    //   handleError(error);
    // }
  };

  return (
    <form onSubmit={handleSubmit}>
      <AddressElement className="mt-6" options={{ mode: 'billing' }} />
      <PaymentElement className="mt-4" />

      <div className="mt-6 flex flex-row gap-2 justify-end items-center">
        <ButtonOutline
          variant="gray"
          className="py-3 px-6"
          onClick={p.onCancel}
        >
          {p.slice.primary.add_modal_cancel_button_text}
        </ButtonOutline>
        <ButtonSolid
          type="submit"
          variant="accent"
          className="py-3 px-8"
          disabled={!stripe || loading}
        >
          {loading
            ? p.slice.primary.add_modal_saving_button_text
            : p.slice.primary.add_modal_save_button_text}
        </ButtonSolid>
      </div>
      {errorMessage && (
        <p className="text-sm text-error-500 font-dmsans">{errorMessage}</p>
      )}
    </form>
  );
};

export default PaymentMethodForm;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Product/index.tsx

import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import ProductDetails from './components/ProductDetails';

/**
 * Props for `Product`.
 */
export type ProductProps = SliceComponentProps<Content.ProductSlice>;

/**
 * Component for "Product" Slices.
 */
const Product: React.FC<ProductProps> = (p) => {
  return (
    <section
      data-slice-type={p.slice.slice_type}
      data-slice-variation={p.slice.variation}
    >
      <div className="mx-auto max-w-5xl pb-16 pt-10 px-4 sm:px-6 lg:px-8">
        <ProductDetails {...p} />
      </div>
    </section>
  );
};

export default Product;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Product/components/ProductDetails.tsx

'use client';

import { useRouter } from 'next/navigation';
import React, { useState } from 'react';
import { twMerge } from 'tailwind-merge';

import ButtonSolid from '@/app/shared/components/buttons/button-solid';
import { RichText } from '@/app/shared/components/text/rich-text';
import { useCartSliderContext } from '@/app/shared/hooks/use-cart-slider-context';
import { ProductWithContent } from '@/app/shared/types';
import { formatCurrency, getFamilyMemberHeader } from '@/utils/utils';
import { Disclosure, Tab } from '@headlessui/react';
import { MinusIcon, PlusIcon } from '@heroicons/react/24/outline';
import { Product, User } from '@prisma/client';
import { PrismicNextImage } from '@prismicio/next';
import { Minus, Plus } from '@untitled-ui/icons-react';

import { ProductProps } from '..';

const postToCart = async (productId: string, amount: number) => {
  try {
    const res = await fetch(`/api/ecommerce/product/${productId}/cart`, {
      method: 'POST',
      body: JSON.stringify({ setAbsoluteAmount: false, amount }),
      headers: getFamilyMemberHeader(),
    });

    if (!res.ok) {
      throw new Error('Error adding product to cart');
    }

    return { success: true };
  } catch (error) {
    return { success: false };
  }
};

/**
 * Component for "ProductDetails"
 */
const ProductDetails = ({ slice, context }: ProductProps): JSX.Element => {
  const router = useRouter();
  const { setShowCart, startTransition } = useCartSliderContext();
  const { product } = context as {
    user: User;
    products: ProductWithContent[];
    product: Product;
  };

  const [quantity, setQuantity] = useState(1);
  const [error, setError] = useState(false);
  const [loading, setLoading] = useState(false);

  const featuresRaw = [
    {
      title: slice.primary.feature_1_title,
      content: slice.primary.feature_1_content,
    },
    {
      title: slice.primary.feature_2_title,
      content: slice.primary.feature_2_content,
    },
    {
      title: slice.primary.feature_3_title,
      content: slice.primary.feature_3_content,
    },
  ];
  const features = featuresRaw.filter((feature) => feature.title != null);

  const incrementQuantity = () => {
    setQuantity(quantity + 1);
  };

  const decrementQuantity = () => {
    if (quantity === 1) return;
    setQuantity(quantity - 1);
  };

  const handleQuantityChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseInt(e.target.value);
    if (value < 1) return;
    setQuantity(value);
  };

  const addToCart = async () => {
    setLoading(true);
    const { success } = await postToCart(product.id, quantity);
    if (success) {
      startTransition(() => router.refresh());
      setShowCart(true);
      const dataLayer = window.dataLayer || [];
      dataLayer.push({ ecommerce: null });
      dataLayer.push({
        event: 'add_to_cart',
        ecommerce: {
          currency: 'USD',
          value: product.price / 100,
          items: [
            {
              item_id: product.id,
              item_name: product.name,
              currency: 'USD',
              price: product.price / 100,
              quantity: quantity,
            },
          ],
        },
      });
    } else {
      setError(true);
    }
    setLoading(false);
  };

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="mx-auto max-w-2xl lg:max-w-none">
        {/* Product */}
        <div className="lg:grid lg:grid-cols-2 lg:items-start lg:gap-x-8">
          <div className="hidden sm:block lg:hidden mb-4">
            <h1 className="text-4xl font-bold tracking-tight text-gray-900">
              {slice.primary.title}
            </h1>
          </div>
          {/* Image gallery */}
          <Tab.Group as="div" className="flex flex-col-reverse">
            {/* Image selector */}
            <div className="mx-auto mt-6 hidden w-full max-w-2xl sm:block lg:max-w-none">
              <Tab.List className="grid grid-cols-2 gap-6">
                {slice.items.map((image, i) => (
                  <Tab
                    key={`gallery-image-${i}`}
                    className="relative flex h-48 cursor-pointer items-center justify-center rounded-lg bg-white text-sm font-medium uppercase text-gray-900 hover:bg-gray-50 focus:outline-none"
                  >
                    {({ selected }) => (
                      <>
                        <span className="absolute inset-0 overflow-hidden rounded-md">
                          <PrismicNextImage
                            field={image.image}
                            className="h-full w-full object-cover object-center"
                          />
                        </span>
                        <span
                          className={twMerge(
                            selected ? 'ring-accent-500' : 'ring-transparent',
                            'pointer-events-none absolute inset-0 rounded-md ring-2 ring-offset-2'
                          )}
                          aria-hidden="true"
                        />
                      </>
                    )}
                  </Tab>
                ))}
              </Tab.List>
            </div>

            <Tab.Panels className="aspect-h-7 aspect-w-6  w-full">
              {slice.items.map((image, i) => (
                <Tab.Panel key={`panel-image-${i}`}>
                  <PrismicNextImage
                    field={image.image}
                    className="h-full w-full object-cover object-center rounded-lg"
                  />
                </Tab.Panel>
              ))}
            </Tab.Panels>
          </Tab.Group>

          {/* Product info */}
          <div className="mt-10 px-4 sm:mt-16 sm:px-0 lg:mt-0">
            <p className="block sm:hidden lg:block text-4xl font-bold tracking-tight text-gray-900">
              {slice.primary.title}
            </p>

            <div className="mt-6">
              <h3 className="sr-only">Description</h3>

              <RichText field={slice.primary.description} />
            </div>

            {product.active ? (
              <form className="mt-8">
                <div className="flex justify-between items-center">
                  <div>
                    <label
                      htmlFor="quantity-input"
                      className="font-dmsans block mb-2 text-base text-gray-900"
                    >
                      Quantity:
                    </label>
                    <div className="relative flex items-center max-w-[8rem]">
                      <button
                        type="button"
                        id="decrement-button"
                        className="bg-white hover:bg-gray-100 border border-gray-200 rounded-s-lg p-3 h-9 focus:ring-inset focus:ring-gray-100 focus:ring-2 focus:outline-none"
                        onClick={decrementQuantity}
                      >
                        <Minus
                          className="w-3.5 h-3 text-gray-900"
                          aria-hidden="true"
                          viewBox="0 0 24 24"
                        />
                      </button>
                      <input
                        type="text"
                        id="quantity-input"
                        className="bg-white border-x-0 border-gray-200 h-9 text-center text-gray-900 text-sm focus:ring-inset focus:ring-accent-500 focus:border-accent-500 block w-full py-2.5"
                        placeholder="1"
                        value={quantity}
                        onChange={handleQuantityChange}
                        required
                        disabled
                      />
                      <button
                        type="button"
                        id="increment-button"
                        className="bg-white hover:bg-gray-100 border border-gray-200 rounded-e-lg p-3 h-9 focus:ring-inset focus:ring-gray-100 focus:ring-2 focus:outline-none"
                        onClick={incrementQuantity}
                      >
                        <Plus
                          className="w-3 h-3 text-gray-900"
                          aria-hidden="true"
                          viewBox="0 0 24 24"
                        />
                      </button>
                    </div>
                  </div>
                  <p className="text-3xl font-semibold text-gray-900">
                    {formatCurrency(product.price)}
                  </p>
                </div>
                <div className="mt-8 flex flex-col gap-2">
                  <ButtonSolid
                    type="button"
                    variant="accent"
                    size="lg"
                    className="flex w-full flex-1 items-center justify-center py-2"
                    onClick={addToCart}
                  >
                    {loading ? 'Adding to Cart...' : 'Add to Cart'}
                  </ButtonSolid>
                  {error && (
                    <p className="font-dmsans text-sm text-red-500">
                      {slice.primary.error_text ??
                        'Unable to add to cart. Please try again later.'}
                    </p>
                  )}
                </div>
              </form>
            ) : (
              <div className="mt-8 flex">
                <ButtonSolid
                  type="button"
                  variant="gray"
                  size="lg"
                  className="flex w-full flex-1 items-center justify-center py-2 disabled:text-white"
                  disabled
                >
                  Unavailable
                </ButtonSolid>
              </div>
            )}

            <section aria-labelledby="details-heading" className="mt-10">
              <h2
                id="details-heading"
                className="font-dmsans text-2xl text-gray-900 font-semibold"
              >
                Product Details
              </h2>

              <div className="mt-6 divide-y divide-gray-200 border-t border-b">
                {features.map((feature) => (
                  <Disclosure as="div" key={feature.title}>
                    {({ open }) => (
                      <>
                        <h3>
                          <Disclosure.Button className="group relative flex w-full items-center justify-between py-4 text-left">
                            <span className="text-gray-900 text-base font-medium">
                              {feature.title}
                            </span>
                            <span className="ml-6 flex items-center">
                              {open ? (
                                <MinusIcon
                                  className="block h-6 w-6 text-accent-400 group-hover:text-accent-500"
                                  aria-hidden="true"
                                />
                              ) : (
                                <PlusIcon
                                  className="block h-6 w-6 text-gray-400 group-hover:text-accent-500"
                                  aria-hidden="true"
                                />
                              )}
                            </span>
                          </Disclosure.Button>
                        </h3>
                        <Disclosure.Panel
                          as="div"
                          className="prose prose-sm pb-6"
                        >
                          <RichText field={feature.content} />
                        </Disclosure.Panel>
                      </>
                    )}
                  </Disclosure>
                ))}
              </div>
            </section>
          </div>
        </div>
      </div>
    </section>
  );
};

export default ProductDetails;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Checkout/index.tsx

import { cookies } from 'next/headers';
import { ShopCartDocument } from 'prismicio-types';

import { CartInclude } from '@/app/shared/types';
import { createClient } from '@/prismicio';
import { cartPriceReturn } from '@/utils/ecommerce/cartUtils';
import { getBaseUrl } from '@/utils/getBaseUrl';
import { getProductContentForCart } from '@/utils/helpers/helpers';
import { PrismicCustomType } from '@/utils/prismic/enums';
import { UserEventNames } from '@/utils/user-events/enums';
import UserEventsClient from '@/utils/user-events/user-events-client';
import { User } from '@prisma/client';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import CheckoutSliceWrapper from './components/checkout-slice-wrapper';
import NoItemsView from './components/no-items-view';

/**
 * Props for `Checkout`.
 */
export type CheckoutProps = SliceComponentProps<Content.CheckoutSlice> & {
  context: {
    user: User;
  };
};

const getCart = async () => {
  const res = await fetch(`${getBaseUrl()}/api/ecommerce/cart`, {
    method: 'GET',
    headers: { Cookie: cookies().toString() },
    cache: 'no-store',
  });
  return (await res.json()) as CartInclude;
};

const getCartPrice = async () => {
  const res = await fetch(`${getBaseUrl()}/api/ecommerce/cart/price`, {
    method: 'GET',
    headers: { Cookie: cookies().toString() },
    cache: 'no-store',
  });
  return (await res.json()) as cartPriceReturn;
};

const getCartContent = async () => {
  const client = createClient();
  return client.getSingle<ShopCartDocument>(PrismicCustomType.SHOPCART);
};

/**
 * Component for "Checkout" Slices.
 */
const Checkout = async (p: CheckoutProps): Promise<JSX.Element> => {
  const [cart, cartPrice, cartContent] = await Promise.all([
    getCart(),
    getCartPrice(),
    getCartContent(),
  ]);

  const productContent = await getProductContentForCart(cart);

  const hasItems =
    cart.cartProducts.length > 0 || cart.cartSubscriptionProducts.length > 0;

  await UserEventsClient.addEvent(
    p.context.user,
    UserEventNames.DERMI_CHECKOUT_STARTED,
    {}
  );

  return hasItems ? (
    <div
      data-slice-type={p.slice.slice_type}
      data-slice-variation={p.slice.variation}
      className="mx-auto w-full max-w-lg pb-16 md:pt-10 flex flex-col gap-y-6 lg:flex-row-reverse lg:overflow-hidden lg:max-w-6xl lg:px-8 lg:gap-x-4 p-4"
    >
      <CheckoutSliceWrapper
        slice={p.slice}
        user={p.context.user}
        cart={cart}
        cartPrice={cartPrice}
        productsContent={productContent}
      />
    </div>
  ) : (
    <NoItemsView {...p} />
  );
};

export default Checkout;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Checkout/components/no-items-view.tsx

import React from 'react';

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { RichText } from '@/app/shared/components/text/rich-text';
import { ShoppingBagIcon } from '@heroicons/react/24/outline';

import { CheckoutProps } from '..';

const NoItemsView: React.FC<CheckoutProps> = (p) => {
  return (
    <div className="flex flex-col items-center text-center py-24 px-4">
      <ShoppingBagIcon className="mx-auto h-12 w-12 text-gray-400" />

      <p className="mt-3 font-dmsans font-medium text-lg sm:text-2xl text-gray-900">
        {p.slice.primary.no_items_title}
      </p>
      <RichText
        className="mt-1 font-dmsans text-sm sm:text-md text-gray-600 max-w-sm"
        field={p.slice.primary.no_items_description}
      />
      <div className="mt-6">
        <CustomPrismicLink
          field={p.slice.primary.no_items_cta_link}
          variant="solid-accent"
          className="py-2 text-sm"
        >
          {p.slice.primary.no_items_cta_link_text}
        </CustomPrismicLink>
      </div>
    </div>
  );
};

export default NoItemsView;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Checkout/components/checkout-slice-wrapper.tsx

'use client';

import { useRouter, useSearchParams } from 'next/navigation';
import { CheckoutSlice, ProductPageDocument } from 'prismicio-types';
import React from 'react';

import CheckoutModule from '@/app/shared/components/checkout/checkout-module';
import { CartInclude } from '@/app/shared/types';
import { cartPriceReturn } from '@/utils/ecommerce/cartUtils';
import { User } from '@prisma/client';

export interface ICheckoutSliceProps {
  slice: CheckoutSlice;
  user: User;
  cart: CartInclude;
  cartPrice: cartPriceReturn;
  productsContent: ProductPageDocument[];
}

/**
 * Component for "Checkout" Slices.
 */
const CheckoutSliceWrapper: React.FC<ICheckoutSliceProps> = (p) => {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [isPending, startTransition] = React.useTransition();

  const startRefresh = () => {
    startTransition(() => router.refresh());
  };

  const handleRedirect = () => {
    startRefresh();
    const redirectUrlParam = searchParams.get('redirect_url');
    const redirectUrl = redirectUrlParam
      ? decodeURIComponent(redirectUrlParam)
      : p.slice.primary.on_submit_redirect_link;

    router.push(redirectUrl ?? '/shop/order-confirmation');
  };

  return (
    <CheckoutModule
      user={p.user}
      cart={p.cart}
      cartPrice={p.cartPrice}
      productsContent={p.productsContent}
      startRefresh={startRefresh}
      isRefreshing={isPending}
      onSuccess={() => {
        handleRedirect();
      }}
      disableConsultationRemove={false}
    />
  );
};

export default CheckoutSliceWrapper;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BeforeAfterImages/index.tsx

import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import DefaultBeforeAfter from './variants/DefaultBeforeAfter';
import TretinoinBeforeAfter from './variants/Tretinoin';

/**
 * Props for `BeforeAfterImages`.
 */
export type BeforeAfterImagesProps =
  SliceComponentProps<Content.BeforeAfterImagesSlice>;

/**
 * Component for "BeforeAfterImages" Slices.
 */
const BeforeAfterImages = (p: BeforeAfterImagesProps): JSX.Element => {
  if (p.slice.variation === 'tretinoin') {
    return <TretinoinBeforeAfter {...p} />;
  }

  return <DefaultBeforeAfter {...p} />;
};

export default BeforeAfterImages;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BeforeAfterImages/variants/Tretinoin.tsx

'use client';

import { Fragment } from 'react';
import {
  ReactCompareSlider,
  ReactCompareSliderImage,
} from 'react-compare-slider';

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { isFilled } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import { PrismicRichText } from '@prismicio/react';

import { BeforeAfterImagesProps } from '..';
import CustomHandle from './CustomHandle';

const TretinoinBeforeAfter: React.FC<BeforeAfterImagesProps> = ({ slice }) => {
  if (slice.variation !== 'tretinoin') {
    return null;
  }

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="pt-16 lg:pt-20 pb-14 px-6 bg-[#f5f5f5]"
    >
      <div className="mx-auto flex flex-col items-center justify-center text-center w-full max-w-6xl">
        <div className="w-full flex flex-row bg-[#CDEBE5] rounded-full px-6 md:px-16">
          <div className="hidden lg:block relative w-1/3">
            <div className="absolute bottom-0 left-0 h-[238px]">
              <PrismicNextImage
                field={slice.primary.title_image}
                className="h-full w-full mix-blend-darken"
              />
            </div>
          </div>
          <div className="w-full px-0 py-3 text-center lg:pb-10 lg:pt-12 lg:w-2/3 lg:pr-10 lg:text-left">
            <PrismicRichText
              field={slice.primary.title}
              components={{
                heading2: ({ children }) => (
                  <h2 className="font-dmsans font-medium text-base text-black tracking-tight md:text-2xl lg:text-3xl lg:leading-10">
                    {children}
                  </h2>
                ),
              }}
            />
          </div>
        </div>
        <div className="mt-14 flex flex-col items-center px-6 max-w-xs gap-4 sm:flex-row sm:gap-4 sm:justify-around sm:w-full sm:max-w-3xl">
          {slice.items.map((item, index) => (
            <Fragment key={`compare-image-${index}`}>
              {isFilled.image(item.before_image) &&
              isFilled.image(item.after_image) ? (
                <ReactCompareSlider
                  className="aspect-square max-w-[176px]"
                  position={33}
                  itemOne={
                    <ReactCompareSliderImage
                      src={item.before_image.url}
                      alt=""
                    />
                  }
                  itemTwo={
                    <ReactCompareSliderImage
                      src={item.after_image.url}
                      alt=""
                    />
                  }
                  handle={<CustomHandle />}
                />
              ) : null}
            </Fragment>
          ))}
        </div>
        <div className="mt-12 sm:max-w-[730px]">
          <PrismicRichText
            field={slice.primary.content}
            components={{
              paragraph: ({ children }) => (
                <p className="font-dmsans text-lg text-black">{children}</p>
              ),
            }}
          />
        </div>
        <CustomPrismicLink
          field={slice.primary.cta_link}
          variant="solid-accent"
          className="mt-10 mx-auto py-2.5 md:text-lg text-black border-0 max-w-xs w-full font-bold"
        >
          {slice.primary.cta_link_text}
        </CustomPrismicLink>
      </div>
    </section>
  );
};

export default TretinoinBeforeAfter;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BeforeAfterImages/variants/CustomHandle.tsx

const CustomHandle: React.FC = () => {
  return (
    <div
      style={{
        backgroundColor: 'rgb(250, 250, 250)',
        cursor: 'e-resize',
        opacity: 0.4,
        zIndex: 2,
        userSelect: 'none',
        position: 'absolute',
        width: '2px',
        height: '100%',
        top: '0px',
        right: '60%',
        overflow: 'visible',
        transform: 'translateX(50%)',
      }}
    >
      <div
        style={{
          position: 'relative',
          width: '100%',
          height: '100%',
        }}
      >
        <div
          style={{
            position: 'absolute',
            width: '32px',
            height: '32px',
            lineHeight: '30px',
            textAlign: 'center',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            borderRadius: '50%',
            backgroundColor: 'rgb(250, 250, 250)',
          }}
        >
          <i
            style={{
              borderStyle: 'solid',
              borderColor: 'rgb(51, 51, 51)',
              borderImage: 'initial',
              borderWidth: '0px 2px 2px 0px',
              display: 'inline-block',
              padding: '3px',
              transform: 'rotate(135deg)',
            }}
          ></i>
          <i
            style={{
              borderStyle: 'solid',
              borderColor: 'rgb(51, 51, 51)',
              borderImage: 'initial',
              borderWidth: '2px 0px 0px 2px',
              display: 'inline-block',
              padding: '3px',
              transform: 'rotate(135deg)',
            }}
          ></i>
        </div>
      </div>
    </div>
  );
};

export default CustomHandle;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BeforeAfterImages/variants/DefaultBeforeAfter.tsx

'use client';

import { Fragment } from 'react';
import {
  ReactCompareSlider,
  ReactCompareSliderImage,
} from 'react-compare-slider';

import { isFilled } from '@prismicio/client';

import { BeforeAfterImagesProps } from '..';
import CustomHandle from './CustomHandle';

const DefaultBeforeAfter: React.FC<BeforeAfterImagesProps> = ({ slice }) => {
  if (slice.variation !== 'default') {
    return null;
  }

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="py-6 bg-white"
    >
      <div className="bg-white py-4">
        <div className="mx-auto max-w-3xl px-6 lg:px-8">
          <h2 className="font-financier text-[#263a61] text-4xl font-semibold sm:text-6xl text-center">
            {slice.primary.title}
          </h2>
          <dl className="mt-8 grid gap-6 overflow-hidden rounded-2xl text-center grid-cols-1 sm:grid-cols-[1fr_1fr_1fr] font-dmsans">
            <div
              key={slice.primary.stat_1_title}
              className="mx-auto flex max-w-xs flex-col gap-y-1 px-2"
            >
              <dt className="font-light text-base text-[#263a61]">
                {slice.primary.stat_1_subtitle}
              </dt>
              <dd className="order-first font-semibold text-2xl sm:text-4xl lg:text-[42px] text-[#263a61]">
                {slice.primary.stat_1_title}
              </dd>
            </div>
            <div
              key={slice.primary.stat_2_title}
              className="mx-auto flex max-w-xs flex-col gap-y-1 border-x-0 sm:border-x border-[#263a61] px-2 sm:px-8 lg:px-12"
            >
              <dt className="font-light text-base text-[#263a61]">
                {slice.primary.stat_2_subtitle}
              </dt>
              <dd className="order-first font-semibold text-2xl sm:text-4xl lg:text-[42px] text-[#263a61]">
                {slice.primary.stat_2_title}
              </dd>
            </div>
            <div
              key={slice.primary.stat_3_title}
              className="mx-auto flex max-w-xs flex-col gap-y-1 px-2"
            >
              <dt className="font-light text-base text-[#263a61]">
                {slice.primary.stat_3_subtitle}
              </dt>
              <dd className="order-first font-semibold text-2xl sm:text-4xl lg:text-[42px] text-[#263a61]">
                {slice.primary.stat_3_title}
              </dd>
            </div>
          </dl>
        </div>
      </div>
      <div className="flex flex-col mx-auto px-6 max-w-xs gap-4 sm:flex-row sm:gap-1 sm:max-w-5xl">
        {slice.items.map((item, index) => (
          <Fragment key={`compare-image-${index}`}>
            {isFilled.image(item.before_image) &&
            isFilled.image(item.after_image) ? (
              <ReactCompareSlider
                className="aspect-square"
                position={33}
                itemOne={
                  <ReactCompareSliderImage src={item.before_image.url} alt="" />
                }
                itemTwo={
                  <ReactCompareSliderImage src={item.after_image.url} alt="" />
                }
                handle={<CustomHandle />}
              />
            ) : null}
          </Fragment>
        ))}
      </div>
    </section>
  );
};

export default DefaultBeforeAfter;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/TextBanner/index.tsx

import get from 'lodash.get';

import { Content } from '@prismicio/client';
import {
  JSXMapSerializer,
  PrismicRichText,
  SliceComponentProps,
} from '@prismicio/react';

/**
 * Props for `TextBanner`.
 */
export type TextBannerProps = SliceComponentProps<Content.TextBannerSlice>;

const components: JSXMapSerializer = {
  label: ({ node, children }) => {
    if (node.data.label === 'largeText') {
      return (
        <span className="inline align-middle mx-3 font-dmserif text-4xl leading-7 tracking-tight lg:text-6xl lg:leading-7">
          {children}
        </span>
      );
    }
  },
  paragraph: ({ children }) => (
    <p className="flex-inline flex-row justify-center items-center font-dmsans text-xl leading-7 tracking-tighter font-medium lg:text-2xl lg:leading-7">
      {children}
    </p>
  ),
};

/**
 * Component for "TextBanner" Slices.
 */
const TextBanner = ({ slice }: TextBannerProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      style={{
        backgroundColor: get(slice, 'primary.background_color', '#CDEBE5'),
      }}
      className="text-center px-6 py-8"
    >
      <div style={{ color: get(slice, 'primary.text_color', 'black') }}>
        <PrismicRichText field={slice.primary.text} components={components} />
      </div>
    </section>
  );
};

export default TextBanner;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/HeroSection/index.tsx

import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import CenteredImageHero from './variants/CenteredImageHero';
import DefaultHero from './variants/DefaultHero';
import LeftAlignedHero from './variants/LeftAlignedHero';
import RightAlignedImageHero from './variants/RightAlignedImageHero';
import TretinoinHero from './variants/TretinoinHero';

export enum Variations {
  image = 'default',
  leftAligned = 'leftAligned',
  video = 'heroWithVideo',
  centeredImage = 'heroWithCenteredImage',
  rightAlignedImage = 'rightAlignedImageHero',
  tretinoinHero = 'tretinoinHero',
}

/**
 * Props for `HeroSection`.
 */
export type HeroSectionProps = SliceComponentProps<Content.HeroSectionSlice>;

/**
 * Component for "HeroSection" Slices.
 */
const HeroSection = ({ slice }: HeroSectionProps): JSX.Element => {
  switch (slice.variation) {
    case Variations.leftAligned:
      return <LeftAlignedHero slice={slice} />;
    case Variations.centeredImage:
      return <CenteredImageHero slice={slice} />;
    case Variations.video:
    case Variations.image:
      return <DefaultHero slice={slice} />;
    case Variations.rightAlignedImage:
      return <RightAlignedImageHero slice={slice} />;
    case Variations.tretinoinHero:
      return <TretinoinHero slice={slice} />;
    default:
      return <></>;
  }
};

export default HeroSection;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/HeroSection/variants/LeftAlignedHero.tsx

import Image from 'next/image';

import PrismicNextLink from '@components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';

/**
 * Props for `LeftAlignedHero`.
 */
export type LeftAlignedHeroProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.HeroSectionSliceLeftAligned;

/**
 * Component for "LeftAlignedHero" Slices.
 */
const LeftAlignedHero = ({
  slice,
}: {
  slice: LeftAlignedHeroProps;
}): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="relative px-6 py-32 sm:px-12 sm:py-40 max-h-[620px] lg:px-16 lg:max-h-[620px]">
        <div className="absolute inset-0 overflow-hidden">
          {slice.primary.background_image && (
            <PrismicNextImage
              field={slice.primary.background_image}
              alt=""
              className="hidden sm:block h-full w-full object-cover object-center"
            />
          )}
          {slice.primary.background_image_mobile && (
            <PrismicNextImage
              field={slice.primary.background_image_mobile}
              alt=""
              className="block sm:hidden h-full w-full object-cover object-center"
            />
          )}
        </div>
        <div
          aria-hidden="true"
          className="absolute inset-0 bg-gray-900 bg-opacity-0"
        />
        <div className="relative mx-auto flex max-w-[900px] flex-col">
          <div className="flex max-w-[535px] flex-col">
            <h1
              className="font-financier mb-6 text-4xl font-semibold tracking-[-0.6px] sm:text-6xl sm:leading-[60px]"
              style={{
                color: slice.primary.title_color ?? '#263A61',
              }}
            >
              {slice.primary.title}
            </h1>
            <p
              className="font-dmsans text-sm font-medium tracking-[3.5px]"
              style={{
                color: slice.primary.list_header_color ?? '#fff',
              }}
            >
              {slice.primary.list_header}
            </p>
            <div className="mt-4 columns-1 space-y-3 sm:columns-2 w-full max-w-[400px] text-sm">
              {slice.items.map((item) => (
                <div key={item.list_item} className="relative pl-7">
                  <div
                    className="font-dmsans inline font-bold align-middle"
                    style={{ color: slice.primary.list_item_color ?? '#fff' }}
                  >
                    {slice.primary.list_item_icon.url && (
                      <Image
                        src={slice.primary.list_item_icon.url}
                        alt=""
                        className="absolute left-0 top-0"
                        width={slice.primary.list_item_icon.dimensions.width}
                        height={slice.primary.list_item_icon.dimensions.height}
                      />
                    )}
                    {item.list_item}
                  </div>
                </div>
              ))}
            </div>
            <div className="flex flex-col sm:flex-row gap-4 items-center mt-6">
              {slice.primary.primary_cta_text && (
                <PrismicNextLink
                  field={slice.primary.primary_cta}
                  className="block w-full max-w-[234px] text-center rounded-md border border-transparent p-2 text-base font-medium"
                  style={{
                    color: slice.primary.primary_cta_text_color ?? '#fff',
                    backgroundColor:
                      slice.primary.primary_cta_color ?? '#263A61',
                  }}
                >
                  {slice.primary.primary_cta_text}
                </PrismicNextLink>
              )}
              {slice.primary.secondary_cta_text && (
                <PrismicNextLink
                  field={slice.primary.secondary_cta}
                  className="block w-full text-base underline text-center sm:text-start sm:w-auto"
                  style={{
                    color: slice.primary.secondary_cta_text_color ?? '#263A61',
                  }}
                >
                  {slice.primary.secondary_cta_text}
                </PrismicNextLink>
              )}
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default LeftAlignedHero;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/HeroSection/variants/CenteredImageHero.tsx

import { Content } from '@prismicio/client';

/**
 * Props for `CenteredImageHero`.
 */
export type CenteredImageHeroProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.HeroSectionSliceHeroWithCenteredImage;

/**
 * Component for "CenteredImageHero" Slices.
 */
const CenteredImageHero = ({
  slice,
}: {
  slice: CenteredImageHeroProps;
}): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="relative bg-gray-800 px-6 py-32 sm:px-12 sm:py-40 lg:px-16 h-[628px]">
        <div className="absolute inset-0 overflow-hidden">
          <div
            className="hidden sm:block h-full object-center bg-no-repeat bg-center"
            style={{
              backgroundImage: `url(${slice.primary.center_image?.url}), linear-gradient(#eafbff,#dfebee)`,
              backgroundPosition: '55% 100%, 0 0',
              backgroundRepeat: 'no-repeat,repeat',
              backgroundSize: '700px, auto',
            }}
          />
          <div
            className="block sm:hidden h-[628px] object-center bg-no-repeat bg-center"
            style={{
              backgroundImage: `url(${slice.primary.center_image_mobile?.url}), linear-gradient(#eafbff,#dfebee)`,
              backgroundPosition: '50% 100%, 0 0',
              backgroundRepeat: 'no-repeat,repeat',
              backgroundSize: '393px, auto',
            }}
          />
        </div>
      </div>
    </section>
  );
};

export default CenteredImageHero;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/HeroSection/variants/DefaultHero.tsx

import PrismicNextLink from '@components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicLink } from '@prismicio/react';

import { Variations } from '..';

/**
 * Props for `DefaultHero`.
 */

type SliceProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
};

type DefaultHeroProps =
  | (SliceProps & Content.HeroSectionSliceHeroWithVideo)
  | (SliceProps & Content.HeroSectionSliceDefault);

const PrimaryCTA: React.FC<{ slice: DefaultHeroProps }> = ({ slice }) => {
  return slice.primary.primary_cta_text ? (
    <PrismicNextLink
      field={slice.primary.primary_cta}
      className="mt-8 block w-full max-w-[320px] rounded-md border border-transparent p-2 text-base font-medium text-primary-950"
      style={{
        color: slice.primary.primary_cta_text_color ?? 'black',
        backgroundColor: slice.primary.primary_cta_color ?? '#fff',
      }}
    >
      {slice.primary.primary_cta_text}
    </PrismicNextLink>
  ) : null;
};

const SecondaryCTA: React.FC<{ slice: DefaultHeroProps }> = ({ slice }) => {
  return slice.primary.secondary_cta_text ? (
    <PrismicNextLink
      field={slice.primary.secondary_cta}
      className="mt-2 block w-full text-base underline sm:w-auto"
      style={{
        color: slice.primary.secondary_cta_text_color ?? '#fff',
      }}
    >
      {slice.primary.secondary_cta_text}
    </PrismicNextLink>
  ) : null;
};

/**
 * Component for "DefaultHero" Slices.
 */
const DefaultHero = ({ slice }: { slice: DefaultHeroProps }): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="relative bg-gray-800 px-6 py-20">
        <div className="absolute inset-0 overflow-hidden">
          {slice.variation === Variations.video && (
            <PrismicLink
              field={slice.primary.background_video}
              externalComponent={(props) => (
                <video
                  src={props.href}
                  className="h-full w-full object-cover object-center brightness-75"
                  autoPlay={true}
                  muted={true}
                  playsInline={true}
                  loop={true}
                />
              )}
            />
          )}
          {slice.variation === Variations.image && (
            <div
              className="h-full w-full object-cover object-center bg-no-repeat bg-cover bg-center brightness-75"
              style={{
                backgroundImage: `url(${slice.primary.background_image?.url})`,
              }}
            />
          )}
        </div>
        <div
          aria-hidden="true"
          className="absolute inset-0 bg-gray-900 bg-opacity-0"
        />
        <div className="relative mx-auto flex max-w-[900px] flex-col items-center text-center">
          <p
            className="mb-6 text-sm font-bol tracking-[4px]"
            style={{ color: slice.primary.eyebrow_color ?? '#fff' }}
          >
            {slice.primary.eyebrow}
          </p>
          <h1
            className="font-financier text-5xl font-medium tracking-tight sm:text-7xl"
            style={{ color: slice.primary.title_color ?? '#fff' }}
          >
            {slice.primary.title}
          </h1>
          <p
            className="mt-3 text-2xl"
            style={{ color: slice.primary.subtitle_color ?? '#fff' }}
          >
            {slice.primary.subtitle}
          </p>
          <PrimaryCTA slice={slice} />
          <SecondaryCTA slice={slice} />
        </div>
      </div>
    </section>
  );
};

export default DefaultHero;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/HeroSection/variants/RightAlignedImageHero.tsx

import get from 'lodash.get';

import { Content, isFilled } from '@prismicio/client';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';
import { JSXMapSerializer, PrismicRichText } from '@prismicio/react';

/**
 * Props for `CenteredImageHero`.
 */
export type RightAlignedImageHeroProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.HeroSectionSliceRightAlignedImageHero;

const richTextComponents: JSXMapSerializer = {
  heading1: ({ children }) => (
    <h1 className="font-dmsans font-medium text-4xl tracking-tight text-white max-w-[240px] sm:max-w-[440px] lg:max-w-[615px] mb-6 lg:text-[2.75rem] lg:leading-[1.2]">
      {children}
    </h1>
  ),
  paragraph: ({ children }) => (
    <p className="font-dmsans text-lg text-gray-200 max-w-[240px] sm:max-w-[440px] lg:max-w-[480px] md:text-2xl">
      {children}
    </p>
  ),
};

/**
 * Component for "CenteredImageHero" Slices.
 */
const RightAlignedImageHero = ({
  slice,
}: {
  slice: RightAlignedImageHeroProps;
}): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      style={{
        backgroundImage: `linear-gradient(${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
      }}
      className=""
    >
      <div className="lg:pt-10 relative mx-auto max-w-8xl">
        <div className="absolute inset-0 lg:top-10 overflow-hidden pb-16 md:pb-0">
          <PrismicNextImage
            field={slice.primary.image}
            alt=""
            className="block h-full w-full object-cover object-[60%] opacity-80 sm:object-[50%] md:opacity-100 md:object-center"
          />
        </div>
        <div
          aria-hidden="true"
          className="absolute inset-0 bg-gray-900 bg-opacity-0"
        />
        <div className="relative flex flex-col pt-32 pb-10 px-6 sm:pb-16 lg:px-24 sm:pt-40">
          <div className="flex flex-col">
            <PrismicRichText
              field={slice.primary.content}
              components={richTextComponents}
            />
            <div className="flex flex-col sm:flex-row gap-4 mt-10">
              {isFilled.link(slice.primary.primary_cta) && (
                <PrismicNextLink
                  field={slice.primary.primary_cta}
                  className="font-dmsans block text-center rounded-lg border border-transparent py-2 sm:py-3 px-14 text-base font-semibold"
                  style={{
                    color: slice.primary.primary_cta_text_color ?? '#fff',
                    backgroundColor:
                      slice.primary.primary_cta_color ?? '#263A61',
                  }}
                >
                  {slice.primary.primary_cta_text}
                </PrismicNextLink>
              )}
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default RightAlignedImageHero;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/HeroSection/variants/TretinoinHero.tsx

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';

/**
 * Props for `CenteredImageHero`.
 */
export type TretinoinHeroProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.HeroSectionSliceTretinoinHero;

/**
 * Component for "CenteredImageHero" Slices.
 */
const TretinoinHero = ({
  slice,
}: {
  slice: TretinoinHeroProps;
}): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      {/* MOBILE */}
      <div className="block lg:hidden relative isolate overflow-hidden pt-20">
        <PrismicNextImage
          field={slice.primary.background_image}
          alt=""
          className="absolute inset-0 object-none object-[50%_0] -z-10 h-full w-full aspect-[11/5]"
        />
        <div className="flex flex-col items-center justify-center text-center px-8">
          <figure>
            <div className="relative">
              <svg
                width="33"
                height="31"
                viewBox="0 0 70 65"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                className="-z-10 mx-auto"
              >
                <path
                  opacity="0.4"
                  d="M26.0308 36.6979V65H0V42.6563C0 30.559 1.43866 21.8021 4.31599 16.3854C8.09249 9.16319 14.0719 3.70139 22.2543 0L28.1888 9.47917C23.2434 11.5556 19.6018 14.6701 17.264 18.8229C14.9261 22.8854 13.6224 28.8438 13.3526 36.6979H26.0308ZM67.842 36.6979V65H41.8112V42.6563C41.8112 30.559 43.2498 21.8021 46.1272 16.3854C49.9037 9.16319 55.8831 3.70139 64.0655 0L70 9.47917C65.0546 11.5556 61.413 14.6701 59.0751 18.8229C56.7373 22.8854 55.4335 28.8438 55.1638 36.6979H67.842Z"
                  fill="#15AD98"
                />
              </svg>
              <blockquote className="mt-2 font-dmsans font-medium tracking-tight text-black text-xl sm:text-2xl max-w-xl">
                <p>{slice.primary.quote}</p>
              </blockquote>
            </div>
          </figure>
          <div className="mt-6">
            <CustomPrismicLink
              field={slice.primary.cta_link}
              variant="solid-accent"
              className="text-black w-full text-sm py-2 px-10 border-0 font-bold"
            >
              {slice.primary.cta_link_text}
            </CustomPrismicLink>
          </div>
          <p className="font-dmsans mt-6 max-w-sm text-[7px] sm:text-[9px] sm:max-w-md italic text-gray-600">
            {slice.primary.small_text}
          </p>
          <div className="relative block w-[342px] h-[235px] ml-14 mt-3 overflow-hidden">
            <PrismicNextImage
              field={slice.primary.mobile_image}
              className="mx-auto"
              width={342}
              height={235}
              alt=""
            />
          </div>
        </div>
      </div>

      {/* DESKTOP */}
      <div className="hidden relative isolate overflow-hidden pt-24 lg:block">
        <PrismicNextImage
          field={slice.primary.background_image}
          alt=""
          className="absolute inset-0 -z-10 h-full w-full aspect-[11/5] max-h-[707px]"
        />
        <div className="flex items-end justify-center mx-auto max-w-screen-2xl px-0">
          <PrismicNextImage
            field={slice.primary.desktop_image_left}
            className="w-auto -mr-[3%] max-h-[433px] xl:max-h-[577px]"
            alt=""
          />
          <div className="max-w-lg xl:max-w-[610px] self-center">
            <figure>
              <div className="relative">
                <svg
                  viewBox="0 0 70 65"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  className="absolute -z-10 w-auto h-10 -top-4 xl:h-[65px] xl:-top-8"
                >
                  <path
                    opacity="0.4"
                    d="M26.0308 36.6979V65H0V42.6563C0 30.559 1.43866 21.8021 4.31599 16.3854C8.09249 9.16319 14.0719 3.70139 22.2543 0L28.1888 9.47917C23.2434 11.5556 19.6018 14.6701 17.264 18.8229C14.9261 22.8854 13.6224 28.8438 13.3526 36.6979H26.0308ZM67.842 36.6979V65H41.8112V42.6563C41.8112 30.559 43.2498 21.8021 46.1272 16.3854C49.9037 9.16319 55.8831 3.70139 64.0655 0L70 9.47917C65.0546 11.5556 61.413 14.6701 59.0751 18.8229C56.7373 22.8854 55.4335 28.8438 55.1638 36.6979H67.842Z"
                    fill="#15AD98"
                  />
                </svg>
                <blockquote className="font-dmsans font-medium tracking-tight text-black text-2xl pl-14 xl:pl-20 xl:text-3xl">
                  <p>{slice.primary.quote}</p>
                </blockquote>
              </div>
            </figure>
            <div className="mt-6 xl:mt-12 flex items-center justify-center gap-x-6">
              <CustomPrismicLink
                field={slice.primary.cta_link}
                variant="solid-accent"
                className="text-black w-full max-w-xs border-0 lg:text-lg font-bold"
              >
                {slice.primary.cta_link_text}
              </CustomPrismicLink>
            </div>
            <p className="font-dmsans mt-12 mx-auto max-w-sm text-[9px] xl:text-xs xl:max-w-[474px] italic text-gray-600 text-center">
              {slice.primary.small_text}
            </p>
          </div>
          <PrismicNextImage
            field={slice.primary.desktop_image_right}
            className="pb-3 -ml-[10%] w-auto lg:max-h-[375px] xl:max-h-[500px] aspect-square"
            alt=""
          />
        </div>
      </div>
    </section>
  );
};

export default TretinoinHero;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Faqs/index.tsx

'use client';

import get from 'lodash.get';
import { twMerge } from 'tailwind-merge';

import { Disclosure } from '@headlessui/react';
import { ChevronDownIcon } from '@heroicons/react/24/outline';
import { Content } from '@prismicio/client';
import { PrismicRichText, SliceComponentProps } from '@prismicio/react';

/**
 * Props for `Faqs`.
 */
export type FaqsProps = SliceComponentProps<Content.FaqsSlice>;

/**
 * Component for "Faqs" Slices.
 */
const Faqs = ({ slice }: FaqsProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      style={{
        backgroundImage: `linear-gradient(${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
      }}
    >
      <div className="mx-auto max-w-7xl px-6 py-14 lg:px-8 lg:py-16">
        <div className="mx-auto max-w-4xl">
          <h2
            className="text-6xl font-financier font-bold leading-10 tracking-tight text-center"
            style={{ color: get(slice, 'primary.title_color', 'white') }}
          >
            {slice.primary.title}
          </h2>
          <dl className="mt-8 pb-6 space-y-6 divide-y divide-white/10">
            {slice.items.map((faq) => (
              <Disclosure
                as="div"
                key={faq.question}
                className="pt-6 px-2 lg:px-6"
              >
                {({ open }) => (
                  <>
                    <dt
                      style={{
                        color: get(slice, 'primary.faq_color', 'white'),
                      }}
                    >
                      <Disclosure.Button className="font-dmsans flex w-full items-start justify-between text-left">
                        <span className="text-xl leading-7">
                          {faq.question}
                        </span>
                        <span className="ml-6 mr-2 flex h-7 items-center">
                          <ChevronDownIcon
                            className={twMerge(
                              open ? 'h-5 w-5 rotate-180' : '',
                              'h-5 w-5'
                            )}
                            aria-hidden="true"
                          />
                        </span>
                      </Disclosure.Button>
                    </dt>
                    <Disclosure.Panel
                      as="dd"
                      className="mt-4 pr-12 font-dmsans text-base"
                      style={{
                        color: get(slice, 'primary.faq_color', 'white'),
                      }}
                    >
                      <PrismicRichText field={faq.answer} />
                    </Disclosure.Panel>
                  </>
                )}
              </Disclosure>
            ))}
          </dl>
        </div>
      </div>
    </section>
  );
};

export default Faqs;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/FooterGroup/index.tsx

import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `FooterGroup`.
 */
export type FooterGroupProps = SliceComponentProps<Content.FooterGroupSlice>;

/**
 * Component for "FooterGroup" Slices.
 */
const FooterGroup = ({ slice }: FooterGroupProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      Placeholder component for footer_group (variation: {slice.variation})
      Slices
    </section>
  );
};

export default FooterGroup;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountCtaSection/index.tsx

import { AccountPageContext } from '@/app/shared/types';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import DefaultCTASection from './variants/DefaultCtaSection';
import FeaturedImage from './variants/FeaturedImage';
import ImageCtaSection from './variants/ImageCtaSection';
import ImageTitleCta from './variants/ImageTitleCta';
import ProductListCta from './variants/ProductListCta';
import ProductCards from './variants/ProductsCards';
import TwoColumnGrid from './variants/TwoColumnGrid';
import TwoColumnWithImage from './variants/TwoColumnWithImage';

/**
 * Props for `AccountCtaSection`.
 */
export type AccountCtaSectionProps = SliceComponentProps<
  Content.MessagingCtaSectionSlice,
  AccountPageContext
>;

const componentMap: { [variation: string]: any } = {
  default: DefaultCTASection,
  ctaWithImage: ImageCtaSection,
  twoColumnGrid: TwoColumnGrid,
  imageTitleCta: ImageTitleCta,
  twoColumnWithImage: TwoColumnWithImage,
  productCards: ProductCards,
  productListCta: ProductListCta,
  featuredImage: FeaturedImage,
};

/**
 * Component for "AccountCtaSection" Slices.
 */
const AccountCtaSection = ({
  slice,
  context,
}: AccountCtaSectionProps): JSX.Element => {
  const Component = componentMap?.[slice.variation];

  if (Component) {
    return <Component {...slice} context={context} />;
  }
  return <></>;
};

export default AccountCtaSection;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountCtaSection/variants/DefaultCtaSection.tsx

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicRichText } from '@prismicio/react';

/**
 * Props for `DefaultCTASection`.
 */
export type DefaultCTASectionProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.MessagingCtaSectionSliceDefault;

/**
 * Component for "MessagingCtaSection" Slices.
 */
const DefaultCTASection = (slice: DefaultCTASectionProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="max-w-5xl mx-auto my-4 lg:mx-0">
        <div className="bg-gray-100 mx-3 sm:mx-5 rounded-xl">
          <div className="p-6">
            <p className="font-dmsans text-accent-700 font-medium text-sm mb-3">
              {slice.primary.eyebrow}
            </p>
            <h2 className="font-financier text-3xl font-semibold tracking-tight text-accent-950 sm:text-4xl mb-3">
              {slice.primary.title}
            </h2>
            <div className="font-dmsans text-gray-600 text-lg">
              <PrismicRichText field={slice.primary.content} />
            </div>
            <div className="mt-8 flex items-center gap-x-6">
              <CustomPrismicLink
                field={slice.primary.cta_link}
                className="border border-gray-300 font-dmsans py-2 px-4 bg-white rounded-lg text-base text-gray-700 font-semibold hover:bg-gray-50 transition duration-150 ease-in-out"
              >
                {slice.primary.cta_button_text}
              </CustomPrismicLink>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default DefaultCTASection;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountCtaSection/variants/ProductsCards.tsx

import get from 'lodash.get';

import { Content } from '@prismicio/client';
import { PrismicImage } from '@prismicio/react';

import CustomCTA from './CustomCTA';

/**
 * Props for `ImageTitleCta`.
 */
export type ProductCardsProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.MessagingCtaSectionSliceProductCards;

const ProductCards = (slice: ProductCardsProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      style={{
        backgroundImage: `linear-gradient(180deg, ${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )} 0%, ${get(
          slice,
          'primary.background_color_end',
          '#FFFFFF'
        )} 123.83%)`,
      }}
    >
      <div className="max-w-6xl mx-auto lg:mx-0">
        <div className="max-w-4xl mx-auto pt-8 px-8 pb-24">
          <div className="relative">
            <div
              className="absolute inset-0 flex items-center"
              aria-hidden="true"
            >
              <div className="w-full border-t border-gray-200" />
            </div>
            <div className="relative flex justify-center">
              <span
                className="font-dmsans px-3 text-xl sm:text-2xl font-semibold leading-6 text-black"
                style={{
                  color: get(slice, 'primary.divider_color', '#000000'),
                  backgroundColor: get(
                    slice,
                    'primary.background_color_start',
                    '#FFFFFF'
                  ),
                }}
              >
                {slice.primary.divider_text}
              </span>
            </div>
          </div>
          <div className="mx-auto justify-items-center grid max-w-2xl grid-cols-1 items-start gap-x-8 gap-y-16 pt-14 lg:mx-0 lg:max-w-none lg:grid-cols-2">
            {slice.items.map((card, index) => (
              <div
                key={`${card.header_text}-${index}`}
                className="w-full h-full flex max-w-lg flex-col items-start justify-between border border-gray-200 rounded-lg"
                style={{
                  boxShadow:
                    '0px 27.911px 55.822px -13.956px rgba(16, 24, 40, 0.18)',
                }}
              >
                <div className="flex items-center justify-center bg-black w-full rounded-tl-lg rounded-tr-lg">
                  <p className="font-dmsans text-md font-medium text-white py-3">
                    {card.header_text}
                  </p>
                </div>
                <div
                  className="rounded-bl-lg rounded-br-lg w-full flex flex-col h-full"
                  style={{
                    background:
                      'linear-gradient(180deg, rgba(255, 255, 255, 0.40) 37.7%, rgba(214, 235, 229, 0.40) 92.21%), #FFF',
                  }}
                >
                  <div className="group relative py-8 px-12 flex-1">
                    <p className="font-dmsans text-lg text-accent-950 tracking-[2.5px]">
                      {card.eyebrow}
                    </p>
                    <PrismicImage
                      field={card.title_image}
                      className="-ml-1"
                      width={231}
                      height={21}
                    />
                    <p className="mt-5 text-lg font-medium text-gray-600 font-dmsans">
                      {card.description}
                    </p>
                    <p className="text-sm text-gray-600 font-dmsans">
                      {card.description_subtext}
                    </p>
                    <div className="mt-6">
                      <p className="block sm:inline font-dmsans font-medium text-4xl text-black">
                        {card.price}
                        <span className="text-base">{card.price_units}</span>
                      </p>
                      <span className="sm:ml-3 font-dmsans text-base text-gray-600">
                        {card.price_callout}
                      </span>
                    </div>
                  </div>
                  <div className="flex items-center py-4 border-t border-gray-200 justify-center bg-transparent w-full">
                    <CustomCTA
                      actionType={card.cta_action}
                      text={card.cta_link_text}
                      link={card.cta_link}
                      linkStyle={card.cta_link_style}
                    />
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
    </section>
  );
};

export default ProductCards;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountCtaSection/variants/TwoColumnWithImage.tsx

import get from 'lodash.get';
import { twMerge } from 'tailwind-merge';

import { Content } from '@prismicio/client';
import { PrismicImage, PrismicRichText } from '@prismicio/react';

import CustomCTA from './CustomCTA';

/**
 * Props for `ImageTitleCta`.
 */
export type TwoColumnWithImageProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.MessagingCtaSectionSliceTwoColumnWithImage;

const TwoColumnWithImage = (slice: TwoColumnWithImageProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      style={{
        backgroundImage: `linear-gradient(${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
      }}
    >
      <div className="max-w-6xl mx-auto lg:mx-0">
        <div
          className={twMerge(
            'max-w-4xl mx-auto flex py-16 px-8 flex-col-reverse gap-x-10 gap-y-8 items-center md:justify-between',
            slice.primary.alignment === 'image-right'
              ? 'md:flex-row'
              : 'md:flex-row-reverse'
          )}
        >
          <div className="w-full flex-auto max-w-md text-center justify-center md:text-start md:justify-start">
            {slice.primary.header_badge_text && (
              <div className="mb-2 inline-flex items-center rounded-full bg-accent-50 px-3 py-1.5 text-xs font-semibold text-accent-700 ring-1 ring-inset ring-accent-200">
                {slice.primary.header_badge_text}
              </div>
            )}
            <h2
              className="font-dmsans text-2xl font-semibold tracking-tight sm:text-2xl"
              style={{
                color: get(slice, 'primary.title_color', '#ffffff'),
                lineHeight: '2.5rem',
              }}
            >
              {slice.primary.title}
            </h2>
            <div
              className="font-dmsans mt-2 text-lg leading-8 [&_strong]:text-black [&_strong]:text-2xl [&_strong]:-mb-4 [&_strong]:font-normal [&_strong]:block"
              style={{
                color: get(slice, 'primary.content_color', '#ffffff'),
              }}
            >
              <PrismicRichText field={slice.primary.content} />
            </div>
            {slice.primary.cta_button_text && (
              <CustomCTA
                actionType={slice.primary.cta_action}
                text={slice.primary.cta_button_text}
                link={slice.primary.cta_link}
                linkStyle={slice.primary.cta_link_style}
                className="mt-4 px-4 max-w-[320px] mx-auto md:mx-0 md:px-4"
              />
            )}
          </div>

          {/* Image Column */}
          <div
            className={twMerge(
              'mb-4 max-w-none flex-shrink-0 sm:mb-0 sm:mr-4',
              slice.primary.alignment === 'image-right' ? '' : 'md:-ml-6'
            )}
          >
            <PrismicImage
              field={slice.primary.image}
              className="w-full h-auto"
              style={{
                maxWidth: slice.primary.image.dimensions?.width,
                maxHeight: slice.primary.image.dimensions?.height,
              }}
            />
          </div>
        </div>
      </div>
    </section>
  );
};

export default TwoColumnWithImage;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountCtaSection/variants/ImageCtaSection.tsx

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import { PrismicRichText } from '@prismicio/react';

/**
 * Props for `ImageCTASection`.
 */
export type ImageCTASectionProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.MessagingCtaSectionSliceCtaWithImage;

/**
 * Component for "MessagingCtaSection" Slices.
 */
const ImageCTASection = (slice: ImageCTASectionProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="max-w-5xl mx-auto my-4 lg:mx-0">
        <div className="bg-white border border-gray-200 rounded-xl mx-3 sm:mx-5">
          <div className="p-3 sm:p-6 flex flex-col gap-6 items-center sm:flex-row xl:gap-12">
            <div className="w-auto flex-none self-center">
              <PrismicNextImage
                field={slice.primary.image}
                className="sm:aspect-square md:aspect-[7/5] object-cover w-full sm:w-[15rem] md:w-[25rem] max-w-none rounded-xl bg-gray-50 sm:object-cover"
              />
            </div>
            <div className="max-w-sm">
              <p className="font-dmsans text-accent-700 font-medium text-sm mb-3.5">
                {slice.primary.eyebrow}
              </p>
              <div className="font-dmsans text-gray-600 text-md">
                <PrismicRichText field={slice.primary.content} />
              </div>
              <div className="mt-8 flex items-center gap-x-6">
                <CustomPrismicLink
                  field={slice.primary.cta_link}
                  className="border border-gray-300 font-dmsans py-2 px-4 bg-white rounded-lg text-base text-gray-700 font-semibold hover:bg-gray-50 transition duration-150 ease-in-out"
                >
                  {slice.primary.cta_button_text}
                </CustomPrismicLink>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default ImageCTASection;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountCtaSection/variants/ImageTitleCta.tsx

import get from 'lodash.get';
import React from 'react';

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content, isFilled } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';

import CustomCTA from './CustomCTA';

/**
 * Props for `ImageTitleCta`.
 */
export type ImageTitleCtaProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.MessagingCtaSectionSliceImageTitleCta;

const ImageTitleCta: React.FC<ImageTitleCtaProps> = (slice) => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      style={{
        backgroundImage: `linear-gradient(91deg, ${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )} 0.54%, ${get(
          slice,
          'primary.background_color_end',
          '#FFFFFF'
        )} 99.54%)`,
      }}
    >
      <div className="max-w-6xl mx-auto lg:mx-0">
        <div className="max-w-4xl mx-auto flex flex-col md:flex-row py-20 sm:py-28 px-8 gap-x-16 sm:px-10 md:justify-between">
          <div className="">
            <PrismicNextImage field={slice.primary.title_image} />
            <p
              className="font-dmsans mt-4 text-xl sm:text-[28px] sm:leading-[160%] "
              style={{
                color: get(slice, 'primary.subheader_color', '#ffffff'),
              }}
            >
              {slice.primary.subheader}
            </p>
          </div>
          <div className="mt-6 flex flex-col justify-center gap-y-3 md:items-center max-w-[220px]">
            <CustomCTA
              actionType={slice.primary.cta_action}
              text={slice.primary.cta_link_text}
              link={slice.primary.cta_link}
              linkStyle={slice.primary.cta_link_style}
            />
            {isFilled.link(slice.primary.secondary_cta) && (
              <CustomPrismicLink
                field={slice.primary.secondary_cta}
                variant={
                  slice.primary.secondary_cta_link_style ?? 'solid-accent'
                }
                className="w-full"
              >
                {slice.primary.secondary_cta_text}
              </CustomPrismicLink>
            )}
            <p
              className="font-dmsans text-xs"
              style={{
                color: get(slice, 'primary.subheader_color', '#ffffff'),
              }}
            >
              {slice.primary.cta_callout}
            </p>
          </div>
        </div>
      </div>
    </section>
  );
};

export default ImageTitleCta;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountCtaSection/variants/TwoColumnGrid.tsx

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { convertStringToKebabCase } from '@/utils/utils';
import { Content } from '@prismicio/client';
import { PrismicRichText } from '@prismicio/react';

import { AccountCtaSectionProps } from '..';

/**
 * Props for `TwoColumnGrid`.
 */
export type TwoColumnGridProps = Pick<AccountCtaSectionProps, 'context'> & {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.MessagingCtaSectionSliceTwoColumnGrid;

/**
 * Component for "TwoColumnGrid" Slices.
 */
const TwoColumnGrid = ({
  context,
  ...slice
}: TwoColumnGridProps): JSX.Element => {
  const { user } = context;

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="max-w-5xl mx-auto my-4 lg:mx-0">
        <div className="mx-3 sm:mx-5 md:grid md:grid-cols-2">
          {slice.items.map((item) => (
            <div
              id={convertStringToKebabCase(item.title)}
              key={item.title}
              className="md:max-w-sm p-6"
            >
              <p className="font-dmsans text-accent-700 font-medium text-sm mb-3">
                {item.eyebrow}
              </p>
              <h2 className="font-financier text-3xl font-semibold tracking-tight text-accent-950 sm:text-4xl mb-3">
                {item.title}
              </h2>
              <div className="font-dmsans text-gray-600 text-lg">
                <PrismicRichText field={item.content} />
              </div>
              <div className="mt-8 flex items-center gap-x-6">
                <CustomPrismicLink
                  field={
                    user?.hasConcierge ? item.concierge_cta_link : item.cta_link
                  }
                  className="border border-gray-300 font-dmsans py-2 px-4 bg-white rounded-lg text-base text-gray-700 font-semibold hover:bg-gray-50 transition duration-150 ease-in-out"
                >
                  {user?.hasConcierge
                    ? item.concierge_cta_link_text
                    : item.cta_button_text}
                </CustomPrismicLink>
              </div>
            </div>
          ))}
        </div>
      </div>
    </section>
  );
};

export default TwoColumnGrid;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountCtaSection/variants/ProductListCta.tsx

import get from 'lodash.get';

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicImage, PrismicRichText } from '@prismicio/react';

/**
 * Props for `ImageTitleCta`.
 */
export type ProductListCtaProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.MessagingCtaSectionSliceProductListCta;

const ProductListCta = (slice: ProductListCtaProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="lg:pl-2.5 xl:pl-10"
      style={{
        backgroundImage: `linear-gradient(${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
      }}
    >
      <div className="max-w-5xl mx-auto lg:mx-0">
        <div className="pt-20 pb-28 px-8 grid grid-cols-1 justify-items-center gap-x-10 gap-y-8 sm:px-16 items-center lg:justify-items-start lg:grid-cols-2">
          <div className="w-full flex-auto max-w-md">
            <div>
              <PrismicImage
                field={slice.primary.logo}
                className="h-[27px] w-auto mx-auto lg:mx-0"
              />
              <PrismicImage
                field={slice.primary.product_logo}
                className="h-4 sm:h-[29px] w-auto mt-3 mx-auto lg:mx-0"
              />
            </div>
            <div
              className="ml-10 lg:ml-0 font-dmsans mt-10 text-lg font-medium leading-8 [&_ul]:list-disc [&_ul]:space-y-6 sm:text-2xl"
              style={{
                color: get(slice, 'primary.content_color', '#ffffff'),
              }}
            >
              <PrismicRichText field={slice.primary.content} />
            </div>
            {slice.primary.cta_button_text && (
              <CustomPrismicLink
                field={slice.primary.cta_link}
                className="mt-10 max-w-[320px] mx-auto lg:mx-0"
                variant={slice.primary.cta_link_style ?? 'solid-black'}
              >
                {slice.primary.cta_button_text}
              </CustomPrismicLink>
            )}
          </div>

          {/* Image Column */}
          <div className="hidden lg:flex mb-4 max-w-none flex-shrink-0 sm:mb-0 sm:mr-4 w-full">
            <PrismicImage
              field={slice.primary.image}
              className="w-full h-auto"
              style={{
                maxWidth: slice.primary.image.dimensions?.width,
                maxHeight: slice.primary.image.dimensions?.height,
              }}
            />
          </div>
        </div>
      </div>
    </section>
  );
};

export default ProductListCta;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountCtaSection/variants/CustomCTA.tsx

'use client';

import { useRouter } from 'next/navigation';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import ButtonSolid from '@/app/shared/components/buttons/button-solid';
import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import LoadingSpinner from '@/app/shared/components/loading-indicators/loading-spinner';
import { useCartSliderContext } from '@/app/shared/hooks/use-cart-slider-context';
import ErrorToast from '@components/error-toast';
import { KeyTextField, LinkField, isFilled } from '@prismicio/client';

interface ICustomCTAProps {
  actionType: string | null;
  text: KeyTextField;
  link: LinkField;
  linkStyle: string | null;
  className?: string;
}

const addConciergeToCart = async (annual = false) => {
  const productId = annual
    ? process.env.NEXT_PUBLIC_PRODUCT_ID_CONCIERGE_SUBSCRIPTION_YEARLY
    : process.env.NEXT_PUBLIC_PRODUCT_ID_CONCIERGE_SUBSCRIPTION_MONTHLY;

  try {
    const res = await fetch(
      `/api/ecommerce/subscription-product/${productId}/cart`,
      {
        method: 'POST',
        body: JSON.stringify({ setAbsoluteAmount: true, amount: 1 }),
      }
    );

    if (!res.ok) {
      throw new Error('Could not add subscription product to cart');
    }

    return { success: true };
  } catch (error) {
    return { success: false };
  }
};

const CustomCTA: React.FC<ICustomCTAProps> = ({
  actionType,
  text,
  link,
  linkStyle,
  className,
}) => {
  const router = useRouter();
  const { startTransition, setShowCart } = useCartSliderContext();
  const [adding, setAdding] = React.useState(false);
  const [error, setError] = React.useState(false);

  const onErrorToastClose = () => {
    setError(false);
  };

  const handleAddToCart = async () => {
    setAdding(true);
    setError(false);
    const response = await addConciergeToCart(
      actionType === 'ADD_CONCIERGE_YEARLY'
    );

    if (response.success) {
      startTransition(() => {
        router.refresh();
      });
      setShowCart(true);
    } else {
      setError(true);
    }

    setAdding(false);
  };

  const loading = adding;

  if (actionType && actionType !== 'LINK') {
    return (
      <>
        <ButtonSolid
          className={twMerge(
            'w-[180px] md:px-10 flex items-center justify-center',
            className
          )}
          variant="accent"
          onClick={handleAddToCart}
          disabled={loading}
        >
          {loading ? (
            <LoadingSpinner fillClass="fill-accent-500" size="sm" />
          ) : (
            text
          )}
        </ButtonSolid>
        <ErrorToast
          show={error}
          position="fixed"
          text="There was a problem adding concierge to cart. Please try again later."
          onClose={onErrorToastClose}
        />
      </>
    );
  }

  if (isFilled.link(link)) {
    return (
      <CustomPrismicLink
        field={link}
        className={twMerge(
          'w-full min-w-[180px] max-w-[280px] md:px-10',
          className
        )}
        variant={linkStyle ?? 'solid-accent'}
      >
        {text}
      </CustomPrismicLink>
    );
  }

  return null;
};

export default CustomCTA;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountCtaSection/variants/FeaturedImage.tsx

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import { PrismicRichText } from '@prismicio/react';

/**
 * Props for `FeaturedImage`.
 */
export type FeaturedImageProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.MessagingCtaSectionSliceFeaturedImage;

/**
 * Component for "FeaturedImage" variant.
 */
const FeaturedImage = (slice: FeaturedImageProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="py-14 mx-auto max-w-6xl px-8 sm:px-4 xl:px-0">
        <div className="bg-white">
          <div className="flex flex-col gap-6 items-center justify-center sm:flex-row xl:gap-12">
            <div className="w-auto flex-none self-center">
              <PrismicNextImage
                field={slice.primary.image}
                className="aspect-square object-cover w-full sm:w-[15rem] md:w-[20rem] lg:w-[25rem] xl:w-[30rem] max-w-none bg-gray-50 sm:object-cover"
              />
            </div>
            <div className="max-w-lg">
              <p className="font-dmsans text-gray-500 font-medium text-xl lg:text-2xl xl:text-3xl mb-2">
                {slice.primary.eyebrow}
              </p>
              <p className="font-dmsans text-gray-900 font-semibold text-3xl lg:text-4xl xl:text-5xl mb-3">
                {slice.primary.title}
              </p>
              <div className="font-dmsans text-gray-500 text-base">
                <PrismicRichText field={slice.primary.content} />
              </div>
              <div className="mt-8 flex items-center gap-x-6">
                <CustomPrismicLink
                  variant="solid-accent"
                  field={slice.primary.cta_link}
                  className=""
                >
                  {slice.primary.cta_button_text}
                </CustomPrismicLink>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default FeaturedImage;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/VideoHighlight/index.tsx

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicRichText, SliceComponentProps } from '@prismicio/react';

/**
 * Props for `VideoHighlight`.
 */
export type VideoHighlightProps =
  SliceComponentProps<Content.VideoHighlightSlice>;

/**
 * Component for "VideoHighlight" Slices.
 */
const VideoHighlight = ({ slice }: VideoHighlightProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="w-full max-w-7xl mx-auto px-6 pt-12 pb-6 text-center bg-white"
    >
      <h2 className="mb-8 font-financier text-5xl sm:text-6xl text-black tracking-tight font-semibold">
        {slice.primary.title}
      </h2>
      <PrismicRichText
        field={slice.primary.content}
        components={{
          paragraph: ({ children }) => (
            <p className="text-black font-dmsans text-[28px] leading-10 tracking-tight font-medium">
              {children}
            </p>
          ),
        }}
      />

      <div className="my-10 mx-auto overflow-hidden relative h-[274px] max-w-[488px]">
        <iframe
          width="488"
          height="274"
          className="absolute top-0 left-0 w-full h-full"
          src={`${slice.primary.video_link}`}
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowFullScreen
          title={`${slice.primary.iframe_title}`}
        />
      </div>

      <CustomPrismicLink
        field={slice.primary.cta_link}
        variant="solid-accent"
        className="mx-auto py-2.5 md:text-lg text-black border-0 max-w-xs w-full font-bold"
      >
        {slice.primary.cta_link_text}
      </CustomPrismicLink>
    </section>
  );
};

export default VideoHighlight;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/OrderHistory/index.tsx

import { cookies } from 'next/headers';
import React from 'react';

import TableLoadingSkeleton from '@/app/shared/components/data-table/table-loading-skeleton';
import { AccountPageContext, OrderInclude } from '@/app/shared/types';
import { getPrismicProductId } from '@/utils/get-prismic-product-id';
import { getBaseUrl } from '@/utils/getBaseUrl';
import { getProductContentByIds } from '@/utils/helpers/helpers';
import { getSelectedDependentOrPrimaryUser } from '@/utils/utils';
import { ProductCategories } from '@prisma/client';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import OrdersTable from './components/OrdersTable';

/**
 * Props for `OrderHistory`.
 */
export type OrderHistoryProps = SliceComponentProps<
  Content.OrderHistorySlice,
  AccountPageContext
>;

export type OrderProduct = {
  content?: Content.ProductPageDocument | undefined;
  orderId: string;
  productId: string;
  createdAt: Date;
  quantity: number;
  name: string;
  orderType: string;
  isSubscription: boolean;
  frequency?: number;
  frequencyUnit?: string;
};

const getOrders = async (userId?: string) => {
  const queryParams = new URLSearchParams(userId ? { userId } : {});
  try {
    const res = await fetch(
      `${getBaseUrl()}/api/ecommerce/order?${queryParams}`,
      {
        method: 'GET',
        headers: { Cookie: cookies().toString() },
      }
    );
    if (!res.ok) {
      throw new Error('Could not fetch orders');
    }
    return (await res.json()) as OrderInclude[];
  } catch (error) {
    return undefined;
  }
};

const getProductsFromOrders = (orders?: OrderInclude[]) => {
  const products: OrderProduct[] = [];
  (orders ?? []).forEach((order) => {
    order.cartProducts.forEach((product) => {
      if (
        product.product.category === ProductCategories.OTC_MEDICATION ||
        product.product.category === ProductCategories.PRESCRIPTION_MEDICATION
      ) {
        products.push({
          orderId: order.id,
          productId: product.product.id,
          createdAt: order.createdAt,
          quantity: product.quantity,
          name: product.product.name,
          orderType: order.orderType.toString(),
          isSubscription: false,
        });
      }
    });
    order.cartSubscriptionProducts.forEach((sub) => {
      if (
        sub.subscriptionProduct.category === ProductCategories.OTC_MEDICATION ||
        sub.subscriptionProduct.category ===
          ProductCategories.PRESCRIPTION_MEDICATION
      ) {
        products.push({
          orderId: order.id,
          productId: sub.subscriptionProduct.id,
          createdAt: order.createdAt,
          quantity: sub.quantity,
          name: sub.subscriptionProduct.name,
          orderType: order.orderType.toString(),
          isSubscription: true,
          frequency: sub.subscriptionProduct.frequency,
          frequencyUnit: sub.subscriptionProduct.frequencyUnit,
        });
      }
    });
  });

  return products.sort((a, b) => {
    return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
  });
};

const getProductsWithContent = async (productList: OrderProduct[]) => {
  const ids = productList.map((item) => item.productId);
  const content = await getProductContentByIds(ids);

  return productList.map((product) => {
    const prismicContent = content.find(
      (item) => getPrismicProductId(item.data) === product.productId
    );
    return {
      ...product,
      name: prismicContent?.data.name ?? product.name,
    };
  });
};

/**
 * Component for "OrderHistory" Slices.
 */
const OrderHistory = async ({
  slice,
  context,
}: OrderHistoryProps): Promise<JSX.Element> => {
  const { searchParams } = context;
  const userId = searchParams?.mid as string;

  const orders = await getOrders(userId);
  const productsList = getProductsFromOrders(orders);
  const products = await getProductsWithContent(productsList);

  return <OrdersTable products={products} slice={slice} />;
};

/**
 * Component for "OrderHistory" Slices.
 */
const OrderHistoryWrapper = (p: OrderHistoryProps): JSX.Element => {
  const userId = p.context.searchParams?.mid as string;
  const user =
    p.context.user && userId
      ? getSelectedDependentOrPrimaryUser(p.context.user, userId)
      : p.context.user;

  return (
    <section
      data-slice-type={p.slice.slice_type}
      data-slice-variation={p.slice.variation}
    >
      <div className="p-8 pt-6 max-w-6xl">
        {user?.firstName && (
          <h2 className="font-dmsans text-2xl text-gray-700">
            {user?.firstName} {user?.lastName}
          </h2>
        )}
        <React.Suspense fallback={<TableLoadingSkeleton />}>
          <OrderHistory {...p} />
        </React.Suspense>
      </div>
    </section>
  );
};

export default OrderHistoryWrapper;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/OrderHistory/components/OrdersTable.tsx

'use client';

import dayjs from 'dayjs';

import DataTable from '@/app/shared/components/data-table/data-table';
import { Content } from '@prismicio/client';
import { createColumnHelper } from '@tanstack/react-table';
import { ShoppingBag01 } from '@untitled-ui/icons-react';

import { OrderProduct } from '..';

interface IOrdersTableProps {
  slice: Content.OrderHistorySlice;
  products: OrderProduct[];
}

const columnHelper = createColumnHelper<OrderProduct>();

const columns = [
  columnHelper.accessor('name', {
    header: () => <span>Item</span>,
    cell: (info) => (
      <span className="text-gray-900 text-sm font-medium">
        {info.getValue()}
      </span>
    ),
  }),
  columnHelper.accessor('createdAt', {
    header: () => <span>Order Placed</span>,
    cell: (info) => dayjs(info.getValue()).format('MMM D, YYYY'),
  }),
  columnHelper.accessor('isSubscription', {
    header: () => <span>Order Type</span>,
    cell: (info) => (
      <div>{info.getValue() ? 'Subscription' : 'One-time purchase'}</div>
    ),
  }),
];

/**
 * Component for "OrderHistory" Slices.
 */
const OrdersTable = ({ slice, products }: IOrdersTableProps): JSX.Element => {
  return products.length > 0 ? (
    <DataTable<OrderProduct> data={products} columns={columns} />
  ) : (
    <div className="my-4 bg-white border border-gray-200 rounded-lg">
      <div className="p-8 flex flex-col items-center justify-center">
        <div className="bg-accent-50 p-2.5 rounded-full">
          <div className="bg-accent-100 p-2.5 rounded-full">
            <ShoppingBag01
              className="h-6 w-6 text-accent-700"
              viewBox="0 0 24 24"
            />
          </div>
        </div>
        <div className="mt-2 text-center">
          <p className="font-dmsans text-gray-900 text-base font-semibold">
            {slice.primary.no_orders_title}
          </p>
          <p className="font-dmsans text-gray-600 text-sm">
            {slice.primary.no_orders_description}
          </p>
        </div>
      </div>
    </div>
  );
};

export default OrdersTable;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/TextArea/index.tsx

import { Container } from '@/app/shared/components/layout/container';
import { RichText } from '@/app/shared/components/text/rich-text';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `TextArea`.
 */
export type TextAreaProps = SliceComponentProps<Content.TextAreaSlice>;

/**
 * Component for "TextArea" Slices.
 */
const TextArea = ({ slice }: TextAreaProps): JSX.Element => {
  return (
    <Container
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <RichText field={slice.primary.text} />
    </Container>
  );
};

export default TextArea;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CenteredRichText/index.tsx

import { Content } from '@prismicio/client';
import { PrismicRichText, SliceComponentProps } from '@prismicio/react';

/**
 * Props for `CenteredRichText`.
 */
export type CenteredRichTextProps =
  SliceComponentProps<Content.CenteredRichTextSlice>;

/**
 * Component for "CenteredRichText" Slices.
 */
const CenteredRichText = ({ slice }: CenteredRichTextProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="px-6 py-10 text-center bg-white"
    >
      <PrismicRichText
        field={slice.primary.content}
        components={{
          paragraph: ({ children }) => (
            <p className="text-[#585858] font-dmsans text-xs leading-5">
              {children}
            </p>
          ),
        }}
      />
    </section>
  );
};

export default CenteredRichText;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountNotifications/index.tsx

import React from 'react';

import { AccountPageContext } from '@/app/shared/types';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import Loading from './components/Loading';
import NotificationList from './components/NotificationList';

/**
 * Props for `AccountNotifications`.
 */
export type AccountNotificationsProps = SliceComponentProps<
  Content.AccountNotificationsSlice,
  AccountPageContext
>;

/**
 * Component for "AccountNotifications" Slices.
 */
const AccountNotifications = async (
  p: AccountNotificationsProps
): Promise<JSX.Element> => {
  return (
    <section
      data-slice-type={p.slice.slice_type}
      data-slice-variation={p.slice.variation}
      className="p-6 lg:p-8"
    >
      <div className="max-w-6xl">
        <h2 className="my-4 font-dmsans text-3xl font-semibold text-gray-900">
          {p.slice.primary.title}
        </h2>
        <React.Suspense fallback={<Loading />}>
          <NotificationList {...p} />
        </React.Suspense>
      </div>
    </section>
  );
};

export default AccountNotifications;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountNotifications/components/NotificationList.tsx

import isEmpty from 'lodash.isempty';

import MarkdownElement from '@/app/shared/components/markdown-element';
import {
  AccountPageContext,
  ICaseDiagnosedStat,
  ICaseExpiringStat,
  IShipmentStat,
  IUnreadThreadStat,
} from '@/app/shared/types';
import { getFamilyStats } from '@/utils/helpers/helpers';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import NoNotificationsView from './NoNotificationsView';

/**
 * Props for `AccountNotifications`.
 */
export type AccountNotificationsProps = SliceComponentProps<
  Content.AccountNotificationsSlice,
  AccountPageContext
>;

type StatType = ICaseExpiringStat | ICaseDiagnosedStat | IShipmentStat;

const groupStatByUser = <T extends StatType>(stats: T[]) =>
  stats.reduce((acc, stat) => {
    const userIdentifier = `${stat.user.firstName} ${stat.user.lastName}`;
    if (!acc?.[userIdentifier]) {
      acc[userIdentifier] = [];
    }

    acc[userIdentifier].push(stat);

    return acc;
  }, {} as Record<string, T[]>);

const groupUnreadMessageCountByUser = (threads: IUnreadThreadStat[]) =>
  threads.reduce((acc, stat) => {
    const userIdentifier = `${stat.user.firstName} ${stat.user.lastName}`;
    if (stat.unreadMessagesForThread > 0) {
      if (!acc?.[userIdentifier]) {
        acc[userIdentifier] = 0;
      }

      acc[userIdentifier] += stat.unreadMessagesForThread;
    }

    return acc;
  }, {} as Record<string, number>);

/**
 * Component for "AccountNotifications" Slices.
 */
const NotificationList: React.FC<AccountNotificationsProps> = async () => {
  const familyStats = await getFamilyStats();

  const groupedDiagnosedCases = groupStatByUser<ICaseDiagnosedStat>(
    familyStats.casesDiagnosedInLast7Days
  );
  const groupedExpiringCases = groupStatByUser<ICaseExpiringStat>(
    familyStats.casesWithConsultationExpiringWithin7Days
  );
  const groupedShipments = groupStatByUser<IShipmentStat>(
    familyStats.shippingChangesInLast7Days
  );
  const groupedMessageCounts = groupUnreadMessageCountByUser(
    familyStats.unreadThreads
  );

  const noNotifications =
    isEmpty(groupedDiagnosedCases) &&
    isEmpty(groupedExpiringCases) &&
    isEmpty(groupedShipments) &&
    Object.keys(groupedMessageCounts).every(
      (userIdentifier) => groupedMessageCounts[userIdentifier] < 1
    );

  if (noNotifications) {
    return <NoNotificationsView />;
  }

  return (
    <div className="">
      <ul
        role="list"
        className="mt-8 divide-y divide-gray-200 border-y border-gray-200"
      >
        {Object.keys(groupedDiagnosedCases).map((userIdentifier, i) => (
          <NotificationListItem
            key={`diagnosed-cases-${userIdentifier}-${i}`}
            title={userIdentifier}
            description="Has {{ count }} case{{#if multiple}}s{{/if}} diagnosed in the last 7 days"
            notificationCount={groupedDiagnosedCases[userIdentifier].length}
          />
        ))}
        {Object.keys(groupedMessageCounts).map((userIdentifier, i) => (
          <NotificationListItem
            key={`messages-${userIdentifier}-${i}`}
            title={userIdentifier}
            description="Has {{ count }} unread message{{#if multiple}}s{{/if}}"
            notificationCount={groupedMessageCounts[userIdentifier]}
          />
        ))}
        {Object.keys(groupedShipments).map((userIdentifier, i) => (
          <NotificationListItem
            key={`shipments-${userIdentifier}-${i}`}
            title={userIdentifier}
            description="Has {{ count }} shipping update{{#if multiple}}s{{/if}} in the last 7 days"
            notificationCount={groupedShipments[userIdentifier].length}
          />
        ))}
        {Object.keys(groupedExpiringCases).map((userIdentifier, i) => (
          <NotificationListItem
            key={`expiring-cases-${userIdentifier}-${i}`}
            title={userIdentifier}
            description="Has physician access expiring for {{ count }} case{{#if multiple}}s{{/if}} within 7 days"
            notificationCount={groupedExpiringCases[userIdentifier].length}
          />
        ))}
      </ul>
    </div>
  );
};

const NotificationListItem = (p: {
  title: string;
  description: string;
  notificationCount: number;
}) => {
  return (
    p.notificationCount > 0 && (
      <li className="flex justify-between gap-x-6 py-4">
        <div className="min-w-0 flex-auto">
          <p className="text-sm font-medium text-gray-700">{p.title}</p>
          <div className="mt-1 text-sm text-gray-600">
            <MarkdownElement
              dataContext={{
                count: p.notificationCount,
                multiple: p.notificationCount > 1,
              }}
              overridePTag={false}
            >
              {p.description}
            </MarkdownElement>
          </div>
        </div>
      </li>
    )
  );
};

export default NotificationList;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountNotifications/components/NoNotificationsView.tsx

import React from 'react';

import { BellIcon } from '@heroicons/react/24/outline';

const NoNotificationsView: React.FC = () => {
  return (
    <div className="flex flex-col items-center text-center py-24 px-4">
      <BellIcon className="mx-auto h-12 w-12 text-gray-400" />

      <p className="mt-3 font-dmsans font-medium text-lg sm:text-2xl text-gray-900">
        No Notifications
      </p>
      <div className="mt-1 font-dmsans text-sm sm:text-md text-gray-600 max-w-sm">
        You have no new notifications
      </div>
    </div>
  );
};

export default NoNotificationsView;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountNotifications/components/Loading.tsx

const Loading = () => {
  return (
    <div className="mt-8 divide-y divide-gray-200 border-y border-gray-200 animate-pulse">
      <div className="flex justify-between gap-x-6 py-4">
        <div className="min-w-0 flex-auto">
          <div className="h-5 max-w-[120px] bg-gray-200 rounded" />
          <div className="mt-1 h-5 max-w-prose bg-gray-200 rounded" />
        </div>
      </div>
      <div className="flex justify-between gap-x-6 py-4">
        <div className="min-w-0 flex-auto">
          <div className="h-5 max-w-[120px] bg-gray-200 rounded" />
          <div className="mt-1 h-5 max-w-prose bg-gray-200 rounded" />
        </div>
      </div>
      <div className="flex justify-between gap-x-6 py-4">
        <div className="min-w-0 flex-auto">
          <div className="h-5 max-w-[120px] bg-gray-200 rounded" />
          <div className="mt-1 h-5 max-w-prose bg-gray-200 rounded" />
        </div>
      </div>
    </div>
  );
};

export default Loading;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/CalendlyScheduler/index.tsx

'use client';

import React from 'react';
import { InlineWidget } from 'react-calendly';

import { AccountPageContext } from '@/app/shared/types';
import { ExclamationCircleIcon } from '@heroicons/react/24/outline';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `CalendlyScheduler`.
 */
export type CalendlySchedulerProps = SliceComponentProps<
  Content.CalendlySchedulerSlice,
  AccountPageContext
>;

/**
 * Component for "CalendlyScheduler" Slices.
 */
const CalendlyScheduler = ({
  slice,
  context,
}: CalendlySchedulerProps): JSX.Element => {
  if (!slice.primary.url) {
    return (
      <div className="bg-error-50 rounded-md p-6 my-2 w-full">
        <div className="flex items-start">
          <div className="flex-shrink-0">
            <ExclamationCircleIcon
              className="h-6 w-6 text-error-500"
              aria-hidden="true"
            />
          </div>
          <div className="ml-2 w-0 flex-1 pt-0.5">
            <p className="font-dmsans text-sm font-medium text-gray-900">
              Unable to load the scheduler. Please check back later.
            </p>
          </div>
        </div>
      </div>
    );
  }

  const { user } = context;

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="block">
        <InlineWidget
          url={slice.primary.url}
          styles={{
            height: '1000px',
          }}
          pageSettings={{
            backgroundColor: 'ffffff',
            hideEventTypeDetails: false,
            hideLandingPageDetails: false,
            hideGdprBanner: true,
          }}
          prefill={{
            email: `${user?.email}`,
            firstName: user?.firstName ?? undefined,
            lastName: user?.lastName ?? undefined,
            name: user?.firstName
              ? `${user?.firstName} ${user?.lastName}`
              : undefined,
            smsReminderNumber: user?.phoneNumber ?? undefined,
          }}
        />
      </div>
    </section>
  );
};

export default CalendlyScheduler;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/LargeQuote/index.tsx

import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import LargeQuoteDefault from './variants/LargeQuoteDefault';
import LeftAlignedImage from './variants/LeftAlignedImage';
import LeftAlignedVideo from './variants/LeftAlignedVideo';

/**
 * Props for `LargeQuote`.
 */
export type LargeQuoteProps = SliceComponentProps<Content.LargeQuoteSlice>;

/**
 * Component for "LargeQuote" Slices.
 */
const LargeQuote = ({ slice }: LargeQuoteProps): JSX.Element => {
  switch (slice.variation) {
    case 'leftAlignedProfileImage':
      return <LeftAlignedImage {...slice} />;
    case 'leftAlignedVideo':
      return <LeftAlignedVideo {...slice} />;
    case 'default':
      return <LargeQuoteDefault {...slice} />;
    default:
      return <></>;
  }
};

export default LargeQuote;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/LargeQuote/variants/LeftAlignedImage.tsx

import get from 'lodash.get';

import { Content } from '@prismicio/client';
import { PrismicImage } from '@prismicio/react';

/**
 * Props for `LeftAlignedImage`.
 */
export type LeftAlignedImageProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.LargeQuoteSliceLeftAlignedProfileImage;

/**
 * Component for "LeftAlignedImage" Slices.
 */
const LeftAlignedImage = (slice: LeftAlignedImageProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="isolate overflow-hidden bg-white px-10"
    >
      <div className="relative mx-auto max-w-2xl pt-20 pb-14 lg:pt-12 lg:pb-10 lg:max-w-4xl">
        <figure className="grid grid-cols-1 items-center gap-x-6 gap-y-8 lg:gap-y-4 lg:gap-x-14">
          <div className="relative col-span-2 lg:col-start-1 lg:row-start-2">
            <svg
              width="70"
              height="65"
              viewBox="0 0 70 65"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
              className="absolute -top-16 -left-4 -z-10 h-32"
            >
              <path
                opacity="0.08"
                d="M26.0308 36.6979V65H0V42.6562C0 30.559 1.43866 21.8021 4.31599 16.3854C8.09249 9.16319 14.0719 3.70139 22.2543 0L28.1888 9.47917C23.2434 11.5556 19.6018 14.6701 17.264 18.8229C14.9261 22.8854 13.6223 28.8438 13.3526 36.6979H26.0308ZM67.842 36.6979V65H41.8112V42.6562C41.8112 30.559 43.2498 21.8021 46.1272 16.3854C49.9037 9.16319 55.8831 3.70139 64.0655 0L70 9.47917C65.0546 11.5556 61.413 14.6701 59.0751 18.8229C56.7373 22.8854 55.4335 28.8438 55.1638 36.6979H67.842Z"
                fill="#263A61"
              />
            </svg>
            <blockquote>
              <p
                className="font-dmsans text-xl font-medium"
                style={{
                  color: get(slice, 'primary.quote_title_color', '#838383'),
                }}
              >
                {slice.primary.quote_title}
              </p>
              <p
                className="mt-4 font-dmsans text-lg"
                style={{
                  color: get(slice, 'primary.quote_color', '#838383'),
                }}
              >
                {slice.primary.quote}
              </p>
            </blockquote>
          </div>
          <div className="col-end-1 w-16 lg:row-span-4 lg:w-72">
            <PrismicImage
              className="rounded-xl bg-indigo-50 lg:rounded-lg ml-auto"
              field={slice.primary.image}
              width={slice.primary.image.dimensions?.width}
              height={slice.primary.image.dimensions?.height}
            />
          </div>
          <figcaption className="lg:col-start-1 lg:row-start-3 lg:flex lg:flex-row lg:items-center">
            <div className="flex flex-row items-center flex-wrap">
              <div
                className="font-dmsans text-lg font-medium lg:mr-2"
                style={{
                  color: get(slice, 'primary.name_color', '#838383'),
                }}
              >
                – {slice.primary.name}
              </div>
              {slice.items.map((item, index) => (
                <div key={`${slice.id}-item-${index}`}>
                  <PrismicImage
                    field={item.social_icon}
                    className=""
                    width={item.social_icon.dimensions?.width}
                    height={item.social_icon.dimensions?.height}
                  />
                </div>
              ))}
            </div>
            <div
              className="mt-1 lg:mt-0 text-sm italic font-dmsans font-medium lg:ml-2"
              style={{
                color: get(slice, 'primary.job_title_color', '#838383'),
              }}
            >
              {slice.primary.job_title}
            </div>
          </figcaption>
        </figure>
      </div>
    </section>
  );
};

export default LeftAlignedImage;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/LargeQuote/variants/LargeQuoteDefault.tsx

import get from 'lodash.get';

import { Content } from '@prismicio/client';
import { PrismicImage } from '@prismicio/react';

/**
 * Props for `LargeQuoteDefault`.
 */
export type LargeQuoteDefaultProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.LargeQuoteSliceDefault;

/**
 * Component for "LargeQuoteDefault" Slices.
 */
const LargeQuoteDefault = (slice: LargeQuoteDefaultProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="relative isolate overflow-hidden bg-white px-6 py-10 lg:px-8"
    >
      <div className="mx-auto max-w-2xl lg:max-w-4xl">
        <figure className="mt-2">
          <blockquote className="font-dmsans text-center text-lg leading-8">
            <p style={{ color: get(slice, 'primary.quote_color', '#838383') }}>
              {slice.primary.quote}
            </p>
          </blockquote>
          <figcaption className="mt-6 flex justify-center items-center gap-x-4">
            <PrismicImage
              field={slice.primary.profile_image}
              className="h-16 w-16 rounded-full"
            />
            <div className="text-base">
              <div className="flex items-center flex-wrap">
                <div
                  className="font-medium text-lg mr-2"
                  style={{
                    color: get(slice, 'primary.name_color', '#838383'),
                  }}
                >
                  {slice.primary.name}
                </div>
                {slice.items.map((item, index) => (
                  <div
                    key={`${slice.id}-item-${index}`}
                    className="font-medium text-sm italic"
                  >
                    <PrismicImage
                      field={item.social_icon}
                      className=""
                      width={item.social_icon.dimensions?.width}
                      height={item.social_icon.dimensions?.height}
                    />
                  </div>
                ))}
              </div>
              <div
                className="font-medium text-sm italic"
                style={{
                  color: get(slice, 'primary.job_title_color', '#838383'),
                }}
              >
                {slice.primary.job_title}
              </div>
            </div>
          </figcaption>
        </figure>
      </div>
    </section>
  );
};

export default LargeQuoteDefault;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/LargeQuote/variants/LeftAlignedVideo.tsx

import get from 'lodash.get';

import { Content } from '@prismicio/client';
import { PrismicImage } from '@prismicio/react';

/**
 * Props for `LeftAlignedVideo`.
 */
export type LeftAlignedVideoProps = {
  slice_type: string;
  slice_label: string | null;
  id?: string;
} & Content.LargeQuoteSliceLeftAlignedVideo;

/**
 * Component for "LeftAlignedVideo" Slices.
 */
const LeftAlignedVideo = (slice: LeftAlignedVideoProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="isolate overflow-hidden bg-white px-10"
    >
      <div className="relative mx-auto max-w-2xl pt-12 pb-10 lg:max-w-4xl">
        <figure className="flex flex-col lg:flex-row items-center gap-x-6 gap-y-8 lg:gap-y-6 lg:gap-x-14">
          <div className="relative mb-8 w-60 lg:mb-0 lg:w-72 flex-shrink-0">
            {slice.primary.include_background_box_decoration && (
              <div className="absolute -bottom-3 -left-3 lg:-bottom-5 lg:-left-5 -z-10 bg-gradient-to-bl from-[#D8F0F6] to-[#E9E7E8] rounded-2xl h-40 w-32 lg:h-48 lg:w-40" />
            )}
            <video
              className="rounded-xl bg-indigo-50 lg:rounded-2xl ml-auto"
              src={get(slice, 'primary.video_link.url', '')}
              autoPlay
              loop
              playsInline
              controls={false}
              muted
            />
          </div>
          <div className="relative">
            <svg
              width="70"
              height="65"
              viewBox="0 0 70 65"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
              className="absolute -top-16 -left-4 -z-10 h-32"
            >
              <path
                opacity="0.08"
                d="M26.0308 36.6979V65H0V42.6562C0 30.559 1.43866 21.8021 4.31599 16.3854C8.09249 9.16319 14.0719 3.70139 22.2543 0L28.1888 9.47917C23.2434 11.5556 19.6018 14.6701 17.264 18.8229C14.9261 22.8854 13.6223 28.8438 13.3526 36.6979H26.0308ZM67.842 36.6979V65H41.8112V42.6562C41.8112 30.559 43.2498 21.8021 46.1272 16.3854C49.9037 9.16319 55.8831 3.70139 64.0655 0L70 9.47917C65.0546 11.5556 61.413 14.6701 59.0751 18.8229C56.7373 22.8854 55.4335 28.8438 55.1638 36.6979H67.842Z"
                fill="#263A61"
              />
            </svg>
            <blockquote>
              <p
                className="font-dmsans text-xl font-bold"
                style={{
                  color: get(slice, 'primary.quote_title_color', '#838383'),
                }}
              >
                {slice.primary.quote_title}
              </p>
              <p
                className="mt-4 font-dmsans text-lg"
                style={{
                  color: get(slice, 'primary.quote_color', '#838383'),
                }}
              >
                {slice.primary.quote}
              </p>
            </blockquote>

            <figcaption className="lg:flex lg:flex-row lg:items-center">
              <div className="flex flex-row items-center flex-wrap">
                <div
                  className="font-dmsans text-lg font-medium lg:mr-2"
                  style={{
                    color: get(slice, 'primary.name_color', '#838383'),
                  }}
                >
                  – {slice.primary.name}
                </div>
                {slice.items.map((item, index) => (
                  <div key={`${slice.id}-item-${index}`}>
                    <PrismicImage
                      field={item.social_icon}
                      className=""
                      width={item.social_icon.dimensions?.width}
                      height={item.social_icon.dimensions?.height}
                    />
                  </div>
                ))}
              </div>
              <div
                className="mt-1 lg:mt-0 text-sm italic font-dmsans font-medium lg:ml-2"
                style={{
                  color: get(slice, 'primary.job_title_color', '#838383'),
                }}
              >
                {slice.primary.job_title}
              </div>
            </figcaption>
          </div>
        </figure>
      </div>
    </section>
  );
};

export default LeftAlignedVideo;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/SettingsTab/index.tsx

import { notFound } from 'next/navigation';
import {
  BillingDocument,
  FormDocument,
  SubscriptionsDocument,
} from 'prismicio-types';
import React, { Suspense } from 'react';

import LoadingCircles from '@/app/shared/components/loading-indicators/loading-circles';
import { createClient } from '@/prismicio';
import { PrismicCustomType } from '@/utils/prismic/enums';
import { Content, FilledContentRelationshipField } from '@prismicio/client';
import { SliceComponentProps, SliceZone } from '@prismicio/react';

import { components } from '..';
import Tabs from './components/Tabs';

type LinkedContentRelationshipType =
  | PrismicCustomType.BILLING
  | PrismicCustomType.FORM
  | PrismicCustomType.SUBSCRIPTIONS;

/**
 * Props for `SettingsTab`.
 */
export type SettingsTabProps = SliceComponentProps<Content.SettingsTabSlice>;

const queryContent = async (
  linkedItem: FilledContentRelationshipField<LinkedContentRelationshipType>
) => {
  if (!linkedItem.uid) return notFound();

  const client = createClient();

  return await client
    .getByUID<BillingDocument | FormDocument | SubscriptionsDocument>(
      linkedItem.type,
      linkedItem.uid
    )
    .catch(() => notFound());
};

const ContentWindow = async ({
  linkedItem,
  context,
}: {
  linkedItem: FilledContentRelationshipField<LinkedContentRelationshipType>;
  context: any;
}) => {
  if (!linkedItem.link_type) return <></>;

  const content = await queryContent(linkedItem);
  return (
    <div className="flex flex-1 flex-col gap-4 bg-gray-100">
      <SliceZone
        slices={content.data.slices}
        components={components}
        context={context}
      />
    </div>
  );
};

/**
 * Component for "SettingsTab" Slices.
 */
const SettingsTab = (p: SettingsTabProps): JSX.Element => {
  const searchedTab = (p.context as any)?.searchParams?.tab ?? '';

  const tabs = React.useMemo(
    () =>
      p.slice.items.map((item) => ({
        name: item.tab_name as string,
        linkedItem: item.linked_item,
        href: `?tab=${item.tab_name}`,
        current: searchedTab === item.tab_name,
      })),
    [searchedTab, p.slice.items]
  );

  const current = tabs.find((tab) => tab.current) ?? tabs[0];

  return tabs && tabs.length > 0 ? (
    <div className="flex flex-col flex-1 w-full">
      <div className="w-full h-full flex-col flex">
        <h1 className="font-dmsans text-gray-900 text-2xl font-semibold mx-6 mt-4 lg:text-3xl">
          {p.slice.primary.title}
        </h1>
        <Tabs {...{ ...p, tabs }} />
        {current.linkedItem && (
          <Suspense
            key={searchedTab}
            fallback={<LoadingCircles className="bg-gray-100" />}
          >
            <ContentWindow
              linkedItem={
                current.linkedItem as FilledContentRelationshipField<LinkedContentRelationshipType>
              }
              context={p.context}
            />
          </Suspense>
        )}
      </div>
    </div>
  ) : (
    <></>
  );
};

export default SettingsTab;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/SettingsTab/components/Tabs.tsx

'use client';

import Link from 'next/link';
import { usePathname, useRouter, useSearchParams } from 'next/navigation';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import { PrismicCustomType } from '@/utils/prismic/enums';
import { ContentRelationshipField } from '@prismicio/client';

import { SettingsTabProps } from '..';

interface ITab {
  name: string;
  linkedItem: ContentRelationshipField<
    PrismicCustomType.BILLING | PrismicCustomType.FORM
  >;
  href: string;
  current: boolean;
}

/**
 * Component for "SettingsTab" Slice.
 */
const Tabs = ({ tabs }: SettingsTabProps & { tabs: ITab[] }): JSX.Element => {
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const router = useRouter();

  const getNewPath = (tab: string) => {
    const newSearchParams = new URLSearchParams(searchParams);
    newSearchParams.set('tab', tab);
    return `${pathname}?${newSearchParams}`;
  };

  const handleTabChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const newPath = getNewPath(e.target.value);
    router.push(newPath);
  };

  const current = tabs.find((tab) => tab.current) ?? tabs[0];

  return (
    <>
      <div className="mt-2 mx-4 mb-4 sm:hidden">
        <label htmlFor="tabs" className="sr-only">
          Select a tab
        </label>
        <select
          id="tabs"
          name="tabs"
          className="block w-full rounded-md border-gray-300 py-2 pl-3 pr-10 text-base focus:border-accent-700 focus:outline-none focus:ring-accent-700 sm:text-sm"
          defaultValue={tabs.find((tab) => tab.current)?.name ?? ''}
          onChange={handleTabChange}
        >
          {tabs.map((tab) => (
            <option key={tab.name}>{tab.name}</option>
          ))}
        </select>
      </div>
      <div className="hidden sm:block mt-2 lg:mt-4 mx-6">
        <div className="border-b border-gray-200">
          <nav className="-mb-px flex space-x-8" aria-label="Tabs">
            {tabs.map((tab) => (
              <Link
                key={tab.name}
                href={getNewPath(tab.name)}
                className={twMerge(
                  current.name === tab.name
                    ? 'border-accent-700 text-accent-700'
                    : 'border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700',
                  'font-dmsans whitespace-nowrap border-b-2 py-2 px-1 text-sm font-medium'
                )}
                aria-current={tab.current ? 'page' : undefined}
              >
                {tab.name}
              </Link>
            ))}
          </nav>
        </div>
      </div>
    </>
  );
};

export default Tabs;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/Redirect/index.tsx

import { redirect } from 'next/navigation';
import React from 'react';

import { UserInclude } from '@/app/shared/types';
import { getUserStatus } from '@/utils/get-user-state';
import LoadingCircles from '@components/loading-indicators/loading-circles';
import { Case } from '@prisma/client';
import { isFilled } from '@prismicio/client';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

export type RedirectProps = SliceComponentProps<Content.RedirectSlice>;

const Redirect: React.FC<RedirectProps> = async ({ slice, context }) => {
  const ctx = context as {
    user: UserInclude;
    cases: Case[];
    searchParams?: Record<string, string>;
  };

  // console.log('context');
  // console.log(JSON.stringify(ctx, null, 2));

  const status = await getUserStatus(ctx?.user);

  const redirectLinkItem = slice.items.find(
    (option) => option.state === status
  );

  let baseUrl = '/account';
  if (
    isFilled.link(redirectLinkItem?.redirect_link) &&
    redirectLinkItem?.redirect_link.url
  ) {
    baseUrl = redirectLinkItem.redirect_link.url;
  }

  if (ctx.searchParams && Object.keys(ctx.searchParams).length > 0) {
    const searchParams = new URLSearchParams(ctx.searchParams).toString();
    redirect(`${baseUrl}${baseUrl.includes('?') ? '&' : '?'}${searchParams}`);
  } else {
    redirect(baseUrl);
  }
};

const RedirectWrapper = (p: RedirectProps): JSX.Element => {
  return (
    <React.Suspense fallback={<LoadingCircles />}>
      <Redirect {...p} />
    </React.Suspense>
  );
};

export default RedirectWrapper;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/PrimaryUserContextSwitch/index.tsx

'use client';

import React from 'react';
import Cookies from 'universal-cookie';

import { AccountPageContext } from '@/app/shared/types';
import { COOKIE_KEYS } from '@/utils/enums';
import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `PrimaryUserContextSwitch`.
 */
export type PrimaryUserContextSwitchProps = SliceComponentProps<
  Content.PrimaryUserContextSwitchSlice,
  AccountPageContext
>;

/**
 * Component for "PrimaryUserContextSwitch" Slices.
 */
const PrimaryUserContextSwitch = ({
  context,
}: PrimaryUserContextSwitchProps): JSX.Element => {
  React.useEffect(() => {
    if (context.user?.guardianId != null) {
      const cookieStore = new Cookies();
      cookieStore.remove(COOKIE_KEYS.FAMILY_MEMBER, { path: '/' });
      window.location.reload();
    }
  }, [context.user?.guardianId]);

  return <></>;
};

export default PrimaryUserContextSwitch;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/HelpArticle/index.tsx

import { Content } from '@prismicio/client';
import { PrismicNextLink } from '@prismicio/next';
import {
  JSXMapSerializer,
  PrismicRichText,
  SliceComponentProps,
} from '@prismicio/react';

/**
 * Props for `HelpArticle`.
 */
export type HelpArticleProps = SliceComponentProps<Content.HelpArticleSlice>;

export const richTextComponents: JSXMapSerializer = {
  heading1: ({ children }) => (
    <div className="text-4xl font-bold tracking-tight text-gray-900">
      {children}
    </div>
  ),
  heading2: ({ children }) => (
    <div className="text-3xl font-semibold text-gray-900">{children}</div>
  ),
  heading3: ({ children }) => (
    <div className="text-2xl font-semibold text-gray-900">{children}</div>
  ),
  heading4: ({ children }) => (
    <div className="text-xl font-medium text-gray-900">{children}</div>
  ),
  heading5: ({ children }) => (
    <div className="text-lg text-gray-900">{children}</div>
  ),
  paragraph: ({ children }) => (
    <p className="font-dmsans text-base text-gray-900 min-h-[24px]">
      {children}
    </p>
  ),
  list: ({ children }) => (
    <ul className="list-disc ml-6 space-y-1.5">{children}</ul>
  ),
  hyperlink: ({ children, node }) => (
    <PrismicNextLink field={node.data} className="underline text-[#25395F]">
      {children}
    </PrismicNextLink>
  ),
  em: ({ children }) => <em>{children}</em>,
};

/**
 * Component for "HelpArticle" Slices.
 */
const HelpArticle = ({ slice }: HelpArticleProps): JSX.Element => {
  return (
    <div
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <PrismicRichText
        field={slice.primary.content}
        components={richTextComponents}
      />
    </div>
  );
};

export default HelpArticle;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/LogoCloud/index.tsx

import get from 'lodash.get';

import { Content } from '@prismicio/client';
import { PrismicImage, SliceComponentProps } from '@prismicio/react';

/**
 * Props for `LogoCloud`.
 */
export type LogoCloudProps = SliceComponentProps<Content.LogoCloudSlice>;

/**
 * Component for "LogoCloud" Slices.
 */
const LogoCloud = ({ slice }: LogoCloudProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="bg-white py-8"
      style={{
        backgroundImage: `linear-gradient(${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
      }}
    >
      <div className="mx-auto max-w-7xl px-6 lg:px-8">
        <div className="mx-auto max-w-2xl lg:max-w-none">
          <h2
            className="font-dmsans text-center text-lg font-bold leading-8 text-gray-900"
            style={{ color: get(slice, 'primary.title_color', 'black') }}
          >
            {slice.primary.title}
          </h2>
          <div className="mx-auto mt-4 grid grid-cols-4 items-center justify-items-center gap-x-8 gap-y-10 sm:grid-cols-6 sm:gap-x-10 lg:mx-0 lg:grid-cols-6">
            {slice.items.map((item, index) => (
              <PrismicImage
                key={`${slice.id}-item-${index}`}
                field={item.logo}
                className="col-span-2 object-contain object-left lg:col-span-1"
                width={item.logo.dimensions?.width}
                height={item.logo.dimensions?.height}
              />
            ))}
          </div>
        </div>
      </div>
    </section>
  );
};

export default LogoCloud;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/ComparisonChart/index.tsx

'use client';

import get from 'lodash.get';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import { useBreakpoints } from '@/app/shared/hooks/useBreakpoints';
import {
  ColorField,
  Content,
  KeyTextField,
  SelectField,
} from '@prismicio/client';
import { PrismicImage, SliceComponentProps } from '@prismicio/react';

import CategoryData from './CategoryData';
import SliderBubbles from './SliderBubbles';
import SliderTier from './SliderTier';

/**
 * Props for `ComparisonChart`.
 */
export type ComparisonChartProps =
  SliceComponentProps<Content.ComparisonChartSlice>;

export interface ICategoryData {
  category: KeyTextField;
  contentType: SelectField<'text' | 'check' | 'x-icon'>;
  content: KeyTextField;
  contentColor: ColorField;
}

export interface ISecondaryTier {
  title: KeyTextField;
  titleColor: ColorField;
  categories: ICategoryData[];
}

/**
 * Component for "ComparisonChart" Slices.
 */
const ComparisonChart = ({ slice }: ComparisonChartProps): JSX.Element => {
  const { isMd } = useBreakpoints();
  const [tierIndex, setTierIndex] = React.useState(0);

  const handleClick = () => {
    setTierIndex((ti) => (ti === 0 ? 1 : 0));
  };

  const categories = React.useMemo(() => {
    return slice.items.map((cat) => ({
      category: cat.category,
      categoryColor: cat.category_color,
    }));
  }, [slice.items]);

  // Transforms the data into a better format for display.
  const [tier1, tier2, tier3] = React.useMemo(() => {
    return [
      {
        logo: get(slice, 'primary.Tier_1_logo'),
        categories: slice.items.map((cat) => {
          return {
            category: cat.category,
            categoryColor: cat.category_color,
            contentType: cat.tier_1_type,
            content: cat.tier_1,
            contentColor: cat.category_1_content_color,
          };
        }),
      },
      {
        title: get(slice, 'primary.tier_2_title'),
        titleColor: get(slice, 'primary.tier_title_color'),
        categories: slice.items.map((cat) => {
          return {
            category: cat.category,
            contentType: cat.tier_2_type,
            content: cat.tier_2,
            contentColor: cat.alt_tier_content_color,
          };
        }),
      },
      {
        title: get(slice, 'primary.tier_3_title'),
        titleColor: get(slice, 'primary.tier_title_color'),
        categories: slice.items.map((cat) => {
          return {
            category: cat.category,
            contentType: cat.tier_3_type,
            content: cat.tier_3,
            contentColor: cat.alt_tier_content_color,
          };
        }),
      },
    ];
  }, [slice]);

  const secondaryTiers = [tier2, tier3];
  const slides = isMd ? secondaryTiers : [secondaryTiers[tierIndex]];

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="py-16"
      style={{
        backgroundImage: `linear-gradient(${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )}, ${get(slice, 'primary.background_color_end', '#FFFFFF')})`,
      }}
    >
      <div className="mx-auto max-w-2xl px-2 md:max-w-4xl lg:max-w-5xl lg:px-8">
        <div className="grid grid-cols-3 gap-2 md:grid-cols-4 lg:grid-cols-[minmax(285px,_1fr)_1fr_1fr_1fr] lg:gap-6 overflow-scroll md:overflow-hidden">
          {/* Categories */}
          <div className="flex flex-col gap-4 pt-4 col-span-1">
            <div className="h-16 md:h-10" />
            {categories.map((category, i) => (
              <div
                key={category.category}
                className="flex justify-end items-center  h-16"
              >
                <p
                  className={twMerge(
                    'text-right font-semibold font-dmsans',
                    i === 0 || i === categories.length - 1
                      ? 'text-sm md:text-base lg:text-lg'
                      : 'text-xs md:text-sm lg:text-base'
                  )}
                  style={{ color: category.categoryColor ?? '#FFFFFF' }}
                >
                  {category.category}
                </p>
              </div>
            ))}
          </div>

          {/* Non-slider Primary Tier 1 */}
          <div
            className="flex flex-col w-full max-w-[200px] gap-4 items-center rounded-2xl pt-4"
            style={{
              backgroundColor: get(
                slice,
                'primary.tier_1_background_color',
                '#DDFAE8'
              ),
            }}
          >
            <div className="h-16 md:h-10 px-2 flex items-center">
              <PrismicImage field={tier1.logo} height="26px" width="108px" />
            </div>
            {tier1.categories.map((category) => (
              <CategoryData key={category.category} {...category} />
            ))}
          </div>

          {/* Slider Secondary Tiers 2 & 3 */}
          <div className="col-span-1 md:col-span-2">
            <SliderTier
              tiers={slides}
              handleClick={handleClick}
              tierIndex={tierIndex}
            />
            <SliderBubbles
              slice={slice}
              tierIndex={tierIndex}
              onClick={handleClick}
            />
          </div>
        </div>
      </div>
    </section>
  );
};

export default ComparisonChart;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/ComparisonChart/SliderTier.tsx

'use client';

import { AnimatePresence, motion } from 'framer-motion';
import React from 'react';

import { type ISecondaryTier } from '.';
import CategoryData from './CategoryData';

interface ISliderTier {
  tiers: ISecondaryTier[];
  handleClick: () => void;
  tierIndex: number;
}

const SliderTier: React.FC<ISliderTier> = ({
  tiers,
  handleClick,
  tierIndex,
}) => {
  return (
    <div className="overflow-hidden">
      <AnimatePresence mode="wait">
        <motion.div
          initial={{ x: '100%', opacity: 0 }}
          animate={{
            x: '0%',
            opacity: 1,
            transition: { duration: 0.5, ease: 'easeOut' },
          }}
          exit={{
            x: '-100%',
            opacity: 0,
            transition: {
              duration: 0.5,
              ease: 'easeIn',
            },
          }}
          style={{ fontSize: 100 }}
          key={tierIndex}
        >
          <div
            className="grid grid-cols-1 md:grid-cols-2"
            onClick={handleClick}
          >
            {tiers.map((tier) => (
              <div key={tier.title}>
                <div className="flex flex-col gap-4 pt-4">
                  <div className="h-16 md:h-10 flex items-center justify-center">
                    <p
                      className="text-xl text-center font-bold font-dmsans"
                      style={{ color: tier.titleColor ?? '#FFFFFF' }}
                    >
                      {tier.title}
                    </p>
                  </div>
                  {tier.categories.map((category) => (
                    <CategoryData key={category.category} {...category} />
                  ))}
                </div>
              </div>
            ))}
          </div>
        </motion.div>
      </AnimatePresence>
    </div>
  );
};

export default SliderTier;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/ComparisonChart/SliderBubbles.tsx

import get from 'lodash.get';
import React from 'react';

import { Content } from '@prismicio/client';

interface ISliderBubbles {
  slice: Content.ComparisonChartSlice;
  tierIndex: number;
  onClick: () => void;
}

const SliderBubbles: React.FC<ISliderBubbles> = ({
  slice,
  tierIndex,
  onClick,
}) => {
  const getBackground = React.useCallback(
    (index: number) => {
      return tierIndex === index
        ? get(slice, 'primary.slide_dot_active', '#FFFFFF')
        : get(slice, 'primary.slide_dot_inactive', '#FFFFFF');
    },
    [slice, tierIndex]
  );

  return (
    <div className="flex justify-center gap-2 md:hidden">
      <button
        className="rounded-full p-1.5"
        style={{
          backgroundColor: getBackground(0),
        }}
        onClick={onClick}
      />
      <button
        className="rounded-full p-1.5"
        style={{
          backgroundColor: getBackground(1),
        }}
        onClick={onClick}
      />
    </div>
  );
};

export default SliderBubbles;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/ComparisonChart/CategoryData.tsx

import React from 'react';

import { CheckIcon, XMarkIcon } from '@heroicons/react/20/solid';

import { type ICategoryData } from '.';

const CategoryData: React.FC<ICategoryData> = ({
  contentType,
  content,
  contentColor,
}) => {
  const color = contentColor ?? '#FFFFFF';
  return (
    <div className="px-3 flex justify-center items-center h-16">
      {contentType === 'text' ? (
        <div
          className="font-dmsans text-center text-base font-bold leading-6"
          style={{
            color,
          }}
        >
          {content}
        </div>
      ) : (
        <>
          {contentType === 'check' ? (
            <CheckIcon
              className="mx-auto h-8 w-8"
              aria-hidden="true"
              style={{
                color,
              }}
            />
          ) : (
            <XMarkIcon
              className="mx-auto h-10 w-10"
              aria-hidden="true"
              style={{
                color,
              }}
            />
          )}
        </>
      )}
    </div>
  );
};

export default CategoryData;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/BlogArticle/index.tsx

import dayjs from 'dayjs';

import { BlogArticleContext } from '@/app/(non-account)/blog/[uid]/page';
import InlineShareButtons from '@/app/shared/components/buttons/share-buttons/inline-share-button';
import { Content } from '@prismicio/client';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';
import {
  JSXMapSerializer,
  PrismicRichText,
  SliceComponentProps,
} from '@prismicio/react';

const components: JSXMapSerializer = {
  paragraph: ({ children }) => (
    <p className="font-dmsans text-[15px] text-[#333] leading-[26px] font-light mb-[15px] [&_strong]:font-bold">
      {children}
    </p>
  ),
  heading1: ({ children }) => (
    <div className="font-dmsans text-4xl font-bold tracking-tight text-[#263A61]">
      {children}
    </div>
  ),
  heading2: ({ children }) => (
    <div className="font-dmsans text-[32px] leading-9 font-bold text-[#263A61] my-6">
      {children}
    </div>
  ),
  heading3: ({ children }) => (
    <div className="font-dmsans text-2xl font-semibold text-[#263A61]">
      {children}
    </div>
  ),
  heading4: ({ children }) => (
    <div className="font-dmsans text-xl font-medium text-[#263A61]">
      {children}
    </div>
  ),
  heading5: ({ children }) => (
    <div className="font-dmsans text-lg text-[#263A61]">{children}</div>
  ),
  list: ({ children }) => (
    <ul className="font-dmsans list-disc ml-10 space-y-1.5 text-[15px] text-[#333] leading-[26px] font-light mb-[15px] [&_strong]:font-bold">
      {children}
    </ul>
  ),
  hyperlink: ({ children, node }) => (
    <PrismicNextLink
      field={node.data}
      className="font-dmsans text-[15px] leading-[26px] font-light underline text-[#9B6222] [&_strong]:text-[#9B6222] hover:text-[#A1CFAE]"
    >
      {children}
    </PrismicNextLink>
  ),
  em: ({ children }) => <em className="font-dmsans">{children}</em>,
};

/**
 * Props for `BlogArticle`.
 */
export type BlogArticleProps = SliceComponentProps<
  Content.BlogArticleSlice,
  BlogArticleContext
>;

/**
 * Component for "BlogArticle" Slices.
 */
const BlogArticle = ({ slice, context }: BlogArticleProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      className="mb-5"
    >
      <div className="mx-auto max-w-6xl">
        <div className="flex flex-row justify-between items-center pb-[60px]">
          {context.blogAuthor ? (
            <div className="flex items-center gap-x-6">
              <PrismicNextImage
                className="h-16 w-16 rounded-full"
                field={context.blogAuthor.avatar}
                alt=""
              />
              <div className="font-dmsans">
                <p className="text-lg font-semibold leading-8 tracking-[-0.02em] text-[#333]">
                  {context.blogAuthor.name}
                </p>
                <p className="text-lg font-light leading-8 tracking-[-0.02em] text-gray-500">
                  {`${dayjs(context.page.data.publication_date).format(
                    'MMMM DD, YYYY'
                  )} • ${context.page.data.read_time}`}
                </p>
              </div>
            </div>
          ) : (
            <div />
          )}
          <InlineShareButtons />
        </div>
        <div className="h-auto w-full overflow-hidden rounded-[20px] bg-gray-100">
          <PrismicNextImage
            field={slice.primary.hero_image}
            className="object-cover object-center"
            alt=""
          />
        </div>

        <div className="mx-auto max-w-[840px] mt-10">
          <PrismicRichText
            field={slice.primary.content}
            components={components}
          />

          <div className="mt-16 flex flex-row justify-between items-center py-8 border-y border-[#eee] ">
            {context.blogAuthor ? (
              <div className="flex items-center gap-x-6">
                <PrismicNextImage
                  className="h-16 w-16 rounded-full"
                  field={context.blogAuthor.avatar}
                  alt=""
                />
                <div className="font-dmsans">
                  <p className="text-lg font-light leading-8 tracking-[-0.02em] text-gray-500">
                    Article by
                  </p>
                  <p className="text-lg font-semibold leading-8 tracking-[-0.02em] text-[#333]">
                    {context.blogAuthor.name}
                  </p>
                </div>
              </div>
            ) : (
              <div />
            )}
            <InlineShareButtons />
          </div>
        </div>
      </div>
    </section>
  );
};

export default BlogArticle;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/IconBulletList/index.tsx

'use client';

import get from 'lodash.get';

import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `IconBulletList`.
 */
export type IconBulletListProps =
  SliceComponentProps<Content.IconBulletListSlice>;

/**
 * Component for "IconBulletList" Slices.
 */
const IconBulletList = ({ slice }: IconBulletListProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
      style={{
        backgroundImage: `linear-gradient(180deg, ${get(
          slice,
          'primary.background_color_start',
          '#FFFFFF'
        )} 0%, ${get(slice, 'primary.background_color_end', '#FFFFFF')} 100%)`,
      }}
    >
      <div className="max-w-6xl mx-auto lg:mx-0">
        <div className="max-w-5xl mx-auto px-6 pt-14 pb-20">
          <div className="mx-auto bg-[#ABEBD9] w-full max-w-[122px] h-1" />
          <h2 className="font-dmsans mt-6 text-2xl sm:text-4xl font-semibold tracking-tight text-center text-gray-900">
            {slice.primary.title}
          </h2>
          <div className="mt-16 flex flex-row flex-wrap gap-x-8 gap-y-12 item-center justify-center font-dmsans">
            {slice.items.map((item) => (
              <div
                key={item.header}
                className="flex flex-col items-center max-w-[289px] text-center"
              >
                <PrismicNextImage
                  className=""
                  field={item.icon}
                  alt=""
                  width={48}
                  height={48}
                  aria-hidden="true"
                />
                <h2 className="mt-3 text-gray-900 text-lg sm:text-xl font-semibold">
                  {item.header}
                </h2>
                <p className="mt-1 text-base text-gray-600">{item.subheader}</p>
              </div>
            ))}
          </div>
        </div>
      </div>
    </section>
  );
};

export default IconBulletList;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/FeaturedCollection/index.tsx

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { ProductWithContent } from '@/app/shared/types';
import { formatCurrency } from '@/utils/utils';
import { User } from '@prisma/client';
import { Content } from '@prismicio/client';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `FeaturedCollection`.
 */
export type FeaturedCollectionProps =
  SliceComponentProps<Content.FeaturedCollectionSlice>;

/**
 * Component for "FeaturedCollection" Slices.
 */
const FeaturedCollection: React.FC<FeaturedCollectionProps> = async (p) => {
  const ctx = p.context as {
    user: User;
    products: ProductWithContent[];
  };

  const products = ctx.products.filter(
    (product) => product.data.type === p.slice.primary.collection_tag
  );

  return products.length > 0 ? (
    <section
      data-slice-type={p.slice.slice_type}
      data-slice-variation={p.slice.variation}
    >
      <div className="mx-auto my-6 max-w-5xl px-4">
        <div className="font-dmsans text-5xl text-black font-semibold">
          {p.slice.primary.header}
        </div>
        <div className="mt-12 grid grid-cols-1 gap-x-6 gap-y-6 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-3 xl:gap-x-8">
          {products.map((product) => (
            <PrismicNextLink
              key={product.uid}
              document={product}
              className="group font-dmsans"
            >
              <div className="aspect-square w-full sm:w-[300px] overflow-hidden rounded-lg bg-white">
                <PrismicNextImage
                  field={product.data.thumbnail}
                  className="w-full h-full object-cover object-center group-hover:opacity-75"
                />
              </div>
              <div className="p-6">
                <p className="text-base font-medium text-gray-600">
                  {product.data.type}
                </p>
                <p className="mt-2 text-2xl font-medium text-gray-900">
                  {product.data.name}
                </p>
                <p className="mt-2 text-lg font-semibold text-gray-900">
                  {formatCurrency(product.price)}
                </p>
              </div>
            </PrismicNextLink>
          ))}
        </div>
        <div className="flex w-full justify-center items-center mt-10">
          <CustomPrismicLink
            variant="solid-accent"
            field={p.slice.primary.products_link}
            className=""
          >
            {p.slice.primary.products_link_text}
          </CustomPrismicLink>
        </div>
      </div>
    </section>
  ) : null;
};

export default FeaturedCollection;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountHero/index.tsx

import { Content } from '@prismicio/client';
import { SliceComponentProps } from '@prismicio/react';

import DefaultHero from './variants/DefaultHero';
import HeroCenteredTitle from './variants/HeroCenteredTitle';
import HeroImageTitle from './variants/HeroImageTitle';

/**
 * Props for `AccountHero`.
 */
export type AccountHeroProps = SliceComponentProps<Content.AccountHeroSlice>;

/**
 * Component for "AccountHero" Slices.
 */
const AccountHero = ({ slice, context }: AccountHeroProps): JSX.Element => {
  let Hero = null;

  if (slice.variation === 'heroCenteredTitle') {
    Hero = <HeroCenteredTitle slice={slice} context={context} />;
  } else if (slice.variation === 'heroImageTitle') {
    Hero = <HeroImageTitle slice={slice} context={context} />;
  } else {
    Hero = <DefaultHero slice={slice} context={context} />;
  }

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      {Hero}
    </section>
  );
};

export default AccountHero;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountHero/variants/HeroCenteredTitle.tsx

import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';

interface IAccountHeroProps {
  slice: Content.AccountHeroSliceHeroCenteredTitle;
  context: unknown;
}

/**
 * Component for "HeroCenteredTitle" variation.
 */
const HeroCenteredTitle = ({ slice }: IAccountHeroProps): JSX.Element => {
  return (
    <div className="relative isolate overflow-hidden pt-14">
      <PrismicNextImage
        field={slice.primary.image}
        alt=""
        className="absolute inset-0 -z-10 h-full w-full object-cover"
        priority
      />

      <div className="mx-auto max-w-2xl py-20">
        <div className="text-center">
          <h1 className="font-dmsans text-4xl font-medium text-white sm:text-7xl">
            {slice.primary.header as string}
          </h1>
        </div>
      </div>
    </div>
  );
};

export default HeroCenteredTitle;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountHero/variants/HeroImageTitle.tsx

import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';

interface IAccountHeroProps {
  slice: Content.AccountHeroSliceHeroImageTitle;
  context: unknown;
}

/**
 * Component for "HeroImageTitle" variation.
 */
const HeroImageTitle = ({ slice }: IAccountHeroProps): JSX.Element => {
  return (
    <div className="relative isolate overflow-hidden pt-14">
      <PrismicNextImage
        field={slice.primary.image}
        alt=""
        className="absolute inset-0 -z-10 h-full w-full object-cover"
        priority
      />
      <div className="mx-auto max-w-2xl py-20 sm:py-24 lg:py-24">
        <div className="text-center">
          <PrismicNextImage
            field={slice.primary.title_image}
            className="mx-auto h-32 sm:h-40 lg:h-80 w-auto"
            alt=""
            priority
          />
        </div>
      </div>
    </div>
  );
};

export default HeroImageTitle;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/AccountHero/variants/DefaultHero.tsx

import MarkdownElement from '@/app/shared/components/markdown-element';
import { SexAtBirthEnum } from '@prisma/client';
import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';

interface IAccountHeroProps {
  slice: Content.AccountHeroSliceDefault;
  context: unknown;
}

/**
 * Component for "DefaultHero" variation.
 */
const DefaultHero = ({ slice, context }: IAccountHeroProps): JSX.Element => {
  const ctx = context as any;

  const imageField =
    ctx?.user?.medicalProfile?.sexAtBirth === SexAtBirthEnum.MALE
      ? slice.primary.image_male
      : slice.primary.image_female;

  return (
    <div className="relative max-w-none 2xl:max-w-7xl 2xl:pr-5">
      <div className="w-full overflow-hidden h-[315px] 2xl:rounded-br-xl">
        <PrismicNextImage
          field={imageField}
          className="h-full w-full object-cover object-center"
          alt=""
          priority
        />
      </div>
      <div className="absolute bottom-6 left-6">
        <div className="[&_p]:text-3xl [&_p]:font-financier sm:[&_p]:text-4xl [&_p]:text-white">
          <MarkdownElement dataContext={context as any}>
            {slice.primary.header as string}
          </MarkdownElement>
        </div>
        <p className="font-dmsans text-2xl sm:text-3xl text-white max-w-sm">
          {slice.primary.subheader}
        </p>
      </div>
    </div>
  );
};

export default DefaultHero;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/DiscoverTretinoin/index.tsx

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import {
  JSXMapSerializer,
  PrismicRichText,
  SliceComponentProps,
} from '@prismicio/react';

/**
 * Props for `DiscoverTretinoin`.
 */
export type DiscoverTretinoinProps =
  SliceComponentProps<Content.DiscoverTretinoinSlice>;

const richTextComponents: JSXMapSerializer = {
  label: ({ node, children }) => {
    if (node.data.label === 'strike') {
      return (
        <span className="relative">
          {children}
          <span className="absolute -z-10 bg-[#CDEBE5] h-5 bottom-0 left-0 right-0" />
        </span>
      );
    }
  },
};

/**
 * Component for "DiscoverTretinoin" Slices.
 */
const DiscoverTretinoin = ({ slice }: DiscoverTretinoinProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="bg-[#F5F5F5] py-8">
        <div className="relative isolate">
          <div className="mx-auto max-w-8xl">
            <div className="mx-auto flex max-w-2xl flex-col gap-8 px-10 sm:gap-16 md:flex-row md:mx-0 md:max-w-none md:items-center xl:gap-x-16">
              {/* Image Column */}
              <div className="mb-4 w-full max-w-[610px] sm:mb-0 sm:mr-4">
                <PrismicNextImage
                  field={slice.primary.image}
                  alt=""
                  className="w-full h-auto"
                />
              </div>

              <div className="w-full flex-auto">
                <p className="font-dmsans text-sm tracking-[4px] font-medium leading-10 text-[#4C4C4C]">
                  {slice.primary.eyebrow}
                </p>
                <h2 className="font-financier text-5xl font-semibold tracking-tight max-w-xl md:text-6xl md:leading-[62px] mb-3">
                  {slice.primary.title}
                </h2>
                <div className="font-dmsans mt-3 text-[28px] tracking-tight">
                  <PrismicRichText
                    field={slice.primary.content}
                    components={richTextComponents}
                  />
                </div>
                <CustomPrismicLink
                  field={slice.primary.cta_link}
                  variant="solid-accent"
                  className="mt-6 py-2.5 md:text-lg text-black border-0 max-w-xs w-full font-bold"
                >
                  {slice.primary.cta_link_text}
                </CustomPrismicLink>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  );
};

export default DiscoverTretinoin;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/StepsSection/index.tsx

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { Content } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import {
  JSXMapSerializer,
  PrismicRichText,
  SliceComponentProps,
} from '@prismicio/react';

/**
 * Props for `StepsSection`.
 */
export type StepsSectionProps = SliceComponentProps<Content.StepsSectionSlice>;

const components: JSXMapSerializer = {
  paragraph: ({ children }) => (
    <p className="text-black font-dmsans text-[28px] leading-10 tracking-tight font-medium">
      {children}
    </p>
  ),
};

/**
 * Component for "StepsSection" Slices.
 */
const StepsSection = ({ slice }: StepsSectionProps): JSX.Element => {
  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="bg-white text-center">
        <div className="mx-auto flex flex-col items-center max-w-2xl px-4 pt-10 pb-14 sm:px-6 lg:max-w-7xl xl:px-8">
          <h2 className="font-financier font-semibold text-6xl leading-[60px] tracking-tight text-black">
            {slice.primary.title}
          </h2>

          <div className="mt-10 max-w-[704px]">
            <PrismicRichText
              field={slice.primary.subheader}
              components={components}
            />
          </div>

          <div className="mt-14 mb-12 grid grid-cols-1 gap-y-4 justify-items-center sm:grid-cols-2 sm:gap-x-6 sm:gap-y-10 lg:grid-cols-4 lg:gap-x-4 xl:gap-x-8">
            {slice.items.map((step, i) => (
              <div
                key={`${slice.id}-step-${i}`}
                className="relative flex flex-col overflow-hidden rounded-[15px] border border-gray-200 bg-white py-4 px-5 max-w-xs"
              >
                <div className="relative aspect-h-4 aspect-w-3 bg-gray-200 sm:aspect-none lg:h-48 xl:h-60">
                  <PrismicNextImage
                    field={step.image}
                    className="h-full w-full object-cover object-center sm:h-full sm:w-full"
                  />
                  <div className="absolute bottom-0 left-0 flex items-center justify-center bg-[#E1F9F7] h-11 w-11">
                    <span className="font-financier text-4xl text-black">
                      {i + 1}
                    </span>
                  </div>
                </div>
                <div className="mt-4 flex flex-1 flex-col space-y-2 justify-center">
                  <div className="text-center font-dmsans text-base font-medium text-black">
                    <PrismicRichText field={step.content} />
                  </div>
                </div>
              </div>
            ))}
          </div>

          <p className="font-dmsans italic text-base text-[#565656] max-w-5xl leading-[18px]">
            {slice.primary.disclaimer_text}
          </p>

          <div className="my-9">
            <PrismicRichText
              field={slice.primary.footer}
              components={components}
            />
          </div>
          <CustomPrismicLink
            field={slice.primary.cta_link}
            variant="solid-accent"
            className="mx-auto py-2.5 md:text-lg text-black border-0 max-w-xs w-full font-bold"
          >
            {slice.primary.cta_link_text}
          </CustomPrismicLink>
        </div>
      </div>
    </section>
  );
};

export default StepsSection;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/ComplaintSelect/index.tsx

import { AccountPageContext } from '@/app/shared/types';
import { Content, isFilled } from '@prismicio/client';
import { PrismicRichText, SliceComponentProps } from '@prismicio/react';

import ComplaintLink from './link';

/**
 * Props for `ComplaintSelect`.
 */
export type ComplaintSelectProps = SliceComponentProps<
  Content.ComplaintSelectSlice,
  AccountPageContext
>;

/**
 * Component for "ComplaintSelect" Slices.
 */
const ComplaintSelect = ({
  slice,
  context,
}: ComplaintSelectProps): JSX.Element => {
  const { partner } = context;
  const hasFooter = isFilled.richText(slice.primary.footer);

  const partnerDisallowsIntakeByTreatment =
    partner &&
    partner.allowIntakeByTreatment !== null &&
    !partner.allowIntakeByTreatment;

  const hideOptions =
    slice.primary.hide_when_treatment_disallowed &&
    partnerDisallowsIntakeByTreatment;

  return (
    <section
      data-slice-type={slice.slice_type}
      data-slice-variation={slice.variation}
    >
      <div className="flex flex-col justify-center w-full max-w-3xl mx-auto px-4">
        {!hideOptions && (
          <>
            {slice.primary.header && (
              <div className="flex flex-col justify-center w-full pb-4 pt-14 lg:pt-20">
                <h1 className="font-financier text-gray-700 text-4xl font-semibold mb-3">
                  {slice.primary.header}
                </h1>
                <div className="font-dmsans text-base text-gray-600 font-medium">
                  <PrismicRichText field={slice.primary.subheader} />
                </div>
              </div>
            )}
            <h2 className="font-financier text-gray-700 text-[28px] mt-4 font-semibold mb-1">
              {slice.primary.section_title}
            </h2>
            <div className="font-dmsans text-base text-gray-600 font-medium">
              <PrismicRichText field={slice.primary.section_description} />
            </div>
            <div className="flex flex-row gap-2 items-center flex-wrap my-5">
              {slice.items.map((complaint) => (
                <ComplaintLink key={complaint.link_text} {...complaint} />
              ))}
            </div>
          </>
        )}
        {hasFooter && (
          <div className="mt-6 mb-10">
            <div className="bg-accent-300 w-14 h-0.5 mb-4" />
            <div className="font-dmsans text-base text-gray-600 font-medium">
              <PrismicRichText field={slice.primary.footer} />
            </div>
          </div>
        )}
      </div>
    </section>
  );
};

export default ComplaintSelect;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/slices/ComplaintSelect/link.tsx

'use client';

import { useSearchParams } from 'next/navigation';
import { Simplify } from 'prismicio-types';

import {
  Content,
  FilledContentRelationshipField,
  LinkResolverFunction,
} from '@prismicio/client';
import { PrismicNextLink } from '@prismicio/next';
import { SliceComponentProps } from '@prismicio/react';

/**
 * Props for `ComplaintSelect`.
 */
export type ComplaintSelectProps =
  SliceComponentProps<Content.ComplaintSelectSlice>;

/**
 * Component for "ComplaintSelect" Slices.
 */
const ComplaintLink = (
  complaint: Simplify<Content.ComplaintSelectSliceDefaultItem>
): JSX.Element => {
  const searchParams = useSearchParams();

  const queryParamResolver: LinkResolverFunction = (
    linkToDocumentField: FilledContentRelationshipField<string, string, unknown>
  ) => {
    if (!linkToDocumentField.url) return null;

    const prismicUrl = new URL(
      linkToDocumentField.url,
      process.env.NEXT_PUBLIC_BASE_URL
    );

    if (complaint.search_params) {
      // If the link has search params, append them to the URL
      if (searchParams.toString()) {
        return `${prismicUrl.pathname}${
          complaint.search_params
        }&${searchParams.toString()}`;
      }

      return `${prismicUrl.pathname}${complaint.search_params}`;
    }
    return prismicUrl.pathname;
  };

  return (
    <PrismicNextLink
      key={complaint.link_text}
      field={complaint.link}
      className="inline-flex items-center justify-center px-[18px] py-2.5 rounded-lg bg-white border border-gray-300 cursor-pointer font-dmsans text-base text-gray-700 font-semibold hover:text-accent-700 hover:border-accent-300 hover:bg-accent-100"
      linkResolver={queryParamResolver}
    >
      {complaint.link_text}
    </PrismicNextLink>
  );
};

export default ComplaintLink;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/robots.ts

import { MetadataRoute } from 'next';

export default function robots(): MetadataRoute.Robots {
  const env = process.env.ENVIRONMENT_NAME ?? 'production';

  if (env === 'production') {
    return {
      rules: [
        {
          userAgent: '*',
          allow: '/',
          disallow: ['/private/', '/account/'],
        },
      ],
      sitemap: 'https://www.cortinahealth.com/sitemap.xml',
    };
  }

  return {
    rules: {
      disallow: '/',
    },
  };
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/sitemap.ts

import { MetadataRoute } from 'next';
import { BlogpostDocument, HelpArticleDocument } from 'prismicio-types';

import { createClient } from '@/prismicio';
import { PrismicPageType } from '@/utils/prismic/enums';

export enum SitemapChangeFrequency {
  YEARLY = 'yearly',
  MONTHLY = 'monthly',
  WEEKLY = 'weekly',
  DAILY = 'daily',
  HOURLY = 'hourly',
  ALWAYS = 'always',
}

export enum SitemapPriority {
  VERY_HIGH = 1,
  HIGH = 0.8,
  MEDIUM = 0.5,
  LOW = 0.3,
}

const queryBlogPosts = async () => {
  const client = createClient();
  const posts = await client
    .getAllByType<BlogpostDocument>(PrismicPageType.BLOG_POST)
    .catch(() => [] as BlogpostDocument[]);

  return posts.map((post) => {
    return {
      url: `https://www.cortinahealth.com/blog/${post.uid}`,
      lastModified: new Date(post.last_publication_date),
      changeFrequency: SitemapChangeFrequency.WEEKLY,
      priority: SitemapPriority.MEDIUM,
    };
  });
};

const queryHelpArticles = async () => {
  const client = createClient();

  const articles = await client
    .getAllByType<HelpArticleDocument>(PrismicPageType.HELP_ARTICLE)
    .catch(() => [] as HelpArticleDocument[]);

  return articles.map((article) => {
    return {
      url: `https://www.cortinahealth.com/help/articles/${article.uid}`,
      lastModified: new Date(article.last_publication_date),
      changeFrequency: SitemapChangeFrequency.MONTHLY,
      priority: SitemapPriority.LOW,
    };
  });
};

export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  const LAUNCH_DATE = '2024-03-01T18:00:00+00:00';
  const TODAY = new Date();

  const [posts, articles] = await Promise.all([
    queryBlogPosts(),
    queryHelpArticles(),
  ]);

  return [
    ...posts,
    ...articles,
    {
      url: 'https://www.cortinahealth.com',
      lastModified: TODAY,
      changeFrequency: SitemapChangeFrequency.WEEKLY,
      priority: SitemapPriority.VERY_HIGH,
    },
    {
      url: 'https://www.cortinahealth.com/tretinoin',
      lastModified: TODAY,
      changeFrequency: SitemapChangeFrequency.WEEKLY,
      priority: SitemapPriority.HIGH,
    },
    {
      url: 'https://www.cortinahealth.com/shop',
      lastModified: LAUNCH_DATE,
      changeFrequency: SitemapChangeFrequency.WEEKLY,
      priority: SitemapPriority.HIGH,
    },
    {
      url: 'https://www.cortinahealth.com/shop/products/cortina-2828-5-step-skincare-system',
      lastModified: LAUNCH_DATE,
      changeFrequency: SitemapChangeFrequency.WEEKLY,
      priority: SitemapPriority.HIGH,
    },
    {
      url: 'https://www.cortinahealth.com/shop/products/cortina-2828-base-cleanser',
      lastModified: LAUNCH_DATE,
      changeFrequency: SitemapChangeFrequency.WEEKLY,
      priority: SitemapPriority.HIGH,
    },
    {
      url: 'https://www.cortinahealth.com/shop/products/cortina-2828-mist-toner',
      lastModified: LAUNCH_DATE,
      changeFrequency: SitemapChangeFrequency.WEEKLY,
      priority: SitemapPriority.HIGH,
    },
    {
      url: 'https://www.cortinahealth.com/shop/products/cortina-2828-steep-moisturizer',
      lastModified: LAUNCH_DATE,
      changeFrequency: SitemapChangeFrequency.WEEKLY,
      priority: SitemapPriority.HIGH,
    },
    {
      url: 'https://www.cortinahealth.com/shop/products/cortina-2828-revitalizing-vitamin-c-bio-serum',
      lastModified: LAUNCH_DATE,
      changeFrequency: SitemapChangeFrequency.WEEKLY,
      priority: SitemapPriority.HIGH,
    },
    {
      url: 'https://www.cortinahealth.com/shop/products/cortina-2828-bio-regenerative-oil',
      lastModified: LAUNCH_DATE,
      changeFrequency: SitemapChangeFrequency.WEEKLY,
      priority: SitemapPriority.HIGH,
    },
    {
      url: 'https://www.cortinahealth.com/help',
      lastModified: LAUNCH_DATE,
      changeFrequency: SitemapChangeFrequency.MONTHLY,
      priority: SitemapPriority.MEDIUM,
    },
    {
      url: 'https://www.cortinahealth.com/our-story',
      lastModified: LAUNCH_DATE,
      changeFrequency: SitemapChangeFrequency.YEARLY,
      priority: SitemapPriority.LOW,
    },
    {
      url: 'https://www.cortinahealth.com/blog',
      lastModified: LAUNCH_DATE,
      changeFrequency: SitemapChangeFrequency.WEEKLY,
      priority: SitemapPriority.MEDIUM,
    },
    {
      url: 'https://www.cortinahealth.com/blog/tags',
      lastModified: LAUNCH_DATE,
      changeFrequency: SitemapChangeFrequency.YEARLY,
      priority: SitemapPriority.LOW,
    },
    {
      url: 'https://www.cortinahealth.com/terms-and-conditions',
      lastModified: LAUNCH_DATE,
      changeFrequency: SitemapChangeFrequency.YEARLY,
      priority: SitemapPriority.LOW,
    },
    {
      url: 'https://www.cortinahealth.com/privacy-policy',
      lastModified: LAUNCH_DATE,
      changeFrequency: SitemapChangeFrequency.YEARLY,
      priority: SitemapPriority.LOW,
    },
  ];
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/layout.tsx

import Script from 'next/script';
import { twMerge } from 'tailwind-merge';
import { NextAppDirEmotionCacheProvider } from 'tss-react/next/appDir';

import { repositoryName } from '@/prismicio';
import { DMSans, DMSerifDisplay, Financier } from '@/styles/font-loader';
import '@/styles/globals.css';
import WindowDOM from '@components/analytics/windowDOM/window-dom';
import CartContextWrapper from '@components/cart/cart-context-wrapper';
import CookieSetter from '@components/cookie-setter/cookie-setter';
import DatadogInit from '@components/datadog-init/datadog-init';
import { PrismicPreview } from '@prismicio/next';

import LocationWarning from './shared/components/banner/location-warning';
import ContextWrapper from './shared/components/context-wrapper';

const RootLayout = async ({ children }: { children: React.ReactNode }) => {
  return (
    <html
      lang="en"
      className={twMerge(
        'scroll-smooth bg-white antialiased h-full',
        DMSans.variable,
        Financier.variable,
        DMSerifDisplay.variable
      )}
    >
      <head>
        <link
          rel="apple-touch-icon"
          sizes="180x180"
          href="/favicons/apple-touch-icon.png"
        />
        <link
          rel="icon"
          type="image/png"
          sizes="32x32"
          href="/favicons/favicon-32x32.png"
        />
        <link
          rel="icon"
          type="image/png"
          sizes="16x16"
          href="/favicons/favicon-16x16.png"
        />
        <Script id="google-tag-manager">
          {` (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-57D47R35'); `}
        </Script>
      </head>
      <body className="fixed inset-0 flex flex-col root-layout h-full overflow-hidden">
        <div className="scroll-window min-h-full flex flex-col flex-1 overflow-auto">
          <CookieSetter />
          <WindowDOM />
          <DatadogInit />

          <LocationWarning />

          <NextAppDirEmotionCacheProvider options={{ key: 'css' }}>
            <ContextWrapper>
              <CartContextWrapper>{children}</CartContextWrapper>
            </ContextWrapper>
          </NextAppDirEmotionCacheProvider>
          <PrismicPreview repositoryName={repositoryName} />
        </div>
      </body>
    </html>
  );
};

export default RootLayout;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/error.tsx

'use client';

import React from 'react';

import ErrorView from '@components/error-view';

const Error: React.FC = () => {
  return <ErrorView />;
};

export default Error;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/loading.tsx

import LoadingCircles from '@components/loading-indicators/loading-circles';

export default function Loading() {
  return <LoadingCircles />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/page.tsx

import { notFound } from 'next/navigation';
import { HomeDocument } from 'prismicio-types';

import NavigationWrapper from '@/app/shared/components/navigation-wrapper';
import { createClient } from '@/prismicio';
import { components } from '@/slices';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { SliceZone } from '@prismicio/react';
import { PrismicPageType } from '@utils/prismic/enums';

export default async function Page() {
  const page = await queryPage();

  return (
    <NavigationWrapper
      shouldShow={page.data.show_navigation_header}
      initialNavigationLinkedItem={page.data.initial_header_theme}
      scrollNavigationLinkedItem={page.data.scroll_header_theme}
    >
      <div className="home-page">
        <SliceZone
          slices={page.data.slices}
          components={components}
          context={{}}
        />
      </div>
    </NavigationWrapper>
  );
}

export async function generateMetadata() {
  const page = await queryPage();
  return prismicPageToMetadata(page, '/');
}

const queryPage = async () => {
  const client = createClient();
  return await client
    .getSingle<HomeDocument>(PrismicPageType.HOME)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/global-error.tsx

'use client';

import ErrorView from './shared/components/error-view';

export default function GlobalError() {
  return <ErrorView />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/not-found.tsx

import NotFoundView from '@components/not-found-view';

export default function NotFound() {
  return <NotFoundView />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/slice-simulator/page.tsx

'use client';

import dynamic from 'next/dynamic';

import { SliceZone } from '@prismicio/react';
import { SliceSimulator } from '@slicemachine/adapter-next/simulator';

const components = {
  account_hero: dynamic(() => import('../../slices/AccountHero')),
  comparison_chart: dynamic(() => import('../../slices/ComparisonChart')),
  complaint_selector: dynamic(() => import('../../slices/ComplaintSelector')),
  cta_section: dynamic(() => import('../../slices/CtaSection')),
  faqs: dynamic(() => import('../../slices/Faqs')),
  footer_group: dynamic(() => import('../../slices/FooterGroup')),
  hero_carousel: dynamic(() => import('../../slices/HeroCarousel')),
  hero_section: dynamic(() => import('../../slices/HeroSection')),
  incentives: dynamic(() => import('../../slices/Incentives')),
  large_quote: dynamic(() => import('../../slices/LargeQuote')),
  logo_cloud: dynamic(() => import('../../slices/LogoCloud')),
  messaging_cta_section: dynamic(
    () => import('../../slices/AccountCtaSection')
  ),
  navigation_bar: dynamic(() => import('../../slices/NavigationItem')),
  stats_banner: dynamic(() => import('../../slices/StatsBanner')),
  testimonials: dynamic(() => import('../../slices/Testimonials')),
  text_area: dynamic(() => import('../../slices/TextArea')),
  vertical_timeline: dynamic(() => import('../../slices//VerticalTimeline')),
};

export default function SliceSimulatorPage() {
  return (
    <SliceSimulator
      sliceZone={({ slices }) => (
        <SliceZone slices={slices as any} components={components} />
      )}
    />
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/layout.tsx

import '@/styles/globals.css';
import WindowDOM from '@components/analytics/windowDOM/window-dom';

export const dynamic = 'force-dynamic';

const NonAccountLayout = ({ children }: { children: React.ReactNode }) => {
  return (
    <>
      <WindowDOM />
      {children}
    </>
  );
};

export default NonAccountLayout;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(root-pages)/[uid]/page.tsx

import { notFound } from 'next/navigation';
import { PageDocument } from 'prismicio-types';

import NavigationWrapper from '@/app/shared/components/navigation-wrapper';
import { createClient } from '@/prismicio';
import { components } from '@/slices';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { SliceZone } from '@prismicio/react';
import { PrismicPageType } from '@utils/prismic/enums';

export const dynamicParams = false;

type Params = { uid: string };
export default async function Page({ params }: { params: Params }) {
  const page = await queryPage(params.uid);
  return (
    <NavigationWrapper
      shouldShow={page.data.show_navigation_header}
      initialNavigationLinkedItem={page.data.initial_header_theme}
      scrollNavigationLinkedItem={page.data.scroll_header_theme}
    >
      <div className="non-account-page">
        <SliceZone
          slices={page.data.slices}
          components={components}
          context={{}}
        />
      </div>
    </NavigationWrapper>
  );
}

export async function generateMetadata({ params }: { params: Params }) {
  const page = await queryPage(params.uid);

  return prismicPageToMetadata(page, `/${params.uid}`);
}

export async function generateStaticParams() {
  const client = createClient();
  const pages = await client.getAllByType(PrismicPageType.PAGE);

  return pages.map((page) => {
    return { uid: page.uid };
  });
}

const queryPage = async (uid: string) => {
  const client = createClient();
  return await client
    .getByUID<PageDocument>(PrismicPageType.PAGE, uid)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/contexts/form-modal-context.tsx

'use client';

import React from 'react';

interface IFormModalContext {
  isModalVisible: boolean;
  modalId: string;
  openModal: (modalId?: string) => void;
  closeModal: () => void;
}

export const FormModalContext = React.createContext<IFormModalContext>({
  isModalVisible: false,
  modalId: '',
  openModal: () => {},
  closeModal: () => {},
});

export function FormModalContextProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const [isModalVisible, setIsModalVisible] = React.useState(false);
  const [modalId, setModalId] = React.useState('');

  const openModal = (modalId?: string) => {
    if (modalId) {
      setModalId(modalId);
      setIsModalVisible(true);
    }
  };

  const closeModal = () => {
    setIsModalVisible(false);
  };

  return (
    <FormModalContext.Provider
      value={{
        isModalVisible,
        modalId,
        openModal,
        closeModal,
      }}
    >
      {children}
    </FormModalContext.Provider>
  );
}

export default FormModalContextProvider;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/contexts/form-navigation-context.tsx

'use client';

import React from 'react';

import {
  FormInclude,
  SectionInclude,
  StepInclude,
} from '@/app/(non-account)/(features)/(form)/utils/types';
import { SlideDirection } from '@form/utils/enums';

export interface IStep extends StepInclude {
  isVisible?: boolean;
}

export interface ISection extends SectionInclude {
  steps: IStep[];
  isVisible?: boolean;
  confirmationView?: boolean;
}

export interface IFormNavigationContext {
  sections: ISection[];
  setSections: React.Dispatch<React.SetStateAction<ISection[]>>;
  currentSectionIndex: number;
  setCurrentSectionIndex: React.Dispatch<React.SetStateAction<number>>;
  currentStepIndex: number;
  setCurrentStepIndex: React.Dispatch<React.SetStateAction<number>>;
  showConfirmationView: boolean;
  setShowConfirmationView: React.Dispatch<React.SetStateAction<boolean>>;
  visitedSections: Array<string>;
  setVisitedSections: React.Dispatch<React.SetStateAction<Array<string>>>;
  slideDirection: string;
  setSlideDirection: React.Dispatch<React.SetStateAction<string>>;
  showConfirmation: boolean;
  showNavigation: boolean;
  showProgressBar: boolean;
  confirmationSectionTitle: string;
  confirmationViewTitle: string;
}

export const FormNavigationContext =
  React.createContext<IFormNavigationContext>({
    sections: [],
    setSections: () => {},
    currentSectionIndex: 0,
    setCurrentSectionIndex: () => {},
    currentStepIndex: 0,
    setCurrentStepIndex: () => {},
    showConfirmationView: false,
    setShowConfirmationView: () => {},
    visitedSections: [],
    setVisitedSections: () => {},
    slideDirection: SlideDirection.Left,
    setSlideDirection: () => {},
    showConfirmation: true,
    showNavigation: true,
    showProgressBar: true,
    confirmationSectionTitle: 'Confirmation',
    confirmationViewTitle: 'Please confirm',
  });

export function FormNavigationProvider({
  form,
  children,
}: {
  form: FormInclude;
  children: React.ReactNode;
}) {
  const [sections, setSections] = React.useState<ISection[]>(
    form?.sections ?? []
  );
  const [currentSectionIndex, setCurrentSectionIndex] =
    React.useState<number>(0);
  const [currentStepIndex, setCurrentStepIndex] = React.useState<number>(0);
  const [showConfirmationView, setShowConfirmationView] =
    React.useState<boolean>(false);
  const [visitedSections, setVisitedSections] = React.useState<string[]>([]);
  const [slideDirection, setSlideDirection] = React.useState<string>(
    SlideDirection.Left
  );

  return (
    <FormNavigationContext.Provider
      value={{
        sections,
        setSections,
        currentSectionIndex,
        setCurrentSectionIndex,
        currentStepIndex,
        setCurrentStepIndex,
        showConfirmationView,
        setShowConfirmationView,
        visitedSections,
        setVisitedSections,
        slideDirection,
        setSlideDirection,
        showConfirmation: form.showConfirmation ?? true,
        showNavigation: form.showNavigation ?? true,
        showProgressBar: form.showProgressBar ?? true,
        confirmationSectionTitle:
          form.confirmationSectionTitle ?? 'Confirmation',
        confirmationViewTitle: form.confirmationViewTitle ?? 'Please confirm',
      }}
    >
      {children}
    </FormNavigationContext.Provider>
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/contexts/form-context.tsx

'use client';

import React from 'react';
import { createContext, ReactNode } from 'react';

import {
  FormInclude,
  FormElementInclude,
  isFormField,
} from '@form/utils/types';

export interface IFormStateContext {
  fields: Array<FormElementInclude>;
  form?: FormInclude;
  formId: string;
  disabled: boolean;
  setDisabled: React.Dispatch<React.SetStateAction<boolean>>;
  showSuccessView: boolean;
  setShowSuccessView: React.Dispatch<React.SetStateAction<boolean>>;
  submissionError: boolean;
  setSubmissionError: React.Dispatch<React.SetStateAction<boolean>>;
  dataContext?: { [key: string]: any };
}

export const FormStateContext = createContext<IFormStateContext>({
  fields: [],
  form: undefined,
  formId: '',
  disabled: false,
  setDisabled: () => {},
  showSuccessView: false,
  setShowSuccessView: () => {},
  submissionError: false,
  setSubmissionError: () => {},
  dataContext: {},
});

const getAllFieldElements = (form: FormInclude) => {
  const fields: FormElementInclude[] = [];

  form?.sections?.forEach((section) => {
    section?.steps?.forEach((step) => {
      step?.formElements?.forEach((formElement) => {
        if (isFormField(formElement)) {
          fields.push(formElement);
        }
      });
    });
  });

  return fields;
};

export function FormProvider({
  form,
  formId,
  initialDisabled,
  context,
  children,
}: {
  form: FormInclude;
  formId: string;
  initialDisabled: boolean;
  context?: { [key: string]: any };
  children: ReactNode;
}) {
  const [disabled, setDisabled] = React.useState<boolean>(initialDisabled);
  const [showSuccessView, setShowSuccessView] = React.useState<boolean>(false);
  const [submissionError, setSubmissionError] = React.useState<boolean>(false);
  const allFields = getAllFieldElements(form);

  return (
    <FormStateContext.Provider
      value={{
        fields: allFields,
        form,
        formId,
        disabled,
        setDisabled,
        showSuccessView,
        setShowSuccessView,
        submissionError,
        setSubmissionError,
        dataContext: context,
      }}
    >
      {children}
    </FormStateContext.Provider>
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/generate-initial-form-data.ts

import Handlebars from 'handlebars';
import get from 'lodash.get';
import { cookies } from 'next/headers';

import LoggerUtil from '@/utils/clients/logging/apiUtilLogger';
import { UploadStatus } from '@/utils/enums';
import { getBaseUrl } from '@/utils/getBaseUrl';
import { registerHelpers } from '@/utils/handlebars-helpers';
import { parseJSONOrDefault } from '@/utils/utils';

import {
  FormElementInclude,
  FormFieldType,
  FormInclude,
  isFormField,
} from '../utils/types';

const getFileData = async (s3Url: string) => {
  try {
    const res = await fetch(`${getBaseUrl()}/api/forms/file-upload/info`, {
      headers: { Cookie: cookies().toString(), s3Url },
    });
    return (await res.json()) as any;
  } catch (error) {
    await LoggerUtil.logError(
      'file_retrieval_failure',
      'generate-initial-form-data > getFileData',
      error,
      { s3Url }
    );
    return null;
  }
};

export const getAllFieldElements = (form: FormInclude) => {
  const fields: FormElementInclude[] = [];

  form?.sections?.forEach((section) => {
    section?.steps?.forEach((step) => {
      step?.formElements?.forEach((formElement) => {
        if (isFormField(formElement)) {
          fields.push(formElement);
        }
      });
    });
  });

  return fields;
};

const getFieldType = (typename: string) => {
  switch (typename) {
    case FormFieldType.SingleCheckbox:
      return {
        default: false,
        dataType: 'boolean',
      };
    case FormFieldType.CheckboxGroup:
    case FormFieldType.FileUpload:
    case FormFieldType.AddressPicker:
    case FormFieldType.ApiCombobox:
      return {
        default: [],
        dataType: 'array',
      };
    case FormFieldType.PharmacyPicker:
      return {
        default: undefined,
        dataType: 'object',
      };
    default:
      return {
        default: '',
        dataType: 'string',
      };
  }
};

const getInitialFieldValue = async (
  field: FormElementInclude,
  initialData: { [key: string]: any },
  autoSaveData: { [key: string]: any },
  isAutoSaveEnabled = false
) => {
  const fieldType = getFieldType(field?.field?.fieldType ?? '');

  let fieldValue = get(initialData, field.name, fieldType.default);
  if (isAutoSaveEnabled) {
    // If auto save is enabled, autosave data takes precedence over initial data
    const autoSaveValue = get(autoSaveData, field.name, undefined);
    const autoSaveIsDefined = autoSaveValue != null && autoSaveValue.length > 0;
    fieldValue = autoSaveIsDefined ? autoSaveValue : fieldValue;
  }

  if (fieldType.dataType === 'array' && typeof fieldValue === 'string') {
    fieldValue = parseJSONOrDefault(fieldValue, []);
  }

  if (fieldType.dataType === 'object' && typeof fieldValue === 'string') {
    fieldValue = parseJSONOrDefault(fieldValue, undefined);
  }

  if (fieldType.dataType === 'boolean') {
    fieldValue = fieldValue === 'true';
  }

  // Get file metadata from S3 for each file
  if (field.field?.fieldType === FormFieldType.FileUpload) {
    if (fieldValue.some((file: any) => !file.status)) {
      const files = await Promise.all(
        fieldValue.map((file: any) => {
          if (!file.s3Url) return file;
          return getFileData(file.s3Url);
        })
      );
      fieldValue = files.filter(
        (file: any) => file.name != null && file.status === UploadStatus.SUCCESS
      );
    }
  }

  if (field.field?.fieldType === FormFieldType.Datepicker) {
    fieldValue = fieldValue ? fieldValue.split('T')?.[0] : fieldValue;
  }

  return fieldValue;
};

const getTemplatedInitialData = (
  fields: FormElementInclude[],
  context?: { [key: string]: any }
) => {
  registerHelpers();

  const templateValues: any = {};

  // Generate template values
  fields.forEach((field) => {
    if (field.field?.initialData !== null) {
      templateValues[field.name] = field.field?.initialData;
    }
  });

  const result: any = {};

  for (const key in templateValues) {
    const template = Handlebars.compile(templateValues[key]);
    const value = template(context);

    result[key] = value;
  }

  return result;
};

export const generateInitialFormData = async (
  form: FormInclude,
  autoSaveData: { [key: string]: any },
  context?: { [key: string]: any }
) => {
  const isAutoSaveEnabled = form.autoSaveEnabled ?? false;
  const fields = getAllFieldElements(form);
  const templatedValues = getTemplatedInitialData(fields, context);

  let initialValues: any = {};

  for (const formElement of fields) {
    const fieldValue = await getInitialFieldValue(
      formElement,
      templatedValues,
      autoSaveData,
      isAutoSaveEnabled
    );

    // Convert dot notation to bracket notation for Formik
    if (formElement.name.split?.('.').length > 1) {
      const [parent, child] = formElement.name.split('.');

      initialValues = {
        ...initialValues,
        [parent]: {
          ...(initialValues?.[parent] ?? []),
          [child]: fieldValue,
        },
      };
    } else {
      initialValues = {
        ...initialValues,
        [formElement?.name as string]: fieldValue,
      };
    }
  }

  return initialValues;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/generate-confirm-data.ts

import dayjs from 'dayjs';
import Handlebars from 'handlebars';
import DOMPurify from 'isomorphic-dompurify';
import get from 'lodash.get';

import { registerHelpers } from '@/utils/handlebars-helpers';
import {
  FormElementFieldProperties,
  FormSectionResponses,
} from '@prisma/client';

import { evaluateShowLogic } from './show-logic';
import { FormFieldType, FormInclude, isFormField } from './types';
import { isDateDefined, isStringDefined } from './validation-methods';

type generateConfirmDataType = (
  form: FormInclude,
  formValues: unknown,
  dataContext: unknown
) => FormSectionResponses[];

const handleCheckout = (fieldValue: unknown) =>
  typeof fieldValue === 'boolean'
    ? fieldValue
      ? 'Confirmed'
      : 'Unconfirmed'
    : null;

const handleSingleCheckbox = (fieldValue: unknown) =>
  typeof fieldValue === 'boolean'
    ? fieldValue
      ? 'Checked'
      : 'Not Checked'
    : null;

const handleTextAreaOrDatePicker = (fieldValue: unknown) =>
  typeof fieldValue === 'string' && isDateDefined(dayjs(fieldValue))
    ? dayjs(fieldValue).format('MMM DD, YYYY')
    : '';

const handleCheckboxGroup = (fieldValue: unknown) =>
  Array.isArray(fieldValue)
    ? fieldValue.length > 0
      ? fieldValue.join(', ')
      : ''
    : null;

const handleFileUpload = (fieldValue: unknown) => {
  if (Array.isArray(fieldValue)) {
    return fieldValue.map((file) => file.name).join(', ');
  }
  return null;
};

const handleAddressPicker = (fieldValue: unknown) => {
  if (Array.isArray(fieldValue)) {
    const address = fieldValue.find((address) => address.default);
    return `${address.name}: ${address.address1}, ${address.city}, ${address.state} ${address.zip} `;
  }
  return null;
};

const handleDefault = (fieldValue: unknown) =>
  typeof fieldValue === 'string'
    ? isStringDefined(fieldValue)
      ? fieldValue
      : ''
    : null;

const handleApiCombobox = (
  fieldValue: unknown,
  fieldProperties?: FormElementFieldProperties | null
) => {
  if (Array.isArray(fieldValue)) {
    const results: string[] = [];
    fieldValue.forEach((item) => {
      if (typeof item === 'string') {
        return item ?? '';
      }
      results.push(get(item, fieldProperties?.displayKey ?? '', ''));
    });
    return results.join(', ');
  }
  return null;
};

const handlePharmacyPicker = (fieldValue: unknown) => {
  if (fieldValue && typeof fieldValue === 'object') {
    const pharmacy = fieldValue as any;
    return `${pharmacy?.StoreName}, ${pharmacy?.Address1}, ${pharmacy?.City}, ${pharmacy?.State} ${pharmacy?.ZipCode}`;
  }
  return null;
};

const getFieldValue = (
  fieldType: string,
  fieldValue: unknown,
  fieldProperties?: FormElementFieldProperties | null
) => {
  switch (fieldType) {
    case FormFieldType.SingleCheckbox:
      return handleSingleCheckbox(fieldValue);
    case FormFieldType.Datepicker:
      return handleTextAreaOrDatePicker(fieldValue);
    case FormFieldType.CheckboxGroup:
      return handleCheckboxGroup(fieldValue);
    case FormFieldType.FileUpload:
      return handleFileUpload(fieldValue);
    case FormFieldType.AddressPicker:
      return handleAddressPicker(fieldValue);
    case FormFieldType.PharmacyPicker:
      return handlePharmacyPicker(fieldValue);
    case FormFieldType.ApiCombobox:
      return handleApiCombobox(fieldValue, fieldProperties);
    case FormFieldType.Hidden:
      return null;
    case FormFieldType.Checkout:
      return handleCheckout(fieldValue);
    default:
      return handleDefault(fieldValue);
  }
};

export const generateConfirmData: generateConfirmDataType = (
  form,
  formValues,
  dataContext
) => {
  const responses = form.sections.map((section) => {
    const elements = section.steps.flatMap((step) => step.formElements);
    const fields = elements.filter((elem) => isFormField(elem));
    const visibleFields = fields.filter((elem) =>
      evaluateShowLogic(elem, fields, dataContext, formValues)
    );

    return {
      sectionTitle: section.sectionTitle,
      responses: visibleFields.map((field) => ({
        question: field.field?.label ?? '',
        answer: DOMPurify.sanitize(
          getFieldValue(
            field.field?.fieldType ?? '',
            get(formValues, field?.name ?? '', ''),
            field.field?.fieldProperties
          ) ?? ''
        ),
      })),
    };
  });

  return responses;
};

export const compileConfirmData = (
  confirmData: FormSectionResponses[],
  dataContext: unknown
) => {
  registerHelpers();

  const compiled = [...confirmData];
  compiled.forEach((section) => {
    section.responses.forEach((response) => {
      const template = Handlebars.compile(response.question);
      const compiled = template(dataContext);
      response.question = compiled;
    });
  });

  return compiled;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/show-logic.ts

import dayjs from 'dayjs';
import isSameOrAfter from 'dayjs/plugin/isSameOrAfter';
import isSameOrBefore from 'dayjs/plugin/isSameOrBefore';

import { FormElementInclude } from '@/app/(non-account)/(features)/(form)/utils/types';
import { parseReferenceData } from '@form/utils';
import { elementType } from '@prisma/client';

import {
  stringValidatorMap,
  dateValidatorMap,
  numberValidatorMap,
  booleanValidatorMap,
  arrayValidatorMap,
  objectValidatorMap,
} from './validation-methods';

dayjs.extend(isSameOrBefore);
dayjs.extend(isSameOrAfter);

const validateDate = (
  operandA: string,
  operator: string,
  operandB: string,
  dateOffset: number | null | undefined,
  dateOffsetUnits: string | null | undefined
) => {
  let comparisonDate: dayjs.Dayjs | undefined = dayjs();
  let date = undefined;

  if (operandB !== 'today') {
    date = operandB;
  }

  if (dayjs(date).isValid()) {
    comparisonDate = dayjs(date).add(
      dateOffset ?? 0,
      (dateOffsetUnits ?? 'd') as dayjs.ManipulateType
    );
  } else {
    comparisonDate = undefined;
  }

  return dateValidatorMap?.[operator]?.(dayjs(operandA), comparisonDate);
};

export const evaluateShowLogic = (
  formElement: FormElementInclude,
  fields: FormElementInclude[],
  dataContext: any,
  formValues: any
) => {
  const showLogicConfig =
    formElement.elementType === elementType.FormField
      ? formElement.field?.showLogic
      : formElement.text?.showLogic;

  if (!showLogicConfig || (showLogicConfig ?? []).length < 1) return true;
  // Outer array is OR
  return showLogicConfig.some((showLogic) => {
    if ((showLogic.ruleset ?? []).length < 1) {
      return true;
    }
    // Inner arrays are AND
    return (showLogic.ruleset ?? []).every((rule) => {
      const { dataValue, dataType, fieldType } = parseReferenceData(
        rule.operandA,
        fields,
        dataContext,
        formValues
      );

      const parsedRule = parseReferenceData(
        rule.operandB as string,
        fields,
        dataContext,
        formValues
      );

      // Evaluate based on the data type
      switch (dataType) {
        case 'boolean':
          return booleanValidatorMap?.[rule.operator]?.(
            dataValue,
            parsedRule.dataValue
          );
        case 'number':
          return numberValidatorMap?.[rule.operator]?.(
            dataValue,
            parsedRule.dataValue as number
          );
        case 'array':
          return arrayValidatorMap?.[rule.operator]?.(
            dataValue,
            parsedRule.dataValue,
            fieldType
          );
        case 'object':
          return objectValidatorMap?.[rule.operator]?.(
            dataValue,
            parsedRule.dataValue
          );
        case 'date':
          return validateDate(
            dataValue,
            rule.operator,
            parsedRule.dataValue as string,
            rule.dateOffset,
            rule.dateOffsetUnits
          );
        default:
          return stringValidatorMap?.[rule.operator]?.(
            dataValue,
            parsedRule.dataValue
          );
      }
    });
  });
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/types.ts

import { ElementType } from '@form/utils/enums';
import { Prisma } from '@prisma/client';

export enum FormFieldType {
  Datepicker = 'Datepicker',
  Select = 'Select',
  SingleCheckbox = 'Single Checkbox',
  CheckboxGroup = 'Checkbox Group',
  RadioButtons = 'Radio Buttons',
  TextArea = 'Text Area',
  AddressAutocomplete = 'Address Autocomplete',
  Hidden = 'Hidden',
  FileUpload = 'File Upload',
  AddressPicker = 'Address Picker',
  PharmacyPicker = 'Pharmacy Select',
  TextField = 'Text Field',
  ApiCombobox = 'API Combobox',
  Checkout = 'Checkout',
}

export const FORM_INCLUDE = {
  sections: {
    include: {
      steps: {
        include: { formElements: { include: { text: true, field: true } } },
      },
    },
  },
};

export type FormInclude = Prisma.FormGetPayload<{
  include: typeof FORM_INCLUDE;
}>;

export type SectionInclude = FormInclude['sections'][0];

export type StepInclude = SectionInclude['steps'][0];

export type FormElementInclude = StepInclude['formElements'][0];

export type FormFieldInclude = FormElementInclude['field'];

export type FormTextInclude = FormElementInclude['text'];

export const isFormField = (element: FormElementInclude) =>
  element.elementType === ElementType.FormField;

export const isFormText = (element: FormElementInclude) =>
  element.elementType === ElementType.FormText;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/api-utils.ts

import { FormInclude } from '@form/utils/types';

export function sortForm(form: FormInclude) {
  const sortedForm = {
    ...form,
    sections: form.sections
      .map((section) => ({
        ...section,
        steps: section.steps
          .map((step) => ({
            ...step,
            formElements: step.formElements.sort(
              (a, b) => step.order.indexOf(a.id) - step.order.indexOf(b.id)
            ),
          }))
          .sort(
            (a, b) => section.order.indexOf(a.id) - section.order.indexOf(b.id)
          ),
      }))
      .sort((a, b) => form.order.indexOf(a.id) - form.order.indexOf(b.id)),
  };

  return sortedForm;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/index.ts

import get from 'lodash.get';

import AddressAutocomplete from '@form/components/form-fields/address-autocomplete';
import AddressPicker from '@form/components/form-fields/address-picker/address-picker';
import ApiCombobox from '@form/components/form-fields/api-combobox';
import Checkbox from '@form/components/form-fields/checkbox';
import CheckboxGroup from '@form/components/form-fields/checkbox-group';
import DatePicker from '@form/components/form-fields/datepicker';
import FileUpload from '@form/components/form-fields/file-upload';
import HiddenField from '@form/components/form-fields/hidden-field';
import PharmacyPicker from '@form/components/form-fields/pharmacy-picker/pharmacy-picker';
import RadioButtonGroup from '@form/components/form-fields/radio-button-group';
import Select from '@form/components/form-fields/select';
import TextArea from '@form/components/form-fields/text-area';
import TextField from '@form/components/form-fields/text-field';

import Checkout from '../components/form-fields/checkout';
import { FormElementInclude, FormFieldType } from './types';

interface IFieldConfiguration {
  initialValue: any;
  component: any;
  type: string;
}

const fieldConfigurationMap: { [key: string]: IFieldConfiguration } = {
  [FormFieldType.Datepicker]: {
    initialValue: '',
    component: DatePicker,
    type: 'date',
  },
  [FormFieldType.Select]: {
    initialValue: '',
    component: Select,
    type: 'string',
  },
  [FormFieldType.SingleCheckbox]: {
    initialValue: false,
    component: Checkbox,
    type: 'boolean',
  },
  [FormFieldType.CheckboxGroup]: {
    initialValue: [],
    component: CheckboxGroup,
    type: 'array',
  },
  [FormFieldType.FileUpload]: {
    initialValue: [],
    component: FileUpload,
    type: 'array',
  },
  [FormFieldType.AddressPicker]: {
    initialValue: [],
    component: AddressPicker,
    type: 'array',
  },
  [FormFieldType.PharmacyPicker]: {
    initialValue: undefined,
    component: PharmacyPicker,
    type: 'object',
  },
  [FormFieldType.RadioButtons]: {
    initialValue: '',
    component: RadioButtonGroup,
    type: 'string',
  },
  [FormFieldType.TextArea]: {
    initialValue: '',
    component: TextArea,
    type: 'string',
  },
  [FormFieldType.AddressAutocomplete]: {
    initialValue: '',
    component: AddressAutocomplete,
    type: 'string',
  },
  [FormFieldType.ApiCombobox]: {
    initialValue: [],
    component: ApiCombobox,
    type: 'array',
  },
  [FormFieldType.Hidden]: {
    initialValue: '',
    component: HiddenField,
    type: 'string',
  },
  [FormFieldType.Checkout]: {
    initialValue: false,
    component: Checkout,
    type: 'boolean',
  },
  default: {
    initialValue: '',
    component: TextField,
    type: 'string',
  },
};

const getFieldConfiguration = (typename: string) => {
  const fieldConfig = fieldConfigurationMap?.[typename];

  if (fieldConfig) {
    return fieldConfig;
  }

  return fieldConfigurationMap.default;
};

const parseGoogleAddress = (placeDetails: google.maps.places.PlaceResult) => {
  const address = {
    address1: '',
    address2: '',
    city: '',
    state: '',
    postal: '',
    country: '',
  };

  for (const component of placeDetails.address_components as google.maps.GeocoderAddressComponent[]) {
    const componentType = component.types[0];

    switch (componentType) {
      case 'street_number': {
        address.address1 = `${component.long_name} ${address.address1}`;
        break;
      }
      case 'route': {
        address.address1 += component.long_name;
        break;
      }
      case 'postal_code': {
        address.postal = `${component.long_name}${address.postal}`;
        break;
      }
      case 'locality':
        address.city = component.long_name;
        break;

      case 'administrative_area_level_1': {
        address.state = component.long_name;
        break;
      }
      case 'country':
        address.country = component.long_name;
        break;
    }
  }

  return address;
};

const mapFormValuesToAPI = (mapping: any = {}, values: any, context: any) => {
  const result: { [key: string]: any } = {};

  for (const key in mapping) {
    const path = mapping[key];

    if (Array.isArray(path)) {
      // If the value is an array, map each element in the array
      result[key] = path.map((item) =>
        mapFormValuesToAPI(item, values, context)
      );
    } else if (typeof path !== 'object') {
      const value = parseReferenceData(path, [], context, values);
      result[key] = value.dataValue;
    } else {
      result[key] = mapFormValuesToAPI(path, values, context);
    }
  }

  return result;
};

const parseReferenceData = (
  prop: any,
  fields: FormElementInclude[],
  dataContext: any,
  formValues: any
) => {
  if (typeof prop !== 'string') {
    return { dataValue: prop, dataType: 'any', fieldType: '' };
  }

  const pathParts = prop.split(':');

  if (pathParts.length > 1 && pathParts[0] === '$ctx') {
    // Get the value from the context
    pathParts.shift();
    const ctxArray = pathParts.join(':');
    const [ctxPath, dataType] = JSON.parse(ctxArray);
    return {
      dataValue: get(dataContext, ctxPath, ''),
      dataType,
      fieldType: '',
    };
  } else if (pathParts.length > 1 && pathParts[0] === '$field') {
    // Get the value from the formik context
    const fieldName = pathParts[1];
    const basedOnField = fields.find((field) => field?.name === fieldName);

    const dataType = getFieldConfiguration(
      basedOnField?.field?.fieldType as string
    ).type;

    const dataValue = get(formValues as any, fieldName, '');

    return { dataValue, dataType, fieldType: basedOnField?.field?.fieldType };
  }

  return { dataValue: prop, dataType: 'string', fieldType: '' };
};

export {
  getFieldConfiguration,
  mapFormValuesToAPI,
  parseGoogleAddress,
  parseReferenceData,
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/enums.ts

export enum SlideDirection {
  Left = 'left',
  Right = 'right',
}

export enum ElementType {
  FormText = 'FormText',
  FormField = 'FormField',
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/field-validation.tsx

import dayjs, { Dayjs } from 'dayjs';
import isSameOrAfter from 'dayjs/plugin/isSameOrAfter';
import isSameOrBefore from 'dayjs/plugin/isSameOrBefore';

import { FormElementInclude } from '@/app/(non-account)/(features)/(form)/utils/types';
import { getFieldConfiguration } from '@form/utils';
import { parseReferenceData } from '@form/utils';
import {
  stringValidatorMap,
  dateValidatorMap,
  numberValidatorMap,
  booleanValidatorMap,
  arrayValidatorMap,
  isStringDefined,
  isBooleanDefined,
  isNumberDefined,
  isArrayDefined,
  isObjectDefined,
  objectValidatorMap,
} from '@form/utils/validation-methods';
import { FormElementValidation } from '@prisma/client';

dayjs.extend(isSameOrBefore);
dayjs.extend(isSameOrAfter);

const validateString = (
  required: boolean,
  operandA: string,
  operator: string,
  operandB: string
) => {
  if (required || isStringDefined(operandA)) {
    return stringValidatorMap?.[operator]?.(operandA, operandB);
  } else {
    return true;
  }
};

const validateBoolean = (
  required: boolean,
  operandA: boolean,
  operator: string,
  operandB: string
) => {
  if (required || isBooleanDefined(operandA)) {
    return booleanValidatorMap?.[operator]?.(operandA, operandB);
  } else {
    return true;
  }
};

const validateNumber = (
  required: boolean,
  operandA: number,
  operator: string,
  operandB: number
) => {
  if (required || isNumberDefined(operandA)) {
    return numberValidatorMap?.[operator]?.(operandA, operandB);
  } else {
    return true;
  }
};

const validateArray = (
  required: boolean,
  operandA: any[],
  operator: string,
  operandB: string | number,
  _dateOffset?: number | null,
  _dateOffsetUnits?: string | null,
  fieldType?: string
) => {
  if (required || isArrayDefined(operandA)) {
    return arrayValidatorMap?.[operator]?.(operandA, operandB, fieldType);
  } else {
    return true;
  }
};

const validateObject = (
  required: boolean,
  operandA: any,
  operator: string,
  operandB: string
) => {
  if (required || isObjectDefined(operandA)) {
    return objectValidatorMap?.[operator]?.(operandA, operandB);
  } else {
    return true;
  }
};

const validateDate = (
  required: boolean,
  operandA: string,
  operator: string,
  operandB: string,
  dateOffset?: number | null,
  dateOffsetUnits?: string | null
) => {
  if (!required && operandA === '') {
    return true;
  }

  let comparisonDate: Dayjs | undefined = dayjs();
  let date = undefined;

  if (operandB !== 'today') {
    date = operandB;
  }

  if (dayjs(date).isValid()) {
    comparisonDate = dayjs(date).add(
      dateOffset ?? 0,
      (dateOffsetUnits ?? 'd') as dayjs.ManipulateType
    );
  } else {
    comparisonDate = undefined;
  }

  return dateValidatorMap[operator](dayjs(operandA), comparisonDate);
};

type OperandType =
  | 'string'
  | 'boolean'
  | 'number'
  | 'object'
  | 'array'
  | 'date';

type ValidatorFunction<A, B> = (
  required: boolean,
  operandA: A,
  operator: string,
  operandB: B,
  dateOffset?: number | null,
  dateOffsetUnits?: string | null,
  fieldType?: string
) => boolean;

const validationFunctionsMap: {
  [key in OperandType]: ValidatorFunction<any, any>;
} = {
  string: validateString,
  boolean: validateBoolean,
  number: validateNumber,
  object: validateObject,
  array: validateArray,
  date: validateDate,
};

const getOperands = (
  value: any,
  fieldType: string,
  rule: any,
  fields: FormElementInclude[],
  dataContext: any,
  formValues: any
) => {
  let operandA = value;
  let operandAType: OperandType = fieldType as OperandType;

  if (rule.operandA) {
    const { dataValue, dataType } = parseReferenceData(
      rule.operandA,
      fields,
      dataContext,
      formValues
    );
    operandA = dataValue;
    operandAType = dataType as OperandType;
  }

  const operandB = parseReferenceData(
    rule.operandB,
    fields,
    dataContext,
    formValues
  ).dataValue;

  return { operandA, operandAType, operandB };
};

const validateRule = (
  rule: FormElementValidation,
  elementType: string,
  required: boolean,
  operandA: any,
  operandAType: OperandType,
  operandB: any
) => {
  const validationFunction = validationFunctionsMap[operandAType];

  if (validationFunction) {
    return validationFunction(
      required ?? false,
      operandA,
      rule.operator,
      operandB,
      rule.dateOffset,
      rule.dateOffsetUnits,
      elementType ?? ''
    );
  }

  return true;
};

type IValidateField = (
  value: any,
  validationRules: FormElementValidation[],
  elementType: string,
  required: boolean,
  validationOptions: {
    fields: FormElementInclude[];
    dataContext: any;
    formValues: any;
    defaultRequiredText?: string;
  }
) => string;

export const validateField: IValidateField = (
  value,
  validationRules,
  elementType,
  required,
  validationOptions
) => {
  const rulesToValidate = validationRules ?? [];
  if (required) {
    rulesToValidate.push({
      operandA: null,
      operator: 'required',
      operandB: '',
      errorMessage:
        validationOptions.defaultRequiredText ?? 'This field is required',
      dateOffset: 0,
      dateOffsetUnits: 'days',
    });
  }
  if (rulesToValidate.length === 0 || elementType == undefined) {
    return '';
  }

  const fieldType = getFieldConfiguration(elementType).type;

  for (const rule of rulesToValidate) {
    const { operandA, operandAType, operandB } = getOperands(
      value,
      fieldType,
      rule,
      validationOptions.fields,
      validationOptions.dataContext,
      validationOptions.formValues
    );
    const isValid = validateRule(
      rule,
      elementType,
      required,
      operandA,
      operandAType,
      operandB
    );

    if (!isValid) {
      return rule.errorMessage;
    }
  }

  return '';
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/validation-methods/boolean-validators.ts

export type BooleanValidatorType = (
  operandA: boolean,
  operandB?: string | number
) => boolean;

export const isBooleanDefined = (operandA?: boolean) => {
  return operandA !== undefined && operandA !== null;
};

const isChecked: BooleanValidatorType = (operandA) => {
  return !!operandA;
};

const isNotChecked: BooleanValidatorType = (operandA) => {
  return !operandA;
};

export const booleanValidatorMap: { [name: string]: BooleanValidatorType } = {
  isChecked,
  isNotChecked,
  required: isChecked,
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/validation-methods/string-validators.ts

import { z } from 'zod';

import {
  validatePhoneNumber,
  validateUSPhoneNumber,
} from '@prisma/custom-validators/phoneNumberValidation';

export type StringValidatorType = (
  operandA: string,
  operandB?: string | number
) => boolean;

const warnMissConfiguredValidator = (validatorName: string) => {
  console.warn(`Validator ${validatorName} is not configured correctly.`);
};

export const isStringDefined = (operandA?: string) => {
  return operandA !== undefined && operandA !== null && operandA !== '';
};

const containsUppercase: StringValidatorType = (operandA) => {
  return /[A-Z]/.test(operandA);
};

const containsLowercase: StringValidatorType = (operandA) => {
  return /[a-z]/.test(operandA);
};

const containsNumeric: StringValidatorType = (operandA) => {
  return /[0-9]/.test(operandA);
};

const hasMinLength: StringValidatorType = (operandA, operandB) => {
  if (typeof operandB !== 'number') {
    warnMissConfiguredValidator('hasMinLength');
    return false;
  }
  return z.string().min(operandB).safeParse(operandA).success;
};

const hasMaxLength: StringValidatorType = (operandA, operandB) => {
  if (typeof operandB !== 'number') {
    warnMissConfiguredValidator('hasMaxLength');
    return false;
  }
  return z.string().max(operandB).safeParse(operandA).success;
};

const isEmail: StringValidatorType = (operandA) => {
  return z.string().email().safeParse(operandA).success;
};

const matches: StringValidatorType = (operandA, operandB) => {
  return operandA === operandB;
};

const doesNotMatch: StringValidatorType = (operandA, operandB) => {
  return operandA !== operandB;
};

const contains: StringValidatorType = (
  operandA?: string | string[],
  operandB?: string | number
) => {
  if (typeof operandB !== 'string') {
    warnMissConfiguredValidator('contains');
    return false;
  }
  return !!operandA && operandA.includes(operandB);
};

const doesNotContain: StringValidatorType = (
  operandA?: string | string[],
  operandB?: string | number
) => {
  if (typeof operandB !== 'string') {
    warnMissConfiguredValidator('contains');
    return false;
  }
  return !!operandA && !operandA.includes(operandB);
};

const isValidPhone: StringValidatorType = (operandA) => {
  return validatePhoneNumber(operandA);
};

const isValidUSPhone: StringValidatorType = (operandA) => {
  return validateUSPhoneNumber(operandA);
};

const required: StringValidatorType = (operandA) => {
  return operandA != undefined && operandA.length > 0;
};

export const stringValidatorMap: { [name: string]: StringValidatorType } = {
  hasMinLength,
  hasMaxLength,
  isEmail,
  matches,
  doesNotMatch,
  contains,
  doesNotContain,
  required,
  isFilled: isStringDefined,
  isNotFilled: (value) => !isStringDefined(value),
  containsUppercase,
  containsLowercase,
  containsNumeric,
  isValidPhone,
  isValidUSPhone,
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/validation-methods/number-validators.ts

export type NumberValidatorType = (
  operandA?: number,
  operandB?: number
) => boolean;

export const isNumberDefined = (operandA?: number) => {
  return operandA !== undefined && operandA !== null && !isNaN(operandA);
};

const equals: NumberValidatorType = (operandA, operandB) => {
  return !!operandA && !!operandB && operandA === operandB;
};

const doesNotEqual: NumberValidatorType = (operandA, operandB) => {
  return !!operandA && !!operandB && operandA !== operandB;
};

const isGreaterThan: NumberValidatorType = (operandA, operandB) => {
  return !!operandA && !!operandB && operandA > operandB;
};

const isGreaterThanOrEqualTo: NumberValidatorType = (operandA, operandB) => {
  return !!operandA && !!operandB && operandA >= operandB;
};

const isLessThan: NumberValidatorType = (operandA, operandB) => {
  return !!operandA && !!operandB && operandA < operandB;
};

const isLessThanOrEqualTo: NumberValidatorType = (operandA, operandB) => {
  return !!operandA && !!operandB && operandA <= operandB;
};

const required: NumberValidatorType = (operandA) => {
  return !!operandA && !isNaN(operandA);
};

export const numberValidatorMap: { [name: string]: NumberValidatorType } = {
  equals,
  doesNotEqual,
  isGreaterThan,
  isGreaterThanOrEqualTo,
  isLessThan,
  isLessThanOrEqualTo,
  required,
  isFilled: isNumberDefined,
  isNotFilled: (operandA) => !isNumberDefined(operandA),
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/validation-methods/array-validators.ts

import { UploadStatus } from '@/utils/enums';

import { FormFieldType } from '../types';

export type ArrayValidatorType = (
  operandA: any[],
  operandB?: string | number,
  fieldType?: string | null
) => boolean;

const warnMissConfiguredValidator = (validatorName: string) => {
  console.warn(`Validator ${validatorName} is not configured correctly.`);
};

export const isArrayDefined = (operandA?: string[]) => {
  return operandA !== undefined && operandA !== null && operandA.length > 0;
};

const hasAtLeastSelected: ArrayValidatorType = (
  operandA,
  operandB,
  fieldType
) => {
  if (typeof operandB !== 'number') {
    warnMissConfiguredValidator('hasAtLeastSelected');
    return false;
  }

  if (fieldType === FormFieldType.FileUpload) {
    const successes = operandA.filter(
      (file) => file.status === UploadStatus.SUCCESS
    );
    return successes.length >= operandB;
  }

  return operandA.length >= operandB;
};

const hasAtMostSelected: ArrayValidatorType = (
  operandA,
  operandB,
  fieldType
) => {
  if (typeof operandB !== 'number') {
    warnMissConfiguredValidator('hasAtMostSelected');
    return false;
  }

  if (fieldType === FormFieldType.FileUpload) {
    const successes = operandA.filter(
      (file) => file.status === UploadStatus.SUCCESS
    );
    return successes.length <= operandB;
  }

  return operandA.length <= operandB;
};

const contains: ArrayValidatorType = (operandA, operandB) => {
  if (typeof operandB !== 'string') {
    warnMissConfiguredValidator('contains');
    return false;
  }
  return operandA.includes(operandB);
};

const doesNotContain: ArrayValidatorType = (operandA, operandB) => {
  if (typeof operandB !== 'string') {
    warnMissConfiguredValidator('contains');
    return false;
  }
  return !operandA.includes(operandB);
};

const allUploadedSuccessfully: ArrayValidatorType = (operandA) => {
  return (
    operandA.length > 0 &&
    operandA.every((file) => file.status === UploadStatus.SUCCESS)
  );
};

const required: ArrayValidatorType = (operandA, _operandB, fieldType) => {
  if (fieldType === FormFieldType.FileUpload) {
    return (
      operandA.length > 0 &&
      operandA.some((file) => file.status === UploadStatus.SUCCESS)
    );
  }
  return operandA.length > 0;
};

export const arrayValidatorMap: { [name: string]: ArrayValidatorType } = {
  hasAtLeastSelected,
  hasAtMostSelected,
  contains,
  doesNotContain,
  allUploadedSuccessfully,
  required,
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/validation-methods/object-validators.ts

import get from 'lodash.get';
import isEmpty from 'lodash.isempty';

export type ObjectValidatorType = (operandA: any, operandB?: string) => boolean;

const warnMissConfiguredValidator = (validatorName: string) => {
  console.warn(`Validator ${validatorName} is not configured correctly.`);
};

export const isObjectDefined = (operandA?: any) => {
  return operandA != null && !isEmpty(operandA);
};

const fieldIsDefined: ObjectValidatorType = (operandA, operandB) => {
  if (!operandB) {
    warnMissConfiguredValidator('fieldIsDefined');
    return false;
  }
  return get(operandA, operandB, undefined) !== undefined;
};

export const objectValidatorMap: { [name: string]: ObjectValidatorType } = {
  fieldIsDefined,
  required: isObjectDefined,
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/validation-methods/index.ts

export {
  arrayValidatorMap,
  isArrayDefined,
  type ArrayValidatorType,
} from './array-validators';
export {
  booleanValidatorMap,
  isBooleanDefined,
  type BooleanValidatorType,
} from './boolean-validators';
export {
  numberValidatorMap,
  isNumberDefined,
  type NumberValidatorType,
} from './number-validators';
export {
  stringValidatorMap,
  isStringDefined,
  type StringValidatorType,
} from './string-validators';
export {
  dateValidatorMap,
  isDateDefined,
  type DateValidatorType,
} from './date-validators';
export {
  objectValidatorMap,
  isObjectDefined,
  type ObjectValidatorType,
} from './object-validators';


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/utils/validation-methods/date-validators.ts

import dayjs from 'dayjs';
import isSameOrAfter from 'dayjs/plugin/isSameOrAfter';
import isSameOrBefore from 'dayjs/plugin/isSameOrBefore';

dayjs.extend(isSameOrBefore);
dayjs.extend(isSameOrAfter);

export type DateValidatorType = (
  date: dayjs.Dayjs,
  comparisonDate?: dayjs.Dayjs
) => boolean;

export const isDateDefined = (operandA?: dayjs.Dayjs) => {
  return operandA !== undefined && operandA !== null && operandA.isValid();
};

const dateIsEqualTo: DateValidatorType = (date, comparisonDate) => {
  return date.isSame(comparisonDate, 'day');
};

const dateIsGreaterThan: DateValidatorType = (date, comparisonDate) => {
  return date.isAfter(comparisonDate, 'day');
};

const dateIsGreaterThanOrEqualTo: DateValidatorType = (
  date,
  comparisonDate
) => {
  return date.isSameOrAfter(comparisonDate, 'day');
};

const dateIsLessThan: DateValidatorType = (date, comparisonDate) => {
  return date.isBefore(comparisonDate, 'day');
};

const dateIsLessThanOrEqualTo: DateValidatorType = (date, comparisonDate) => {
  return date.isSameOrBefore(comparisonDate, 'day');
};

const required: DateValidatorType = (value) => {
  return value != undefined && value.isValid();
};

export const dateValidatorMap: { [name: string]: DateValidatorType } = {
  dateIsEqualTo,
  dateIsGreaterThan,
  dateIsGreaterThanOrEqualTo,
  dateIsLessThan,
  dateIsLessThanOrEqualTo,
  required,
  isDefined: isDateDefined,
  isNotDefined: (operandA) => !isDateDefined(operandA),
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-layout.tsx

'use client';

import React from 'react';

import ActionBar from '@form/components/action-bar';
import ConfirmationView from '@form/components/confirmation-view';
import FormModal from '@form/components/form-modal';
import Loading from '@form/components/loading';
import ProgressBar from '@form/components/progress-bar';
import SectionGenerator from '@form/components/section-generator';
import SectionNavigator from '@form/components/section-navigator';
import useFormNavigation from '@form/hooks/use-form-navigation';

import { IFormProps } from './client-form';

const FormLayout: React.FC<IFormProps> = () => {
  const { showConfirmationView, setInitialStep } = useFormNavigation();
  const [loadingSection, setLoadingSection] = React.useState(true);

  React.useEffect(() => {
    if (loadingSection) {
      setInitialStep();
      setLoadingSection(false);
    }
  }, [loadingSection, setInitialStep]);

  if (loadingSection) {
    return <Loading />;
  }

  return (
    <>
      <ProgressBar />
      <SectionNavigator />
      <div className="w-full flex flex-col">
        <div className="p-5 w-full mx-auto">
          {showConfirmationView ? <ConfirmationView /> : <SectionGenerator />}
        </div>
      </div>
      <ActionBar />
      <FormModal />
    </>
  );
};

export default FormLayout;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-text.tsx

import { useFormikContext } from 'formik';
import React from 'react';

import MarkdownElement from '@components/markdown-element';
import CenteredTextWithImage from '@form/components/custom-form-text/centered-text-with-image';
import { useFormState } from '@form/hooks/use-form-state';
import { evaluateShowLogic } from '@form/utils/show-logic';
import { FormElementInclude } from '@form/utils/types';
import { FormTextType } from '@prisma/client';

interface IFormTextProps {
  formElement: FormElementInclude;
  index: number;
  id: string;
}

const FormText: React.FC<IFormTextProps> = (p) => {
  const { formElement, id } = p;
  const { fields, dataContext } = useFormState();
  const { values } = useFormikContext();

  const shouldShow = React.useCallback(() => {
    const ss = evaluateShowLogic(formElement, fields, dataContext, values);
    return ss;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [values]);

  if (!formElement || !formElement.text || !shouldShow()) {
    return null;
  }

  if (
    formElement.text.componentType === FormTextType.CENTERED_TEXT_WITH_IMAGE
  ) {
    return formElement?.text?.formTextProperties ? (
      <div className="max-w-[615px] w-full">
        <CenteredTextWithImage
          id={id}
          name={formElement.name}
          {...formElement.text.formTextProperties}
          context={{ formValues: values, context: dataContext }}
        />
      </div>
    ) : null;
  }

  return (
    <div
      className="form-text-container max-w-[615px] w-full"
      id={id}
      key={formElement?.name ?? ''}
    >
      <MarkdownElement
        dataContext={{ formValues: values, context: dataContext }}
      >
        {formElement.text.text}
      </MarkdownElement>
    </div>
  );
};

export default FormText;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/section-generator.tsx

import StepGenerator from '@form/components/step-generator';
import useFormNavigation from '@form/hooks/use-form-navigation';
import { convertStringToKebabCase } from '@utils/utils';

const SectionGenerator = () => {
  const { sections, currentSectionIndex } = useFormNavigation();

  const section = sections[currentSectionIndex];
  const sectionId =
    convertStringToKebabCase(section?.sectionTitle) + '-section';

  return (
    section && (
      <div id={sectionId} className="form-section my-6 max-w-5xl mx-auto">
        <StepGenerator />
      </div>
    )
  );
};

export default SectionGenerator;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/success-view.tsx

import React from 'react';

const SuccessView: React.FC = () => {
  return (
    <div className="flex flex-col items-center justify-center h-full py-24">
      <p className="font-financier text-4xl font-semibold text-[#202939] mb-0">
        Thank You for Your Interest!
      </p>
      <p className="my-5 text-center text-base text-gray-700">
        We look forward to exploring partnership opportunities with you soon.
      </p>
    </div>
  );
};

export default SuccessView;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/confirmation-view.tsx

import { useFormikContext } from 'formik';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import ButtonOutline from '@/app/shared/components/buttons/button-outline';
import ButtonSolid from '@/app/shared/components/buttons/button-solid';
import LoadingSpinner from '@/app/shared/components/loading-indicators/loading-spinner';
import MarkdownElement from '@components/markdown-element';
import { useFormState } from '@form/hooks/use-form-state';
import { generateConfirmData } from '@form/utils/generate-confirm-data';
import { FormSectionResponses } from '@prisma/client';
import { Edit03 } from '@untitled-ui/icons-react';

import useFormNavigation from '../hooks/use-form-navigation';

const EditButton: React.FC<{ className?: string; onClick: () => void }> = (
  p
) => {
  return (
    <div>
      <ButtonOutline
        type="button"
        variant="gray"
        className={twMerge([
          'flex items-center gap-2 py-2 px-3.5',
          p.className,
        ])}
        onClick={p.onClick}
      >
        <Edit03
          width="20px"
          height="20px"
          viewBox="0 0 24 24"
          className="text-gray-500"
        />
        Edit
      </ButtonOutline>
    </div>
  );
};

const ConfirmationView: React.FC = () => {
  const { form, dataContext, disabled } = useFormState();
  const { navigateToSection } = useFormNavigation();
  const { values, isSubmitting } = useFormikContext();
  const [data, setData] = React.useState<FormSectionResponses[]>([]);

  React.useEffect(() => {
    if (form) {
      const confirmData = generateConfirmData(form, values, dataContext);
      setData(confirmData);
    }
  }, [values, dataContext, form]);

  return (
    <div className="w-full max-w-[1032px] mx-auto overflow-hidden bg-white shadow rounded-lg py-4 px-3 md:px-9 md:py-10">
      <div className="border-gray-100">
        <div className="divide-y divide-gray-100">
          {data.map((section, index) => (
            <div
              key={index}
              className="px-4 py-6 md:grid md:grid-cols-6 md:px-0"
            >
              <div className="flex flex-wrap gap-4 justify-between items-center md:items-start md:col-span-1 lg:col-span-2">
                <p className="text-lg font-medium leading-6 text-gray-950">
                  {section?.sectionTitle}
                </p>
                <EditButton
                  className="flex md:hidden"
                  onClick={() => navigateToSection(section.sectionTitle)}
                />
              </div>

              <div className="flex w-full text-sm leading-6 font-dmsans text-gray-500 break-words mt-2 md:col-span-4 md:mx-4 lg:col-span-3">
                <div className="flex-grow">
                  <dl>
                    {section.responses.map((response, j) => (
                      <div
                        key={j}
                        className="flex flex-col mb-2 mt-2 md:grid md:grid-cols-2 md:gap-8 "
                      >
                        <dt>
                          <MarkdownElement overridePTag={false}>
                            {response.question}
                          </MarkdownElement>
                        </dt>
                        <dd className="text-gray-700 font-medium">
                          {response.answer}
                        </dd>
                      </div>
                    ))}
                  </dl>
                </div>
              </div>

              <EditButton
                className="mt-2 hidden md:flex ml-auto"
                onClick={() => navigateToSection(section.sectionTitle)}
              />
            </div>
          ))}
        </div>
      </div>
      <div className="flex justify-center md:mt-8">
        <ButtonSolid
          type="submit"
          variant="accent"
          className="w-full max-w-[133px] flex items-center justify-center"
          disabled={disabled || isSubmitting}
        >
          {isSubmitting && (
            <LoadingSpinner fillClass="fill-accent-300 mr-1" size="sm" />
          )}
          {isSubmitting ? form?.submittingText : form?.submitButtonText}
        </ButtonSolid>
      </div>
    </div>
  );
};

export default ConfirmationView;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/action-bar.tsx

import { FormikTouched, setNestedObjectValues, useFormikContext } from 'formik';
import React from 'react';

import ButtonOutline from '@components/buttons/button-outline';
import ButtonSolid from '@components/buttons/button-solid';
import LoadingSpinner from '@components/loading-indicators/loading-spinner';
import AutoSave from '@form/components/auto-save';
import { FormValues } from '@form/components/client-form';
import useFormNavigation from '@form/hooks/use-form-navigation';
import { useFormState } from '@form/hooks/use-form-state';

const ActionBar: React.FC = () => {
  const { form, disabled } = useFormState();
  const { setTouched, validateForm, isSubmitting } = useFormikContext();
  const {
    next,
    previous,
    currentSectionIndex,
    currentStepIndex,
    shouldAllowNavBack,
    hasNextVisible,
    showConfirmationView,
  } = useFormNavigation();
  const [displayBackButton, setDisplayBackButton] = React.useState(false);
  const [nextVisible, setNextVisible] = React.useState(false);

  React.useEffect(() => {
    setDisplayBackButton(shouldAllowNavBack());
    setNextVisible(hasNextVisible());
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    currentSectionIndex,
    currentStepIndex,
    shouldAllowNavBack,
    hasNextVisible,
  ]);

  const handleNext = async (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault();

    const validationErrors = await validateForm();
    if (Object.keys(validationErrors).length > 0) {
      setTouched(
        setNestedObjectValues<FormikTouched<FormValues>>(validationErrors, true)
      );
      return;
    }

    next();
  };

  const handleBack = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault();
    previous();
  };

  if (showConfirmationView) {
    return null;
  }

  return (
    <div className="px-4 sm:px-0 max-w-[615px] mx-auto w-full pb-8">
      <div className="flex flex-row gap-2 justify-between">
        {displayBackButton && (
          <ButtonOutline
            type="button"
            variant="gray"
            size="lg"
            className="md:px-11 md:py-4 w-full max-w-[124px]"
            onClick={handleBack}
            disabled={isSubmitting}
          >
            {form?.backButtonText ?? 'Next'}
          </ButtonOutline>
        )}
        {!nextVisible ? (
          <ButtonSolid
            type="submit"
            variant="accent"
            size="lg"
            className="flex items-center justify-center md:px-11 md:py-4 ml-auto w-full max-w-[124px]"
            disabled={disabled || isSubmitting}
          >
            {isSubmitting && (
              <LoadingSpinner fillClass="fill-accent-300 mr-1" size="sm" />
            )}
            {isSubmitting ? form?.submittingText : form?.submitButtonText}
          </ButtonSolid>
        ) : (
          <ButtonSolid
            type="button"
            variant="accent"
            size="lg"
            className="md:px-11 md:py-4 ml-auto w-full max-w-[124px]"
            onClick={handleNext}
            disabled={isSubmitting}
          >
            {form?.nextButtonText ?? 'Next'}
          </ButtonSolid>
        )}
      </div>
      {form?.autoSaveEnabled && (
        <div className="flex justify-end my-3">
          <AutoSave debounceMs={2000} />
        </div>
      )}
    </div>
  );
};

export default ActionBar;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-modal.tsx

import React from 'react';

import LoadingSpinner from '@/app/shared/components/loading-indicators/loading-spinner';
import Modal from '@/app/shared/components/overlays/modal';
import { useFormModal } from '@form/hooks/use-form-modal';
import { useQuery } from '@tanstack/react-query';

const fetchModalContent = async (modalId: string) => {
  const response = await fetch(`/api/forms/modals/${modalId}`);
  const data = await response.json();

  return data ?? {};
};

const ModalQueryWrapper = () => {
  const { modalId, closeModal } = useFormModal();
  const { data, isLoading, isError } = useQuery(['modal', modalId], () =>
    fetchModalContent(modalId)
  );

  if (isLoading) {
    return (
      <Modal
        show={true}
        contentRenderer={() => (
          <div className="flex items-center justify-center">
            <LoadingSpinner size="md" fillClass="fill-accent-500" />
          </div>
        )}
        onClose={closeModal}
      />
    );
  }

  if (isError) {
    return (
      <Modal
        show={true}
        title={'Something went wrong'}
        content={'We were unable to load this content. Please try again later.'}
        onClose={closeModal}
      />
    );
  }

  return (
    <Modal
      show={true}
      title={data?.title}
      content={data?.content}
      onClose={closeModal}
    />
  );
};

const FormModal = () => {
  const { isModalVisible } = useFormModal();
  return isModalVisible ? <ModalQueryWrapper /> : null;
};

export default FormModal;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/section-navigator.tsx

import React from 'react';

import FlyoutMenu, {
  type IMenuItem,
} from '@components/overlays/flyout-menu/flyout-menu';
import useFormNavigation from '@form/hooks/use-form-navigation';
import { useFormState } from '@form/hooks/use-form-state';

const SectionNavigator: React.FC = () => {
  const {
    sections,
    currentSectionIndex,
    navigateToSection,
    visitedSections,
    showNavigation,
    showConfirmationView,
  } = useFormNavigation();
  const [currentSelection, setCurrentSelection] = React.useState<
    string | undefined
  >(visitedSections[visitedSections.length - 1]);
  const { form } = useFormState();
  const handleSectionNavigation = (item: IMenuItem) => {
    navigateToSection(item.name);
  };

  const currentSectionTitle = React.useMemo(
    () =>
      sections[currentSectionIndex]?.sectionTitle ??
      visitedSections[visitedSections.length - 1],
    [sections, currentSectionIndex, visitedSections]
  );

  const menuItems = React.useMemo(
    () =>
      visitedSections.map((section) => {
        if (section === form?.confirmationSectionTitle) {
          return {
            name: section,
            description: form?.confirmationSectionDesc,
            icon: form?.confirmationSectionIcon,
          };
        }
        const matchingSection = sections.find(
          (s) => s.sectionTitle === section
        );
        return {
          name: section,
          description: matchingSection?.sectionDesc,
          icon: matchingSection?.icon,
        };
      }),
    [
      sections,
      visitedSections,
      form?.confirmationSectionDesc,
      form?.confirmationSectionIcon,
      form?.confirmationSectionTitle,
    ]
  );

  React.useEffect(() => {
    let currentSection = currentSectionTitle;

    if (showConfirmationView) {
      currentSection = visitedSections[visitedSections.length - 1];
    }
    setCurrentSelection(currentSection);
  }, [
    currentSectionTitle,
    currentSectionIndex,
    visitedSections,
    showConfirmationView,
  ]);

  return showNavigation ? (
    <div className="h-fit w-full flex flex-col py-6 mx-auto bg-gray-800">
      <div className="flex flex-col self-center justify-center max-w-[300px] w-full">
        <label
          htmlFor="form-section-navigator"
          className="text-base font-dmsans text-gray-200 font-semibold text-center mb-3"
        >
          Navigate to section:
        </label>
        <FlyoutMenu
          id="form-section-navigator"
          value={currentSelection}
          onChange={handleSectionNavigation}
          items={menuItems}
        />
      </div>
    </div>
  ) : null;
};

export default SectionNavigator;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/progress-bar.tsx

import React from 'react';

import useFormNavigation from '@form/hooks/use-form-navigation';

const ProgressBar: React.FC = () => {
  const { sections, visitedSections, showProgressBar } = useFormNavigation();

  const progress = (visitedSections.length / (sections.length + 1)) * 100;

  return showProgressBar ? (
    <div className="w-full bg-gray-200 h-2.5">
      <div
        className="bg-accent-400 h-2.5"
        style={{ width: `${progress}%` }}
      ></div>
    </div>
  ) : null;
};

export default ProgressBar;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/loading.tsx

const FormFieldSkeleton = () => {
  return (
    <div className="flex flex-col gap-2 w-full">
      <div className="bg-gray-200 w-20 rounded h-4" />
      <div className="bg-gray-200 w-full rounded h-10" />
    </div>
  );
};

const LargeFormFieldSkeleton = () => {
  return (
    <div className="flex flex-col gap-2 w-full">
      <div className="bg-gray-200 w-20 rounded h-4" />
      <div className="bg-gray-200 w-full rounded h-28" />
    </div>
  );
};

const Loading = () => {
  return (
    <div className="relative flex flex-1 flex-col h-full">
      <div className="w-full flex flex-col animate-pulse">
        <div className="py-5 px-4 sm:py-12 w-full max-w-[615px] mx-auto flex flex-col gap-6 items-center">
          <FormFieldSkeleton />
          <FormFieldSkeleton />
          <FormFieldSkeleton />
          <LargeFormFieldSkeleton />
          <span className="sr-only">Loading Form...</span>
        </div>
      </div>
      <div className="px-4 max-w-[615px] mx-auto w-full pb-8 animate-pulse">
        <div className="flex flex-row justify-between">
          <div className="ml-auto flex flex-row gap-2 items-center">
            <div className="bg-gray-200 w-20 h-10 rounded-lg" />
          </div>
        </div>
      </div>
    </div>
  );
};
export default Loading;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/auto-save.tsx

import dayjs from 'dayjs';
import realtiveTime from 'dayjs/plugin/relativeTime';
import { useFormikContext } from 'formik';
import debounce from 'lodash.debounce';
import React from 'react';

import { getFamilyMemberHeader } from '@/utils/utils';
import LoadingSpinner from '@components/loading-indicators/loading-spinner';
import { FormValues } from '@form/components/client-form';
import { useFormState } from '@form/hooks/use-form-state';
import { useTimeFromNow } from '@form/hooks/use-time-from-now';

dayjs.extend(realtiveTime);

interface IAutoSaveProps {
  debounceMs?: number;
}

const saveForm = async (
  formId: string,
  formValues: FormValues,
  setIsSaving: React.Dispatch<React.SetStateAction<boolean>>,
  setSaveError: React.Dispatch<React.SetStateAction<boolean>>,
  updateLastTime: () => void
) => {
  setIsSaving(true);
  try {
    const response = await fetch(`/api/forms/${formId}/save`, {
      method: 'POST',
      body: JSON.stringify({ formValues }),
      headers: getFamilyMemberHeader(),
    });
    if (response.status !== 200) throw new Error('Error saving form');
    updateLastTime();
    setIsSaving(false);
  } catch (e) {
    setSaveError(true);
    setIsSaving(false);
    console.error(e);
  }
};

const AutoSave: React.FC<IAutoSaveProps> = ({ debounceMs }) => {
  const formState = useFormState();
  const formik = useFormikContext();
  const [isSaving, setIsSaving] = React.useState(false);
  const [saveError, setSaveError] = React.useState(false);
  const { updateLastTime, fromNow } = useTimeFromNow(false);

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const debouncedSubmit = React.useCallback(
    debounce(() => {
      if (!formik.dirty) return false;
      return saveForm(
        formState.formId,
        formik.values as FormValues,
        setIsSaving,
        setSaveError,
        updateLastTime
      );
    }, debounceMs),
    [formik.isValid, formik.initialValues, formik.values, debounceMs]
  );

  React.useEffect(() => {
    debouncedSubmit();
    return debouncedSubmit.cancel;
  }, [debouncedSubmit, formik.values]);

  if (isSaving) {
    return (
      <div className="flex items-center text-sm text-accent-700 font-dmsans italic">
        <LoadingSpinner size="sm" fillClass="fill-accent-700" />
        Saving...
      </div>
    );
  }

  if (saveError) {
    return (
      <div>
        <p className="flex items-center text-sm text-red-500 font-dmsans italic">
          Error saving
        </p>
      </div>
    );
  }

  return fromNow ? (
    <p className="flex items-center text-sm text-gray-500 font-dmsans italic">
      Saved {fromNow}
    </p>
  ) : null;
};

export default AutoSave;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/client-form.tsx

'use client';

import DOMPurify from 'dompurify';
import { Formik, Form } from 'formik';
import Handlebars from 'handlebars';
import { useRouter } from 'next/navigation';
import React from 'react';

import { getFamilyMemberHeader } from '@/utils/utils';
import ErrorToast from '@components/error-toast';
import FormLayout from '@form/components/form-layout';
import SuccessView from '@form/components/success-view';
import { FormProvider } from '@form/contexts/form-context';
import FormModalContextProvider from '@form/contexts/form-modal-context';
import { FormNavigationProvider } from '@form/contexts/form-navigation-context';
import { mapFormValuesToAPI } from '@form/utils';
import {
  compileConfirmData,
  generateConfirmData,
} from '@form/utils/generate-confirm-data';
import { FormInclude } from '@form/utils/types';

export type FormValues = {
  [fieldname: string]: string | string[] | boolean | number | any | undefined;
};

export interface IFormProps {
  formId: string;
  initialValues?: FormValues;
  form: FormInclude;
  disabled?: boolean;
  context?: { [key: string]: unknown };
}

const ClientForm = (p: IFormProps) => {
  const { form, initialValues, context } = p;
  const { push, refresh } = useRouter();
  const [error, setError] = React.useState(false);
  const [isSubmitted, setIsSubmitted] = React.useState(false);

  const onErrorToastClose = () => {
    setError(false);
  };

  if (isSubmitted) {
    if (form.afterSubmitAction === 'default') {
      return <SuccessView />;
    }
  }

  const handleAfterSubmitAction = (
    formValues: FormValues,
    submissionResponse: any
  ) => {
    if (form.afterSubmitAction === 'redirect' && form.redirectUrl) {
      const template = Handlebars.compile(form.redirectUrl);
      const compiled = template({ formValues, context, submissionResponse });
      const redirectPath = DOMPurify.sanitize(compiled);
      push(redirectPath);
      refresh();
      setIsSubmitted(false);
    }

    if (form.afterSubmitAction === 'refresh') {
      refresh();
      setIsSubmitted(false);
    }
  };

  return (
    <FormModalContextProvider>
      <FormProvider
        form={p.form}
        formId={p.formId}
        initialDisabled={p.disabled ?? false}
        context={p.context}
      >
        <div className="flex-col bg-gray-100">
          <ErrorToast
            show={error}
            text="There was a problem submitting. Please try again later."
            onClose={onErrorToastClose}
            position="fixed"
          />
          <Formik
            initialValues={initialValues ?? {}}
            enableReinitialize={true}
            onSubmit={async (values, { setSubmitting }) => {
              try {
                const mappedResults = mapFormValuesToAPI(
                  (form?.apiMapping ?? {}) as any,
                  values,
                  { ...form, ...context }
                );

                const familyMemberHeader = getFamilyMemberHeader();

                if (form.generatePDF) {
                  const confirmData = generateConfirmData(
                    form,
                    values,
                    context
                  );

                  const savePDFResult = await fetch(
                    `/api/forms/pdf/save-data`,
                    {
                      method: 'POST',
                      body: JSON.stringify({
                        formId: form.id,
                        formTitle: form.title,
                        submissionDateTime: new Date(),
                        responses: compileConfirmData(confirmData, context),
                      }),
                      headers: familyMemberHeader,
                    }
                  );

                  if (!savePDFResult.ok) {
                    throw new Error('There was a problem saving PDF');
                  }
                }

                const headers = {
                  'Content-Type': 'application/json',
                  ...(familyMemberHeader ? familyMemberHeader : {}),
                };

                const res = await fetch(`/api/${form?.submissionEndpoint}`, {
                  method: form.submissionAPIMethod,
                  body: JSON.stringify(mappedResults),
                  headers,
                });
                const resJson = await res.json();
                if (res.status !== 200) {
                  setError(true);
                } else {
                  setSubmitting(false);
                  setIsSubmitted(true);
                  handleAfterSubmitAction(values, resJson);
                }
              } catch (e) {
                console.error(e);
                setSubmitting(false);
                setError(true);
              }
            }}
          >
            <Form className="flex flex-col">
              <FormNavigationProvider form={p.form}>
                <FormLayout {...p} />
              </FormNavigationProvider>
            </Form>
          </Formik>
        </div>
      </FormProvider>
    </FormModalContextProvider>
  );
};

export default ClientForm;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/step-generator.tsx

import { motion } from 'framer-motion';

import FormField from '@form/components/form-fields/formfield';
import FormText from '@form/components/form-text';
import useFormNavigation from '@form/hooks/use-form-navigation';
import { FormElementInclude, isFormField, isFormText } from '@form/utils/types';
import { convertStringToKebabCase } from '@utils/utils';

const renderField = (formElement: FormElementInclude, index: number) => {
  const fieldId = `field-${index}-${convertStringToKebabCase(
    formElement?.name
  )}`;

  if (isFormField(formElement)) {
    return (
      <FormField
        key={fieldId}
        formElement={formElement}
        index={index}
        id={fieldId}
      />
    );
  } else if (isFormText(formElement)) {
    return (
      <FormText
        key={fieldId}
        formElement={formElement}
        index={index}
        id={fieldId}
      />
    );
  } else {
    return null;
  }
};

const StepGenerator = () => {
  const { sections, currentSectionIndex, currentStepIndex, slideDirection } =
    useFormNavigation();

  const step = sections[currentSectionIndex].steps[currentStepIndex];
  const stepId = convertStringToKebabCase(step?.stepTitle) + '-step';

  return step ? (
    <motion.div
      key={stepId}
      initial={{ x: slideDirection === 'left' ? 1000 : -1000 }}
      transition={{ duration: 0.5 }}
      animate={{ x: 0 }}
      exit={{ x: 0 }}
      id={stepId}
      className="form-step flex flex-col items-center gap-5"
    >
      {step?.formElements?.map((formElement, index) =>
        renderField(formElement, index)
      )}
    </motion.div>
  ) : null;
};

export default StepGenerator;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form.tsx

import { cookies } from 'next/headers';
import { cache } from 'react';

import LoggerUtil from '@/utils/clients/logging/apiUtilLogger';
import { getBaseUrl } from '@/utils/getBaseUrl';
import { getForm } from '@/utils/helpers/helpers';
import { parseJSONOrDefault } from '@/utils/utils';
import ErrorView from '@components/error-view';
import ClientForm from '@form/components/client-form';
import { generateInitialFormData } from '@form/utils/generate-initial-form-data';

const baseUrl = getBaseUrl();

// Ensure the submission endpoint is valid
async function checkValidEndpoint(endpoint: string, submissionMethod: string) {
  try {
    const result = await fetch(`${baseUrl}/api/${endpoint}`, {
      method: 'OPTIONS',
    });
    const allows = result.headers.get('Allow');
    const allowsMethod = allows?.includes(submissionMethod);

    return result.status === 200 && allowsMethod ? true : false;
  } catch (error) {
    await LoggerUtil.logError(
      'invalid_form_submission_endpoint',
      'checkValidEndpoint',
      error,
      { endpoint, submissionMethod }
    );
  }
  return false;
}

// Get the auto saved form data
const getAutoSavedForm = cache(async (formId: string) => {
  let savedForm;
  try {
    const resp = await fetch(`${baseUrl}/api/forms/${formId}/save`, {
      method: 'GET',
      headers: {
        Cookie: cookies().toString(),
      },
      cache: 'no-store',
    });
    savedForm = await resp.json();
  } catch (error) {
    await LoggerUtil.logError(
      'error_fetching_autosave_data',
      'getAutoSavedForm',
      error,
      {
        formId,
      }
    );
    return {};
  }
  return {
    formValues: savedForm?.data ?? {},
  };
});

export default async function Form({
  id,
  locale,
  context,
}: {
  id: string;
  locale: string;
  context?: { [key: string]: unknown };
}) {
  const [formData, autoSaveData] = await Promise.all([
    getForm(id, locale),
    getAutoSavedForm(id),
  ]);

  const parsedForm = parseJSONOrDefault(JSON.stringify(formData), null);
  const isValid = !parsedForm
    ? false
    : await checkValidEndpoint(
        parsedForm?.submissionEndpoint,
        parsedForm?.submissionAPIMethod
      );

  if (!isValid || !formData) {
    return <ErrorView />;
  }

  const initialValues = await generateInitialFormData(
    parsedForm,
    autoSaveData.formValues,
    context
  );

  return formData ? (
    <ClientForm
      key={id}
      formId={id}
      form={parsedForm}
      initialValues={initialValues}
      context={{ ...context, formId: id }}
    />
  ) : (
    <></>
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/custom-form-text/centered-text-with-image.tsx

import Image from 'next/image';
import React from 'react';

import MarkdownElement from '@/app/shared/components/markdown-element';
import { FormTextProperties } from '@prisma/client';

interface ICenteredTextWithImageProps extends FormTextProperties {
  name: string;
  id: string;
  context: { [key: string]: unknown };
}

const CenteredTextWithImage: React.FC<ICenteredTextWithImageProps> = (p) => {
  return (
    <div className="mx-auto w-full max-w-md py-2 flex flex-col justify-center items-center text-center">
      {p.imageTop?.image && (
        <Image
          src={p.imageTop.image}
          alt={p.imageTop?.alt ?? ''}
          className="mb-5"
          width={p.imageTop?.width ?? 200}
          height={p.imageTop?.height ?? 200}
        />
      )}
      {p.title && (
        <h5 className="font-financier text-4xl font-semibold text-[#202939] mb-0">
          {p.title}
        </h5>
      )}
      {p.markdown && (
        <div
          className="form-text-container my-5 text-center [&_p]:text-base [&_p]:text-gray-700"
          id={p.id}
          key={p.name}
        >
          <MarkdownElement dataContext={p.context}>
            {p.markdown}
          </MarkdownElement>
        </div>
      )}
      {p.imageBottom?.image && (
        <Image
          src={p.imageBottom.image}
          alt={p.imageBottom?.alt ?? ''}
          className="my-5"
          width={p.imageBottom?.width ?? 200}
          height={p.imageBottom?.height ?? 200}
        />
      )}
    </div>
  );
};
export default CenteredTextWithImage;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/text-area.tsx

import { useField } from 'formik';
import React from 'react';

import CustomTextArea from '@components/form-controls/text-area';
import ErrorText from '@form/components/form-fields/error-text';
import { ICommonFieldProps } from '@form/components/form-fields/formfield';

interface ITextAreaProps extends ICommonFieldProps {
  rows?: number | null;
  placeholder?: string | null;
  maxLength?: number | null;
}

const TextArea: React.FC<ITextAreaProps> = (p) => {
  const [field, meta] = useField({
    name: p.name,
    type: 'text',
    validate: p.validate,
  });

  const inputId = `${p.id}-input`;

  return (
    <div>
      <CustomTextArea
        id={inputId}
        rows={p.rows ?? 3}
        maxLength={p.maxLength ?? 500}
        placeholder={p.placeholder ?? ''}
        disabled={p.disabled}
        isInvalid={!!meta.error && meta.touched}
        helperTextTitle={p.helperTextTitle}
        helperText={p.helperText}
        label={p.label ?? ''}
        {...field}
      />
      <ErrorText
        id={p.id}
        name={field.name}
        meta={meta}
        helperText={p.helperText}
      />
    </div>
  );
};

export default TextArea;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/datepicker.tsx

import dayjs, { Dayjs } from 'dayjs';
import {
  FieldInputProps,
  useField,
  useFormikContext,
  FieldHelperProps,
} from 'formik';
import React from 'react';

import TextField from '@/app/shared/components/form-controls/text-field';
import CommonDatePicker from '@components/form-controls/datepicker/datepicker';
import ErrorText from '@form/components/form-fields/error-text';
import { ICommonFieldProps } from '@form/components/form-fields/formfield';

interface IDatePickerProps extends ICommonFieldProps {
  variant?: string | null;
  defaultDate?: string | null;
  defaultDateOffset?: number | null;
  maxOffset?: number | null;
  minOffset?: number | null;
  max?: string | null;
  min?: string | null;
}

interface IDateInputProps {
  id: string;
  min: string;
  max: string;
  field: FieldInputProps<any>;
  disabled?: boolean;
  isInvalid?: boolean;
  helpers: FieldHelperProps<any>;
  helperTextTitle?: string;
  helperText?: string;
  label?: string;
}

const TextStyledDateInput: React.FC<IDateInputProps> = (p) => {
  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    let { value } = e.target;
    if (!/\d/.test(value)) {
      value = '';
    }
    p.field.onChange(p.field.name)({ ...e, target: { value } });
  };

  return (
    <TextField
      id={p.id}
      type="text"
      placeholder="MM/DD/YYYY"
      maskType="MM/DD/YYYY"
      {...p.field}
      onChange={onChange}
      disabled={p.disabled}
      label={p.label}
      helperTextTitle={p.helperTextTitle}
      helperText={p.helperText}
      isInvalid={p.isInvalid}
    />
  );
};

const DatepickerInput: React.FC<IDateInputProps> = (p) => {
  p;
  return (
    <CommonDatePicker
      id={p.id}
      name={p.field.name}
      minDate={dayjs(p.min)}
      maxDate={dayjs(p.max)}
      value={p.field.value}
      onChange={(date: string) => p.field.onChange(p.field.name)(date)}
      onBlur={p.field.onBlur}
      isInvalid={p.isInvalid}
      disabled={p.disabled}
      helperTextTitle={p.helperTextTitle}
      helperText={p.helperText}
      label={p.label}
    />
  );
};

const parseDate = (
  formValues: any,
  offset: number | null | undefined = 0,
  date?: string | null
) => {
  if (!date) return '';

  let newDate: Dayjs | undefined;

  switch (date) {
    case 'today':
      newDate = dayjs();
      break;
    case 'yesterday':
      newDate = dayjs().add(-1, 'day');
      break;
    case 'tomorrow':
      newDate = dayjs().add(1, 'day');
      break;
    default: {
      const fieldDate = formValues?.[date];
      if (fieldDate && dayjs(fieldDate).isValid()) {
        newDate = dayjs(fieldDate);
      } else {
        newDate = undefined;
      }
      break;
    }
  }

  if (newDate && offset) {
    newDate = newDate.add(offset, 'day');
  }

  return newDate ? newDate?.format?.('YYYY-MM-DD') : '';
};

const DatePicker: React.FC<IDatePickerProps> = (p) => {
  const [field, meta, helpers] = useField({ ...p, type: 'date' });
  const formikContext = useFormikContext();

  const Component =
    p.variant === 'textStyled' ? TextStyledDateInput : DatepickerInput;

  React.useEffect(() => {
    const defaultDate = parseDate(
      formikContext.values,
      p.defaultDateOffset,
      p.defaultDate
    );
    if ((!field.value || !dayjs(field.value).isValid()) && defaultDate) {
      field.onChange(p.name)(defaultDate);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const fieldId = `${p.id}-input`;

  return (
    <div>
      <Component
        id={fieldId}
        max={parseDate(formikContext.values, p.maxOffset, p.max)}
        min={parseDate(formikContext.values, p.minOffset, p.min)}
        field={field}
        disabled={p.disabled}
        isInvalid={!!meta.error && meta.touched}
        helpers={helpers}
        helperTextTitle={p.helperTextTitle}
        helperText={p.helperText}
        label={p.label ?? ''}
      />
      <ErrorText
        id={p.id}
        name={field.name}
        meta={meta}
        helperText={p.helperText}
      />
    </div>
  );
};

export default DatePicker;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/text-field.tsx

import { useField, useFormikContext } from 'formik';
import React from 'react';

import PhoneInput from '@components/form-controls/phone-input';
import CustomTextField from '@components/form-controls/text-field';
import ErrorText from '@form/components/form-fields/error-text';
import { ICommonFieldProps } from '@form/components/form-fields/formfield';

interface ITextFieldProps extends ICommonFieldProps {
  type?: string | null;
  mask?: string | null;
  placeholder?: string | null;
}

const TextField: React.FC<ITextFieldProps> = (p) => {
  const { placeholder = '' } = p;
  const { setFieldTouched } = useFormikContext();
  const [field, meta] = useField({
    name: p.name,
    type: p.type ?? 'text',
    validate: p.validate,
  });

  const inputId = `${p.id}-input`;

  const onBlur = () => {
    setFieldTouched(p.name, true);
  };

  return (
    <div>
      {p.mask && p.mask === 'phone' ? (
        <PhoneInput
          id={inputId}
          helperTextTitle={p.helperTextTitle}
          helperText={p.helperText}
          label={p.label}
          placeholder={placeholder ?? ''}
          disabled={p.disabled}
          isInvalid={!!meta.error && meta.touched}
          {...field}
          onBlur={onBlur}
        />
      ) : (
        <CustomTextField
          id={inputId}
          helperTextTitle={p.helperTextTitle}
          helperText={p.helperText}
          maskType={p.mask}
          label={p.label}
          placeholder={placeholder ?? ''}
          disabled={p.disabled}
          isInvalid={!!meta.error && meta.touched}
          {...field}
        />
      )}
      <ErrorText
        id={p.id}
        name={field.name}
        meta={meta}
        helperText={p.helperText}
      />
    </div>
  );
};

export default TextField;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/radio-button-group.tsx

import { useField } from 'formik';
import React from 'react';

import CustomRadioButtonGroup from '@components/form-controls/radio-group/radio-group';
import ErrorText from '@form/components/form-fields/error-text';
import { ICommonFieldProps } from '@form/components/form-fields/formfield';
import { ImageOption } from '@prisma/client';

interface IRadioButtonGroupProps extends ICommonFieldProps {
  variant?: string | null;
  options?: string[];
  imageOptions?: ImageOption[];
}

const RadioButtonGroup: React.FC<IRadioButtonGroupProps> = (p) => {
  const [field, meta] = useField({ ...p, type: 'checked' });

  return (
    <div>
      <CustomRadioButtonGroup
        id={p.id}
        name={field.name}
        variant={p.variant}
        value={field.value}
        onChange={field.onChange}
        onBlur={field.onBlur}
        options={p.options ?? []}
        imageOptions={p.imageOptions ?? []}
        disabled={p.disabled}
        isInvalid={!!meta.error && meta.touched}
        label={p.label ?? ''}
        helperTextTitle={p.helperTextTitle}
        helperText={p.helperText}
      />
      <ErrorText
        id={p.id}
        name={field.name}
        meta={meta}
        helperText={p.helperText}
      />
    </div>
  );
};

export default RadioButtonGroup;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/helper-text.tsx

import React from 'react';

interface IHelperTextProps {
  id?: string;
  text?: string;
}

const HelperText: React.FC<IHelperTextProps> = (p) => {
  return p.text ? (
    <p
      id={`${p.id}-helper-text`}
      className="mt-1 font-dmsans text-sm text-gray-600"
    >
      {p.text}
    </p>
  ) : null;
};

export default HelperText;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/formfield.tsx

import { FormikContextType, useFormikContext } from 'formik';
import get from 'lodash.get';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import { useFormState } from '@form/hooks/use-form-state';
import { getFieldConfiguration } from '@form/utils';
import { validateField } from '@form/utils/field-validation';
import { evaluateShowLogic } from '@form/utils/show-logic';
import { FormElementInclude, FormFieldType } from '@form/utils/types';

interface FormFieldProps {
  formElement: FormElementInclude;
  index: number;
  id: string;
}

const clearHiddenField = (
  formElement: FormElementInclude,
  shouldShow: boolean,
  fieldValue: any,
  formikContext: FormikContextType<unknown>
) => {
  const initialValue = getFieldConfiguration(
    formElement?.field?.fieldType ?? ''
  ).initialValue;

  if (!shouldShow && fieldValue !== '' && fieldValue !== initialValue) {
    formikContext.setFieldValue(formElement.name, initialValue, false);
    setTimeout(() => formikContext.setFieldTouched(formElement.name, false));
  }
};

const FormField = (props: FormFieldProps) => {
  const { formElement, id } = props;
  const formikContext = useFormikContext();
  const [showField, setShowField] = React.useState(false);
  const formContext = useFormState();
  const fieldConfig = getFieldConfiguration(
    formElement?.field?.fieldType ?? ''
  );

  React.useEffect(() => {
    const ss = evaluateShowLogic(
      formElement,
      formContext.fields,
      formContext.dataContext,
      formikContext.values
    );
    const fieldValue = get(formikContext?.values, formElement.name, '');
    clearHiddenField(formElement, ss, fieldValue, formikContext);
    setShowField(ss);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [formikContext.values]);

  return showField && formElement?.name != null ? (
    <div
      className={twMerge([
        formElement.field?.fieldType !== FormFieldType.Checkout &&
          'max-w-[615px]',
        'w-full',
      ])}
    >
      <fieldConfig.component
        id={id}
        name={formElement.name}
        label={formElement?.field?.label}
        helperTextTitle={formElement?.field?.helperTextTitle ?? undefined}
        helperText={formElement?.field?.helperText as string}
        disabled={formContext.disabled || formikContext.isSubmitting}
        validate={(value: any) =>
          validateField(
            value,
            formElement.field?.validation ?? [],
            formElement?.field?.fieldType ?? '',
            formElement?.field?.required ?? false,
            {
              fields: formContext.fields,
              dataContext: formContext.dataContext,
              formValues: formikContext.values,
              defaultRequiredText: formContext.form?.defaultRequiredText,
            }
          )
        }
        {...(formElement?.field?.fieldProperties ?? {})}
      />
    </div>
  ) : null;
};

export interface ICommonFieldProps {
  id: string;
  name: string;
  label?: string;
  helperTextTitle?: string;
  helperText?: string;
  validate: any;
  disabled?: boolean;
}

export default FormField;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/address-autocomplete.tsx

import { useField, useFormikContext, FormikContextType } from 'formik';
import React from 'react';

import AddressAutocompleteComponent from '@/app/shared/components/form-controls/address-autocomplete';
import ErrorText from '@form/components/form-fields/error-text';
import { ICommonFieldProps } from '@form/components/form-fields/formfield';

const AddressAutocomplete: React.FC<ICommonFieldProps> = (p) => {
  const formikContext: FormikContextType<unknown> = useFormikContext();
  const [field, meta] = useField(p);

  const handleOnAddressChange = (address: any, place: any) => {
    const baseName = field.name.split('.')[0];
    formikContext.setFieldValue(`${baseName}.address2`, address.address2);
    formikContext.setFieldValue(`${baseName}.city`, address.city);
    formikContext.setFieldValue(`${baseName}.state`, address.state);
    formikContext.setFieldValue(`${baseName}.zipcode`, address.postal);
    formikContext.setFieldValue(`${baseName}.country`, address.country);
    formikContext.setFieldValue(`${baseName}.place_id`, place.place_id);
  };

  return (
    <div>
      <AddressAutocompleteComponent
        {...p}
        label={p.label ?? ''}
        {...field}
        onChange={(e) => field.onChange(field.name)(e)}
        triggerOnChange={handleOnAddressChange}
      />
      <ErrorText
        id={p.id}
        name={field.name}
        meta={meta}
        helperText={p.helperText}
      />
    </div>
  );
};

export default AddressAutocomplete;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/api-combobox.tsx

import { useField } from 'formik';
import React from 'react';

import CustomApiCombobox from '@/app/shared/components/form-controls/api-combobox/api-combobox';
import ErrorText from '@form/components/form-fields/error-text';
import { ICommonFieldProps } from '@form/components/form-fields/formfield';

interface ITextAreaProps extends ICommonFieldProps {
  searchApi: string;
  displayKey?: string;
  errorText?: string;
  noResultsText?: string;
  placeholder?: string;
}

const ApiCombobox: React.FC<ITextAreaProps> = (p) => {
  const [field, meta] = useField({
    name: p.name,
    multiple: true,
    validate: p.validate,
  });

  const inputId = `${p.id}-input`;

  const onChange = (option: any[]) => {
    field.onChange({
      target: {
        name: field.name,
        value: option,
      },
    });
  };

  return (
    <div>
      <CustomApiCombobox
        id={inputId}
        placeholder={p.placeholder}
        searchApi={p.searchApi}
        resultKey={p.displayKey}
        disabled={p.disabled}
        isInvalid={!!meta.error && meta.touched}
        helperTextTitle={p.helperTextTitle}
        helperText={p.helperText}
        label={p.label ?? ''}
        {...field}
        onChange={onChange}
      />
      <ErrorText
        id={p.id}
        name={field.name}
        meta={meta}
        helperText={p.helperText}
      />
    </div>
  );
};

export default ApiCombobox;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/checkbox-group.tsx

import { useField } from 'formik';
import React from 'react';

import CustomCheckboxGroup from '@components/form-controls/checkboxes/checkbox-group';
import ErrorText from '@form/components/form-fields/error-text';
import { ICommonFieldProps } from '@form/components/form-fields/formfield';

interface ICheckboxGroupProps extends ICommonFieldProps {
  variant?: string | null;
  options?: string[] | null;
}

const CheckboxGroup: React.FC<ICheckboxGroupProps> = (p) => {
  const [field, meta] = useField({ ...p, type: 'checkbox' });

  return (
    <div>
      <CustomCheckboxGroup
        id={p.id}
        name={field.name}
        variant={p.variant}
        value={field.value}
        onChange={field.onChange}
        onBlur={field.onBlur}
        disabled={p.disabled}
        isInvalid={!!meta.error && meta.touched}
        options={p.options ?? []}
        helperTextTitle={p.helperTextTitle}
        helperText={p.helperText}
        label={p.label ?? ''}
      />
      <ErrorText
        id={p.id}
        name={field.name}
        meta={meta}
        helperText={p.helperText}
      />
    </div>
  );
};

export default CheckboxGroup;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/file-upload.tsx

import { useField } from 'formik';
import React from 'react';

import { getFamilyMemberHeader } from '@/utils/utils';
import FileUploadComponent, {
  type ICustomFile,
} from '@components/file-upload/file-upload';
import ErrorText from '@form/components/form-fields/error-text';
import { ICommonFieldProps } from '@form/components/form-fields/formfield';
import { COOKIE_KEYS, UploadStatus } from '@utils/enums';

interface IFileUploadProps extends ICommonFieldProps {
  allowMultiple?: boolean | null;
  acceptedFileTypes?: string[] | null;
  dropzoneCTA?: string | null;
  dropzoneText?: string | null;
  dropzoneLimits?: string | null;
  dropzoneInvalidType?: string | null;
  s3Bucket?: string | null;
}

const uploadFile: (
  file: ICustomFile,
  meta?: {
    [key: string]: any;
  }
) => Promise<ICustomFile> = async (file, meta) => {
  const formData = new FormData();
  formData.append('file', file.file, file.name);
  let newFileState = { ...file };

  const familyMemberHeader = getFamilyMemberHeader();

  const headers: { s3Bucket?: string; [COOKIE_KEYS.FAMILY_MEMBER]?: string } = {
    ...(familyMemberHeader ? familyMemberHeader : {}),
  };

  if (meta?.s3Bucket) {
    headers['s3Bucket'] = meta.s3Bucket;
  }

  try {
    const response = await fetch('/api/forms/file-upload', {
      method: 'POST',
      headers,
      body: formData,
    });

    const uploadResult = await response.json();

    if (uploadResult && uploadResult.length > 0) {
      newFileState = {
        ...file,
        status: uploadResult[0].status,
        s3Url: uploadResult[0].s3Url,
      } as ICustomFile;
    } else {
      throw new Error(`Upload Failed for ${file.id}`);
    }
  } catch (e) {
    newFileState.status = UploadStatus.ERROR;
  }
  return newFileState;
};

const FileUpload: React.FC<IFileUploadProps> = (p) => {
  const [field, meta, helpers] = useField({
    name: p.name,
    validate: p.validate,
    type: 'file',
    multiple: true,
  });

  const handleFieldChange = (files: ICustomFile[]) => helpers.setValue(files);

  const isFileTypeValid = (fileType: string) =>
    (p.acceptedFileTypes ?? []).includes(fileType);

  return (
    <FileUploadComponent
      id={p.id}
      label={p.label}
      helperText={p.helperText}
      helperTextTitle={p.helperTextTitle}
      multiple={p.allowMultiple ?? false}
      isFileTypeValid={isFileTypeValid}
      handleFieldChange={handleFieldChange}
      defaultValue={field.value}
      uploadFile={uploadFile}
      meta={{ s3Bucket: p.s3Bucket }}
      ErrorComponent={
        <ErrorText
          id={p.id}
          name={field.name}
          meta={meta}
          helperText={p.helperText}
        />
      }
      content={{
        buttonText: p.dropzoneCTA ?? 'Click to upload',
        afterButtonText: p.dropzoneText ?? 'or drag and drop',
        acceptedFileTypeText:
          p.dropzoneLimits ?? 'SVG, PNG, JPG or GIF (max. 800x400px)',
        invalidFileTypeText:
          p.dropzoneInvalidType ??
          'One of the files you selected is not an accepted type',
      }}
      disabled={p.disabled}
    />
  );
};

export default FileUpload;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/checkbox.tsx

import { useField } from 'formik';
import React from 'react';

import CheckboxInput from '@components/form-controls/checkboxes/checkbox';
import ErrorText from '@form/components/form-fields/error-text';
import { ICommonFieldProps } from '@form/components/form-fields/formfield';

interface ICheckboxProps extends ICommonFieldProps {
  checkLabel?: string | null;
  showFieldLabel?: boolean | null;
}

const Checkbox: React.FC<ICheckboxProps> = (p) => {
  const [field, meta] = useField({ ...p, type: 'checkbox' });

  const inputId = `${p.id}-input`;

  return (
    <div>
      <CheckboxInput
        id={inputId}
        name={field.name}
        onChange={field.onChange}
        onBlur={field.onBlur}
        checked={field.checked ?? false}
        disabled={p.disabled}
        label={p.label ?? ''}
        isInvalid={!!meta.error && meta.touched}
        helperTextTitle={p.helperTextTitle}
        helperText={p.helperText}
      />
      <ErrorText
        id={p.id}
        name={field.name}
        meta={meta}
        helperText={p.helperText}
      />
    </div>
  );
};

export default Checkbox;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/error-text.tsx

import { ErrorMessage, ErrorMessageProps, FieldMetaProps } from 'formik';
import React from 'react';

import HelperText from './helper-text';

interface IErrorTextProps extends ErrorMessageProps {
  id?: string;
  meta?: FieldMetaProps<any>;
  helperText?: string | null;
}

const ErrorText: React.FC<IErrorTextProps> = (p) => {
  const { id, name, helperText, meta } = p;
  const errorId = `${id}-error`;

  const showHelpText = !!meta?.touched && !!meta?.error;

  return (
    <div id={errorId} className="mt-1.5">
      <ErrorMessage
        component="p"
        className="text-sm text-error-500 font-dmsans"
        name={name}
      />
      {showHelpText && helperText && <HelperText id={id} text={helperText} />}
    </div>
  );
};

export default ErrorText;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/select.tsx

import { useField } from 'formik';
import React from 'react';

import { listOfStates } from '@/utils/utils';
import CustomSelect from '@components/form-controls/select';
import ErrorText from '@form/components/form-fields/error-text';
import { ICommonFieldProps } from '@form/components/form-fields/formfield';

interface ISelectProps extends ICommonFieldProps {
  includePlaceholderOption?: boolean | null;
  placeholderOption?: string | null;
  optionsType?: string | null;
  options?: string[];
}

const Select: React.FC<ISelectProps> = (p) => {
  const [field, meta] = useField({ ...p });

  const inputId = `${p.id}-input`;

  const handleOnChange = (option: string) => {
    field.onChange({
      target: {
        name: field.name,
        value: option,
      },
    });
  };

  const handleBlur = (e: React.FocusEvent<Element>) => {
    field.onBlur(field.name)(e);
  };

  let options: string[] = p.options ?? [];
  if (p.optionsType === 'states') {
    options = listOfStates;
  }

  return options.length > 0 ? (
    <div>
      <CustomSelect
        id={inputId}
        name={field.name}
        options={options}
        value={field.value}
        onChange={handleOnChange}
        onBlur={handleBlur}
        placeholderOption={
          p.includePlaceholderOption ? p.placeholderOption : null
        }
        label={p.label}
        helperTextTitle={p.helperTextTitle}
        helperText={p.helperText}
        isInvalid={!!meta.error && meta.touched}
      />
      <ErrorText
        id={p.id}
        name={field.name}
        meta={meta}
        helperText={p.helperText}
      />
    </div>
  ) : null;
};

export default Select;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/hidden-field.tsx

import { useField } from 'formik';
import React from 'react';

import { ICommonFieldProps } from '@form/components/form-fields/formfield';

const HiddenField: React.FC<ICommonFieldProps> = (p) => {
  const { id, disabled } = p;
  const [field] = useField({ ...p, type: 'hidden' });

  return (
    <input
      id={`${id}-input`}
      type="hidden"
      className="hidden"
      {...field}
      disabled={disabled}
    />
  );
};

export default HiddenField;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/pharmacy-picker/pharmacy-search-form.tsx

import React from 'react';

import ButtonOutline from '@/app/shared/components/buttons/button-outline';
import LoadingSpinner from '@/app/shared/components/loading-indicators/loading-spinner';
import { PharmacyResult } from '@/utils/clients/dosespot/dosespotTypes';
import ButtonSolid from '@components/buttons/button-solid';
import TextField from '@components/form-controls/text-field';
import { Check } from '@untitled-ui/icons-react';

interface IPharmacySearchFormProps {
  value?: any;
  onChange: (value: any) => void;
  fieldError: () => React.JSX.Element;
  disabled?: boolean;
}

const searchPharmacies = async (name?: string, city?: string, zip?: string) => {
  try {
    const res = await fetch(
      `/api/dosespot/search-pharmacies?name=${name}&city=${city}&zip=${zip}`
    );

    if (!res.ok) {
      throw new Error('Could not find pharmacy');
    }

    const searchResult = (await res.json()) as PharmacyResult[];
    return { result: searchResult, success: true };
  } catch (error) {
    return { result: [], success: false };
  }
};

const PharmacySearchForm: React.FC<IPharmacySearchFormProps> = (p) => {
  const [searchResults, setSearchResults] = React.useState<PharmacyResult[]>(
    []
  );
  const [searching, setSearching] = React.useState(false);
  const [searched, setSearched] = React.useState(false);
  const [error, setError] = React.useState(false);
  const [pharmacyName, setPharmacyName] = React.useState('');
  const [pharmacyCity, setPharmacyCity] = React.useState('');
  const [pharmacyZip, setPharmacyZip] = React.useState('');

  const handlePharmacySearch = async () => {
    // Reset states
    setError(false);
    setSearchResults([]);
    setSearched(false);

    // Search
    setSearching(true);
    const res = await searchPharmacies(pharmacyName, pharmacyCity, pharmacyZip);
    if (res.success) {
      setSearched(true);
      setSearchResults(res.result);
    } else {
      setError(true);
    }
    setSearching(false);
  };

  const handlePharmacySelect = (pharmacy: any) => {
    p.onChange(pharmacy);
  };

  const handlePharmacyRemove = () => {
    p.onChange(undefined);
  };

  const searchOnEnter = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      handlePharmacySearch();
    }
  };

  const disabled = p.disabled || searching;

  return (
    <div>
      <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
        <div className="flex flex-col">
          <p className="font-dmsans text-gray-900 text-base mb-2">
            My <strong>Preferred Local</strong> Pharmacy
          </p>
          {p?.value?.PharmacyId ? (
            <div className="flex-1 bg-white rounded-md shadow-md p-4">
              <p className="font-dmsans text-gray-900 font-semibold text-lg">
                {p.value.StoreName}
              </p>
              <p className="mt-2 font-dmsans text-gray-600 text-sm">
                {p.value.Address1}
                {p.value.Address2 && (
                  <>
                    <br />
                    {p.value.Address2}
                  </>
                )}
                <br />
                {p.value.City}, {p.value.State} {p.value.Zip}
              </p>
              <div className="mt-6 flex flex-row gap-4 justify-between items-center">
                <div className="flex items-center font-dmsans text-accent-600 text-sm font-medium">
                  <Check className="h-4 w-4 mr-1" viewBox="0 0 24 24" />
                  Selected
                </div>
                <ButtonOutline
                  variant="gray"
                  size="sm"
                  onClick={handlePharmacyRemove}
                  disabled={disabled}
                >
                  Remove
                </ButtonOutline>
              </div>
            </div>
          ) : (
            <div className="flex-1 bg-white rounded-md shadow-md p-4 pb-6">
              <p className="font-dmsans text-gray-900 font-semibold text-lg">
                No Pharmacy Selected
              </p>
              <p className="mt-2 font-dmsans text-gray-600 text-sm">
                Please use the search below to find your preffered local
                pharmacy
              </p>
            </div>
          )}
        </div>
        <div className="flex flex-col">
          <p className="font-dmsans text-gray-900 text-base mb-2">
            Cortina&apos;s <strong>Mail-Order</strong> Pharmacy
          </p>
          <div className="bg-white rounded-md shadow-md p-4 pb-6">
            <p className="font-dmsans text-gray-900 font-semibold text-lg">
              Curexa
            </p>
            <p className="mt-2 font-dmsans text-gray-600 text-sm">
              3007 Ocean Heights Ave
              <br />
              Egg Harbor Township, NJ 08234
            </p>
          </div>
        </div>
      </div>
      {p.fieldError()}
      <div className="mt-8 border-t border-gray-200 pt-6">
        <p className="font-dmsans text-gray-900 text-base font-semibold">
          Local Pharmacy Search
        </p>
        <p className="font-dmsans text-gray-600 text-sm mb-2">
          Use a combination of name, city and/or zip code to search for your
          preferred local pharmacy:
        </p>
      </div>
      <div className="mt-4 flex flex-col sm:flex-row gap-3">
        <TextField
          placeholder="Pharmacy Name"
          value={pharmacyName}
          onChange={(e) => setPharmacyName(e.target.value)}
          onKeyDown={searchOnEnter}
          disabled={disabled}
        />
        <TextField
          placeholder="City"
          value={pharmacyCity}
          onChange={(e) => setPharmacyCity(e.target.value)}
          onKeyDown={searchOnEnter}
          disabled={disabled}
        />
        <TextField
          placeholder="Zip"
          value={pharmacyZip}
          onChange={(e) => setPharmacyZip(e.target.value)}
          onKeyDown={searchOnEnter}
          disabled={disabled}
        />
        <ButtonSolid
          variant="accent"
          className="min-w-[80px] text-center flex items-center justify-center text-base"
          onClick={handlePharmacySearch}
          disabled={disabled}
        >
          {searching ? (
            <LoadingSpinner fillClass="fill-accent-400" size="sm" />
          ) : (
            'Search'
          )}
        </ButtonSolid>
      </div>
      {error && (
        <p className="mt-2 text-red-500 text-sm">
          There was an error searching for pharmacies. Please check your search
          and try again.
        </p>
      )}
      {searching && (
        <>
          <p className="my-4 font-dmsans text-gray-600 text-base">
            Searching...
          </p>
          <div className="mt-2 space-y-3 animate-pulse">
            <div className="flex justify-between items-center gap-x-6 p-8 bg-white border border-gray-200 rounded-md shadow-sm" />
            <div className="flex justify-between items-center gap-x-6 p-8 bg-white border border-gray-200 rounded-md shadow-sm" />
          </div>
        </>
      )}
      {searched && searchResults.length === 0 && (
        <p className="mt-2 text-gray-600 text-sm">
          No pharmacies found for your search.
        </p>
      )}
      {searchResults.length > 0 && (
        <div>
          <p className="my-4 font-dmsans text-gray-600 text-base">
            Search Results
          </p>
          <ul
            role="listbox"
            className="mt-2 space-y-3 max-h-96 overflow-y-auto pr-2"
          >
            {searchResults.map((pharmacy: any) => (
              <li
                key={pharmacy.PharmacyId}
                role="option"
                aria-selected={p?.value?.PharmacyId === pharmacy.PharmacyId}
                className="flex justify-between items-center gap-x-6 p-4 bg-white border border-gray-200 rounded-md shadow-sm"
              >
                <div className="flex min-w-0 gap-x-4">
                  <div className="min-w-0 flex-auto">
                    <p className="text-base font-semibold leading-6 text-gray-900">
                      {pharmacy.StoreName}
                    </p>
                    <p className="mt-1 text-xs leading-5 text-gray-500">
                      {`${pharmacy.Address1}, ${pharmacy.City}, ${pharmacy.State} ${pharmacy.ZipCode}`}
                    </p>
                  </div>
                </div>
                <div className="shrink-0 sm:flex sm:flex-col sm:items-end">
                  {p?.value?.PharmacyId === pharmacy.PharmacyId ? (
                    <div className="flex items-center font-dmsans text-accent-600 text-sm font-medium">
                      <Check className="h-4 w-4 mr-1" viewBox="0 0 24 24" />
                      Selected
                    </div>
                  ) : (
                    <ButtonOutline
                      variant="gray"
                      onClick={() => handlePharmacySelect(pharmacy)}
                      disabled={disabled}
                    >
                      Select
                    </ButtonOutline>
                  )}
                </div>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
};

export default PharmacySearchForm;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/pharmacy-picker/pharmacy-picker.tsx

'use client';

import { useField } from 'formik';
import React, { ChangeEvent } from 'react';

import Label from '@/app/shared/components/form-controls/label';
import ErrorText from '@form/components/form-fields/error-text';
import type { ICommonFieldProps } from '@form/components/form-fields/formfield';
import { FormElementValidation } from '@prisma/client';

import PharmacySearchForm from './pharmacy-search-form';

interface IPharmacyPickerProps extends ICommonFieldProps {
  nameLabel?: string | null;
  address1Label?: string | null;
  address2Label?: string | null;
  cityLabel?: string | null;
  stateLabel?: string | null;
  zipLabel?: string | null;
  innerFormValidation?: FormElementValidation[] | null;
}

const PharmacyPicker: React.FC<IPharmacyPickerProps> = (p) => {
  const [field, meta] = useField({
    name: p.name,
    validate: p.validate,
  });

  const handleChange = (value: any) => {
    field.onChange(p.name)({ target: { value } } as ChangeEvent<any>);
  };

  return (
    <div>
      {p.label && <Label htmlFor={p.id} label={p.label} />}
      <PharmacySearchForm
        value={field.value}
        onChange={handleChange}
        fieldError={() => (
          <ErrorText
            id={p.id}
            name={field.name}
            meta={meta}
            helperText={p.helperText}
          />
        )}
      />
    </div>
  );
};

export default PharmacyPicker;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/checkout/index.tsx

import { useField } from 'formik';
import React from 'react';

import { IStartCheckoutResponse } from '@/app/api/checkout/start-checkout/route';
import LoadingSpinner from '@/app/shared/components/loading-indicators/loading-spinner';
import LoadError from '@components/checkout/load-error';
import { ICommonFieldProps } from '@form/components/form-fields/formfield';
import { useQuery } from '@tanstack/react-query';

import { useFormState } from '../../../hooks/use-form-state';
import ErrorText from '../error-text';
import CheckoutFieldWrapper from './checkout-field-wrapper';

const startCheckout = async (existingDependentId?: string | null) => {
  // Passing the existingDependentId as a header
  const headers = existingDependentId
    ? { 'selected-user-id': existingDependentId }
    : undefined;

  const res = await fetch('/api/checkout/start-checkout', {
    method: 'GET',
    headers,
  });

  return (await res.json()) as IStartCheckoutResponse;
};

const Checkout: React.FC<ICommonFieldProps> = (p) => {
  const formContext = useFormState();
  const [field, meta] = useField<boolean>({
    ...p,
    type: 'checkbox',
  });

  const existingDependentId =
    formContext?.dataContext?.mid ?? formContext?.dataContext?.selectedUser?.id;

  const { isLoading, isError, data } = useQuery(
    ['checkout'],
    async () => startCheckout(existingDependentId),
    {
      refetchOnWindowFocus: false,
    }
  );

  if (isError) {
    return <LoadError />;
  }

  if (isLoading || !data) {
    return (
      <div className="flex justify-center px-6 py-10">
        <LoadingSpinner fillClass="fill-accent-500" />
      </div>
    );
  }

  return (
    <div id={`${p.id}-form`}>
      <CheckoutFieldWrapper field={field} checkoutData={data} />
      <div className="mt-4">
        <ErrorText
          id={p.id}
          name={field.name}
          meta={meta}
          helperText={p.helperText}
        />
      </div>
    </div>
  );
};

export default Checkout;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/checkout/checkout-field-wrapper.tsx

import { FieldInputProps, useFormikContext } from 'formik';
import React from 'react';

import { IStartCheckoutResponse } from '@/app/api/checkout/start-checkout/route';
import PurchaseConfirmation from '@components/checkout//purchase-confirmation';
import CheckoutDataWrapper from '@components/checkout/checkout-data-wrapper';

interface ICheckoutFieldWrapperProps {
  field: FieldInputProps<boolean>;
  checkoutData: IStartCheckoutResponse;
}

const CheckoutFieldWrapper: React.FC<ICheckoutFieldWrapperProps> = (p) => {
  const { values } = useFormikContext();
  const setPaymentConfirmed = () => {
    p.field.onChange(p.field.name)({ target: { value: true } } as any);
  };

  const handlePaymentSetup = async () => {
    await createDSUser(values);
  };

  React.useEffect(() => {
    if (
      !p.field.value &&
      p.checkoutData &&
      (p.checkoutData.paymentConfirmed || !p.checkoutData.paymentRequired)
    ) {
      setPaymentConfirmed();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [p.checkoutData, p.field.value]);

  if (
    !!p.field.value ||
    p.checkoutData?.paymentConfirmed ||
    !p.checkoutData?.paymentRequired
  ) {
    return <PurchaseConfirmation />;
  }

  return (
    <CheckoutDataWrapper
      onSubmit={handlePaymentSetup}
      onSuccess={setPaymentConfirmed}
      user={p.checkoutData.user}
      disableConsultationRemove={true}
    />
  );
};

const createDSUser = async (formValues: any) => {
  const res = await fetch('/api/checkout/create-ds-user', {
    method: 'POST',
    body: JSON.stringify({
      firstName: formValues?.firstName,
      lastName: formValues?.lastName,
      addresses: formValues?.addressPicker,
      phoneNumber: formValues?.phone,
      dob: new Date(formValues?.dob),
      sexAtBirth: formValues?.sex,
    }),
    headers: {
      'Content-Type': 'application/json',
    },
  });

  if (!res.ok) {
    throw new Error("Couldn't create user in dosespot");
  }

  const result = (await res.json()) as { success: boolean };

  if (!result.success) {
    throw new Error("Couldn't create user in dosespot");
  }
};

export default CheckoutFieldWrapper;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/address-picker/address-form.tsx

import { Field, Formik, FieldProps } from 'formik';
import React from 'react';

import { listOfStates } from '@/utils/utils';
import ButtonOutline from '@components/buttons/button-outline';
import ButtonSolid from '@components/buttons/button-solid';
import AddressAutocomplete from '@components/form-controls/address-autocomplete';
import Select from '@components/form-controls/select';
import TextField from '@components/form-controls/text-field';
import ErrorText from '@form/components/form-fields/error-text';
import { useFormState } from '@form/hooks/use-form-state';
import { validateField } from '@form/utils/field-validation';
import { FormFieldType } from '@form/utils/types';
import { Address, FormElementValidation } from '@prisma/client';

import { IAddress, ModalMode } from './address-radio-group';

interface IAddressFormProps {
  labels: {
    nameLabel?: string | null;
    address1Label?: string | null;
    address2Label?: string | null;
    cityLabel?: string | null;
    stateLabel?: string | null;
    zipLabel?: string | null;
  };
  validations?: FormElementValidation[];
  push: (address: Address) => void;
  replace: (index: number, value: Address) => void;
  selectedAddress?: IAddress;
  mode: ModalMode;
  addresses: IAddress[];
  onClose: () => void;
}

const getFieldValidationRules = (
  fieldName: string,
  validations: FormElementValidation[] = []
) => {
  return validations.filter((v) => v.operandA === `$field:${fieldName}`);
};

const formFields = [
  {
    name: 'name',
    field: {
      fieldType: FormFieldType.TextField,
    },
  },
  {
    name: 'address1',
    field: {
      fieldType: FormFieldType.AddressAutocomplete,
    },
  },
  {
    name: 'address2',
    field: {
      fieldType: FormFieldType.TextField,
    },
  },
  {
    name: 'city',
    field: {
      fieldType: FormFieldType.TextField,
    },
  },
  {
    name: 'state',
    field: {
      fieldType: FormFieldType.Select,
    },
  },
  {
    name: 'zip',
    field: {
      fieldType: FormFieldType.TextField,
    },
  },
];

const AddressForm: React.FC<IAddressFormProps> = (p) => {
  const formContext = useFormState();
  const initialValues = React.useMemo(() => {
    if (p.mode === ModalMode.Edit && p.selectedAddress) {
      const formValues = { ...p.selectedAddress };
      delete formValues.index;
      return formValues;
    } else {
      return {
        name: '',
        address1: '',
        address2: '',
        city: '',
        state: '',
        zip: '',
      };
    }
  }, [p.mode, p.selectedAddress]);

  const [
    nameField,
    address1Field,
    address2Field,
    cityField,
    stateField,
    zipField,
  ] = formFields;

  return (
    <Formik
      initialValues={initialValues}
      onSubmit={(values) => {
        if (p.mode === ModalMode.Edit) {
          const selectedAddressIndex = p.selectedAddress?.index;
          selectedAddressIndex &&
            p.replace(selectedAddressIndex, {
              ...values,
              default: p.selectedAddress?.default ?? false,
            });
        } else {
          p.push({
            ...values,
            default: p.addresses && p.addresses.length === 0,
          });
        }
        p.onClose();
      }}
    >
      {(props) => {
        const validate = (
          value: string,
          fieldName: string,
          required = false
        ) => {
          return validateField(
            value,
            getFieldValidationRules(fieldName, p.validations) ?? [],
            FormFieldType.TextField,
            required,
            {
              fields: formFields as any,
              dataContext: formContext.dataContext,
              formValues: props.values,
              defaultRequiredText: formContext.form?.defaultRequiredText,
            }
          );
        };

        return (
          <div className="w-full flex flex-col gap-4">
            <div>
              <Field
                name={nameField.name}
                validate={(v: string) => validate(v, nameField.name, true)}
              >
                {({ field }: FieldProps) => (
                  <TextField
                    label={p.labels.nameLabel ?? ''}
                    placeholder="e.g. Home"
                    {...field}
                  />
                )}
              </Field>
              <ErrorText name={nameField.name} />
            </div>
            <div>
              <Field
                name={address1Field.name}
                validate={(v: string) => validate(v, address1Field.name, true)}
              >
                {({ field }: FieldProps) => (
                  <AddressAutocomplete
                    {...field}
                    label={p.labels.address1Label ?? ''}
                    onChange={(e) => field.onChange(field.name)(e)}
                    triggerOnChange={(address: any) => {
                      props.setFieldValue(address2Field.name, address.address2);
                      props.setFieldValue(cityField.name, address.city);
                      props.setFieldValue(stateField.name, address.state);
                      props.setFieldValue(zipField.name, address.postal);
                    }}
                  />
                )}
              </Field>
              <ErrorText name={address1Field.name} />
            </div>
            <div>
              <Field
                name={address2Field.name}
                validate={(v: string) => validate(v, address2Field.name, false)}
              >
                {({ field }: FieldProps) => (
                  <TextField label={p.labels.address2Label ?? ''} {...field} />
                )}
              </Field>
              <ErrorText name={address2Field.name} />
            </div>
            <div>
              <Field
                name={cityField.name}
                validate={(v: string) => validate(v, cityField.name, true)}
              >
                {({ field }: FieldProps) => (
                  <TextField label={p.labels.cityLabel ?? ''} {...field} />
                )}
              </Field>
              <ErrorText name={cityField.name} />
            </div>
            <div>
              <Field
                name={stateField.name}
                validate={(v: string) => validate(v, stateField.name, true)}
              >
                {({ field }: FieldProps) => (
                  <Select
                    label={p.labels.stateLabel ?? ''}
                    {...field}
                    options={listOfStates}
                    onChange={(option: string) => {
                      field.onChange({
                        target: {
                          name: field.name,
                          value: option,
                        },
                      });
                    }}
                  />
                )}
              </Field>
              <ErrorText name={stateField.name} />
            </div>
            <div>
              <Field
                name={zipField.name}
                validate={(v: string) => validate(v, zipField.name, true)}
              >
                {({ field }: FieldProps) => (
                  <TextField label={p.labels.zipLabel ?? ''} {...field} />
                )}
              </Field>
              <ErrorText name={zipField.name} />
            </div>

            <div className="mt-5 flex justify-end gap-4">
              <ButtonOutline variant="gray" type="button" onClick={p.onClose}>
                Cancel
              </ButtonOutline>
              <ButtonSolid
                variant="accent"
                className="px-6"
                type="button"
                onClick={() => props.handleSubmit()}
              >
                {p.mode === ModalMode.Edit ? 'Update' : 'Add'}
              </ButtonSolid>
            </div>
          </div>
        );
      }}
    </Formik>
  );
};

export default AddressForm;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/address-picker/address-picker.tsx

'use client';

import { useField } from 'formik';
import React from 'react';

import AddressRadioGroup from '@form/components/form-fields/address-picker/address-radio-group';
import ErrorText from '@form/components/form-fields/error-text';
import type { ICommonFieldProps } from '@form/components/form-fields/formfield';
import { FormElementValidation } from '@prisma/client';

interface IAddressPickerProps extends ICommonFieldProps {
  nameLabel?: string | null;
  address1Label?: string | null;
  address2Label?: string | null;
  cityLabel?: string | null;
  stateLabel?: string | null;
  zipLabel?: string | null;
  innerFormValidation?: FormElementValidation[] | null;
}

const AddressPicker: React.FC<IAddressPickerProps> = (p) => {
  const [field, meta] = useField({
    name: p.name,
    multiple: true,
    validate: p.validate,
  });

  return (
    <div>
      <AddressRadioGroup
        {...p}
        validations={p.innerFormValidation}
        {...field}
      />
      <ErrorText
        id={p.id}
        name={field.name}
        meta={meta}
        helperText={p.helperText}
      />
    </div>
  );
};

export default AddressPicker;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/components/form-fields/address-picker/address-radio-group.tsx

import { FieldArray } from 'formik';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import ButtonBase from '@components/buttons/button-base';
import Label from '@components/form-controls/label';
import Modal from '@components/overlays/modal';
import type { ICommonFieldProps } from '@form/components/form-fields/formfield';
import { RadioGroup } from '@headlessui/react';
import { CheckCircleIcon, PlusIcon } from '@heroicons/react/20/solid';
import { FormElementValidation, Address } from '@prisma/client';

import AddressForm from './address-form';

export interface IAddress extends Address {
  index?: number;
}

export enum ModalMode {
  Create = 'create',
  Edit = 'edit',
}

interface IAddressRadioGroupProps extends ICommonFieldProps {
  value?: any[];
  nameLabel?: string | null;
  address1Label?: string | null;
  address2Label?: string | null;
  cityLabel?: string | null;
  stateLabel?: string | null;
  zipLabel?: string | null;
  validations?: FormElementValidation[] | null;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onBlur?: (e: React.FocusEvent<HTMLInputElement>) => void;
}

const formatedAddress = (address: IAddress) => {
  const { address1, address2, city, state, zip } = address;
  return (
    <div>
      <p>{`${address1} ${address2}`}</p>
      <p>{`${city}, ${state} ${zip}`}</p>
    </div>
  );
};

const AddressRadioGroup: React.FC<IAddressRadioGroupProps> = (p) => {
  const [showModal, setShowModal] = React.useState(false);
  const [modalMode, setModalMode] = React.useState<ModalMode>(ModalMode.Create);
  const [selectedAddress, setSelectedAddress] = React.useState<
    IAddress | undefined
  >(undefined);

  const addresses: IAddress[] = React.useMemo(() => {
    return (p.value ?? []).map((address: Address, index: number) => ({
      ...address,
      index,
    }));
  }, [p.value]);

  const handleAddressDefaultChange = (
    value: IAddress,
    replace: (index: number, value: Address) => void
  ) => {
    // Set all addresses to not default
    addresses.forEach((address: IAddress) => {
      const addressIndex = address.index as number;
      const newAddress = { ...address };
      delete newAddress.index;
      replace(addressIndex, { ...newAddress, default: false });
    });

    // Set the selected address to default
    const selectedAddressIndex = value.index as number;
    const newDefaultAddress = { ...value };
    delete newDefaultAddress.index;
    replace(selectedAddressIndex, { ...newDefaultAddress, default: true });
  };

  return (
    <>
      <FieldArray
        name={p.name}
        render={({ push, replace, remove }) => {
          const handleEdit = (
            e: React.MouseEvent<HTMLButtonElement, MouseEvent>,
            address: IAddress,
            index: number
          ) => {
            e.stopPropagation();
            setSelectedAddress({ ...address, index });
            setModalMode(ModalMode.Edit);
            setShowModal(true);
          };

          const handleRemove = (
            e: React.MouseEvent<HTMLButtonElement, MouseEvent>,
            indexToRemove: number
          ) => {
            e.stopPropagation();
            // If the address being removed is the default address, set the next address as default
            if (addresses[indexToRemove].default) {
              const nextDefaultIndex = indexToRemove === 0 ? 1 : 0;
              if (addresses?.[nextDefaultIndex]) {
                const { index, ...address } = addresses[nextDefaultIndex];
                replace<Address>(index as number, {
                  ...address,
                  default: true,
                });
              }
            }
            remove(indexToRemove);
          };

          const addNew = () => {
            setSelectedAddress(undefined);
            setModalMode(ModalMode.Create);
            setShowModal(true);
          };

          const inputId = `${p.id}-input`;

          return (
            <div key={`${p.name}-field-array`}>
              <Label
                id={p.id}
                helperText={p.helperText}
                helperTextTitle={p.helperTextTitle}
                label={p.label}
                htmlFor={inputId}
              />
              {addresses.length > 0 ? (
                <>
                  <RadioGroup
                    id={inputId}
                    value={addresses.find(
                      (address: IAddress) => address.default
                    )}
                    onChange={(value: IAddress) =>
                      handleAddressDefaultChange(value, replace)
                    }
                    disabled={p.disabled}
                  >
                    <div className="mt-2 grid grid-cols-1 gap-y-3">
                      {addresses.map(
                        (address: IAddress, addressIndex: number) => (
                          <RadioGroup.Option
                            key={`${address.name}-option-${addressIndex}`}
                            value={address}
                            className={({ checked, active }) =>
                              twMerge(
                                active
                                  ? 'bg-accent-50 border-accent-600 ring-2 ring-accent-600'
                                  : 'bg-white border-gray-300',
                                checked ? 'bg-accent-50' : 'bg-white',
                                'relative flex cursor-pointer rounded-lg border p-4 shadow-sm focus:outline-none'
                              )
                            }
                          >
                            {({ checked, active }) => (
                              <>
                                <span className="flex flex-1">
                                  <span className="flex flex-col">
                                    <RadioGroup.Label
                                      as="span"
                                      className={twMerge(
                                        checked
                                          ? 'text-accent-800'
                                          : 'text-gray-800',
                                        'block text-sm font-bold'
                                      )}
                                    >
                                      {address.name}
                                    </RadioGroup.Label>
                                    <RadioGroup.Description
                                      as="span"
                                      className={twMerge(
                                        checked
                                          ? 'text-accent-600'
                                          : 'text-gray-500',
                                        'mt-1 flex items-center text-sm'
                                      )}
                                    >
                                      {formatedAddress(address)}
                                    </RadioGroup.Description>
                                    <RadioGroup.Description
                                      as="div"
                                      className="flex mt-1 font-dmsans text-sm font-semibold"
                                    >
                                      <ButtonBase
                                        className="z-10 py-2 px-0 pr-2"
                                        variant="accent"
                                        onClick={(e) =>
                                          handleEdit(e, address, addressIndex)
                                        }
                                        disabled={p.disabled}
                                      >
                                        Edit
                                      </ButtonBase>
                                      <ButtonBase
                                        className={twMerge(
                                          checked
                                            ? 'text-accent-500'
                                            : 'text-gray-600',
                                          'z-10 py-2 px-2'
                                        )}
                                        variant="accent"
                                        onClick={(e) =>
                                          handleRemove(e, addressIndex)
                                        }
                                        disabled={p.disabled}
                                      >
                                        Remove
                                      </ButtonBase>
                                      <div
                                        className={twMerge(
                                          checked
                                            ? 'text-accent-500'
                                            : 'text-gray-600',
                                          'pl-2 py-2'
                                        )}
                                      >
                                        Set as default
                                      </div>
                                    </RadioGroup.Description>
                                  </span>
                                </span>
                                <CheckCircleIcon
                                  className={twMerge(
                                    !checked ? 'invisible' : '',
                                    'h-5 w-5 text-accent-600'
                                  )}
                                  aria-hidden="true"
                                />
                                <span
                                  className={twMerge(
                                    active ? 'border' : 'border-2',
                                    checked
                                      ? 'border-accent-600'
                                      : 'border-transparent',
                                    'pointer-events-none absolute -inset-px rounded-lg'
                                  )}
                                  aria-hidden="true"
                                />
                              </>
                            )}
                          </RadioGroup.Option>
                        )
                      )}
                    </div>
                  </RadioGroup>
                  <ButtonBase
                    variant="accent"
                    onClick={addNew}
                    className="mt-2 flex justify-center items-center px-0"
                    disabled={p.disabled}
                  >
                    <PlusIcon className="w-5 h-5" /> Add new address
                  </ButtonBase>
                </>
              ) : (
                <button
                  type="button"
                  onClick={addNew}
                  className="relative block w-full text-accent-700 rounded-lg border-2 border-dashed border-gray-300 px-12 py-4 text-center hover:border-gray-400 focus:outline-none focus:ring-2 focus:ring-accent-600 focus:ring-offset-2"
                  disabled={p.disabled}
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    strokeWidth="0.75"
                    stroke="currentColor"
                    className="mx-auto h-10 w-10 text-accent-700"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      d="M15 10.5a3 3 0 11-6 0 3 3 0 016 0z"
                    />
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1115 0z"
                    />
                  </svg>

                  <span className="mt-2 block text-sm font-semibold text-accent-700">
                    Add an address
                  </span>
                </button>
              )}
              <Modal
                show={showModal}
                title="Add New Address"
                contentRenderer={() => (
                  <AddressForm
                    labels={{
                      nameLabel: p.nameLabel,
                      address1Label: p.address1Label,
                      address2Label: p.address2Label,
                      cityLabel: p.cityLabel,
                      stateLabel: p.stateLabel,
                      zipLabel: p.zipLabel,
                    }}
                    validations={p.validations ?? []}
                    push={push}
                    replace={replace}
                    selectedAddress={selectedAddress}
                    mode={modalMode}
                    addresses={addresses}
                    onClose={() => setShowModal(false)}
                  />
                )}
                onClose={() => setShowModal(false)}
              />
            </div>
          );
        }}
      />
    </>
  );
};

export default AddressRadioGroup;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/hooks/use-form-state.ts

import { useContext } from 'react';

import { FormStateContext } from '@form/contexts/form-context';

export function useFormState() {
  const context = useContext(FormStateContext);
  if (!context) {
    console.warn('useFormState must be used within the FormProvider');
  }
  return context;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/hooks/use-form-navigation.ts

'use client';

import { FormikContextType, useFormikContext } from 'formik';
import React from 'react';

import { FormNavigationContext } from '@form/contexts/form-navigation-context';
import { useFormState } from '@form/hooks/use-form-state';
import { SlideDirection } from '@form/utils/enums';
import { evaluateShowLogic } from '@form/utils/show-logic';

import { getFieldConfiguration } from '../utils';
import { FormElementInclude } from '../utils/types';

const clearHiddenField = (
  formElement: FormElementInclude,
  fieldValue: any,
  formikContext: FormikContextType<unknown>
) => {
  const initialValue = getFieldConfiguration(
    formElement?.field?.fieldType ?? ''
  ).initialValue;

  if (fieldValue !== '' && fieldValue !== initialValue) {
    formikContext.setFieldValue(formElement.name, initialValue, false);
    setTimeout(() => formikContext.setFieldTouched(formElement.name, false));
  }
};

const useFormNavigation = () => {
  const navigationContext = React.useContext(FormNavigationContext);
  const formContext = useFormState();
  const formikContext = useFormikContext();

  if (!navigationContext) {
    console.warn(
      'useFormNavigation must be used within the FormNavigationProvider'
    );
  }

  const {
    sections,
    currentSectionIndex,
    setCurrentSectionIndex,
    setSections,
    currentStepIndex,
    setCurrentStepIndex,
    showConfirmationView,
    setShowConfirmationView,
    visitedSections,
    setVisitedSections,
    setSlideDirection,
    showConfirmation,
    confirmationSectionTitle,
  } = navigationContext;

  const shouldStepShow = (sectionIndex: number, stepIndex: number) => {
    const step = sections?.[sectionIndex]?.steps?.[stepIndex];

    if (step && step.formElements.length > 0) {
      return step.formElements.some((field) => {
        const shouldShow = evaluateShowLogic(
          field,
          formContext.fields,
          formContext.dataContext,
          formikContext.values
        );

        if (!shouldShow) {
          clearHiddenField(
            field,
            (formikContext.values as any)?.[field.name],
            formikContext
          );
        }

        return shouldShow;
      });
    }

    return false;
  };

  const shouldSectionShow = (sectionIndex: number) => {
    const section = sections?.[sectionIndex];

    if (section && section.steps.length > 0) {
      return section.steps.some((_step, stepIndex) =>
        shouldStepShow(sectionIndex, stepIndex)
      );
    }

    return false;
  };

  const findNextSectionIndex = (sectionIndex: number) => {
    const nextSectionIndex = sectionIndex + 1;

    for (let i = nextSectionIndex; i < sections.length; i++) {
      if (shouldSectionShow(i)) {
        return i;
      }
    }

    return null;
  };

  const findNextStepIndex = (sectionIndex: number, stepIndex: number) => {
    const nextStepIndex = stepIndex + 1;
    const stepsInSection = sections?.[sectionIndex]?.steps;

    if (stepsInSection && stepsInSection.length > 0) {
      for (let i = nextStepIndex; i < stepsInSection.length; i++) {
        if (shouldStepShow(sectionIndex, i)) {
          return i;
        }
      }
    }

    return null;
  };

  const getNextSectionAndStepIndex = (
    currentSectionIndex: number,
    currentStepIndex: number
  ) => {
    const nextStepIndex = findNextStepIndex(
      currentSectionIndex,
      currentStepIndex
    );

    if (nextStepIndex !== null) {
      return {
        nextSectionIndex: currentSectionIndex,
        nextStepIndex,
      };
    }

    const nextSectionIndex = findNextSectionIndex(currentSectionIndex);
    if (nextSectionIndex !== null) {
      return {
        nextSectionIndex,
        nextStepIndex: findNextStepIndex(nextSectionIndex, -1) as number,
      };
    }

    return null;
  };

  const resetRemainingSectionVisibility = (
    sectionIndex: number,
    stepIndex: number
  ) => {
    const updatedSections = [...sections];

    for (let i = sectionIndex; i < updatedSections.length; i++) {
      const steps = updatedSections[sectionIndex].steps;
      for (let j = stepIndex + 1; j < steps.length; j++) {
        steps[j].isVisible = false;
      }
      if (i > sectionIndex) {
        updatedSections[i].isVisible = false;
      }
    }

    setSections(updatedSections);
  };

  const next = () => {
    const nextIndexes = getNextSectionAndStepIndex(
      currentSectionIndex,
      currentStepIndex
    );

    if (nextIndexes) {
      const { nextSectionIndex, nextStepIndex } = nextIndexes;
      const updatedSections = [...sections];

      updatedSections[nextSectionIndex].isVisible = true;
      updatedSections[nextSectionIndex].steps[nextStepIndex].isVisible = true;
      const nextSectionTitle = sections?.[nextSectionIndex]?.sectionTitle;
      setSlideDirection(SlideDirection.Left);
      setSections(updatedSections);
      setCurrentSectionIndex(nextSectionIndex);
      setCurrentStepIndex(nextStepIndex);

      if (nextSectionTitle && !visitedSections.includes(nextSectionTitle)) {
        setVisitedSections([...visitedSections, nextSectionTitle]);
      }
    } else if (showConfirmation) {
      setSlideDirection(SlideDirection.Left);
      setVisitedSections([...visitedSections, confirmationSectionTitle]);
      setShowConfirmationView(true);
    }
  };

  const hasNextVisible = () =>
    !showConfirmationView &&
    (getNextSectionAndStepIndex(currentSectionIndex, currentStepIndex) !==
      null ||
      showConfirmation);

  const setInitialStep = () => {
    const shouldFirstSectionShow = shouldSectionShow(0);

    if (shouldFirstSectionShow) {
      const firstVisibleStep = findNextStepIndex(0, -1);

      const updatedSections = [...sections];
      updatedSections[0].isVisible = true;
      updatedSections[0].steps[firstVisibleStep as number].isVisible = true;
      setVisitedSections([sections[0].sectionTitle ?? '']);
      setSections(updatedSections);

      setCurrentSectionIndex(0);
      setCurrentStepIndex(firstVisibleStep as number);
      setSlideDirection(SlideDirection.Left);
    } else {
      next();
    }
  };

  const removeTrailingVisitedSections = (sectionTitle?: string | null) => {
    if (!sectionTitle) {
      return;
    }

    const newVisited = [...visitedSections];
    newVisited.splice(
      visitedSections.indexOf(sectionTitle) + 1,
      visitedSections.length
    );
    setVisitedSections(newVisited);
  };

  function previous() {
    if (showConfirmationView) {
      setSlideDirection(SlideDirection.Right);
      setShowConfirmationView(false);
      removeTrailingVisitedSections(sections[currentSectionIndex].sectionTitle);
      return;
    }

    let prevSectionIndex = currentSectionIndex;
    let prevStepIndex = currentStepIndex - 1;

    while (prevSectionIndex >= 0) {
      const section = sections[prevSectionIndex];
      const steps = section.steps;

      if (section?.isVisible) {
        while (prevStepIndex >= 0) {
          const step = steps[prevStepIndex];

          if (step.isVisible) {
            setSlideDirection(SlideDirection.Right);
            setCurrentSectionIndex(prevSectionIndex);
            setCurrentStepIndex(prevStepIndex);
            resetRemainingSectionVisibility(prevSectionIndex, prevStepIndex);
            removeTrailingVisitedSections(section.sectionTitle);
            return;
          }

          prevStepIndex--;
        }
      }

      prevSectionIndex--;
      prevStepIndex = sections[prevSectionIndex].steps.length - 1 ?? -1;
    }
  }

  const shouldAllowNavBack = () => {
    const previousStep = currentStepIndex - 1;

    for (let i = previousStep; i >= 0; i--) {
      const step = sections[currentSectionIndex].steps[i];
      if (step.isVisible) {
        return true;
      }
    }

    const previousSection = currentSectionIndex - 1;
    for (let i = previousSection; i >= 0; i--) {
      const section = sections[i];
      if (section.isVisible) {
        return true;
      }
    }

    return false;
  };

  const navigateToSection = (sectionTitle?: string | null) => {
    if (sectionTitle === confirmationSectionTitle) {
      setShowConfirmationView(true);
      return;
    }

    const sectionIndex = sections.findIndex(
      (section) => section?.sectionTitle === sectionTitle
    );
    const stepIndex = sections[sectionIndex].steps.findIndex(
      (step) => step.isVisible
    );

    if (sectionTitle && sectionIndex >= 0) {
      setCurrentSectionIndex(sectionIndex);
      setCurrentStepIndex(stepIndex);
      removeTrailingVisitedSections(sectionTitle);
    }
    setShowConfirmationView(false);
  };

  return {
    ...navigationContext,
    next,
    previous,
    navigateToSection,
    setInitialStep,
    shouldAllowNavBack,
    hasNextVisible,
  };
};

export default useFormNavigation;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/hooks/use-form-modal.ts

import { useContext } from 'react';

import { FormModalContext } from '@form/contexts/form-modal-context';

export function useFormModal() {
  const context = useContext(FormModalContext);
  if (!context) {
    console.warn(
      'useFormModal must be used within the FormModalContextProvider'
    );
  }
  return context;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/hooks/use-time-from-now.ts

import dayjs from 'dayjs';
import realtiveTime from 'dayjs/plugin/relativeTime';
import React from 'react';

dayjs.extend(realtiveTime);

export function useTimeFromNow(startInterval = false) {
  const [shouldTrack, setShouldTrack] = React.useState(startInterval);
  const [lastTime, setLastTime] = React.useState<dayjs.Dayjs>(dayjs());
  const [fromNow, setFromNow] = React.useState('');

  const getFromNow = React.useCallback(() => {
    return dayjs(lastTime).fromNow();
  }, [lastTime]);

  React.useEffect(() => {
    if (shouldTrack) {
      setFromNow(getFromNow());
      const interval = setInterval(() => {
        setFromNow(getFromNow());
      }, 60000);
      return () => clearInterval(interval);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [lastTime]);

  const updateLastTime = () => {
    setShouldTrack(true);
    setLastTime(dayjs());
  };

  return {
    fromNow,
    updateLastTime,
  };
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/(demo)/form/layout.tsx

export const metadata = {
  title: 'Form Engine Playground',
  description: 'A playground for the form engine',
};

export default function FormDemoLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <div className="w-full h-screen bg-gray-100">{children}</div>;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/(demo)/form/loading.tsx

export default function LoadingPage() {
  return (
    <div className="m-auto w-full max-w-[400px] mt-12">
      <h1 className="text-3xl font-financier font-semibold text-slate-blue mb-6">
        Form Demos
      </h1>
      <div className="flex flex-col gap-4 animate-pulse">
        <div className="bg-gray-200 w-full max-w-[400px] rounded h-[58px]" />
        <div className="bg-gray-200 w-full max-w-[400px] rounded h-[58px]" />
        <div className="bg-gray-200 w-full max-w-[400px] rounded h-[58px]" />
        <div className="bg-gray-200 w-full max-w-[400px] rounded h-[58px]" />
      </div>
    </div>
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/(demo)/form/page.tsx

import Link from 'next/link';
import React from 'react';

import { getBaseUrl } from '@/utils/getBaseUrl';

export const metadata = {
  title: 'Form Engine Playground',
  description: 'A playground for the form engine',
};

export const dynamic = 'force-dynamic';

const StyledLink = ({
  href,
  children,
}: {
  href: string;
  children: React.ReactNode;
}) => (
  <Link
    className="flex items-center justify-center bg-white text-oxford-blue border border-slate-blue font-medium rounded p-4 w-full shadow-md hover:bg-slate-blue hover:text-white transition-all duration-200 ease-in-out"
    href={href}
  >
    {children}
  </Link>
);

const getAllForms = async () => {
  try {
    const result = await fetch(`${getBaseUrl()}/api/forms/`, {
      cache: 'no-store',
    });
    const data = await result.json();
    return data ?? [];
  } catch (error) {
    console.log(error);
    return [];
  }
};

export default async function FormDemoPage() {
  const forms = await getAllForms();

  return (
    forms &&
    forms.length > 0 && (
      <div className="m-auto w-full max-w-[400px] mt-12">
        <h1 className="text-3xl font-financier font-semibold text-slate-blue mb-6">
          Form Demos
        </h1>
        <div className="flex flex-col gap-4">
          {forms.map((form: any) => (
            <StyledLink key={form.id} href={`/form/${form.id}`}>
              {form.title}
            </StyledLink>
          ))}
        </div>
      </div>
    )
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/(demo)/form/[id]/loading.tsx

import Loading from '@form/components/loading';

export default function LoadingPage() {
  return <Loading />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/(demo)/form/[id]/page.tsx

import Form from '@form/components/form';

export const metadata = {
  title: 'Form Engine Playground',
  description: 'A playground for the form engine',
};

export const dynamic = 'force-dynamic';

const mockDataContext = {
  user: {
    sex: 'Female',
  },
  medical: {
    primaryProvider: 'Dr. John Doe',
    activeMedications: ['Ibuprofen', 'Tylenol'],
    medicationAllergies: ['Penicillin'],
    medicalConditions: ['Asthma'],
    skinProfile: 'Very Fair / Light',
    skinType: 'Normal',
  },
  employerName: 'Carrot',
};

export default async function FormDemoPage({
  params,
}: {
  params: { id: string };
}) {
  return <Form id={params.id} locale="en" context={mockDataContext} />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/(demo)/components/components.tsx

'use client';

import dayjs from 'dayjs';
import React from 'react';

import ButtonBase from '@/app/shared/components/buttons/button-base';
import ButtonOutline from '@/app/shared/components/buttons/button-outline';
import ButtonSolid from '@/app/shared/components/buttons/button-solid';
import Combobox from '@/app/shared/components/form-controls/combobox';
import DatePicker from '@/app/shared/components/form-controls/datepicker/datepicker';
import Select from '@/app/shared/components/form-controls/select';
import MarkdownElement from '@/app/shared/components/markdown-element';

const Components = () => {
  const [selectedDate, setSelectedDate] = React.useState(dayjs().toString());
  const [selectValue, setSelectValue] = React.useState('Cats');
  const [comboValue, setComboValue] = React.useState('');

  return (
    <div className="flex flex-col gap-6 h-[2000px]">
      <div>
        <strong>Base Buttons</strong>
      </div>
      <div className="flex items-end justify-start gap-6">
        <ButtonBase onClick={() => {}} size="sm">
          SM Base
        </ButtonBase>
        <ButtonBase onClick={() => {}}>MD Base</ButtonBase>
        <ButtonBase onClick={() => {}} size="lg">
          LG Base
        </ButtonBase>
      </div>
      <div className="flex justify-between">
        <ButtonBase onClick={() => {}} variant="primary">
          Primary Base
        </ButtonBase>
        <ButtonBase onClick={() => {}} variant="accent">
          Accent Base
        </ButtonBase>
        <ButtonBase onClick={() => {}} variant="gray">
          Gray Base
        </ButtonBase>
        <ButtonBase onClick={() => {}} variant="error">
          Error Base
        </ButtonBase>
      </div>
      <div className="flex justify-between">
        <ButtonBase onClick={() => {}} variant="primary" disabled>
          Primary Base
        </ButtonBase>
        <ButtonBase onClick={() => {}} variant="accent" disabled>
          Accent Base
        </ButtonBase>
        <ButtonBase onClick={() => {}} variant="gray" disabled>
          Gray Base
        </ButtonBase>
        <ButtonBase onClick={() => {}} variant="error" disabled>
          Error Base
        </ButtonBase>
      </div>
      <div>
        <strong>Solid Buttons</strong>
      </div>
      <div className="flex items-end justify-start gap-6">
        <ButtonSolid onClick={() => {}} size="sm">
          SM Solid
        </ButtonSolid>
        <ButtonSolid onClick={() => {}}>MD Solid</ButtonSolid>
        <ButtonSolid onClick={() => {}} size="lg">
          LG Solid
        </ButtonSolid>
      </div>
      <div className="flex justify-between">
        <ButtonSolid onClick={() => {}} variant="primary">
          Primary Solid
        </ButtonSolid>
        <ButtonSolid onClick={() => {}} variant="accent">
          Accent Solid
        </ButtonSolid>
        <ButtonSolid onClick={() => {}} variant="gray">
          Gray Solid
        </ButtonSolid>
        <ButtonSolid onClick={() => {}} variant="error">
          Error Solid
        </ButtonSolid>
      </div>
      <div className="flex justify-between">
        <ButtonSolid onClick={() => {}} variant="primary" disabled>
          Primary Solid
        </ButtonSolid>
        <ButtonSolid onClick={() => {}} variant="accent" disabled>
          Accent Solid
        </ButtonSolid>
        <ButtonSolid onClick={() => {}} variant="gray" disabled>
          Gray Solid
        </ButtonSolid>
        <ButtonSolid onClick={() => {}} variant="error" disabled>
          Error Solid
        </ButtonSolid>
      </div>
      <div>
        <strong>Outline Buttons</strong>
      </div>
      <div className="flex items-end justify-start gap-6">
        <ButtonOutline onClick={() => {}} size="sm">
          SM Outline
        </ButtonOutline>
        <ButtonOutline onClick={() => {}}>MD Outline</ButtonOutline>
        <ButtonOutline onClick={() => {}} size="lg">
          LG Outline
        </ButtonOutline>
      </div>
      <div className="flex justify-between">
        <ButtonOutline onClick={() => {}} variant="primary">
          Primary Outline
        </ButtonOutline>
        <ButtonOutline onClick={() => {}} variant="accent">
          Accent Outline
        </ButtonOutline>
        <ButtonOutline onClick={() => {}} variant="gray">
          Gray Outline
        </ButtonOutline>
        <ButtonOutline onClick={() => {}} variant="error">
          Error Outline
        </ButtonOutline>
      </div>
      <div className="flex justify-between">
        <ButtonOutline onClick={() => {}} variant="primary" disabled>
          Primary Outline
        </ButtonOutline>
        <ButtonOutline onClick={() => {}} variant="accent" disabled>
          Accent Outline
        </ButtonOutline>
        <ButtonOutline onClick={() => {}} variant="gray" disabled>
          Gray Outline
        </ButtonOutline>
        <ButtonOutline onClick={() => {}} variant="error" disabled>
          Error Outline
        </ButtonOutline>
      </div>
      <div>
        <strong>Datepicker</strong>
      </div>
      <DatePicker
        minDate={dayjs('08/25/2023')}
        value={selectedDate}
        onChange={(date) => setSelectedDate(date)}
      />
      <div>
        <strong>Select</strong>
      </div>
      <div className="max-w-[480px]">
        <Select
          options={['Dogs', 'Cats', 'Fish']}
          value={selectValue}
          onChange={(value) => {
            setSelectValue(value);
          }}
        />
      </div>
      <div>
        <strong>Combobox (autocomplete)</strong>
      </div>
      <div className="max-w-[480px]">
        <Combobox
          options={['Dogs', 'Cats', 'Fish']}
          value={comboValue}
          onChange={(value) => {
            setComboValue(value);
          }}
        />
      </div>

      <div>
        <strong>Markdown</strong>
      </div>
      <MarkdownElement dataContext={{ user: { name: 'John Doe' } }}>
        {'# H1 Be the first to know when we launch.' +
          "\n We're still building. Subscribe for updates and 20% off when we launch. No spam, we promise!" +
          '\n ## H2 We bring honesty and transparency to financial services technology' +
          '\n Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec ullamcorper mattis lorem non.' +
          '\n ### H3 Introduction' +
          '\n Mi tincidunt elit, id quisque ligula ac diam, amet. Vel etiam suspendisse morbi eleifend faucibus eget vestibulum felis. Dictum quis montes, sit sit. Tellus aliquam enim urna, etiam. Mauris posuere vulputate arcu amet, vitae nisi, tellus tincidunt. At feugiat sapien varius id.' +
          '\n&nbsp;\n Eget quis mi enim, leo lacinia pharetra, semper. Eget in volutpat mollis at volutpat lectus velit, sed auctor. Porttitor fames arcu quis fusce augue enim. Quis at habitant diam at. Suscipit tristique risus, at donec. In turpis vel et quam imperdiet. Ipsum molestie aliquet sodales id est ac volutpat.' +
          '\n&nbsp;\n Using data context and a link: Hello {{ user.name }}. [Markdown Guide](https://www.markdownguide.org/cheat-sheet/)'}
      </MarkdownElement>
    </div>
  );
};
export default Components;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/(features)/(form)/(demo)/components/page.tsx

import React from 'react';

import Components from './components';

export default async function ComponentPage() {
  return (
    <div className="m-12">
      <Components />
    </div>
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/blog/loading.tsx

import LoadingCircles from '@/app/shared/components/loading-indicators/loading-circles';

export default function Loading() {
  return <LoadingCircles />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/blog/page.tsx

import { notFound } from 'next/navigation';
import { BloghomeDocument } from 'prismicio-types';
import React from 'react';

import BlogHeader from '@/app/shared/components/blog/blog-header';
import FeaturedListSkeleton from '@/app/shared/components/blog/loading/featured-list-skeleton';
import HeaderSkeleton from '@/app/shared/components/blog/loading/header-skeleton';
import PostListSkeleton from '@/app/shared/components/blog/loading/post-list-skeleton';
import NavigationWrapper from '@/app/shared/components/navigation-wrapper';
import { createClient } from '@/prismicio';
import { components } from '@/slices';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { SliceZone } from '@prismicio/react';
import { PrismicPageType } from '@utils/prismic/enums';

export const dynamic = 'force-dynamic';

const BlogHome = async () => {
  const page = await queryPage();
  return (
    <NavigationWrapper
      shouldShow={page.data.show_navigation_header}
      initialNavigationLinkedItem={page.data.initial_header_theme}
      scrollNavigationLinkedItem={page.data.scroll_header_theme}
    >
      <div className="blog-home">
        <BlogHeader page={page} />
        <SliceZone
          slices={page.data.slices}
          components={components}
          context={{}}
        />
      </div>
    </NavigationWrapper>
  );
};

export default async function Page() {
  return (
    <React.Suspense
      fallback={
        <div className="w-full">
          <HeaderSkeleton />
          <FeaturedListSkeleton />
          <PostListSkeleton />
        </div>
      }
    >
      <BlogHome />
    </React.Suspense>
  );
}

export async function generateMetadata() {
  const page = await queryPage();
  return prismicPageToMetadata(page, '/blog');
}

const queryPage = async () => {
  const client = createClient();
  return await client
    .getSingle<BloghomeDocument>(PrismicPageType.BLOG_HOME, {
      fetchLinks: [
        'blogcategory.category_name',
        'blogpost.title',
        'blogpost.thumbnail',
        'blogpost.publication_date',
        'blogpost.short_description',
        'blog_ad_card.link',
        'blog_ad_card.image',
        'blog_newsletter.background_color_start',
        'blog_newsletter.background_color_end',
        'blog_newsletter.title',
        'blog_newsletter.title_color',
        'blog_newsletter.text',
        'blog_newsletter.text_color',
        'blog_newsletter.label',
        'blog_newsletter.label_color',
        'blog_newsletter.placeholder',
        'blog_newsletter.subscribe_button_text',
        'blog_newsletter.subscribe_button_text_color',
        'blog_newsletter.subscribe_button_color',
      ],
    })
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/blog/tags/layout.tsx

import { notFound } from 'next/navigation';
import { BlogTagDocument } from 'prismicio-types';
import React from 'react';

import BlogHeader from '@/app/shared/components/blog/blog-header';
import HeaderSkeleton from '@/app/shared/components/blog/loading/header-skeleton';
import PostListSkeleton from '@/app/shared/components/blog/loading/post-list-skeleton';
import NavigationWrapper from '@/app/shared/components/navigation-wrapper';
import { createClient } from '@/prismicio';
import { PrismicPageType } from '@/utils/prismic/enums';

const BlogTagsLayoutComponent = async ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const page = await queryPage();

  return (
    <NavigationWrapper
      shouldShow={page.data.show_navigation_header}
      initialNavigationLinkedItem={page.data.initial_header_theme}
      scrollNavigationLinkedItem={page.data.scroll_header_theme}
    >
      <div className="blog-tag">
        <BlogHeader page={page} />
        {children}
      </div>
    </NavigationWrapper>
  );
};

const BlogTagsLayout = async ({ children }: { children: React.ReactNode }) => {
  return (
    <React.Suspense
      fallback={
        <div className="w-full">
          <HeaderSkeleton />
          <PostListSkeleton />
        </div>
      }
    >
      <BlogTagsLayoutComponent>{children}</BlogTagsLayoutComponent>
    </React.Suspense>
  );
};

const queryPage = async () => {
  const client = createClient();

  const page = await client
    .getSingle<BlogTagDocument>(PrismicPageType.BLOG_TAG)
    .catch(() => notFound());

  return page;
};

export default BlogTagsLayout;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/blog/tags/loading.tsx

import PostListSkeleton from '@/app/shared/components/blog/loading/post-list-skeleton';

export default function Loading() {
  return (
    <div className="w-full">
      <PostListSkeleton />
    </div>
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/blog/tags/page.tsx

import { notFound } from 'next/navigation';
import { BlogTagDocument, BlogpostDocument } from 'prismicio-types';
import React from 'react';

import PostListSkeleton from '@/app/shared/components/blog/loading/post-list-skeleton';
import NoPosts from '@/app/shared/components/blog/no-posts';
import PostCard from '@/app/shared/components/blog/post-card/post-card';
import { BlogPostRelatedData } from '@/app/shared/components/blog/types';
import { createClient } from '@/prismicio';
import { PrismicPageType } from '@/utils/prismic/enums';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { filter } from '@prismicio/client';

export const dynamic = 'force-dynamic';

const PostsList = async ({
  page,
  tag,
}: {
  page: BlogTagDocument;
  tag: string;
}) => {
  const posts = await queryByTag(tag);
  const hasPosts = posts.length > 0;

  return (
    <div className="mt-6 mx-auto p-6 max-w-2xl lg:max-w-7xl">
      {hasPosts ? (
        <h1 className="flex items-center gap-4 flex-wrap mb-6 font-dmsans text-2xl leading-6 text-[#585858] font-semibold">
          {page.data.page_title}
          <span className="relative py-1.5 px-4 font-dmsans bg-[#efd9cd] text-sm text-[#9b6222] rounded-full text-center whitespace-nowrap">
            {tag}
          </span>
        </h1>
      ) : (
        <NoPosts
          title={page.data.no_posts_title}
          description={page.data.no_posts_description}
          link={page.data.no_posts_link}
          linkText={page.data.no_posts_link_text}
        />
      )}
      <div className="mb-10 grid grid-cols-1 gap-x-4 gap-y-6 lg:grid-cols-3">
        {posts.map((post) => (
          <PostCard key={post.id} post={post as any} />
        ))}
      </div>
    </div>
  );
};

export default async function Page({
  searchParams,
}: {
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  const page = await queryPage();

  const tag =
    searchParams?.tag && typeof searchParams.tag === 'string'
      ? searchParams.tag
      : '';

  return (
    <React.Suspense fallback={<PostListSkeleton />}>
      <PostsList page={page} tag={decodeURIComponent(tag)} />
    </React.Suspense>
  );
}

export async function generateMetadata() {
  const page = await queryPage();
  return prismicPageToMetadata(page, `/blog/tags`);
}

const queryPage = async () => {
  const client = createClient();

  const page = await client
    .getSingle<BlogTagDocument>(PrismicPageType.BLOG_TAG)
    .catch(() => notFound());

  return page;
};

const queryByTag = async (tag: string) => {
  const client = createClient();

  const posts = await client
    .getAllByTag<BlogpostDocument>(tag, {
      filters: [filter.at('document.type', PrismicPageType.BLOG_POST)],
      orderings: [{ field: 'my.blogpost.publication_date', direction: 'desc' }],
      fetch: [
        'blogpost.title',
        'blogpost.thumbnail',
        'blogpost.short_description',
        'blogpost.publication_date',
      ],
    })
    .catch(() => []);

  return posts as BlogPostRelatedData[];
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/blog/search/loading.tsx

import HeaderSkeleton from '@/app/shared/components/blog/loading/header-skeleton';
import SearchListSkeleton from '@/app/shared/components/blog/loading/search-list-skeleton';

export default function Loading() {
  return (
    <div className="w-full">
      <HeaderSkeleton />
      <SearchListSkeleton />
    </div>
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/blog/search/page.tsx

import { notFound } from 'next/navigation';
import { BlogSearchDocument } from 'prismicio-types';
import React from 'react';

import BlogHeader from '@/app/shared/components/blog/blog-header';
import BlogSearch from '@/app/shared/components/blog/blog-search';
import BlogSearchList from '@/app/shared/components/blog/blog-search-list';
import SearchListSkeleton from '@/app/shared/components/blog/loading/search-list-skeleton';
import NavigationWrapper from '@/app/shared/components/navigation-wrapper';
import { createClient } from '@/prismicio';
import { PrismicPageType } from '@/utils/prismic/enums';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';

export const dynamic = 'force-dynamic';

export default async function Page({
  searchParams,
}: {
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  const page = await queryPage();

  const searchQuery =
    searchParams.q && typeof searchParams.q === 'string'
      ? searchParams.q
      : undefined;

  return (
    <NavigationWrapper
      shouldShow={page.data.show_navigation_header}
      initialNavigationLinkedItem={page.data.initial_header_theme}
      scrollNavigationLinkedItem={page.data.scroll_header_theme}
    >
      <div className="blog-search">
        <BlogHeader page={page} initialQuery={searchQuery} />
        <div className="p-6 mx-auto max-w-7xl">
          <h1 className="font-dmsans text-[40px] leading-[44px] text-[#253a61] my-5">
            {page.data.header}
          </h1>
          <div className="flex w-full mb-10">
            <BlogSearch
              placeholder={page.data?.search_placeholder ?? ''}
              initialQuery={searchQuery}
            />
          </div>
          <React.Suspense key={searchQuery} fallback={<SearchListSkeleton />}>
            <BlogSearchList page={page} query={searchQuery} />
          </React.Suspense>
        </div>
      </div>
    </NavigationWrapper>
  );
}

export async function generateMetadata() {
  const page = await queryPage();
  return prismicPageToMetadata(page, '/blog/search');
}

const queryPage = async () => {
  const client = createClient();
  return await client
    .getSingle<BlogSearchDocument>(PrismicPageType.BLOG_SEARCH)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/blog/[uid]/loading.tsx

import ArticleHeaderSkeleton from '@/app/shared/components/blog/loading/article-header-skeleton';
import ArticleSkeleton from '@/app/shared/components/blog/loading/article-skeleton';

export default function Loading() {
  return (
    <>
      <ArticleHeaderSkeleton />
      <ArticleSkeleton />
    </>
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/blog/[uid]/page.tsx

import Link from 'next/link';
import { notFound } from 'next/navigation';
import { BlogAuthorDocument, BlogpostDocument } from 'prismicio-types';

import NavigationWrapper from '@/app/shared/components/navigation-wrapper';
import { createClient } from '@/prismicio';
import { components } from '@/slices';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { isFilled } from '@prismicio/client';
import { SliceZone } from '@prismicio/react';
import { PrismicPageType } from '@utils/prismic/enums';

export const dynamic = 'force-dynamic';

export type BlogArticleContext = {
  page: BlogpostDocument;
  blogAuthor?: Pick<BlogAuthorDocument['data'], 'name' | 'avatar'> | null;
};

type Params = { uid: string };
export default async function Page({ params }: { params: Params }) {
  const page = await queryPage(params.uid);

  const author = isFilled.contentRelationship<
    'author',
    string,
    Pick<BlogAuthorDocument['data'], 'name' | 'avatar'>
  >(page.data.author)
    ? page.data.author.data
    : null;

  return (
    <NavigationWrapper
      shouldShow={page.data.show_navigation_header}
      initialNavigationLinkedItem={page.data.initial_header_theme}
      scrollNavigationLinkedItem={page.data.scroll_header_theme}
    >
      <div className="blog-post-page mx-auto max-w-7xl pt-40 px-6">
        <h1 className="font-dmsans text-[#9b6222] text-[64px] leading-[1.2] mb-6 tracking-[-0.04em] font-light text-center">
          {page.data.title}
        </h1>
        <ul className="flex flex-row gap-2 justify-center items-center flex-wrap">
          {page.tags.map((tag) => (
            <li
              key={tag}
              className="relative py-1.5 px-4 font-dmsans bg-[#efd9cd] text-sm text-[#9b6222] rounded-full text-center whitespace-nowrap"
            >
              <Link href={`/blog/tags?tag=${encodeURIComponent(tag)}`}>
                <span className="absolute inset-0" />
                {tag}
              </Link>
            </li>
          ))}
        </ul>
        <div className="bg-gray-200 w-full mt-8 mb-6 h-px" />

        <SliceZone<BlogArticleContext>
          slices={page.data.slices}
          components={components}
          context={{ blogAuthor: author, page }}
        />
      </div>
    </NavigationWrapper>
  );
}

export async function generateMetadata({ params }: { params: Params }) {
  const page = await queryPage(params.uid);
  return prismicPageToMetadata(page, `/blog/${params.uid}`);
}

const queryPage = async (uid: string) => {
  const client = createClient();
  return await client
    .getByUID<BlogpostDocument>(PrismicPageType.BLOG_POST, uid, {
      fetchLinks: [
        'blog_author.name',
        'blog_author.avatar',
        'blogcategory.category_name',
      ],
    })
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/help/layout.tsx

import Footer from './components/footer';
import Header from './components/header/header';

const HelpLayout = async ({ children }: { children: React.ReactNode }) => {
  return (
    <>
      <Header />
      {children}
      <Footer />
    </>
  );
};

export default HelpLayout;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/help/page.tsx

import { notFound } from 'next/navigation';
import { HelpCollectionDocument, HelpHomeDocument } from 'prismicio-types';

import { createClient } from '@/prismicio';
import { PrismicPageType } from '@/utils/prismic/enums';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';

export default async function Page() {
  const client = createClient();

  // Get all of the help collections
  const collections = await client.getAllByType('help_collection', {
    orderings: [{ field: 'my.help_collection.order', direction: 'asc' }],
  });

  const articles = await client.getAllByType('help_article', {
    fetch: ['help_article.collection_tag'],
  });

  const groupedArticles = articles.reduce((acc, article) => {
    const tag = article.data.collection_tag;
    if (!tag) return acc;

    if (!acc[tag]) {
      acc[tag] = [];
    }
    acc[tag].push(article);
    return acc;
  }, {} as Record<string, any[]>);

  return (
    <section className="py-10 px-6 w-full">
      <div className="mx-auto max-w-4xl grid grid-cols-1 gap-8">
        {collections.map((collection) => (
          <CollectionCard
            key={collection.id}
            collection={collection}
            groupedArticles={groupedArticles}
          />
        ))}
      </div>
    </section>
  );
}

const CollectionCard = ({
  collection,
  groupedArticles,
}: {
  collection: HelpCollectionDocument;
  groupedArticles: Record<string, HelpCollectionDocument[]>;
}) => {
  const collectionTag = collection.data.collection_tag;
  const collectionHasArticles =
    collectionTag && collectionTag in groupedArticles;
  const articleCount = collectionHasArticles
    ? groupedArticles[collectionTag].length
    : 0;

  return (
    <div
      key={collection.id}
      className="relative border border-gray-200 rounded-lg py-5 px-8 shadow-sm hover:border-gray-600 transition duration-200 ease-in-out"
    >
      <div className="flex min-w-0 gap-x-8 items-center">
        <PrismicNextImage
          className="h-10 w-10 flex-none"
          field={collection.data.image}
          alt=""
        />
        <div className="font-dmsans min-w-0 flex-auto">
          <div className="text-base font-bold text-gray-900">
            <PrismicNextLink document={collection}>
              {collection.data.title}
              <span className="absolute inset-x-0 -top-px bottom-0" />
            </PrismicNextLink>
          </div>
          <p className="flex text-base text-gray-900">
            {collection.data.description}
          </p>
          {articleCount > 0 && (
            <p className="mt-2 flex text-sm text-gray-500">{`${articleCount} article${
              articleCount > 1 ? 's' : ''
            }`}</p>
          )}
        </div>
      </div>
    </div>
  );
};

export async function generateMetadata() {
  const page = await queryPage();
  return prismicPageToMetadata(page, '/help');
}

const queryPage = async () => {
  const client = createClient();

  return await client
    .getSingle<HelpHomeDocument>(PrismicPageType.HELP_HOME)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/help/articles/[uid]/page.tsx

import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import { notFound } from 'next/navigation';
import { HelpArticleDocument } from 'prismicio-types';

import { createClient } from '@/prismicio';
import { components } from '@/slices';
import { PrismicPageType } from '@/utils/prismic/enums';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { ClockIcon } from '@heroicons/react/24/outline';
import { SliceZone } from '@prismicio/react';

import Breadcrumbs from '../../components/breadcrumbs/breadcrumbs';

dayjs.extend(relativeTime);

type Params = { uid: string };

export default async function Page({ params }: { params: Params }) {
  const article = await queryPage(params.uid);

  const publishedText = `Updated ${dayjs(
    article.data.publication_date
  ).fromNow()}`;

  return (
    <section className="py-10 px-6 w-full">
      <div className="mx-auto max-w-4xl">
        <Breadcrumbs breadcrumbs={article.data.breadcrumbs} />
        <h1 className="mt-10 font-dmsans text-gray-900 text-[32px] font-bold">
          {article.data.title}
        </h1>
        <p className="font-dmsans text-base text-gray-600">
          {article.data.description}
        </p>
        <p className="mt-2 flex flex-row items-center gap-x-1.5 font-dmsans text-sm text-gray-500">
          <ClockIcon className="h-5 w-5" />
          {publishedText}
        </p>

        <div className="mt-8">
          <SliceZone slices={article.data.slices} components={components} />
        </div>
      </div>
    </section>
  );
}

export async function generateMetadata({ params }: { params: Params }) {
  const page = await queryPage(params.uid);
  return prismicPageToMetadata(page, `/help/articles/${params.uid}`);
}

const queryPage = async (uid: string) => {
  const client = createClient();

  return await client
    .getByUID<HelpArticleDocument>(PrismicPageType.HELP_ARTICLE, uid)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/help/components/footer.tsx

import { HelpFooterDocument } from 'prismicio-types';

import { createClient } from '@/prismicio';
import { PrismicCustomType } from '@/utils/prismic/enums';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';

const Footer = async () => {
  const footer = await queryFooter();

  return (
    footer && (
      <footer className="bg-white">
        <div className="mx-auto max-w-4xl overflow-hidden px-6 py-20 sm:py-24 lg:px-8">
          <nav className="flex flex-col items-center gap-8" aria-label="Footer">
            <PrismicNextLink
              field={footer.data.logo_link}
              className="-m-1.5 p-1.5"
            >
              <span className="sr-only">Cortina</span>
              <PrismicNextImage
                className="h-8 w-auto"
                field={footer.data.logo}
              />
            </PrismicNextLink>
            <div className="-mb-6 columns-2 text-center sm:flex sm:justify-center sm:space-x-12">
              {footer.data.links.map((item) => (
                <div key={item.link_text} className="pb-6">
                  <PrismicNextLink
                    field={item.link}
                    className="text-sm leading-6 text-gray-400 hover:text-gray-900"
                  >
                    {item.link_text}
                  </PrismicNextLink>
                </div>
              ))}
            </div>
          </nav>
          <div className="mt-6 flex justify-center space-x-10">
            {footer.data.socials.map((item, i) => (
              <PrismicNextLink
                key={`social-link-${i}`}
                field={item.social_link}
                className="text-gray-400 hover:text-gray-500"
              >
                <span className="sr-only">{item.social_icon.alt}</span>
                <PrismicNextImage
                  field={item.social_icon}
                  className="h-6 w-6"
                  aria-hidden="true"
                />
              </PrismicNextLink>
            ))}
          </div>
        </div>
      </footer>
    )
  );
};

const queryFooter = async () => {
  const client = createClient();

  return await client
    .getByUID<HelpFooterDocument>(PrismicCustomType.HELP_FOOTER, 'help-footer')
    .catch(() => undefined);
};

export default Footer;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/help/components/breadcrumbs/breadcrumbs.tsx

import React from 'react';

import { ChevronRightIcon } from '@heroicons/react/20/solid';
import { KeyTextField, LinkField } from '@prismicio/client';
import { PrismicNextLink } from '@prismicio/next';

interface IBreadcrumbsProps {
  breadcrumbs?: {
    link: LinkField;
    text: KeyTextField;
  }[];
}

const Breadcrumbs: React.FC<IBreadcrumbsProps> = ({ breadcrumbs }) => {
  return (
    <nav className="flex mb-4" aria-label="Breadcrumb">
      <ol role="list" className="flex items-center space-x-2 flex-wrap gap-y-6">
        {breadcrumbs &&
          breadcrumbs.map((breadcrumb, i) => (
            <li key={breadcrumb.text}>
              <div className="flex items-center">
                {i > 0 && (
                  <ChevronRightIcon
                    className="mr-2 h-5 w-5 flex-shrink-0 text-gray-400"
                    aria-hidden="true"
                  />
                )}
                <PrismicNextLink
                  field={breadcrumb.link}
                  className="text-sm font-medium text-gray-500 hover:text-gray-700"
                >
                  {breadcrumb.text}
                </PrismicNextLink>
              </div>
            </li>
          ))}
      </ol>
    </nav>
  );
};

export default Breadcrumbs;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/help/components/header/header-nav.tsx

'use client';

import { HelpHeaderDocument } from 'prismicio-types';
import { useState } from 'react';

import { Dialog } from '@headlessui/react';
import { Bars3Icon, XMarkIcon } from '@heroicons/react/24/outline';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';

interface IHeaderNavProps {
  content: HelpHeaderDocument;
}

const HeaderNav: React.FC<IHeaderNavProps> = (p) => {
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

  return (
    <header>
      <nav
        className="mx-auto flex items-center justify-between pb-8"
        aria-label="Global"
      >
        <PrismicNextLink
          field={p.content.data.logo_link}
          className="-m-1.5 p-1.5"
        >
          <span className="sr-only">Cortina</span>
          <PrismicNextImage
            className="h-8 w-auto"
            field={p.content.data.logo}
          />
        </PrismicNextLink>
        <div className="flex md:hidden">
          <button
            type="button"
            className="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-white"
            onClick={() => setMobileMenuOpen(true)}
          >
            <span className="sr-only">Open main menu</span>
            <Bars3Icon className="h-6 w-6" aria-hidden="true" />
          </button>
        </div>
        <div className="hidden md:flex lg:gap-x-12">
          <PrismicNextLink
            field={p.content.data.app_link}
            className="text-sm font-semibold leading-6 text-white"
          >
            {p.content.data.app_link_text}
          </PrismicNextLink>
        </div>
      </nav>
      <Dialog
        as="div"
        className="md:hidden"
        open={mobileMenuOpen}
        onClose={setMobileMenuOpen}
      >
        <div className="fixed inset-0 z-10" />
        <Dialog.Panel className="fixed inset-y-0 right-0 z-10 w-full overflow-y-auto bg-white px-6 py-6 sm:max-w-sm sm:ring-1 sm:ring-gray-900/10">
          <div className="flex items-center justify-between">
            <PrismicNextLink
              field={p.content.data.logo_link}
              className="-m-1.5 p-1.5"
            >
              <span className="sr-only">Cortina</span>
              <PrismicNextImage
                className="h-8 w-auto"
                field={p.content.data.logo}
              />
            </PrismicNextLink>
            <button
              type="button"
              className="-m-2.5 rounded-md p-2.5 text-gray-900"
              onClick={() => setMobileMenuOpen(false)}
            >
              <span className="sr-only">Close menu</span>
              <XMarkIcon className="h-6 w-6" aria-hidden="true" />
            </button>
          </div>
          <div className="mt-6 flow-root">
            <div className="-my-6 divide-y divide-gray-500/10">
              <div className="space-y-2 py-6">
                <PrismicNextLink
                  field={p.content.data.app_link}
                  className="-mx-3 block rounded-lg px-3 py-2 text-base font-semibold leading-7 text-gray-900 hover:bg-gray-50"
                >
                  {p.content.data.app_link_text}
                </PrismicNextLink>
              </div>
            </div>
          </div>
        </Dialog.Panel>
      </Dialog>
    </header>
  );
};

export default HeaderNav;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/help/components/header/help-search.tsx

'use client';

import debounce from 'lodash.debounce';
import { HelpArticleDocument } from 'prismicio-types';
import React from 'react';
import { useState } from 'react';
import { twMerge } from 'tailwind-merge';

import ButtonBase from '@/app/shared/components/buttons/button-base';
import { createClient } from '@/prismicio';
import { PrismicPageType } from '@/utils/prismic/enums';
import { Combobox as HeadlessCombobox } from '@headlessui/react';
import { XMarkIcon } from '@heroicons/react/20/solid';
import { filter } from '@prismicio/client';
import { PrismicNextLink } from '@prismicio/next';
import { SearchLg } from '@untitled-ui/icons-react';

const getSearchResults = async (query: string) => {
  const client = createClient();
  try {
    return await client.getAllByType<HelpArticleDocument>(
      PrismicPageType.HELP_ARTICLE,
      {
        filters: [filter.fulltext(`document`, query)],
        pageSize: 5,
      }
    );
  } catch (error) {
    return [];
  }
};

const HelpSearch: React.FC = () => {
  const [query, setQuery] = useState('');
  const [hasSearched, setHasSearched] = useState(false);
  const [searching, setSearching] = useState(false);
  const [searchResults, setSearchResults] = useState<HelpArticleDocument[]>([]);
  const comboboxButtonRef = React.useRef<HTMLButtonElement>(null);

  const handleSearch = async (searchQuery: string) => {
    setSearching(true);
    try {
      const results = await getSearchResults(searchQuery);
      setSearchResults(results ?? []);
      setHasSearched(true);
    } catch (e) {
      // Do nothing
    } finally {
      setSearching(false);
    }
  };

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const debouncedSearch = React.useCallback(debounce(handleSearch, 500), []);

  const handleQueryChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setQuery(e.target.value);

    if (e.target.value.length > 3) {
      debouncedSearch(e.target.value);
    }
  };

  const handleReset = () => {
    debouncedSearch.cancel();
    setSearching(false);
    setSearchResults([]);
    setHasSearched(false);
    setQuery('');
  };

  return (
    <div className="w-full mt-6">
      <HeadlessCombobox as="div">
        <div className="relative">
          <HeadlessCombobox.Input
            className="peer w-full rounded-md border-0 text-sm bg-[#535A77] py-4 pl-14 pr-10 font-medium text-white focus:bg-white focus:text-gray-500 focus:placeholder:text-gray-500 focus:outline-none sm:text-base sm:leading-6 placeholder:text-white"
            placeholder="Search for articles..."
            value={query}
            onChange={handleQueryChange}
            displayValue={(option: string) => option}
          />
          <HeadlessCombobox.Button
            ref={comboboxButtonRef}
            className="absolute inset-y-0 left-0 flex items-center rounded-md px-4 text-white peer-focus:text-gray-500 peer-focus:placeholder:text-gray-500 peer-focus:bg-white peer-focus:outline-none"
          >
            <SearchLg className="h-5 w-5" viewBox="0 0 24 24" />
          </HeadlessCombobox.Button>
          {query.length > 0 && (
            <ButtonBase
              className="absolute inset-y-0 right-0 flex items-center rounded-r-md px-2 focus:outline-none"
              onClick={handleReset}
            >
              <XMarkIcon className="h-5 w-5 text-gray-400" />
            </ButtonBase>
          )}

          <HeadlessCombobox.Options className="absolute z-10 h-fit top-full mb-0 mt-2 max-h-60 w-full overflow-auto rounded-md bg-white py-4 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm">
            {searching && (
              <div className="py-3 px-6 flex flex-col gap-2">
                {[...Array(2)].map((_e, i) => (
                  <div
                    key={`search-skeleton-${i}`}
                    className="h-12 bg-gray-100 rounded-lg py-2 px-4 w-full animate-pulse"
                  />
                ))}
              </div>
            )}
            {!searching && (
              <>
                {searchResults.length > 0 && (
                  <>
                    {searchResults.map((result, i) => (
                      <HeadlessCombobox.Option
                        key={`option-${i}`}
                        value={result}
                        className="relative cursor-default select-none py-1 px-6 text-gray-700 font-medium"
                      >
                        {({ active }) => (
                          <PrismicNextLink
                            document={result}
                            className={twMerge([
                              'border border-gray-200 font-dmsans text-gray-900 text-sm rounded-lg p-4 flex flex-col w-full',
                              active && 'bg-gray-100',
                            ])}
                            onClick={() => {
                              comboboxButtonRef.current?.click();
                              handleReset();
                            }}
                          >
                            <span className="block font-semibold w-3/4 max-w-prose">
                              {result.data.title}
                            </span>
                          </PrismicNextLink>
                        )}
                      </HeadlessCombobox.Option>
                    ))}
                  </>
                )}
                {searchResults.length === 0 && hasSearched && (
                  <div className="py-1 px-6">
                    <div className="bg-gray-50 font-dmsans text-gray-500 text-sm rounded-lg py-2 px-4 flex justify-between items-center w-full">
                      No results found
                    </div>
                  </div>
                )}
              </>
            )}
          </HeadlessCombobox.Options>
        </div>
      </HeadlessCombobox>
    </div>
  );
};

export default HelpSearch;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/help/components/header/header.tsx

import { HelpHeaderDocument } from 'prismicio-types';

import { createClient } from '@/prismicio';
import { PrismicCustomType } from '@/utils/prismic/enums';

import HeaderNav from './header-nav';
import HelpSearch from './help-search';

const Header = async () => {
  const header = await queryHeader();

  return (
    header && (
      <div className="bg-[#263A61] p-8 w-full">
        <div className="mx-auto max-w-4xl">
          <HeaderNav content={header} />
          <div className="font-dmsans text-white font-bold text-[28px] leading-8">
            {header.data.title}
          </div>
          <HelpSearch />
        </div>
      </div>
    )
  );
};

const queryHeader = async () => {
  const client = createClient();

  return await client
    .getByUID<HelpHeaderDocument>(PrismicCustomType.HELP_HEADER, 'help-header')
    .catch(() => undefined);
};

export default Header;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(non-account)/help/collections/[uid]/page.tsx

import { notFound } from 'next/navigation';
import { HelpArticleDocument, HelpCollectionDocument } from 'prismicio-types';

import { createClient } from '@/prismicio';
import { PrismicPageType } from '@/utils/prismic/enums';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { ChevronRightIcon } from '@heroicons/react/20/solid';
import { filter } from '@prismicio/client';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';

import Breadcrumbs from '../../components/breadcrumbs/breadcrumbs';

type Params = { uid: string };

export default async function Page({ params }: { params: Params }) {
  const client = createClient();

  // Fetch help collections
  const helpCollection = await queryPage(params.uid);

  // Get all of the help articles
  const articles = helpCollection.data.collection_tag
    ? await client.getAllByType<HelpArticleDocument>(
        PrismicPageType.HELP_ARTICLE,
        {
          filters: [
            filter.at(
              `my.help_article.collection_tag`,
              helpCollection.data.collection_tag
            ),
          ],
          orderings: [{ field: 'my.help_article.order', direction: 'asc' }],
        }
      )
    : [];

  const groupedArticles = articles.reduce((acc, article) => {
    const tag = article.data.category;
    if (!tag) return acc;

    if (!acc[tag]) {
      acc[tag] = [];
    }
    acc[tag].push(article);
    return acc;
  }, {} as Record<string, HelpArticleDocument[]>);

  const articleCount = articles.length;

  return (
    <section className="py-10 px-6 w-full">
      <div className="mx-auto max-w-4xl">
        <div>
          <div className="mb-8">
            <Breadcrumbs breadcrumbs={helpCollection.data.breadcrumbs} />
          </div>
          <PrismicNextImage
            field={helpCollection.data.image}
            alt=""
            className="h-10 w-10 flex-none"
          />
          <h1 className="mt-6 font-dmsans text-2xl sm:text-[32px] text-gray-900 font-bold">
            {helpCollection.data.title}
          </h1>
          <p className="mt-1 font-dmsans text-base text-gray-900">
            {helpCollection.data.description}
          </p>
          {articleCount > 0 && (
            <p className="mt-4 flex text-sm text-gray-500">{`${articleCount} article${
              articleCount > 1 ? 's' : ''
            }`}</p>
          )}
        </div>
        <div className="mt-8 grid grid-cols-1 gap-8">
          {Object.keys(groupedArticles).map((category) => {
            const articles = groupedArticles[category];

            return (
              <div
                key={category}
                className="border border-gray-200 shadow-sm rounded-lg p-2"
              >
                <div className="font-dmsans text-[22px] font-bold text-gray-900 border-b border-b-gray-200 mx-3 pt-3 pb-5 mb-2">
                  {category}
                </div>
                {articles.map((article) => (
                  <div
                    key={article.id}
                    className="flex w-full justify-between items-center relative font-dmsans text-gray-900 rounded-lg p-3 hover:bg-gray-100 transition duration-200 ease-in-out"
                  >
                    <PrismicNextLink document={article}>
                      {article.data.title}
                      <span className="absolute inset-x-0 -top-px bottom-0" />
                    </PrismicNextLink>
                    <ChevronRightIcon
                      className="h-5 w-5 flex-none text-gray-900"
                      aria-hidden="true"
                    />
                  </div>
                ))}
              </div>
            );
          })}
        </div>
      </div>
    </section>
  );
}

export async function generateMetadata({ params }: { params: Params }) {
  const page = await queryPage(params.uid);
  return prismicPageToMetadata(page, `/help/collections/${params.uid}`);
}

const queryPage = async (uid: string) => {
  const client = createClient();

  return await client
    .getByUID<HelpCollectionDocument>(PrismicPageType.HELP_COLLECTION, uid)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/layout.tsx

import '@/styles/globals.css';

import DatadogSessionPlayer from '../shared/components/datadog-init/datadog-session-player';

const AccountLayout = ({ children }: { children: React.ReactNode }) => {
  return (
    <>
      <DatadogSessionPlayer />
      {children}
    </>
  );
};

export default AccountLayout;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/error.tsx

'use client';

import React from 'react';

import ErrorView from '@components/error-view';

const Error: React.FC = () => {
  return <ErrorView />;
};

export default Error;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/loading.tsx

import LoadingCircles from '@components/loading-indicators/loading-circles';

export default function Loading() {
  return <LoadingCircles />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/datadog-user.tsx

'use client';

import React from 'react';

import { datadogRum } from '@datadog/browser-rum';
import { User } from '@prisma/client';

const DatadogUser: React.FC<{ user: User }> = ({ user }) => {
  React.useEffect(() => {
    datadogRum.setUser({
      id: user.id,
      name: `${user.firstName} ${user.lastName}`,
      email: `${user.email}`,
    });
  }, [user]);

  return null;
};

export default DatadogUser;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/layout.tsx

import { notFound } from 'next/navigation';
import { AccountNavigationDocument } from 'prismicio-types';

import RedirectIfNotAuthorized from '@/app/(features)/(authentication)/signin/components/redirect-to-authprovider';
import CartSlider from '@/app/shared/components/cart/cart-slider';
import AccountNavigation from '@/app/shared/components/navigation/account-navigation/account-navigation';
import { createClient } from '@/prismicio';
import {
  getUser,
  getUserAvatar,
  registerUserWithPaymentVendor,
} from '@/utils/helpers/helpers';
import { UserEventNames } from '@/utils/user-events/enums';
import UserEventsClient from '@/utils/user-events/user-events-client';
import WindowDOM from '@components/analytics/windowDOM/window-dom';
import { UserRole } from '@prisma/client';
import { PrismicCustomType } from '@utils/prismic/enums';

import DatadogUser from './datadog-user';

export const dynamic = 'force-dynamic';

export default async function AccountLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [user, avatar] = await Promise.all([getUser(), getUserAvatar()]);

  if (!user || !user.roles || !user.roles.includes(UserRole.PATIENT)) {
    return <RedirectIfNotAuthorized />;
  }

  // TODO: This is an anti-pattern that needs remediation
  if (user && user.email && user.stripeId === null) {
    await registerUserWithPaymentVendor();
    await UserEventsClient.addEvent(
      user,
      UserEventNames.DERMI_ACCOUNT_CREATED,
      {}
    );
  }

  const client = createClient();
  const menuData = await client
    .getSingle<AccountNavigationDocument>(PrismicCustomType.ACCOUNT_NAVIGATION)
    .catch(() => notFound());

  return (
    <AccountNavigation {...menuData} user={user} userAvatarS3Url={avatar.s3Url}>
      <WindowDOM user={user} />
      {children}
      <CartSlider />
      <DatadogUser user={user} />
    </AccountNavigation>
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/loading.tsx

import LoadingCircles from '@components/loading-indicators/loading-circles';

export default function Loading() {
  return <LoadingCircles />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/page.tsx

import { notFound } from 'next/navigation';
import { AccounthomeDocument } from 'prismicio-types';

import { AccountHomeContext } from '@/app/shared/types';
import { createClient } from '@/prismicio';
import { components } from '@/slices';
import { getUser, getUserCases } from '@/utils/helpers/helpers';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { SliceZone } from '@prismicio/react';
import { PrismicPageType } from '@utils/prismic/enums';

export default async function Page() {
  const cases = await getUserCases();
  const [user, page] = await Promise.all([getUser(), queryPage()]);

  return (
    <div className="pb-40">
      <SliceZone<AccountHomeContext>
        slices={page.data.slices}
        components={components}
        context={{ user, cases }}
      />
    </div>
  );
}

export async function generateMetadata() {
  const page = await queryPage();
  return prismicPageToMetadata(page, '/account');
}

const queryPage = () => {
  const client = createClient();
  return client
    .getSingle<AccounthomeDocument>(PrismicPageType.ACCOUNT_HOME)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/concierge/error.tsx

'use client';

import React from 'react';

import ErrorView from '@components/error-view';

const Error: React.FC = () => {
  return <ErrorView />;
};

export default Error;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/concierge/loading.tsx

import LoadingCircles from '@components/loading-indicators/loading-circles';

export default function Loading() {
  return <LoadingCircles />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/concierge/page.tsx

import { notFound } from 'next/navigation';
import { ConciergeaccountpageDocument } from 'prismicio-types';

import { createClient } from '@/prismicio';
import { components } from '@/slices';
import { getUser } from '@/utils/helpers/helpers';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { SliceZone } from '@prismicio/react';
import { PrismicPageType } from '@utils/prismic/enums';

type Params = { uid: string };
export default async function Page({
  searchParams,
}: {
  params: Params;
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  const [page, user] = await Promise.all([queryPage(), getUser()]);

  if (user.hasConcierge) {
    return (
      <SliceZone
        slices={page.data.slices2}
        components={components}
        context={{ searchParams, user }}
      />
    );
  }

  return (
    <SliceZone
      slices={page.data.slices}
      components={components}
      context={{ searchParams, user }}
    />
  );
}

export async function generateMetadata() {
  const page = await queryPage();
  return prismicPageToMetadata(page);
}

const queryPage = async () => {
  const client = createClient();

  return await client
    .getSingle<ConciergeaccountpageDocument>(PrismicPageType.CONCIERGE_PAGE)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/loading.tsx

import { SkeletonCard } from '@components/loading-indicators/skeleton-card';

export default function Loading() {
  return <SkeletonCard />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/page.tsx

import { notFound } from 'next/navigation';
import { CasesPageDocument } from 'prismicio-types';
import { Suspense } from 'react';

import { createClient } from '@/prismicio';
import { getUser, getUserCases } from '@/utils/helpers/helpers';
import { PrismicPageType } from '@/utils/prismic/enums';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { getDefaultCase } from '@/utils/utils';
import Dashboard from '@cases/dashboard/dashboard';

import NoCases from './components/no-cases/no-cases';
import Loading from './loading';

export default async function Page({
  searchParams,
}: {
  searchParams: { [key: string]: string | undefined };
}) {
  const caseId = searchParams['caseId'] ? searchParams.caseId : null;

  return (
    <Suspense key={caseId} fallback={<Loading />}>
      <CasesDashboard searchParams={searchParams} />
    </Suspense>
  );
}

const CasesDashboard = async ({
  searchParams,
}: {
  searchParams: { [key: string]: string | undefined };
}) => {
  const [user, cases, page] = await Promise.all([
    getUser(),
    getUserCases(),
    queryPage(),
  ]);

  if (cases.length > 0) {
    const caseId = searchParams['caseId'] ? searchParams.caseId : null;

    const queriedCase = caseId ? cases.find((c) => c.id === caseId) : undefined;

    const defaultCase = queriedCase ?? getDefaultCase(cases);

    return (
      <Dashboard
        user={user}
        cases={cases}
        defaultCase={defaultCase ?? (cases[0] as any)}
      />
    );
  }

  return <NoCases user={user} content={page} />;
};

export async function generateMetadata() {
  const page = await queryPage();
  return prismicPageToMetadata(page);
}

const queryPage = async () => {
  const client = createClient();

  return await client
    .getSingle<CasesPageDocument>(PrismicPageType.CASES_PAGE)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/cases-context.tsx

'use client';

import { useRouter } from 'next/navigation';
import React from 'react';

import { CaseInclude } from '@/app/shared/types';
import { Case } from '@prisma/client';

interface ICasesContext {
  defaultCase: CaseInclude | null;
  selectedCase: CaseInclude | null;
  isRefreshing: boolean;
  setSelectedCase: (selectedCase: CaseInclude) => void;
  triggerRefresh: () => void;
}

export const CasesContext = React.createContext({
  defaultCase: null,
  selectedCase: null,
  isRefreshing: false,
  setSelectedCase: () => {},
  triggerRefresh: () => {},
} as ICasesContext);

export function CasesContextProvider({
  defaultCase,
  children,
}: {
  defaultCase: CaseInclude | null;
  children: React.ReactNode;
}) {
  const router = useRouter();
  const [selectedCase, setSelectedCase] = React.useState<CaseInclude | null>(
    defaultCase
  );
  const [isPending, startTransition] = React.useTransition();

  const triggerRefresh = () => {
    startTransition(() => {
      router.refresh();
    });
  };

  return (
    <CasesContext.Provider
      value={{
        defaultCase,
        selectedCase,
        isRefreshing: isPending,
        setSelectedCase,
        triggerRefresh,
      }}
    >
      {children}
    </CasesContext.Provider>
  );
}

export default CasesContextProvider;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/use-cases-context.ts

import { useContext } from 'react';

import { CasesContext } from './cases-context';

export function useCasesContext() {
  const context = useContext(CasesContext);
  if (!context) {
    throw new Error(
      'useCasesContext must be used within the CasesContextProvider'
    );
  }
  return context;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/treatment-plan/treatment-plan.tsx

import React, { Suspense } from 'react';

import ErrorBoundary from '@/app/shared/components/errors/error-boundary';
import { Case } from '@prisma/client';

import LoadingSkeleton from './loading-skeleton';
import TreatmentPlanCart from './treatment-plan-cart';
import FailedTreatmentPlan from './treatment-plan-failure';

export interface ITreatmentPlanProps {
  currentCase: Case;
}

const TreatmentPlan: React.FC<ITreatmentPlanProps> = async ({
  currentCase,
}) => {
  return (
    <div className="bg-gray-100 lg:w-full lg:max-w-[380px] xl:max-w-[480px]">
      <div className="mx-auto px-6 py-5 lg:px-8">
        <div className="mx-auto max-w-4xl ">
          <h2 className="text-2xl font-bold leading-10 tracking-tight text-gray-900">
            Treatment Plan
          </h2>
          <ErrorBoundary fallback={<FailedTreatmentPlan />}>
            <Suspense fallback={<LoadingSkeleton />}>
              <TreatmentPlanCart currentCase={currentCase} />
            </Suspense>
          </ErrorBoundary>
        </div>
      </div>
    </div>
  );
};

export default TreatmentPlan;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/treatment-plan/loading-skeleton.tsx

'use client';

import ProductsAccordion from './products-accordion';

const LoadingSkeleton = () => {
  return (
    <div className="mt-3 space-y-6 divide-y divide-gray-900/10">
      <ProductsAccordion title="Available for purchase">
        <ul role="list" className="mt-2 divide-y divide-gray-900/10">
          {[...Array(2)].map((_item, i) => (
            <li key={`cart-item-line-${i}`} className="flex py-6 items-center">
              <div className="h-20 w-20 sm:h-24 sm:w-24 flex-shrink-0 overflow-hidden rounded-md bg-gray-200" />

              <div className="ml-4 flex flex-1 flex-col">
                <div>
                  <div className="flex justify-between text-base">
                    <div className="h-6 bg-gray-200 w-3/4 rounded" />
                    <div className="h-6 bg-gray-200 w-10 rounded ml-4" />
                  </div>
                </div>

                <div className="mt-1 flex flex-row gap-1 items-center">
                  <div className="bg-gray-200 h-5 w-20 rounded" />
                  <div className="bg-gray-200 h-5 w-10 ml-1 rounded" />
                </div>
                <div className="mt-3 flex flex-1 text-sm">
                  <div className="bg-gray-200 h-6 w-20 rounded" />
                </div>
              </div>
            </li>
          ))}
        </ul>
      </ProductsAccordion>
    </div>
  );
};

export default LoadingSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/treatment-plan/treatment-plan-failure.tsx

const FailedTreatmentPlan: React.FC = () => {
  return (
    <div className="bg-gray-100 lg:w-full lg:max-w-[380px] xl:max-w-[480px]">
      <div className="mx-auto px-6 py-5 lg:px-8">
        <div className="mx-auto max-w-4xl ">
          <h2 className="text-2xl font-bold leading-10 tracking-tight text-gray-900">
            Error Retrieving Treatment Plan
          </h2>
          <p>
            There was an error retrieving your treatment plan. Don&apos;t worry,
            we already created a ticket and are working on it!
          </p>
        </div>
      </div>
    </div>
  );
};

export default FailedTreatmentPlan;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/treatment-plan/treatment-plan-cart.tsx

import { cookies } from 'next/headers';
import Link from 'next/link';
import { ProductPageDocument } from 'prismicio-types';
import React from 'react';

import { CartInclude, TreatmentPlan } from '@/app/shared/types';
import { createClient } from '@/prismicio';
import { getIsProd } from '@/utils/get-is-prod';
import { getBaseUrl } from '@/utils/getBaseUrl';
import { PrismicPageType } from '@/utils/prismic/enums';
import { Case } from '@prisma/client';
import { filter } from '@prismicio/client';

import OTCItem from './plan-items/otc-item';
import PharmacyItem from './plan-items/pharmacy-item';
import PrescriptionItem from './plan-items/prescription-item';
import ProductsAccordion from './products-accordion';

export interface ITreatmentPlanCartProps {
  currentCase: Case;
}

const baseUrl = getBaseUrl();
const isProd = getIsProd();

const getTreatmentPlanItems = async (caseId: string) => {
  const res = await fetch(`${baseUrl}/api/case/${caseId}/treatment-plan`, {
    method: 'GET',
    headers: { Cookie: cookies().toString() },
    next: { revalidate: 300 },
  });
  if (res.ok) return (await res.json()) as TreatmentPlan;
  else throw new Error('Error getting treatment plan.');
};

const getProductContent = async (ids: string[]) => {
  const client = createClient();

  const filterString = !isProd
    ? `my.${PrismicPageType.PRODUCT_PAGE}.dev_product_id`
    : `my.${PrismicPageType.PRODUCT_PAGE}.product_id`;

  try {
    const products = await client.getAllByType<ProductPageDocument>(
      PrismicPageType.PRODUCT_PAGE,
      {
        filters: [filter.any(filterString, ids)],
      }
    );

    return products;
  } catch (error) {
    return [];
  }
};

const getCart = async () => {
  const res = await fetch(`${getBaseUrl()}/api/ecommerce/cart`, {
    method: 'GET',
    headers: { Cookie: cookies().toString() },
    cache: 'no-store',
  });
  return (await res.json()) as CartInclude;
};

const TreatmentPlanCart: React.FC<ITreatmentPlanCartProps> = async ({
  currentCase,
}) => {
  const [treatmentPlan, cart] = await Promise.all([
    await getTreatmentPlanItems(currentCase.id),
    await getCart(),
  ]);

  // GENERICS
  const generics = treatmentPlan.genericPrescriptions ?? [];

  // CUSTOM PRESCRIPTIONS (CUREXA)
  const customPrescriptions = treatmentPlan.cortinaRxPrescriptions ?? [];

  // OTC & SUBSCRIPTION PRODUCTS
  const otcProducts = treatmentPlan.OTCProducts ?? [];
  const subscriptions = treatmentPlan.OTCSubscriptionProducts ?? [];
  const products = [...otcProducts, ...subscriptions];

  // GET PRISMIC CONTENT IF AVAILABLE
  const prescriptionIds = customPrescriptions.map((p) =>
    p.productId ? p.productId : p.subscriptionProductId
  );
  const allIds = [...prescriptionIds, ...products.map((p) => p.id)];

  const prismicContent = await getProductContent(
    allIds.filter((id): id is string => id != null)
  );

  const hasPurchaseableProducts =
    customPrescriptions.length > 0 || products.length > 0;

  return (
    <>
      <div className="mt-3 space-y-6 divide-y divide-gray-900/10">
        <ProductsAccordion title="Available for purchase">
          {hasPurchaseableProducts ? (
            <>
              {customPrescriptions.map((prescription) => (
                <PrescriptionItem
                  key={prescription.id}
                  prescription={prescription}
                  prismicContent={prismicContent}
                  cart={cart}
                />
              ))}
              {otcProducts.map((product) => (
                <OTCItem
                  key={product.id}
                  product={product}
                  prismicContent={prismicContent}
                  isSubscription={false}
                />
              ))}
              {subscriptions.map((subscription) => (
                <OTCItem
                  key={subscription.id}
                  product={subscription}
                  prismicContent={prismicContent}
                  isSubscription={true}
                />
              ))}
            </>
          ) : (
            <div className="py-3 font-dmsans text-gray-600">
              No medications prescribed are available for purchase through
              Cortina.
            </div>
          )}
        </ProductsAccordion>
        {generics.length > 0 && (
          <ProductsAccordion title="Sent to local pharmacy">
            {generics.map((prescription) => (
              <PharmacyItem key={prescription.id} prescription={prescription} />
            ))}
          </ProductsAccordion>
        )}
      </div>
      {hasPurchaseableProducts && (
        <div className="mt-4 border-t border-gray-900/10 py-3">
          <Link
            href="/shop/checkout"
            className="block border text-center border-accent-300 font-dmsans bg-accent-200 rounded-lg text-base text-accent-700 font-semibold hover:bg-accent-100 transition duration-150 ease-in-out py-2 px-7 mt-3 lg:w-auto w-full"
          >
            Checkout
          </Link>
        </div>
      )}
    </>
  );
};

export default TreatmentPlanCart;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/treatment-plan/products-accordion.tsx

'use client';

import React from 'react';

import { Disclosure } from '@headlessui/react';
import { MinusSmallIcon, PlusSmallIcon } from '@heroicons/react/20/solid';

export interface IProductsAccordionProps {
  title: string;
  children?: React.ReactNode;
}

const ProductsAccordion: React.FC<IProductsAccordionProps> = ({
  title,
  children,
}) => {
  return (
    <Disclosure as="div" className="pt-6" defaultOpen={true}>
      {({ open }) => (
        <>
          <div>
            <Disclosure.Button className="flex w-full items-start justify-between text-left text-gray-900">
              <span className="text-base font-semibold leading-7">{title}</span>
              <span className="ml-6 flex h-7 items-center">
                {open ? (
                  <MinusSmallIcon className="h-6 w-6" aria-hidden="true" />
                ) : (
                  <PlusSmallIcon className="h-6 w-6" aria-hidden="true" />
                )}
              </span>
            </Disclosure.Button>
          </div>
          <Disclosure.Panel as="ul" className="divide-y divide-gray-900/10">
            {children}
          </Disclosure.Panel>
        </>
      )}
    </Disclosure>
  );
};

export default ProductsAccordion;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/treatment-plan/plan-items/otc-item.tsx

'use client';

import { ProductPageDocument } from 'prismicio-types';
import React from 'react';

import ButtonOutline from '@/app/shared/components/buttons/button-outline';
import { CartInclude } from '@/app/shared/types';
import { getPrismicProductId } from '@/utils/get-prismic-product-id';
import { formatCurrency, getFamilyMemberHeader } from '@/utils/utils';
import { Product, SubscriptionProduct } from '@prisma/client';
import { PrismicNextLink } from '@prismicio/next';

import ProductImage from './product-image';

interface IOTCItemProps {
  product: Product | SubscriptionProduct;
  isSubscription: boolean;
  prismicContent?: ProductPageDocument[];
  cart?: CartInclude;
}

const updateQuantity = async (
  id: string,
  quantity: number,
  isSubscription: boolean
) => {
  const updatePath = isSubscription
    ? `/api/ecommerce/subscription-product/${id}/cart`
    : `/api/ecommerce/product/${id}/cart`;

  try {
    const res = await fetch(updatePath, {
      method: 'POST',
      body: JSON.stringify({ setAbsoluteAmount: true, amount: quantity }),
      headers: getFamilyMemberHeader(),
    });

    if (!res.ok) {
      throw new Error('Could not update product quantity in cart');
    }

    return { success: true };
  } catch (error) {
    return { success: false };
  }
};

const OTCItem: React.FC<IOTCItemProps> = ({
  product,
  prismicContent,
  isSubscription,
}) => {
  const [addingToCart, setAddingToCart] = React.useState(false);
  const [error, setError] = React.useState(false);

  if (!product) {
    return null;
  }

  const content = prismicContent?.find(
    (pc) => getPrismicProductId(pc.data) === product.id
  );

  const addToCart = async () => {
    setError(false);
    setAddingToCart(true);
    const result = await updateQuantity(product.id, 1, isSubscription);

    if (!result.success) {
      setError(true);
    }
    setAddingToCart(false);

    const dataLayer = window.dataLayer || [];

    dataLayer.push({ ecommerce: null });
    dataLayer.push({
      event: 'add_to_cart',
      ecommerce: {
        currency: 'USD',
        value: product.price / 100,
        items: [
          {
            item_id: product.id,
            item_name: product.name,
            currency: 'USD',
            price: product.price / 100,
            quantity: 1,
          },
        ],
      },
    });
  };

  return (
    <li className="flex py-6 items-start gap-4">
      <ProductImage item={product} prismicContent={content} />

      <div className="flex flex-1 flex-col">
        <div>
          <div className="flex justify-between text-base font-medium text-gray-900">
            <h3>
              {content ? (
                <>
                  {content.data.is_shop_product ? (
                    <PrismicNextLink document={content}>
                      {content.data.name}
                    </PrismicNextLink>
                  ) : (
                    content.data.name
                  )}
                </>
              ) : (
                product.name
              )}
            </h3>
            <p className="ml-4">{formatCurrency(product.price)}</p>
          </div>
        </div>
        <p className="text-sm text-gray-600">Quantity: 1</p>
        <div className="mt-2">
          <ButtonOutline
            variant="gray"
            className="w-full max-w-sm"
            onClick={addToCart}
            disabled={addingToCart}
          >
            {addingToCart ? 'Adding to cart...' : 'Add to Cart'}
          </ButtonOutline>
        </div>
        {error && (
          <p className="text-red-500 text-sm mt-2">
            There was an error adding the product to your cart
          </p>
        )}
      </div>
    </li>
  );
};

export default OTCItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/treatment-plan/plan-items/prescription-item.tsx

import { ProductPageDocument } from 'prismicio-types';
import React from 'react';

import { CartInclude, UserPrescriptionsWithProduct } from '@/app/shared/types';
import { FulfillmentOptions } from '@/utils/enums';
import { ProductCategories } from '@prisma/client';

import CortinaRXItem from './cortina-rx-item';

export interface IPrescriptionItemProps {
  prescription: UserPrescriptionsWithProduct;
  prismicContent?: ProductPageDocument[];
  cart?: CartInclude;
}

const isItemInCart = (
  prescription: UserPrescriptionsWithProduct,
  cart?: CartInclude
) => {
  const result = { oneTime: false, subscription: false };
  if (
    prescription.productId &&
    (cart?.cartProducts ?? []).find(
      (p) => p.productId === prescription?.productId
    )
  ) {
    result.oneTime = true;
  }

  if (
    prescription.subscriptionProductId &&
    (cart?.cartSubscriptionProducts ?? []).find(
      (p) => p.subscriptionProductId === prescription.subscriptionProductId
    )
  ) {
    result.subscription = true;
  }

  return result;
};

const PrescriptionItem: React.FC<IPrescriptionItemProps> = ({
  prescription,
  prismicContent,
  cart,
}) => {
  const category =
    prescription.product?.category ??
    prescription.subscriptionProduct?.category;

  // Cortina RX Product
  if (category === ProductCategories.PRESCRIPTION_MEDICATION) {
    const { oneTime, subscription } = isItemInCart(prescription, cart);

    const currentSelection = oneTime
      ? FulfillmentOptions.ONE_TIME_PURCHASE
      : subscription
      ? FulfillmentOptions.SUBSCRIPTION
      : '';

    return (
      <CortinaRXItem
        prescription={prescription}
        prismicContent={prismicContent}
        currentSelection={currentSelection}
      />
    );
  }

  return null;
};

export default PrescriptionItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/treatment-plan/plan-items/product-image.tsx

import Image from 'next/image';
import { ProductPageDocument } from 'prismicio-types';
import React from 'react';

import { Product, SubscriptionProduct } from '@prisma/client';
import { isFilled } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';

const ProductImage = ({
  item,
  prismicContent,
}: {
  item: Product | SubscriptionProduct;
  prismicContent?: ProductPageDocument | null;
}) => {
  if (prismicContent && isFilled.image(prismicContent.data.thumbnail)) {
    return (
      <div className="h-24 w-24 flex-shrink-0 overflow-hidden rounded-md">
        <PrismicNextImage
          field={prismicContent.data.thumbnail}
          alt=""
          className="h-full w-full object-cover object-center"
          width={500}
          height={500}
        />
      </div>
    );
  }

  if (item.imageURL) {
    return (
      <div className="h-24 w-24 flex-shrink-0 overflow-hidden rounded-md">
        <Image
          src={item.imageURL}
          alt=""
          className="h-full w-full object-cover object-center"
          width={500}
          height={500}
        />
      </div>
    );
  }

  return null;
};

export default ProductImage;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/treatment-plan/plan-items/cortina-rx-item.tsx

'use client';

import dayjs from 'dayjs';
import { ProductPageDocument } from 'prismicio-types';
import React from 'react';

import Select from '@/app/shared/components/form-controls/select';
import LoadingSpinner from '@/app/shared/components/loading-indicators/loading-spinner';
import { CartInclude, UserPrescriptionsWithProduct } from '@/app/shared/types';
import { FulfillmentOptions } from '@/utils/enums';
import { getPrismicProductId } from '@/utils/get-prismic-product-id';
import { formatCurrency, getFamilyMemberHeader } from '@/utils/utils';

import ProductImage from './product-image';

interface IRXItemProps {
  prescription: UserPrescriptionsWithProduct;
  prismicContent?: ProductPageDocument[];
  cart?: CartInclude;
  currentSelection: string;
}

const updateCartProduct = async (productId: string | null, amount: number) => {
  if (!productId) {
    return { success: true };
  }
  try {
    const res = await fetch(`/api/ecommerce/product/${productId}/cart`, {
      method: 'POST',
      body: JSON.stringify({ setAbsoluteAmount: true, amount }),
      headers: getFamilyMemberHeader(),
    });

    if (!res.ok) {
      throw new Error('Could not add product to cart');
    }

    return { success: true };
  } catch (error) {
    return { success: false };
  }
};

const updateCartSubscriptionProduct = async (
  productId: string | null,
  amount: number
) => {
  if (!productId) {
    return { success: true };
  }
  try {
    const res = await fetch(
      `/api/ecommerce/subscription-product/${productId}/cart`,
      {
        method: 'POST',
        body: JSON.stringify({ setAbsoluteAmount: true, amount }),
        headers: getFamilyMemberHeader(),
      }
    );

    if (!res.ok) {
      throw new Error('Could not add subscription product to cart');
    }

    return { success: true };
  } catch (error) {
    return { success: false };
  }
};

const CortinaRXItem: React.FC<IRXItemProps> = ({
  prescription,
  prismicContent,
  currentSelection,
}) => {
  const [fulfillmentChoice, setFulfillmentChoice] =
    React.useState<string>(currentSelection);
  const [loading, setLoading] = React.useState(false);
  const [error, setError] = React.useState(false);

  const product = prescription.product ?? prescription.subscriptionProduct;

  if (!product) {
    return null;
  }

  const content = prismicContent?.find(
    (pc) => getPrismicProductId(pc.data) === product.id
  );

  const changeFulfillmentChoice = async (option: string) => {
    setError(false);
    setLoading(true);
    const previousChoice = fulfillmentChoice;
    setFulfillmentChoice(option as FulfillmentOptions); // optimistic update

    const subscriptionPromise = updateCartSubscriptionProduct(
      prescription.subscriptionProductId,
      option === FulfillmentOptions.SUBSCRIPTION ? 1 : 0
    );

    const productPromise = updateCartProduct(
      prescription.productId,
      option === FulfillmentOptions.ONE_TIME_PURCHASE ? 1 : 0
    );

    const [subscriptionResult, productResult] = await Promise.all([
      subscriptionPromise,
      productPromise,
    ]);

    if (subscriptionResult.success && productResult.success) {
      setFulfillmentChoice(option as FulfillmentOptions);
    } else {
      setFulfillmentChoice(previousChoice); // failure, so revert optimistic update
      setError(true);
    }

    setLoading(false);
  };

  const options = !prescription.subscriptionProductId
    ? [FulfillmentOptions.ONE_TIME_PURCHASE, FulfillmentOptions.REMOVE]
    : Object.values(FulfillmentOptions);

  const canBePurchased: boolean =
    !prescription.nextAvailableRefillDate ||
    new Date() >= new Date(prescription.nextAvailableRefillDate);

  const noPurchaseText: string = prescription.nextAvailableRefillDate
    ? `This product cannot be purchased again until ${dayjs(
        prescription.nextAvailableRefillDate
      ).format('MMM D, YYYY h:mm A')}`
    : 'This product cannot be purchased at this time. Please contact support.';

  return (
    <li className="font-dmsans flex py-6 items-start gap-4">
      <ProductImage item={product} prismicContent={content} />

      <div className="flex flex-1 flex-col">
        <div>
          <div className="flex justify-between text-base font-medium text-gray-900">
            <h3>{content ? content.data.name : product.name}</h3>
            <p className="ml-4">{formatCurrency(product.price)}</p>
          </div>
        </div>
        <p className="text-sm text-gray-600">Quantity: 1</p>
        <div className="mt-2 max-w-sm lg:max-w-none">
          <Select
            className="text-sm"
            value={fulfillmentChoice}
            onChange={changeFulfillmentChoice}
            options={options}
            placeholderOption={'Purchase Options'}
            disabled={loading || !canBePurchased}
          />
          {!canBePurchased && (
            <p className="text-red-500 text-sm mt-2">{noPurchaseText}</p>
          )}
        </div>
        {loading && (
          <div className="flex flex-row items-center text-accent-700 text-sm font-medium mt-2">
            <LoadingSpinner size="sm" fillClass="fill-accent-700" />
            <span className="ml-2">Updating Cart...</span>
          </div>
        )}
        {!loading && error && (
          <p className="text-red-500 text-sm mt-2">
            There was an error updating your cart. Please try again.
          </p>
        )}
      </div>
    </li>
  );
};

export default CortinaRXItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/treatment-plan/plan-items/pharmacy-item.tsx

import React from 'react';

import { UserPrescriptionWithPharmacy } from '@/app/shared/types';

interface IPharmacyItemProps {
  prescription: UserPrescriptionWithPharmacy;
}

const PharmacyItem: React.FC<IPharmacyItemProps> = ({ prescription }) => {
  return (
    <div className="font-dmsans py-6">
      <p className="font-medium text-gray-900">{prescription.medicationName}</p>
      {prescription.pharmacy && (
        <>
          <p className="mt-2 text-sm text-gray-600 font-semibold">Sent to:</p>
          <p className="mt-1 text-gray-600">
            <span className="block">{prescription.pharmacy.StoreName}</span>
            <span className="block">{prescription.pharmacy.Address1}</span>
            <span className="block">{`${prescription.pharmacy.City}, ${prescription.pharmacy.State} ${prescription.pharmacy.ZipCode}`}</span>
          </p>
        </>
      )}
    </div>
  );
};

export default PharmacyItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/case-submitted/case-submitted.tsx

'use client';

import Image from 'next/image';

import CustomLink from '@/app/shared/components/buttons/custom-link';
import { CaseInclude } from '@/app/shared/types';

export interface ICaseSubmittedProps {
  currentCase: CaseInclude;
}

const CaseSubmitted: React.FC<ICaseSubmittedProps> = ({ currentCase }) => {
  const caseUserName = currentCase.user.firstName;
  const isPrimaryUser = currentCase.user?.guardianId == null;
  const name = !isPrimaryUser && caseUserName ? `${caseUserName}'s` : 'your';
  const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
  return (
    <div className="comp-case-submitted">
      <div className="flex lg:flex-row flex-col border-b border-gray-200 py-5 px-7 gap-x-4">
        <div className="flex-grow">
          <div className="sr-only">Case Progress</div>
          <div className="mt-6" aria-hidden="true">
            <div className="overflow-hidden rounded-full bg-gray-200">
              <div
                className="h-2 rounded-full bg-[#5FE9D0]"
                style={{ width: '10%' }}
              />
            </div>
            <div className="mt-2 grid-cols-4 text-[12px] font-medium text-[#98A2B3] uppercase sm:grid">
              <div className="">Submitted</div>
              <div className="text-center hidden lg:block">Diagnose</div>
              <div className="text-center hidden lg:block">Review</div>
              <div className="text-right hidden lg:block">Purchase</div>
            </div>
          </div>
        </div>
        <div className="lg:w-[220px] text-center">
          <CustomLink
            href="/account/create-profile"
            variant="accent"
            className="block text-center py-2 px-7 mt-3 lg:w-auto w-full"
          >
            Next Step
          </CustomLink>
        </div>
      </div>

      <div className="flex h-full flex-col border-b border-gray-200 p-7">
        <div className="">
          <span
            title={currentCase?.status}
            className="inline-flex items-center rounded-full bg-yellow-50 px-2 py-1 text-xs font-medium text-yellow-800 ring-1 ring-inset ring-yellow-600/20 mb-5"
          >
            Pending
          </span>
        </div>
        <div className="font-dmsans font-medium text-gray-900 text-4xl max-w-[800px] mb-3">
          {`We are waiting for your board-certified dermatologist to review ${name}
          case`}
        </div>
        <div className="text-[#475467] text-sm">
          Estimated time to complete: 24-48 hours
        </div>
      </div>

      <div className="flex h-full lg:flex-row flex-col border-b border-gray-200 p-7 gap-x-20 gap-y-7">
        <div className="">
          <div className="max-w-[350px]">
            <div className="text-[#107569] font-medium">What&apos;s Next</div>
            <div className="font-financier text-[#0A2926] text-3xl my-1">
              Consultation Report
            </div>
            <div className="my-2">
              {`${capitalizedName} Consultation Report will contain a message from your Doctor
              along with your diagnosis and prescriptions available for your
              condition.`}
            </div>
          </div>
        </div>
        <div className="">
          <div className="max-w-[350px]">
            <div className="text-[#107569] font-medium">What&apos;s Next</div>
            <div className="font-financier text-[#0A2926] text-3xl my-1">
              Treatment Plan
            </div>
            <div className="my-2">
              Your Treatment Plan allows you to purchase any other options the
              Doctor has suggested and confirm your order.
            </div>
          </div>
        </div>
      </div>

      <div className="flex h-full lg:flex-row flex-col border-b border-gray-200 p-7 gap-x-12 gap-y-7">
        <div className="">
          <Image
            className=""
            width="359"
            height="242"
            alt="Shop Cortina"
            src="/assets/shop-cortina.png"
          />
        </div>
        <div className="">
          <div className="max-w-[350px]">
            <div className="text-[#107569] font-medium">Selected for You</div>
            <div className="font-financier text-[#0A2926] text-3xl my-1">
              Complement Your
              <br />
              Prescribed Treatment
            </div>
            <div className="my-2">
              Elevate your daily skincare routine with essentials that work with
              your prescribed treatment.
            </div>
            <CustomLink
              variant="gray-outline"
              size="lg"
              href="/shop"
              className="py-2 w-full mt-3"
            >
              Shop Skin Care
            </CustomLink>
          </div>
        </div>
      </div>
    </div>
  );
};

export default CaseSubmitted;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/no-cases/no-cases.tsx

import { CasesPageDocument } from 'prismicio-types';

import FixedInfoPopover from '@/app/shared/components/overlays/fixed-info-popover/fixed-info-popover';
import { ExtendedUser } from '@/app/shared/types';

export interface INoCasesProps {
  user: ExtendedUser;
  content: CasesPageDocument;
}

const NoCases: React.FC<INoCasesProps> = (p) => {
  return (
    <FixedInfoPopover
      user={p.user}
      image={p.content.data.no_cases_image}
      title={p.content.data.no_cases_title}
      content={
        p.user?.firstName
          ? p.content.data.no_cases_content_with_name
          : p.content.data.no_cases_content
      }
      primaryCtaLink={p.content.data.no_cases_primary_cta_link}
      primaryCtaText={p.content.data.no_cases_primary_cta_text}
      primaryCtaStyle={p.content.data.no_cases_primary_cta_style}
      secondaryCtaLink={p.content.data.no_cases_secondary_cta_link}
      secondaryCtaText={p.content.data.no_cases_secondary_cta_text}
      secondaryCtaStyle={p.content.data.no_cases_secondary_cta_style}
      backgroundImage={p.content.data.no_cases_background_image}
    />
  );
};

export default NoCases;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/case-picker/case-picker-header.tsx

'use client';

import { useRouter } from 'next/navigation';

import { CaseInclude } from '@/app/shared/types';
import CasePicker from '@components/case-picker/case-picker';

import { useCasesContext } from '../use-cases-context';

interface ICasePickerHeaderProps {
  cases: CaseInclude[];
}

const CasePickerHeader: React.FC<ICasePickerHeaderProps> = ({ cases }) => {
  const { selectedCase } = useCasesContext();

  const router = useRouter();

  const handleCaseSelectionChange = (newCase: CaseInclude) => {
    router.push(`/account/cases?caseId=${newCase.id}`);
  };
  return (
    <div className="flex-1 flex flex-col justify-between">
      <CasePicker
        cases={cases}
        currentCase={selectedCase}
        onCaseChange={handleCaseSelectionChange}
      />
    </div>
  );
};

export default CasePickerHeader;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/show-cases/show-cases.tsx

import CaseAwaitingPayment from '@/app/(account)/account/cases/components/case-awaiting-payment/case-awaiting-payment';
import CaseDiagnosed from '@/app/(account)/account/cases/components/case-diagnosed/case-diagnosed';
import CaseDynamicCTA from '@/app/(account)/account/cases/components/case-dynamic-cta/case-dynamic-cta';
import CaseSubmitted from '@/app/(account)/account/cases/components/case-submitted/case-submitted';
import { CaseInclude, ExtendedUser } from '@/app/shared/types';
import { CaseStatus } from '@prisma/client';

import CasePickerHeader from '../case-picker/case-picker-header';

export interface IShowCasesProps {
  user: ExtendedUser;
  cases: CaseInclude[];
  defaultCase: CaseInclude;
}

const ShowCases: React.FC<IShowCasesProps> = ({ cases, defaultCase }) => {
  type CaseComponentMap = {
    [key in CaseStatus]?: JSX.Element;
  };

  const caseComponents: CaseComponentMap = {
    [CaseStatus.PREPAYMENT]: <CaseAwaitingPayment currentCase={defaultCase} />,

    [CaseStatus.OPEN]: <CaseSubmitted currentCase={defaultCase} />,
    [CaseStatus.ASSIGNED]: <CaseSubmitted currentCase={defaultCase} />,

    [CaseStatus.DIAGNOSED_AWAITING_PHARMACY]: (
      <CaseDiagnosed currentCase={defaultCase} />
    ),
    [CaseStatus.DIAGNOSED_NO_PRESCRIPTION]: (
      <CaseDiagnosed currentCase={defaultCase} />
    ),
    [CaseStatus.DIAGNOSED_PRESCRIBED]: (
      <CaseDiagnosed currentCase={defaultCase} />
    ),
    [CaseStatus.PHYSICIAN_FINALIZED]: (
      <CaseDiagnosed currentCase={defaultCase} />
    ),

    [CaseStatus.PATIENT_REVIEW]: <CaseDiagnosed currentCase={defaultCase} />,
    [CaseStatus.PATIENT_OPENED]: <CaseDiagnosed currentCase={defaultCase} />,

    [CaseStatus.EXPIRED]: <CaseDiagnosed currentCase={defaultCase} />,
  };
  const defaultCaseComponent = <CaseSubmitted currentCase={defaultCase} />;

  // Get the component based on the case status or default
  const caseComponent =
    caseComponents[defaultCase.status] || defaultCaseComponent;

  return (
    <div className="comp-show-cases min-h-screen">
      <div className="flex h-full lg:flex-row flex-col border-b border-gray-200 py-5 px-7">
        <CasePickerHeader cases={cases} />
        <div className="flex-1 flex flex-col justify-between">
          <CaseDynamicCTA currentCase={defaultCase} />
        </div>
      </div>

      {caseComponent}
    </div>
  );
};

export default ShowCases;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/dashboard/dashboard.tsx

import { CaseInclude, ExtendedUser } from '@/app/shared/types';

import CasesContextProvider from '../cases-context';
import ShowCases from '../show-cases/show-cases';

export interface IDashboardProps {
  user: ExtendedUser;
  cases: CaseInclude[];
  defaultCase: CaseInclude;
}

const Dashboard: React.FC<IDashboardProps> = (p) => {
  return (
    <CasesContextProvider defaultCase={p.defaultCase}>
      <div className="comp-case-dashboard min-h-screen">
        <ShowCases {...p} />
      </div>
    </CasesContextProvider>
  );
};

export default Dashboard;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/case-dynamic-cta/case-dynamic-cta.tsx

import { Case } from '@prisma/client';

export interface ICaseDynamicCTAProps {
  currentCase: Case;
}

const CaseDynamicCTA: React.FC<ICaseDynamicCTAProps> = ({ currentCase }) => {
  if (currentCase === null || currentCase === undefined) {
    return <div>No cases found</div>;
  }
  return (
    <div className="comp-case-dynamic-cta">
      <div></div>
    </div>
  );
};

export default CaseDynamicCTA;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/case-awaiting-payment/case-awaiting-payment.tsx

'use client';

import Image from 'next/image';

import CustomLink from '@/app/shared/components/buttons/custom-link';
import { CaseInclude } from '@/app/shared/types';
import { ConsultationType } from '@/utils/enums';

export interface ICaseSubmittedProps {
  currentCase: CaseInclude;
}

const CaseAwaitingPayment: React.FC<ICaseSubmittedProps> = ({
  currentCase,
}) => {
  const caseUserName = currentCase.user.firstName;
  const isPrimaryUser = currentCase.user?.guardianId == null;
  const name = !isPrimaryUser && caseUserName ? `${caseUserName}'s` : 'Your';
  const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
  return (
    <div className="comp-case-submitted">
      <div className="flex lg:flex-row flex-col border-b border-gray-200 py-5 px-7 gap-x-4">
        <div className="flex-grow">
          <div className="sr-only">Case Progress</div>
          <div className="mt-6" aria-hidden="true">
            <div className="overflow-hidden rounded-full bg-gray-200">
              <div
                className="h-2 rounded-full bg-[#5FE9D0]"
                style={{ width: '10%' }}
              />
            </div>
            <div className="mt-2 grid-cols-5 text-[12px] font-medium text-[#98A2B3] uppercase sm:grid">
              <div className="">Purchase Consultation</div>
              <div className="text-center hidden lg:block">Submitted</div>
              <div className="text-center hidden lg:block">Diagnose</div>
              <div className="text-center hidden lg:block">Review</div>
              <div className="text-right hidden lg:block">Purchase Rx</div>
            </div>
          </div>
        </div>
        <div className="lg:w-[220px] text-center">
          <CustomLink
            href={`/api/submit/collect-consultation-funds?caseId=${currentCase.id}&consult-type=${ConsultationType.PREPAYMENT}`}
            variant="accent"
            className="block text-center py-2 px-7 mt-3 lg:w-auto w-full"
          >
            Purchase Consultation
          </CustomLink>
        </div>
      </div>

      <div className="flex h-full flex-col border-b border-gray-200 p-7">
        <div className="">
          <span
            title={currentCase?.status}
            className="inline-flex items-center rounded-full bg-yellow-50 px-2 py-1 text-xs font-medium text-yellow-800 ring-1 ring-inset ring-yellow-600/20 mb-5"
          >
            Pending Purchase
          </span>
        </div>
        <div className="font-dmsans font-medium text-gray-900 text-4xl max-w-[800px] mb-3">
          {`${name} case has not yet been submitted for physician review. Please purchase a medical consultation to submit this case.`}
        </div>
        <div className="max-w-[320px]">
          <CustomLink
            href={`/api/submit/collect-consultation-funds?caseId=${currentCase.id}&consult-type=${ConsultationType.PREPAYMENT}`}
            variant="accent"
            className="block text-center py-2 px-7 mt-3 lg:w-auto w-full"
          >
            Purchase Consultation
          </CustomLink>
        </div>
      </div>

      <div className="flex h-full lg:flex-row flex-col border-b border-gray-200 p-7 gap-x-20 gap-y-7">
        <div className="">
          <div className="max-w-[350px]">
            <div className="text-[#107569] font-medium">What&apos;s Next</div>
            <div className="font-financier text-[#0A2926] text-3xl my-1">
              Consultation Report
            </div>
            <div className="my-2">
              {`${capitalizedName} Consultation Report will contain a message from your Doctor
              along with your diagnosis and prescriptions available for your
              condition.`}
            </div>
          </div>
        </div>
        <div className="">
          <div className="max-w-[350px]">
            <div className="text-[#107569] font-medium">What&apos;s Next</div>
            <div className="font-financier text-[#0A2926] text-3xl my-1">
              Treatment Plan
            </div>
            <div className="my-2">
              Your Treatment Plan allows you to purchase any other options the
              Doctor has suggested and confirm your order.
            </div>
          </div>
        </div>
      </div>

      <div className="flex h-full lg:flex-row flex-col border-b border-gray-200 p-7 gap-x-12 gap-y-7">
        <div className="">
          <Image
            className=""
            width="359"
            height="242"
            alt="Shop Cortina"
            src="/assets/shop-cortina.png"
          />
        </div>
        <div className="">
          <div className="max-w-[350px]">
            <div className="text-[#107569] font-medium">Selected for You</div>
            <div className="font-financier text-[#0A2926] text-3xl my-1">
              Complement Your
              <br />
              Prescribed Treatment
            </div>
            <div className="my-2">
              Elevate your daily skincare routine with essentials that work with
              your prescribed treatment.
            </div>
            <CustomLink
              variant="gray-outline"
              size="lg"
              href="/shop"
              className="py-2 w-full mt-3"
            >
              Shop Skin Care
            </CustomLink>
          </div>
        </div>
      </div>
    </div>
  );
};

export default CaseAwaitingPayment;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/physician-card/physician-card.tsx

import { CaseInclude } from '@/app/shared/types';

import Avatar from '../../../messaging/components/avatar';

export async function PhysicianCard(p: { caseItem: CaseInclude }) {
  if (!p.caseItem.physician) return null;

  const physician = p.caseItem.physician;

  // Extracting the first and last initials
  const firstInitial = physician.firstName ? physician.firstName[0] : '';
  const lastInitial = physician.lastName ? physician.lastName[0] : '';

  return (
    <div className="mb-8 flex items-center">
      <div className="mr-4 flex items-center justify-center text-lg text-black">
        {physician.avatarUrl ? (
          // If avatar exists, display the image
          <Avatar user={physician} className="h-[60px] w-[60px]" />
        ) : (
          // Display initials in a grey circle if avatar does not exist
          `${firstInitial}${lastInitial}`
        )}
      </div>
      <div>
        <div className="text-[#101828] font-medium text-[18px]">
          {physician.firstName} {physician.lastName}, MD
        </div>
        <div className="leading-tight text-[#344054]">
          Board-certified Dermatologist
        </div>
        <div className="leading-tight text-[#344054]">
          Cortina Medical Group
        </div>
      </div>
    </div>
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/cases/components/case-diagnosed/case-diagnosed.tsx

import Link from 'next/link';
import { Suspense } from 'react';

import { PhysicianCard } from '@/app/(account)/account/cases/components/physician-card/physician-card';
import CustomLink from '@/app/shared/components/buttons/custom-link';
import MarkdownElement from '@/app/shared/components/markdown-element';
import { CaseInclude } from '@/app/shared/types';
import { ArrowUpRightIcon } from '@heroicons/react/20/solid';

import TreatmentPlan from '../treatment-plan/treatment-plan';

export interface ICaseDiagnosedProps {
  currentCase: CaseInclude;
}

const CaseDiagnosed: React.FC<ICaseDiagnosedProps> = ({ currentCase }) => {
  const formattedDiagnosisMessage = (
    currentCase?.diagnosisMessage ?? 'Your case has been diagnosed.'
  ).replace(/(\n)(?!\n)/g, '\n\n');

  return (
    <div className="comp-case-diagnosed min-h-screen">
      <div className="flex lg:flex-row flex-col border-b border-gray-200 py-5 px-7 gap-x-4">
        <div className="flex-grow">
          <div className="sr-only">Case Progress</div>
          <div className="mt-6" aria-hidden="true">
            <div className="overflow-hidden rounded-full bg-gray-200">
              <div
                className="h-2 rounded-full bg-[#5FE9D0]"
                style={{ width: '65%' }}
              />
            </div>
            <div className="mt-2 grid-cols-4 text-[12px] font-medium text-[#98A2B3] uppercase sm:grid">
              <div className="">Submitted</div>
              <div className="text-center hidden lg:block">Diagnosed</div>
              <div className="text-center hidden lg:block">Review</div>
              <div className="text-right hidden lg:block">Purchase</div>
            </div>
          </div>
        </div>
        <div className="lg:w-[220px] text-center">
          <CustomLink
            href="/shop/checkout"
            variant="accent"
            className="block text-center py-2 px-7 mt-3 lg:w-auto w-full text-base font-semibold"
          >
            Checkout
          </CustomLink>
        </div>
      </div>

      <div className="flex lg:flex-row flex-col min-h-screen">
        <div className="flex-grow lg:w-2/3">
          <div className="flex flex-col border-b border-gray-200 p-7 gap-x-20">
            <div className="text-[#107569] font-medium">Diagnosis</div>
            <div className="font-dmsans text-[#0A2926] text-3xl mt-1">
              {`${currentCase?.user?.firstName}'s Consultation Report`}
            </div>
            <div className="text-gray-500 leading-tight">
              {currentCase.diagnosisName} - {currentCase.diagnosisICD}
            </div>
          </div>

          <div className="border-b border-gray-200 p-7">
            <div>
              <Suspense fallback={<div>Loading...</div>}>
                <PhysicianCard caseItem={currentCase} />
              </Suspense>
            </div>
            <MarkdownElement>{formattedDiagnosisMessage}</MarkdownElement>
          </div>

          <div className="p-7 lg:block hidden">
            <div className="text-[#107569] font-medium mb-2">
              Supplemental Articles
            </div>
            <div className="">
              <Link
                href="/blog/hyperpigmentation-and-sunscreen-what-you-need-to-know"
                target="_blank"
                className="block relative py-4 border-b border-gray-200 mb-1 max-w-[85%] hover:bg-gray-100 transition-colors duration-150 ease-in-out"
              >
                <span className="block font-medium text-lg mb-1">
                  Hyperpigmentation and Sunscreen: What You Need To Know
                </span>{' '}
                <span className="block ">
                  Let&apos;s face it: Dark spots are a drag. Everyone wants to
                  put their best face forward, but you can&apos;t do that
                  without proper protection....
                </span>
                <ArrowUpRightIcon className="absolute top-1 right-0 w-6 h-6 text-[#107569]" />
              </Link>
              <Link
                href="/blog/hydroquinone-the-gold-standard-treatment-for-dark-spots"
                target="_blank"
                className="block relative py-4 border-b border-gray-200 mb-1 max-w-[85%] hover:bg-gray-100 transition-colors duration-150 ease-in-out"
              >
                <span className="block font-medium text-lg mb-1">
                  Hydroquinone: The &quot;Gold Standard&quot; Treatment for Dark
                  Spots
                </span>{' '}
                <span className="block">
                  Discover how hydroquinone, the gold standard for fading dark
                  spots, works wonders for your skin while navigating its safety
                  and usage for luminous results.
                </span>
                <ArrowUpRightIcon className="absolute top-1 right-0 w-6 h-6 text-[#107569]" />
              </Link>
            </div>
          </div>
        </div>

        <TreatmentPlan currentCase={currentCase} />
      </div>
    </div>
  );
};

export default CaseDiagnosed;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/[uid]/error.tsx

'use client';

import React from 'react';

import ErrorView from '@components/error-view';

const Error: React.FC = () => {
  return <ErrorView />;
};

export default Error;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/[uid]/loading.tsx

import LoadingCircles from '@components/loading-indicators/loading-circles';

export default function Loading() {
  return <LoadingCircles />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/[uid]/page.tsx

import { notFound } from 'next/navigation';
import { AccountpageDocument } from 'prismicio-types';

import { AccountPageContext } from '@/app/shared/types';
import { createClient } from '@/prismicio';
import { components } from '@/slices';
import { getPartner } from '@/utils/get-partner';
import { getUser } from '@/utils/helpers/helpers';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { SliceZone } from '@prismicio/react';
import { PrismicPageType } from '@utils/prismic/enums';

type Params = { uid: string };
export default async function Page({
  params,
  searchParams,
}: {
  params: Params;
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  const [page, user] = await Promise.all([queryPage(params.uid), getUser()]);
  const partner = await getPartner(user.partnerId);

  return (
    <div
      style={{
        ...(page.data.background_color
          ? { backgroundColor: page.data.background_color }
          : {}),
      }}
      className="w-full flex flex-col flex-1"
    >
      <SliceZone<AccountPageContext>
        slices={page.data.slices}
        components={components}
        context={{ searchParams, user, partner }}
      />
    </div>
  );
}

export async function generateMetadata({ params }: { params: Params }) {
  const page = await queryPage(params.uid);
  return prismicPageToMetadata(page);
}

export async function generateStaticParams() {
  const client = createClient();
  const pages = await client.getAllByType(PrismicPageType.ACCOUNT_PAGE);

  return pages.map((page) => {
    return { uid: page.uid };
  });
}

const queryPage = async (uid: string) => {
  const client = createClient();

  return await client
    .getByUID<AccountpageDocument>(PrismicPageType.ACCOUNT_PAGE, uid)
    .catch(() => {
      console.log('Page not found');
      return notFound();
    });
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/[uid]/not-found.tsx

import NotFoundView from '@components/not-found-view';

export default function NotFound() {
  return <NotFoundView href="/account" />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/esthetician/error.tsx

'use client';

import React from 'react';

import ErrorView from '@components/error-view';

const Error: React.FC = () => {
  return <ErrorView />;
};

export default Error;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/esthetician/loading.tsx

import LoadingCircles from '@components/loading-indicators/loading-circles';

export default function Loading() {
  return <LoadingCircles />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/esthetician/page.tsx

import { notFound } from 'next/navigation';
import { EstheticianPageDocument } from 'prismicio-types';

import { createClient } from '@/prismicio';
import { components } from '@/slices';
import { getUser } from '@/utils/helpers/helpers';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { PrismicNextImage } from '@prismicio/next';
import { PrismicRichText, SliceZone } from '@prismicio/react';
import { PrismicPageType } from '@utils/prismic/enums';

type Params = { uid: string };
export default async function Page({
  searchParams,
}: {
  params: Params;
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  const [page, user] = await Promise.all([queryPage(), getUser()]);

  if (user.hasConcierge) {
    return (
      <div className="fixed inset-0 bg-[#FAFBFC] w-full pl-0 pt-16 overflow-auto lg:pt-0 lg:pl-72">
        <div className="w-full max-w-7xl px-4 py-10 sm:px-8 sm:py-12 lg:py-16 lg:px-12">
          <section>
            <div className="max-w-[312px] mb-6 aspect-[4.8/1]">
              <PrismicNextImage field={page.data.brand_image} />
            </div>
            <h1 className="mb-2 font-dmsans font-semibold text-xl sm:text-2xl text-black">
              {page.data.title}
            </h1>
            <div className="max-w-md">
              <PrismicRichText
                field={page.data.description}
                components={{
                  paragraph: ({ children }) => (
                    <p className="font-dmsans text-base sm:text-lg text-gray-600">
                      {children}
                    </p>
                  ),
                }}
              />
            </div>
          </section>
          <SliceZone
            slices={page.data.slices}
            components={components}
            context={{ searchParams, user }}
          />
        </div>
      </div>
    );
  }

  return (
    <SliceZone
      slices={page.data.slices2}
      components={components}
      context={{ searchParams, user }}
    />
  );
}

export async function generateMetadata() {
  const page = await queryPage();
  return prismicPageToMetadata(page);
}

const queryPage = async () => {
  const client = createClient();

  return await client
    .getSingle<EstheticianPageDocument>(PrismicPageType.ESTHETICIAN_PAGE)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/error.tsx

'use client';

import React from 'react';

import ErrorView from '@components/error-view';

const Error: React.FC = () => {
  return <ErrorView />;
};

export default Error;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/loading.tsx

import DashboardSkeleton from '@messaging/loading-skeletons/dashboard-skeleton';

export default function Loading() {
  return <DashboardSkeleton />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/page.tsx

import { notFound } from 'next/navigation';
import { MessagingpageDocument } from 'prismicio-types';

import { createClient } from '@/prismicio';
import { getThreads, getUser, getUserCases } from '@/utils/helpers/helpers';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import Dashboard from '@messaging/dashboard/dashboard';
import { ThreadCustomType } from '@models/extensions/messaging';
import { PrismicPageType } from '@utils/prismic/enums';

export const dynamic = 'force-dynamic';

const sortThreads = (a: ThreadCustomType, b: ThreadCustomType) => {
  const compareDateA = a.messages?.[0]?.sentWhen ?? a.updatedAt;
  const compareDateB = b.messages?.[0]?.sentWhen ?? b.updatedAt;
  return compareDateA < compareDateB ? 1 : -1;
};

export default async function Page({
  searchParams,
}: {
  searchParams: { [key: string]: string | undefined };
}) {
  const [threads, user, page, cases] = await Promise.all([
    getThreads(),
    getUser(),
    queryPage(),
    getUserCases(),
  ]);

  const threadId = searchParams['threadId'] ? searchParams.threadId : null;

  const initialThread = (threads ?? []).find(
    (thread) => thread.id === threadId
  );

  return (
    <Dashboard
      user={user}
      cases={cases}
      threads={(threads ?? []).sort(sortThreads)}
      initialThread={initialThread}
      pageData={page.data}
    />
  );
}

export async function generateMetadata() {
  const page = await queryPage();
  return prismicPageToMetadata(page);
}

const queryPage = async () => {
  const client = createClient();

  return await client
    .getSingle<MessagingpageDocument>(PrismicPageType.MESSAGING_PAGE)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/contexts/modal-context.tsx

import React from 'react';

import { CaseInclude } from '@/app/shared/types';
import { ThreadType, User } from '@prisma/client';

interface IModalContext {
  open: boolean;
  currentStep: number;
  user: User;
  cases: CaseInclude[];
  selectedCase: CaseInclude | null;
  messageType: ThreadType;
  reset: () => void;
  setOpen: (open: boolean, initialView?: number) => void;
  setCurrentStep: (step: number) => void;
  setSelectedCase: (selectedCase: CaseInclude | null) => void;
  setMessageType: (type: ThreadType) => void;
}

export const ModalContext = React.createContext<IModalContext>({
  open: false,
  currentStep: 0,
  user: {} as any,
  cases: [],
  selectedCase: null,
  messageType: ThreadType.SUPPORT,
  reset: () => {},
  setOpen: () => {},
  setCurrentStep: () => {},
  setSelectedCase: () => {},
  setMessageType: () => {},
});

export function ModalContextProvider({
  user,
  cases,
  children,
}: {
  user: User;
  cases: CaseInclude[];
  children: React.ReactNode;
}) {
  const [open, setOpen] = React.useState(false);
  const [currentStep, setCurrentStep] = React.useState(0);
  const [selectedCase, setSelectedCase] = React.useState<CaseInclude | null>(
    null
  );
  const [messageType, setMessageType] = React.useState<ThreadType>(
    ThreadType.SUPPORT
  );

  const reset = () => {
    setCurrentStep(0);
    setSelectedCase(null);
    setMessageType(ThreadType.SUPPORT);
  };

  const handleModalOpen = (isOpen: boolean, initialView = 0) => {
    if (isOpen) {
      reset();
    }
    setCurrentStep(initialView);
    setOpen(isOpen);
  };

  return (
    <ModalContext.Provider
      value={{
        open,
        currentStep,
        user,
        cases,
        selectedCase,
        messageType,
        reset,
        setOpen: handleModalOpen,
        setCurrentStep,
        setSelectedCase,
        setMessageType,
      }}
    >
      {children}
    </ModalContext.Provider>
  );
}

export default ModalContextProvider;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/contexts/messaging-context.tsx

import { MessagingpageDocumentData } from 'prismicio-types';
import React from 'react';

import { ExtendedUser } from '@/app/shared/types';

interface IMessagingContext {
  user: ExtendedUser;
  content: MessagingpageDocumentData;
}

export const MessagingContext = React.createContext<IMessagingContext | null>(
  null
);

export function MessagingContextProvider({
  user,
  pageData,
  children,
}: {
  user: ExtendedUser;
  pageData: MessagingpageDocumentData;
  children: React.ReactNode;
}) {
  return (
    <MessagingContext.Provider value={{ user, content: pageData }}>
      {children}
    </MessagingContext.Provider>
  );
}

export default MessagingContextProvider;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/no-threads-view.tsx

import React from 'react';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import ButtonOutline from '@components/buttons/button-outline';
import { useModalContext } from '@messaging-hooks/use-modal-context';

const NoThreadsView: React.FC = () => {
  const { content } = useMessagingContext();
  const { setOpen } = useModalContext();

  const handleSupportClick = () => {
    setOpen(true, 2);
  };

  return (
    <div className="flex justify-center items-center w-full h-full">
      <div className="flex flex-col gap-8 items-center justify-center p-4 w-full px-4 max-w-none sm:max-w-2xl">
        <p className="font-dmsans font-medium text-gray-900 text-xl sm:text-3xl text-center">
          {content.no_threads_title}
        </p>
        {content.no_threads_video_link && (
          <div
            className="relative overflow-hidden w-full aspect-video rounded-lg border border-white border-inset"
            style={{ paddingBottom: 'calc(56.25% - 1px)' }}
          >
            <iframe
              src={content.no_threads_video_link}
              loading="lazy"
              title="Synthesia video player - Message Center: No Threads"
              allow="encrypted-media; fullscreen;"
              style={{
                position: 'absolute',
                width: '100%',
                height: '100%',
                top: 0,
                left: 0,
                bottom: 0,
                right: 0,
                border: 'none',
                padding: 0,
                margin: 0,
                overflow: 'hidden',
              }}
            ></iframe>
          </div>
        )}
        <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 sm:gap-8 justify-between">
          <div className="flex flex-col gap-4">
            <CustomPrismicLink
              field={content.no_threads_medical_cta}
              variant="solid-accent"
              className="py-2"
            >
              {content.no_threads_medical_cta_title}
            </CustomPrismicLink>
            <p className="px-3 font-dmsans text-sm text-gray-500 flex-shrink-0">
              {content.no_threads_medical_cta_description}
            </p>
          </div>
          <div className="flex flex-col gap-4">
            <ButtonOutline
              variant="gray"
              size="lg"
              className="py-2"
              onClick={handleSupportClick}
            >
              {content.no_threads_support_cta_title}
            </ButtonOutline>
            <p className="px-3 font-dmsans text-sm text-gray-500">
              {content.no_threads_support_cta_description}
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default NoThreadsView;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/search.tsx

import debounce from 'lodash.debounce';
import React from 'react';
import { useState } from 'react';
import { twMerge } from 'tailwind-merge';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import ButtonBase from '@/app/shared/components/buttons/button-base';
import { getFamilyMemberHeader } from '@/utils/utils';
import { Combobox as HeadlessCombobox } from '@headlessui/react';
import { XMarkIcon } from '@heroicons/react/20/solid';
import { SearchLg } from '@untitled-ui/icons-react';

export interface ISearchResult {
  id: string;
  fromUserId: string;
  threadId: string;
  sentWhen: string;
  in: string;
}

interface ISearchProps {
  className?: string;
  value?: string;
  onChange?: (searchResult: ISearchResult) => void;
}

const getSearchResults = async (query: string) => {
  const encondedQuery = encodeURI(query);
  const response = await fetch(
    `/api/messaging/messages/search?q=${encondedQuery}&take=${5}`,
    {
      method: 'GET',
      headers: getFamilyMemberHeader(),
    }
  );
  return await response.json();
};

const Search: React.FC<ISearchProps> = (p) => {
  const { content } = useMessagingContext();
  const [query, setQuery] = useState('');
  const [hasSearched, setHasSearched] = useState(false);
  const [searching, setSearching] = useState(false);
  const [error, setError] = useState(false);
  const [selected, setSelected] = useState<ISearchResult | null>(null);
  const [searchResults, setSearchResults] = useState<
    { phrase: string; in: string }[]
  >([]);

  const handleSearch = async (searchQuery: string) => {
    setError(false);
    setSearching(true);
    try {
      const results = await getSearchResults(searchQuery);
      setSearchResults(results ?? []);
      setHasSearched(true);
    } catch (_e) {
      setError(true);
    } finally {
      setSearching(false);
    }
  };

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const debouncedSearch = React.useCallback(debounce(handleSearch, 500), []);

  const handleQueryChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setQuery(e.target.value);

    if (e.target.value.length > 3) {
      debouncedSearch(e.target.value);
    }
  };

  const handleSelect = (result: ISearchResult) => {
    setSelected(result);
    p?.onChange?.(result);
  };

  const handleReset = () => {
    debouncedSearch.cancel();
    setSearching(false);
    setSearchResults([]);
    setHasSearched(false);
    setError(false);
    setQuery('');
  };

  return (
    <div className="w-full max-w-lg">
      <HeadlessCombobox as="div" value={selected} onChange={handleSelect}>
        <div className="relative">
          <HeadlessCombobox.Input
            className="peer w-full rounded-md border-0 h-10 focus:shadow-drop bg-white py-1.5 pl-10 pr-10 font-medium text-gray-900 shadow-sm ring-1 ring-gray-300 focus:ring-1 focus:ring-accent-300 sm:text-sm sm:leading-6"
            placeholder={content.search_placeholder as string}
            value={query}
            onChange={handleQueryChange}
            displayValue={(option: string) => option}
          />
          <HeadlessCombobox.Button className="absolute inset-y-0 left-0 flex items-center rounded-r-md px-2 text-gray-700 peer-focus:text-accent-500 focus:outline-none">
            <SearchLg className="h-5 w-5" viewBox="0 0 24 24" />
          </HeadlessCombobox.Button>
          {query.length > 0 && (
            <ButtonBase className="absolute inset-y-0 right-0 flex items-center rounded-r-md px-2 focus:outline-none">
              <XMarkIcon
                className="h-5 w-5 text-gray-400"
                onClick={handleReset}
              />
            </ButtonBase>
          )}

          <HeadlessCombobox.Options className="absolute z-10 h-fit bottom-full mb-3 sm:top-full sm:mb-0 sm:mt-2 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm">
            {searching && (
              <div className="py-3 px-6 flex flex-col gap-2">
                {[...Array(5)].map((_e, i) => (
                  <div
                    key={`search-skeleton-${i}`}
                    className="h-8 bg-gray-100 rounded-lg py-2 px-4 w-full animate-pulse"
                  />
                ))}
              </div>
            )}
            {!searching && error && (
              <div className="py-1 px-6">
                <div className="bg-gray-50 font-dmsans text-gray-500 text-sm rounded-lg py-2 px-4 flex justify-between items-center w-full">
                  {content.search_error_text}
                </div>
              </div>
            )}
            {!searching && !error && (
              <>
                {searchResults.length > 0 && (
                  <>
                    {searchResults.map((result, i) => (
                      <HeadlessCombobox.Option
                        key={`option-${i}`}
                        value={result}
                        className="relative cursor-default select-none py-1 px-6 text-gray-700 font-medium"
                      >
                        {({ active }) => (
                          <div
                            className={twMerge([
                              'bg-gray-50 font-dmsans text-gray-500 text-sm rounded-lg py-2 px-4 flex justify-between items-center w-full',
                              active && 'bg-gray-100',
                            ])}
                          >
                            <span className="block truncate font-medium w-3/4 max-w-prose">
                              {result.phrase}
                            </span>
                            <span className="block truncate font-medium text-xs">
                              {`in ${result.in}`}
                            </span>
                          </div>
                        )}
                      </HeadlessCombobox.Option>
                    ))}
                  </>
                )}
                {searchResults.length === 0 && hasSearched && (
                  <div className="py-1 px-6">
                    <div className="bg-gray-50 font-dmsans text-gray-500 text-sm rounded-lg py-2 px-4 flex justify-between items-center w-full">
                      {content.search_no_results}
                    </div>
                  </div>
                )}
              </>
            )}
          </HeadlessCombobox.Options>
        </div>
      </HeadlessCombobox>
    </div>
  );
};

export default Search;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/no-messages-view.tsx

import Image from 'next/image';
import React from 'react';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import { ThreadType } from '@prisma/client';

interface INoMessagesView {
  threadType: ThreadType;
}

const NoMessagesView: React.FC<INoMessagesView> = (p) => {
  const { content } = useMessagingContext();
  return (
    <div className="flex flex-1 overflow-y-auto justify-center p-4">
      <div
        className="relative flex flex-col justify-center items-center text-center w-full h-full md:max-w-[480px] md:max-h-[480px]"
        style={{
          backgroundImage: `url(/assets/background-ripple.svg)`,
          backgroundPosition: '50%',
          backgroundRepeat: 'no-repeat,repeat',
        }}
      >
        <div className="relative h-[56px] w-full flex items-center justify-center">
          <Image
            src="/assets/icons/chat-box-icon.svg"
            alt=""
            className="w-11 h-11 sm:w-14 sm:h-14"
            width={56}
            height={56}
          />
          <div className="absolute top-full w-full mt-2 sm:mt-3.5 flex flex-col items-center">
            <p className="font-dmsans font-medium text-lg sm:text-3xl text-gray-900">
              {content.no_messages_title}
            </p>
            <p className="font-dmsans text-sm sm:text-md text-gray-600 max-w-sm">
              {p.threadType === ThreadType.MEDICAL
                ? content.no_messages_medical_description
                : content.no_messages_support_description}
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default NoMessagesView;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/avatar.tsx

'use client';

import Image from 'next/image';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import { IFamilyMember } from '@/app/shared/types';
import { User } from '@prisma/client';
import { useQuery } from '@tanstack/react-query';

interface IAvatarProps {
  user: User | IFamilyMember;
  className?: string;
  isPrimary?: boolean;
}

const getAvatarImage = async (id: string) => {
  const response = await fetch(`/api/user/avatar?id=${id}`);
  return await response.json();
};

const Avatar: React.FC<IAvatarProps> = (p) => {
  const { user, className, isPrimary = false } = p;

  const { isLoading, data } = useQuery(
    ['avatar', user.id],
    () => getAvatarImage(user.id),
    {
      refetchOnWindowFocus: false,
      refetchInterval: 3600000, // 1hr same as expire time
      cacheTime: 3600000,
      staleTime: 3600000,
    }
  );

  if (isLoading) {
    return (
      <div
        className={twMerge(
          'inline-block h-10 w-10 rounded-full bg-gray-200 animate-pulse',
          className
        )}
      />
    );
  }

  if (data && data.s3Url) {
    return (
      <span className="relative">
        <Image
          className={twMerge(
            'inline-block h-10 w-10 rounded-full bg-gray-50',
            className
          )}
          src={data.s3Url}
          alt=""
          width="256"
          height="256"
        />
        {/* {isPrimary && (
          <svg
            width="12"
            height="11"
            viewBox="0 0 12 11"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
            className="absolute -right-1 -top-0.5 block"
          >
            <path
              d="M7.63548 3.74896L6.40353 1.25276C6.23846 0.918295 5.76153 0.918295 5.59647 1.25276L4.36452 3.74896L1.6098 4.14924C1.2407 4.20287 1.09332 4.65646 1.3604 4.9168L3.35374 6.85982L2.88318 9.60341C2.82013 9.97102 3.20597 10.2514 3.5361 10.0778L6 8.78244L8.4639 10.0778C8.79403 10.2514 9.17987 9.97102 9.11682 9.60341L8.64626 6.85982L10.6396 4.9168C10.9067 4.65646 10.7593 4.20287 10.3902 4.14924L7.63548 3.74896Z"
              fill="black"
              stroke="#99F6E0"
              stroke-width="0.5"
            />
          </svg>
        )} */}
      </span>
    );
  }

  return (
    <div
      className={twMerge(
        'inline-flex h-10 w-10 text-lg rounded-full bg-accent-500 items-center justify-center text-white font-dmsans',
        className
      )}
    >
      {(user.firstName ? user.firstName : user.email)
        ?.charAt(0)
        ?.toUpperCase() ?? 'A'}
    </div>
  );
};

export default Avatar;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/messages/support-message.tsx

import dayjs from 'dayjs';
import Image from 'next/image';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import { Message, User } from '@prisma/client';

interface ISupportMessageProps extends Message {
  user: User;
}

const SupportMessage: React.FC<ISupportMessageProps> = (p) => {
  const { content } = useMessagingContext();

  const messageBreaks = React.useMemo(
    () => p.content?.split(/\r?\n/).filter((s) => s !== '' && s != null),
    [p.content]
  );

  return (
    <div className="flex">
      <div className="mr-3 flex-shrink-0">
        <Image
          src="/assets/support_avatar.svg"
          alt="Cortina Support"
          width={40}
          height={40}
        />
      </div>
      <div>
        <div className="flex flex-row gap-3 mb-2 items-center">
          <p className="font-dmsans text-sm font-medium text-gray-700">
            {content.support_message_name}
          </p>
          <p className="font-dmsans text-xs font-regular text-gray-600">
            {dayjs(p.sentWhen).format('h:mma')}
          </p>
        </div>
        {messageBreaks?.map((msg, i) => (
          <div
            key={`message-${p.id}-${i}`}
            className={twMerge(
              'bg-gray-100 p-3.5 max-w-xl',
              i === 0 ? 'rounded-b-lg rounded-tr-lg' : 'rounded-lg mt-1.5'
            )}
          >
            <p className="font-dmsans text-md text-black/80">{msg}</p>
          </div>
        ))}
      </div>
    </div>
  );
};

export default SupportMessage;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/messages/user-message.tsx

import dayjs from 'dayjs';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import Avatar from '@messaging/avatar';
import { MessageUserInclude } from '@models/extensions/messaging';
import { User } from '@prisma/client';
import { getFullName } from '@utils/get-full-name';

interface IUserMessageProps extends MessageUserInclude {
  user: User;
}

const UserMessage: React.FC<IUserMessageProps> = (p) => {
  const isCurrentUserMessage = p.fromUserId === p.user.id;

  const messageBreaks = React.useMemo(
    () => p.content?.split(/\r?\n/).filter((s) => s !== '' && s != null),
    [p.content]
  );

  return (
    <div className="flex">
      <div className="mr-3 flex-shrink-0">
        <Avatar user={p.fromUser} />
      </div>
      <div>
        <div className="flex flex-row gap-3 mb-2 items-center">
          <p className="font-dmsans text-sm font-medium text-gray-700">
            {isCurrentUserMessage
              ? 'You'
              : getFullName(
                  p.fromUser?.firstName,
                  p.fromUser?.lastName,
                  p.fromUser?.email
                )}
          </p>
          <p className="font-dmsans text-xs font-regular text-gray-600">
            {dayjs(p.sentWhen).format('h:mma')}
          </p>
        </div>
        {messageBreaks?.map((msg, i) => (
          <div
            key={`message-${p.id}-${i}`}
            className={twMerge(
              'p-3.5 max-w-xl',
              isCurrentUserMessage ? 'pl-0 py-1' : 'bg-gray-100',
              i === 0 ? 'rounded-b-lg rounded-tr-lg' : 'rounded-lg mt-1.5'
            )}
          >
            <p className="font-dmsans text-md text-black/80">{msg}</p>
          </div>
        ))}
      </div>
    </div>
  );
};

export default UserMessage;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/messages/message.tsx

import { useRouter } from 'next/navigation';
import React from 'react';

import { getFamilyMemberHeader } from '@/utils/utils';
import MediaAttachment from '@messaging/media-attachment/media-attachment';
import SupportMessage from '@messaging/messages/support-message';
import UserMessage from '@messaging/messages/user-message';
import {
  MessageUserInclude,
  ThreadCustomType,
} from '@models/extensions/messaging';
import { Message as MessageType, User, UserRole } from '@prisma/client';
import { useMutation } from '@tanstack/react-query';

export interface IMessageProps extends MessageUserInclude {
  selectedThread: ThreadCustomType;
  user: User;
}

const patchMessage = (messageId: string) => {
  return fetch(`/api/messaging/messages/${messageId}/mark-read`, {
    method: 'PATCH',
    headers: getFamilyMemberHeader(),
  });
};

const Message: React.FC<IMessageProps> = (p) => {
  const router = useRouter();
  const markAsRead = useMutation({
    mutationFn: async (messageId: string) => {
      const res = await patchMessage(messageId);
      return (await res.json()) as MessageType;
    },
    retry: 3,
    retryDelay: 3000,
  });

  const isSupport = p.fromUser.roles.includes(UserRole.CORTINA_SUPPORT);

  React.useEffect(() => {
    if (!p.readByIds.includes(p.user.id)) {
      markAsRead.mutate(p.id, { onSettled: () => router.refresh() });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      {isSupport ? <SupportMessage {...p} /> : <UserMessage {...p} />}
      <div className="ml-[52px] flex flex-row gap-x-4 gap-y-0 flex-wrap">
        {p.media.map((mediaObject, i) => (
          <div key={`${mediaObject.mediaUrl}-${i}`}>
            {mediaObject?.mediaUrl && (
              <div className="h-24 w-24 lg:h-48 lg:w-48 my-4">
                <MediaAttachment
                  mediaUrl={mediaObject.mediaUrl}
                  mediaType={mediaObject.mediaType}
                  threadId={p.selectedThread.id}
                />
              </div>
            )}
          </div>
        ))}
      </div>
    </>
  );
};

export default Message;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/media-upload-modal/media-upload-modal.tsx

'use client';

import React, { Fragment } from 'react';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import ButtonOutline from '@components/buttons/button-outline';
import ButtonSolid from '@components/buttons/button-solid';
import { queryClient } from '@components/context-wrapper';
import FileUploadComponent, {
  type ICustomFile,
} from '@components/file-upload/file-upload';
import { Dialog, Transition } from '@headlessui/react';
import { XMarkIcon } from '@heroicons/react/24/outline';
import { MediaType, Message } from '@prisma/client';
import { useMutation } from '@tanstack/react-query';
import {
  isFileTypeValid,
  getMediaTypeForFile,
} from '@utils/file-upload/upload-helpers';

interface IMediaUploadModalProps {
  draftMessage: Message;
  open: boolean;
  setOpen: (isOpen: boolean) => void;
}
export enum UploadStatus {
  UPLOADING = 'UPLOADING',
  ERROR = 'ERROR',
  SUCCESS = 'SUCCESS',
}

const uploadFile: (
  file: ICustomFile,
  meta?: { [key: string]: any }
) => Promise<ICustomFile> = async (file, meta) => {
  const formData = new FormData();
  formData.append('file', file.file, file.name);
  let newFileState = { ...file };

  try {
    const response = await fetch(
      `/api/messaging/messages/${meta?.messageId}/media`,
      {
        method: 'POST',
        headers: {
          messageId: meta?.messageId,
        },
        body: formData,
      }
    );

    const uploadResult = await response.json();

    if (uploadResult && uploadResult.length > 0) {
      newFileState = {
        ...file,
        status: uploadResult[0].status,
        s3Url: uploadResult[0].s3Url,
      } as ICustomFile;
    } else {
      throw new Error(`Upload Failed for ${file.id}`);
    }
  } catch (e) {
    newFileState.status = UploadStatus.ERROR;
  }
  return newFileState;
};

const updateDraft = (
  messageId: string,
  media: { mediaUrl: string; mediaType: MediaType }[]
) => {
  return fetch(`/api/messaging/messages/${messageId}/update-draft`, {
    method: 'PATCH',
    body: JSON.stringify({
      media,
    }),
  });
};

const MediaUploadModal: React.FC<IMediaUploadModalProps> = (p) => {
  const { content } = useMessagingContext();
  const [selectedFiles, setSelectedFiles] = React.useState<ICustomFile[]>([]);

  const saveDraft = useMutation({
    mutationFn: async (media: { mediaUrl: string; mediaType: MediaType }[]) => {
      const res = await updateDraft(p.draftMessage.id, media);
      return (await res.json()) as Message;
    },
  });

  React.useEffect(() => {
    setSelectedFiles([]);
  }, [p.open]);

  const handleFieldChange = (files: ICustomFile[]) => {
    setSelectedFiles(files);
  };

  const handleAttachFiles = () => {
    const mediaObjects = selectedFiles.filter(
      (file): file is ICustomFile & { s3url: string } => !!file.s3Url
    );
    const media = mediaObjects.map((file) => ({
      mediaUrl: file.s3Url ?? '',
      mediaType: getMediaTypeForFile(file.type),
    }));

    if (media.length > 0) {
      saveDraft.mutate(media, {
        onSuccess: () => {
          queryClient.invalidateQueries(['draft', p.draftMessage.threadId]);
          p.setOpen(false);
        },
      });
    }
  };

  return (
    <Transition.Root show={p.open} as={Fragment}>
      <Dialog
        as="div"
        className="relative z-50"
        onClose={() => p.setOpen(false)}
      >
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity" />
        </Transition.Child>

        <div className="fixed inset-0 z-10 w-screen overflow-y-auto">
          <div className="flex min-h-full justify-center p-4 text-center items-center sm:p-0">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
              enterTo="opacity-100 translate-y-0 sm:scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 translate-y-0 sm:scale-100"
              leaveTo="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
            >
              <Dialog.Panel className="relative w-full transform overflow-hidden rounded-lg bg-white px-4 pb-4 pt-5 text-left shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-[480px] sm:p-6">
                <div className="absolute right-0 top-0 hidden pr-4 pt-4 sm:block">
                  <button
                    type="button"
                    className="rounded-md bg-white text-gray-500 hover:text-gray-600 focus:outline-none focus:ring-2 focus:ring-accent-300 focus:ring-offset-2"
                    onClick={() => p.setOpen(false)}
                  >
                    <span className="sr-only">Close</span>
                    <XMarkIcon className="h-6 w-6" aria-hidden="true" />
                  </button>
                </div>
                <div className="sm:flex sm:items-start">
                  <div className="mt-3 text-left sm:mt-0 sm:text-left">
                    <Dialog.Title
                      as="h3"
                      className="text-base font-semibold leading-6 text-gray-900"
                    >
                      {content.upload_modal_title}
                    </Dialog.Title>
                    <div className="mt-2">
                      <p className="text-sm text-gray-500">
                        {content.upload_modal_description}
                      </p>
                    </div>
                  </div>
                </div>
                <div className="mt-4 max-w-xl">
                  <FileUploadComponent
                    id="messaging-media-upload"
                    multiple
                    isFileTypeValid={isFileTypeValid}
                    handleFieldChange={handleFieldChange}
                    meta={{ messageId: p.draftMessage.id }}
                    uploadFile={uploadFile}
                    content={{
                      buttonText: content.upload_dropzone_cta_text as string,
                      afterButtonText: content.upload_dropzone_text as string,
                      acceptedFileTypeText:
                        content.upload_dropzone_limits_text as string,
                      invalidFileTypeText:
                        content.upload_dropzone_invalid_file_type as string,
                    }}
                  />
                </div>
                <div className="mt-4 flex flex-col-reverse gap-2 sm:grid sm:grid-cols-2 sm:gap-4">
                  <ButtonOutline
                    variant="gray"
                    className="w-full"
                    onClick={() => p.setOpen(false)}
                  >
                    {content.upload_modal_cancel_button_text}
                  </ButtonOutline>
                  <ButtonSolid
                    variant="accent"
                    className="w-full"
                    onClick={handleAttachFiles}
                  >
                    {content.upload_modal_attach_button_text}
                  </ButtonSolid>
                </div>
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition.Root>
  );
};

export default MediaUploadModal;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/new-message/case-select-view.tsx

import { CaseInclude } from '@/app/shared/types';
import CasePicker from '@components/case-picker/case-picker';
import { Dialog } from '@headlessui/react';
import { useMessagingContext } from '@messaging-hooks/use-messaging-context';
import { useModalContext } from '@messaging-hooks/use-modal-context';

const CaseSelectView = () => {
  const { content } = useMessagingContext();
  const { selectedCase, cases, setSelectedCase, setCurrentStep } =
    useModalContext();

  const handleCaseSelect = (selectedCase: CaseInclude) => {
    setSelectedCase(selectedCase);
    setCurrentStep(2);
  };

  return (
    <div className="max-w-none sm:w-[400px]">
      <div className="px-4 pb-4">
        <Dialog.Title
          as="h3"
          className="font-dmsans text-lg font-medium leading-6 text-gray-900"
        >
          {content.select_case_modal_title}
        </Dialog.Title>
        <p className="text-gray-600 text-sm mt-1.5 font-normal">
          {content.select_case_modal_description}
        </p>
      </div>
      <div className="w-full border-t border-gray-300" />
      <div className="mt-2 px-4 pt-3">
        <CasePicker
          cases={cases}
          currentCase={selectedCase}
          placeholder="Please select"
          onCaseChange={handleCaseSelect}
          listBoxOnly
        />
      </div>
    </div>
  );
};

export default CaseSelectView;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/new-message/new-message-modal.tsx

'use client';

import { Fragment } from 'react';
import React from 'react';

import { Transition, Dialog } from '@headlessui/react';
import { XMarkIcon } from '@heroicons/react/20/solid';
import { useModalContext } from '@messaging-hooks/use-modal-context';
import CaseSelectView from '@messaging/new-message/case-select-view';
import InitialView from '@messaging/new-message/initial-view';
import InputMessageView from '@messaging/new-message/input-message-view';

export const MODAL_STEPS = [InitialView, CaseSelectView, InputMessageView];

const NewMessageModal = () => {
  const { open, setOpen, currentStep } = useModalContext();

  const View = MODAL_STEPS?.[currentStep] ?? InitialView;

  return (
    <Transition.Root show={open} as={Fragment}>
      <Dialog as="div" className="relative z-50" open={open} onClose={() => {}}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-gray-500 bg-opacity-40 transition-opacity" />
        </Transition.Child>

        <div className="fixed inset-0 z-10 w-screen overflow-y-auto">
          <div className="flex min-h-full items-start mt-10 justify-center p-4 text-center sm:mt-[10%] sm:p-0">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
              enterTo="opacity-100 translate-y-0 sm:scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 translate-y-0 sm:scale-100"
              leaveTo="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
            >
              <Dialog.Panel className="relative transform rounded-lg bg-white pb-4 pt-5 text-left shadow-xl transition-all sm:my-8 w-full sm:w-auto sm:max-w-2xl">
                <div className="absolute right-0 top-0 pr-4 pt-4 block">
                  <button
                    type="button"
                    className="rounded-md bg-white text-gray-500 hover:text-gray-600 focus:outline-none focus:ring-2 focus:ring-accent-500 focus:ring-offset-2"
                    onClick={() => setOpen(false)}
                  >
                    <span className="sr-only">Close</span>
                    <XMarkIcon className="h-6 w-6" aria-hidden="true" />
                  </button>
                </div>
                <View />
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition.Root>
  );
};

export default NewMessageModal;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/new-message/new-message-modal-trigger.tsx

'use client';

import React from 'react';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import ButtonOutline from '@components/buttons/button-outline';
import { useModalContext } from '@messaging-hooks/use-modal-context';
import { Edit05 } from '@untitled-ui/icons-react';

const NewMessageModalTrigger = () => {
  const { content } = useMessagingContext();
  const { setOpen } = useModalContext();

  return (
    <ButtonOutline
      variant="gray"
      size="sm"
      className="flex items-center gap-2"
      onClick={() => setOpen(true)}
    >
      <Edit05
        className="text-accent-700"
        width={20}
        height={20}
        viewBox="0 0 24 24"
      />
      <span className="font-dmsans text-gray-700 font-semibold text-sm">
        {content.new_message_button_text}
      </span>
    </ButtonOutline>
  );
};

export default NewMessageModalTrigger;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/new-message/input-message-view.tsx

import { usePathname, useRouter } from 'next/navigation';
import React from 'react';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import { getFamilyMemberHeader } from '@/utils/utils';
import ButtonSolid from '@components/buttons/button-solid';
import TextArea from '@components/form-controls/text-area';
import LoadingSpinner from '@components/loading-indicators/loading-spinner';
import { Dialog } from '@headlessui/react';
import { useModalContext } from '@messaging-hooks/use-modal-context';
import { Case, Thread, ThreadType } from '@prisma/client';
import { useMutation } from '@tanstack/react-query';

const putThread = (
  type: ThreadType,
  message: string,
  userId: string,
  selectedCase?: Case | null
) => {
  const body: {
    type: ThreadType;
    initialMessage: string;
    participants: string[];
    caseRef?: string;
  } = {
    type,
    initialMessage: message,
    participants: [userId],
  };

  if (type === ThreadType.MEDICAL) {
    if (!selectedCase) {
      throw new Error('Case ID is required for medical thread');
    }

    body.caseRef = selectedCase.id;
    if (selectedCase.physicianId) {
      body.participants.push(selectedCase.physicianId);
    }
  }

  return fetch(`/api/messaging/threads`, {
    method: 'PUT',
    body: JSON.stringify(body),
    headers: getFamilyMemberHeader(),
  });
};

const InputMessageView = () => {
  const { content } = useMessagingContext();
  const { setOpen, messageType, selectedCase, user } = useModalContext();
  const router = useRouter();
  const pathname = usePathname();
  const createThread = useMutation({
    mutationFn: async (thread: {
      type: ThreadType;
      message: string;
      userId: string;
      selectedCase?: Case | null;
    }) => {
      const res = await putThread(
        thread.type,
        thread.message,
        thread.userId,
        thread.selectedCase
      );
      return (await res.json()) as Thread;
    },
    onSuccess: (data) => {
      // Refetch threads
      const params = new URLSearchParams();
      params.set('threadId', data.id);

      router.push(pathname + '?' + params.toString());
    },
  });
  const [message, setMessage] = React.useState('');
  const [submitting, setSubmitting] = React.useState(false);
  const [error, setError] = React.useState(false);
  const [valid, setValid] = React.useState(false);

  const handleMessage = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    if (e.target.value && e.target.value.length > 1) {
      setValid(true);
    } else {
      setValid(false);
    }
    setMessage(e.target.value);
  };

  const handleSendMessage = () => {
    setSubmitting(true);
    createThread.mutate(
      {
        type: messageType,
        message,
        userId: user.id,
        selectedCase: selectedCase,
      },
      {
        onSuccess: () => {
          setSubmitting(false);
          setOpen(false);
        },
        onError: () => {
          setSubmitting(false);
          setError(true);
        },
      }
    );
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      handleSendMessage();
    }
  };

  const isMedical = messageType === ThreadType.MEDICAL;

  return (
    <div className="sm:w-[640px]">
      <div className="px-4 pb-4">
        <Dialog.Title
          as="h3"
          className="font-dmsans text-lg font-medium leading-6 text-gray-900"
        >
          {isMedical
            ? content.message_modal_medical_title
            : content.message_modal_support_title}
        </Dialog.Title>
        <p className="text-gray-600 text-sm mt-1.5 font-normal">
          {isMedical
            ? content.message_modal_medical_description
            : content.message_modal_support_description}
        </p>
      </div>
      <div className="w-full border-t border-gray-300" />

      <div className="flex flex-col px-4 pt-3">
        <TextArea
          id="new-message-text-area"
          label="Enter Message"
          placeholder="Type message here..."
          value={message}
          onChange={handleMessage}
          onKeyDown={handleKeyDown}
          disabled={submitting}
          rows={5}
        />
        {error && (
          <p className="font-dmsans text-error-500 text-sm">
            {content.message_modal_error_text}
          </p>
        )}
        <ButtonSolid
          variant="accent"
          size="lg"
          className="ml-auto mt-3 py-2 flex flex-row gap-1 items-center justify-center"
          onClick={handleSendMessage}
          disabled={submitting || !valid}
        >
          {submitting ? (
            <>
              <LoadingSpinner fillClass="fill-accent-600" size="sm" />
              <span>{content.message_modal_sending_text}</span>
            </>
          ) : (
            <span>{content.message_modal_send_button_text}</span>
          )}
        </ButtonSolid>
      </div>
    </div>
  );
};

export default InputMessageView;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/new-message/initial-view.tsx

import React from 'react';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import ButtonSolid from '@components/buttons/button-solid';
import { Dialog } from '@headlessui/react';
import { useModalContext } from '@messaging-hooks/use-modal-context';
import { ThreadType } from '@prisma/client';

const InitialView = () => {
  const { content } = useMessagingContext();
  const { setMessageType, setCurrentStep } = useModalContext();

  const startSupportThread = () => {
    setMessageType(ThreadType.SUPPORT);
    setCurrentStep(2);
  };

  // Function for initial design. Commented out for now.
  // const startMedicalThread = () => {
  //   setMessageType(ThreadType.MEDICAL);
  //   setCurrentStep(1);
  // };

  return (
    <div className="max-w-none sm:max-w-sm">
      <div className="px-4 pb-4">
        <Dialog.Title
          as="h3"
          className="font-dmsans text-lg font-medium leading-6 text-gray-900"
        >
          {content.new_modal_title}
        </Dialog.Title>
        <p className="text-gray-600 text-sm mt-1.5 font-normal">
          {content.new_modal_description}
        </p>
      </div>
      <div className="w-full border-t border-gray-300" />
      <div className="mt-2 px-4 pt-3">
        <ButtonSolid
          variant="accent"
          size="lg"
          className="w-full"
          onClick={startSupportThread}
        >
          {content.new_modal_support_cta_title}
        </ButtonSolid>
        <p className="ml-3 my-2 text-sm text-gray-500">
          {content.new_modal_support_cta_description}
        </p>
        <CustomPrismicLink
          field={content.new_modal_medical_cta_link}
          variant="outline-gray"
          className="w-full mt-4 px-4 py-3.5 text-sm md:text-base text-center"
        >
          {content.new_modal_medical_cta_title}
        </CustomPrismicLink>
        <p className="ml-3 my-2 text-sm text-gray-500">
          {content.new_modal_medical_cta_description}
        </p>
      </div>
    </div>
  );
};

export default InitialView;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/dashboard/dashboard.tsx

'use client';

import { MessagingpageDocumentData } from 'prismicio-types';
import React from 'react';

import MessagingContextProvider from '@/app/(account)/account/messaging/contexts/messaging-context';
import { CaseInclude, ExtendedUser } from '@/app/shared/types';
import ModalContextProvider from '@messaging-contexts/modal-context';
import DesktopDashboard from '@messaging/dashboard/desktop-dashboard';
import NewMessageModal from '@messaging/new-message/new-message-modal';
import { ThreadCustomType } from '@models/extensions/messaging';

export interface IDashboardProps {
  user: ExtendedUser;
  cases: CaseInclude[];
  threads: ThreadCustomType[];
  initialThread?: ThreadCustomType;
  pageData: MessagingpageDocumentData;
}

const Dashboard: React.FC<IDashboardProps> = (p) => {
  return (
    <MessagingContextProvider user={p.user} pageData={p.pageData}>
      <ModalContextProvider user={p.user} cases={p.cases}>
        <DesktopDashboard {...p} />
        <NewMessageModal />
      </ModalContextProvider>
    </MessagingContextProvider>
  );
};

export default Dashboard;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/dashboard/mobile-dashboard.tsx

import dayjs from 'dayjs';
import { Fragment } from 'react';
import React from 'react';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import ButtonBase from '@components/buttons/button-base';
import { Transition } from '@headlessui/react';
import { IDashboardProps } from '@messaging/dashboard/dashboard';
import MessageList from '@messaging/message-list/message-list';
import NewMessageModalTrigger from '@messaging/new-message/new-message-modal-trigger';
import Search, { ISearchResult } from '@messaging/search';
import ThreadsList from '@messaging/threads/threads-list';
import { ThreadCustomType } from '@models/extensions/messaging';
import { ThreadType } from '@prisma/client';
import { ArrowLeft } from '@untitled-ui/icons-react';

const MobileDashboard: React.FC<
  IDashboardProps & {
    handleSearch: (searchResult: ISearchResult) => void;
    selectThread: (thread: ThreadCustomType | null) => void;
    selectedThread: ThreadCustomType | null;
    searchedMessageId?: string;
  }
> = (p) => {
  const { content } = useMessagingContext();
  const [showMessages, setShowMessages] = React.useState(false);

  const selectMessageThread = (thread: ThreadCustomType) => {
    p.selectThread(thread);
    setShowMessages(true);
  };

  const deselectMessageThread = () => {
    p.selectThread(null);
    setShowMessages(false);
  };

  const handleMobileSearch = (searchResult: ISearchResult) => {
    p.handleSearch(searchResult);
    setShowMessages(true);
  };
  return (
    <div className="relative block md:hidden h-full overflow-hidden">
      <Transition.Root show={showMessages} as={Fragment}>
        <Transition.Child
          as={Fragment}
          enter="transform transition ease-in-out duration-500 sm:duration-700"
          enterFrom="translate-x-full"
          enterTo="translate-x-0"
          leave="transform transition ease-in-out duration-500 sm:duration-700"
          leaveFrom="translate-x-0"
          leaveTo="translate-x-full"
        >
          <div className="absolute bg-white z-10 left-0 w-full h-full">
            <div className="bg-gray-50 py-1 px-2 w-full">
              <ButtonBase
                variant="gray"
                className="flex flex-row items-center gap-1.5 py-2"
                onClick={deselectMessageThread}
              >
                <ArrowLeft
                  className="h-4 w-4 text-gray-600"
                  viewBox="0 0 24 24"
                />{' '}
                <span className="text-sm text-gray-500">Back</span>
              </ButtonBase>
            </div>
            {/* Messages Container */}
            <div className="h-[calc(100%-52px)] relative w-full">
              <div className="w-full absolute top-0 left-0 h-full flex-col flex">
                {/* Messages Header */}
                <div className="border-b border-gray-200 py-4">
                  <div className="flex flex-row justify-between px-5">
                    <p className="text-lg font-medium font-dmsans text-gray-900">
                      {p.selectedThread?.type === ThreadType.SUPPORT
                        ? content.support_message_list_header
                        : p.selectedThread?.case?.complaint ?? 'Medical Thread'}
                    </p>
                    {p.selectedThread?.createdAt && (
                      <p className="text-lg font-normal font-dmsans text-gray-400">
                        {dayjs(p.selectedThread?.createdAt).format(
                          'MMM DD, YYYY'
                        )}
                      </p>
                    )}
                  </div>
                </div>
                {/* Messages */}
                {p.selectedThread && (
                  <MessageList
                    key={
                      `${p.selectedThread?.id}-${p.searchedMessageId}` ??
                      'message-list'
                    }
                    user={p.user}
                    thread={p.selectedThread}
                    searchedMessageId={p.searchedMessageId}
                  />
                )}
              </div>
            </div>
          </div>
        </Transition.Child>
      </Transition.Root>
      <div className="h-full relative w-full">
        <div className="w-full absolute top-0 left-0 h-full flex-col flex">
          {/* Threads Container */}
          <div className="border-b border-gray-200 py-5 px-3 h-[70px] flex flex-row items-center justify-between">
            <p className="ml-2 text-lg font-medium font-dmsans text-gray-900">
              {content.threads_list_header}
            </p>
            <NewMessageModalTrigger />
          </div>
          <ThreadsList
            threads={p.threads}
            selectedThread={p.selectedThread}
            onSelect={selectMessageThread}
          />
          {/* Search Bar */}
          <div className="w-full bg-gray-50 p-4 flex gap-3">
            <div className="w-full">
              <Search
                className="w-full max-w-md h-10"
                onChange={handleMobileSearch}
              />
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default MobileDashboard;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/dashboard/desktop-dashboard.tsx

import dayjs from 'dayjs';
import { useSearchParams } from 'next/navigation';
import React from 'react';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import CaseFilter from '@/app/shared/components/case-picker/case-filter';
import { CaseInclude } from '@/app/shared/types';
import { IDashboardProps } from '@messaging//dashboard/dashboard';
import MobileDashboard from '@messaging/dashboard/mobile-dashboard';
import MessageList from '@messaging/message-list/message-list';
import NewMessageModalTrigger from '@messaging/new-message/new-message-modal-trigger';
import NoThreadsView from '@messaging/no-threads-view';
import Search, { ISearchResult } from '@messaging/search';
import ThreadsList from '@messaging/threads/threads-list';
import { ThreadCustomType } from '@models/extensions/messaging';
import { ThreadType } from '@prisma/client';

const DesktopDashboard: React.FC<IDashboardProps> = (p) => {
  const { content } = useMessagingContext();
  const searchParams = useSearchParams();
  const [selectedThread, setSelectedThread] =
    React.useState<ThreadCustomType | null>(
      p.initialThread
        ? p.initialThread
        : p.threads.length > 0
        ? p.threads[0]
        : null
    );
  const [selectedCase, setSelectedCase] = React.useState<CaseInclude | null>(
    null
  );

  const [filteredThreads, setFilteredThreads] = React.useState<
    ThreadCustomType[]
  >(p.threads);

  const [searchedMessageId, setSearchedMessageId] = React.useState<
    string | undefined
  >(undefined);

  React.useEffect(() => {
    // If threads are updated, reset the case filters and filtered threads
    setSelectedCase(null);
    setFilteredThreads(p.threads);
  }, [p.threads]);

  React.useEffect(() => {
    if (searchParams.has('threadId')) {
      const thread = p.threads.find(
        (thread) => thread.id === searchParams.get('threadId')
      );

      if (thread) {
        setSelectedThread(thread);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams]);

  const handleCaseChange = (selectedCase: CaseInclude) => {
    setSelectedCase(selectedCase ?? null);
    if (selectedCase != null) {
      setFilteredThreads(
        p.threads.filter((thread) => thread.caseId === selectedCase.id)
      );
    } else {
      setFilteredThreads(p.threads);
    }
  };

  const handleSearch = (searchResult: ISearchResult) => {
    const thread = p.threads.find(
      (thread) => thread.id === searchResult.threadId
    );

    if (thread) {
      setSelectedThread(thread);
      setSearchedMessageId(searchResult.id);
    }
  };

  const selectThread = (thread: ThreadCustomType | null) => {
    setSearchedMessageId(undefined);
    setSelectedThread(thread);
  };

  return p.threads.length > 0 ? (
    <div className="flex-1 overflow-hidden">
      {/* Mobile */}
      <MobileDashboard
        {...p}
        handleSearch={handleSearch}
        selectedThread={selectedThread}
        selectThread={selectThread}
        searchedMessageId={searchedMessageId}
      />
      {/* Desktop */}
      <div className="md:flex md:flex-col h-full hidden">
        {/* Header Bar */}
        <div className="border-b border-gray-200 ">
          <div className="w-full grid grid-cols-[284px_1fr_120px] py-4 px-5">
            <div className="pr-4">
              <CaseFilter
                cases={p.cases}
                currentCase={selectedCase}
                onCaseChange={handleCaseChange}
                className="h-10"
              />
            </div>
            <div>
              <Search
                className="w-full max-w-md h-10"
                onChange={handleSearch}
              />
            </div>
          </div>
        </div>

        <div className="flex flex-1 flex-row">
          {/* Threads Container */}
          <div className="relative w-[300px] flex-shrink-0 h-full border-r border-gray-200 block">
            <div className="w-full absolute top-0 left-0 h-full flex-col flex">
              <div className="border-b border-gray-200 py-5 px-3 h-[70px] flex flex-row items-center justify-between">
                <p className="ml-2 text-lg font-medium font-dmsans text-gray-900">
                  {content.threads_list_header}
                </p>
                <NewMessageModalTrigger />
              </div>
              <ThreadsList
                threads={filteredThreads}
                selectedThread={selectedThread}
                onSelect={selectThread}
              />
            </div>
          </div>

          {/* Messages Container */}
          <div className="h-full relative w-full">
            <div className="w-full absolute top-0 left-0 h-full flex-col flex">
              {/* Messages Header */}
              <div className="border-b border-gray-200 py-5 h-[70px]">
                <div className="flex flex-row justify-between px-5">
                  <p className="text-lg font-medium font-dmsans text-gray-900">
                    {selectedThread?.type === ThreadType.SUPPORT
                      ? content.support_message_list_header
                      : selectedThread?.case?.complaint ?? 'Medical Thread'}
                  </p>
                  {selectedThread?.createdAt && (
                    <p className="text-lg font-normal font-dmsans text-gray-400">
                      {dayjs(selectedThread?.createdAt).format('MMM DD, YYYY')}
                    </p>
                  )}
                </div>
              </div>
              {/* Messages */}
              {selectedThread ? (
                <MessageList
                  key={
                    `${selectedThread?.id}-${searchedMessageId}` ??
                    'message-list'
                  }
                  user={p.user}
                  thread={selectedThread}
                  searchedMessageId={searchedMessageId}
                />
              ) : null}
            </div>
          </div>
        </div>
      </div>
    </div>
  ) : (
    <NoThreadsView />
  );
};

export default DesktopDashboard;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/media-attachment/media-modal.tsx

import Image from 'next/image';
import React, { Fragment } from 'react';

import { Dialog, Transition } from '@headlessui/react';
import { XMarkIcon } from '@heroicons/react/20/solid';
import { MediaType } from '@prisma/client';

interface IMediaModalProps {
  s3Url: string;
  mediaType: MediaType;
  open: boolean;
  setOpen: () => void;
}

const MediaModal: React.FC<IMediaModalProps> = (p) => {
  return (
    <Transition.Root show={p.open} as={Fragment}>
      <Dialog as="div" className="relative z-50" onClose={p.setOpen}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity" />
        </Transition.Child>

        <div className="fixed inset-0 z-10 w-screen overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4 text-center sm:items-center sm:p-0">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
              enterTo="opacity-100 translate-y-0 sm:scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 translate-y-0 sm:scale-100"
              leaveTo="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
            >
              <Dialog.Panel className="relative overflow-hidden text-left sm:my-8 sm:w-full sm:max-w-xl">
                <div className="absolute right-0 top-0 block pr-4 pt-4 z-10">
                  <button
                    type="button"
                    className="rounded-md bg-gray-50/30 text-gray-500 hover:text-gray-700 focus:outline-none"
                    onClick={p.setOpen}
                  >
                    <span className="sr-only">Close</span>
                    <XMarkIcon className="h-6 w-6" aria-hidden="true" />
                  </button>
                </div>
                <div className="aspect-h-1 aspect-w-1 overflow-hidden rounded-lg max-h-screen">
                  {p.mediaType === MediaType.VIDEO && (
                    <video
                      src={p.s3Url}
                      className="h-full w-full object-cover object-center"
                      width={1000}
                      height={1000}
                      controls={true}
                    />
                  )}

                  {p.mediaType === MediaType.IMAGE && (
                    <Image
                      className="h-full w-full object-cover object-center"
                      src={p.s3Url}
                      alt=""
                      width={1000}
                      height={1000}
                    />
                  )}
                </div>
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition.Root>
  );
};

export default MediaModal;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/media-attachment/media-attachment.tsx

import Image from 'next/image';
import React from 'react';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import { getFamilyMemberHeader } from '@/utils/utils';
import MediaModal from '@messaging/media-attachment/media-modal';
import { MediaType } from '@prisma/client';
import { useQuery } from '@tanstack/react-query';

const getMediaSignedUrl = async (mediaUrl: string, threadId: string) => {
  const familyMemberHeader = getFamilyMemberHeader();

  const headers = {
    s3url: mediaUrl,
    ...(familyMemberHeader ? familyMemberHeader : {}),
  };

  const result = await fetch(`/api/messaging/threads/${threadId}/media`, {
    method: 'GET',
    headers,
  });

  return (await result.json()) as { s3Url: string };
};

const MediaAttachment = (p: {
  mediaUrl: string;
  mediaType: MediaType;
  threadId: string;
}) => {
  const { content } = useMessagingContext();
  const { isLoading, data, error } = useQuery(
    ['media-attachment', p.mediaUrl],
    () => getMediaSignedUrl(p.mediaUrl, p.threadId),
    {
      refetchOnWindowFocus: false,
      refetchInterval: 3600000, // 1hr same as expire time
      cacheTime: 3600000,
      staleTime: 3600000,
    }
  );
  const [showModal, setShowModal] = React.useState(false);

  if (isLoading) {
    return (
      <div className="bg-gray-200 rounded-lg w-full h-full max-w-[192px] max-h-48 animate-pulse " />
    );
  }

  if (error) {
    return (
      <div className="bg-gray-100 rounded-lg w-full h-full max-w-[192px] max-h-48 flex items-center justify-center">
        <p className="font-dmsans text-sm font-medium text-gray-700 p-2 text-center">
          {content.media_failed_to_load_text}
        </p>
      </div>
    );
  }

  return data?.s3Url ? (
    <div className="relative flex-shrink-0 h-full hover:opacity-75">
      {p.mediaType === MediaType.VIDEO && (
        <video
          src={data.s3Url}
          className="h-full max-h-24 w-auto rounded-md object-cover object-center sm:max-h-48 sm:w-auto"
          width={256}
          height={256}
        />
      )}

      {p.mediaType === MediaType.IMAGE && (
        <Image
          className="h-full max-h-24 w-auto rounded-md object-cover object-center sm:max-h-48 sm:w-auto"
          src={data.s3Url}
          alt=""
          width={256}
          height={256}
        />
      )}

      <button onClick={() => setShowModal(true)}>
        <span aria-hidden="true" className="absolute inset-0" />
      </button>
      <MediaModal
        mediaType={p.mediaType}
        s3Url={data.s3Url}
        open={showModal}
        setOpen={() => setShowModal(false)}
      />
    </div>
  ) : null;
};

export default MediaAttachment;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/threads/support-sub-thread.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import { getFormattedMessageDate } from '@/utils/utils';
import { ThreadCustomType } from '@models/extensions/messaging';
import { ThreadStatus } from '@prisma/client';

interface ISupportSubThreadProps {
  thread: ThreadCustomType;
  selectedThread: ThreadCustomType | null;
  onSelect: (thread: ThreadCustomType) => void;
}

const SupportSubThread: React.FC<ISupportSubThreadProps> = (p) => {
  const { content } = useMessagingContext();
  const hasUnread = p.thread._count.messages > 0;

  const lastMessageDate = React.useMemo(() => {
    return getFormattedMessageDate(p.thread, 'messages.0.sentWhen', 'MMM Do');
  }, [p]);
  return (
    <div
      className={twMerge(
        'relative flex py-3 px-4 flex-col border-l-4 border-b-2 border-b-gray-100 hover:bg-gray-50/50 hover:border-l-[6px] hover:pl-3.5',
        p.selectedThread?.id === p.thread.id
          ? 'border-l-accent-300'
          : 'border-l-gray-100'
      )}
    >
      <button
        className="min-w-0 flex-1 text-start font-dmsans pr-2"
        onClick={() => p.onSelect(p.thread)}
      >
        <span className="absolute inset-0" aria-hidden="true" />
        <p className="text-sm font-medium text-gray-700">
          {content.support_thread_title}
          <span
            className={twMerge(
              'ml-2 inline-flex items-center rounded-full  px-2 py-0.5 text-xs font-medium ring-1 ring-inset',
              p.thread.status === ThreadStatus.ACTIVE
                ? 'bg-accent-50 text-accent-700 ring-accent-200'
                : 'bg-gray-50 text-gray-700 ring-gray-200'
            )}
          >
            {p.thread.status.charAt(0).toUpperCase() +
              p.thread.status.slice(1).toLowerCase()}
          </span>
        </p>
        <p className="truncate text-xs text-gray-500">
          {`${content.last_message_text} ${lastMessageDate}`}
        </p>
        {hasUnread && (
          <div className="absolute top-0 right-0 m-2.5 rounded-full bg-accent-200 w-2.5 h-2.5" />
        )}
      </button>
    </div>
  );
};

export default SupportSubThread;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/threads/support-thread.tsx

'use client';

import Image from 'next/image';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import { getFormattedMessageDate } from '@/utils/utils';
import { Disclosure } from '@headlessui/react';
import SupportSubThread from '@messaging/threads/support-sub-thread';
import { ThreadCustomType } from '@models/extensions/messaging';
import { MinusCircle, PlusCircle } from '@untitled-ui/icons-react';

interface ISupportThreadProps {
  threads: ThreadCustomType[];
  selectedThread: ThreadCustomType | null;
  onSelect: (thread: ThreadCustomType) => void;
}

const SupportThread: React.FC<ISupportThreadProps> = (p) => {
  const { content } = useMessagingContext();

  const lastMessageDate = React.useMemo(() => {
    return getFormattedMessageDate(
      p.threads[0],
      'messages.0.sentWhen',
      'MMM Do'
    );
  }, [p]);

  return (
    <Disclosure as="div" className="" defaultOpen={p.threads.length < 10}>
      {({ open }) => (
        <div
          className={twMerge(
            'relative flex flex-col border-l-4  border-l-gray-300'
          )}
        >
          <Disclosure.Button className="border-b-gray-100 border-b-2 pl-4 pr-4 py-4 hover:bg-gray-50/50">
            <div className="flex items-center space-x-3">
              <div className="flex-shrink-0">
                <Image
                  className="h-12 w-12 sm:h-[58px] sm:w-[58px]"
                  src="/assets/support_avatar.svg"
                  width={58}
                  height={58}
                  alt=""
                />
              </div>
              <div className="min-w-0 flex-1 text-start font-dmsans">
                <p className="text-sm font-medium text-gray-700">
                  {content.support_thread_accordion_title} ({p.threads.length})
                </p>
                <p className="truncate text-xs text-gray-500">
                  {content.last_message_text} {lastMessageDate}
                </p>
              </div>
              <span className="ml-3 flex h-7 items-center">
                {open ? (
                  <MinusCircle
                    className="h-6 w-6 text-gray-400"
                    aria-hidden="true"
                  />
                ) : (
                  <PlusCircle
                    className="h-6 w-6 text-gray-400"
                    aria-hidden="true"
                  />
                )}
              </span>
            </div>
          </Disclosure.Button>
          <Disclosure.Panel className="">
            {p.threads.map((thread) => (
              <SupportSubThread
                key={thread.id}
                thread={thread}
                selectedThread={p.selectedThread}
                onSelect={p.onSelect}
              />
            ))}
          </Disclosure.Panel>
        </div>
      )}
    </Disclosure>
  );
};

export default SupportThread;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/threads/medical-thread.tsx

'use client';

import Image from 'next/image';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import { getFullName } from '@/utils/get-full-name';
import { getFormattedMessageDate } from '@/utils/utils';
import { ThreadCustomType } from '@models/extensions/messaging';

import Avatar from '../avatar';

interface IMedicalThreadProps extends ThreadCustomType {
  isSelected: boolean;
  onSelect: (thread: ThreadCustomType) => void;
}

const MedicalThread: React.FC<IMedicalThreadProps> = (p) => {
  const { content } = useMessagingContext();

  const handleClick = () => {
    p.onSelect(p);
  };

  const hasUnread = p._count.messages > 0;

  const hasPhysician = p.case?.physician?.id != null;

  const lastMessageDate = React.useMemo(() => {
    return getFormattedMessageDate(p, 'messages.0.sentWhen', 'MMM Do');
  }, [p]);

  const getRecentMessageContent = React.useMemo(() => {
    if (p.messages.length === 0) {
      return 'No recent messages';
    }

    const latestMessage = p.messages[0];

    return latestMessage.content != null
      ? latestMessage.content
      : lastMessageDate;
  }, [p.messages, lastMessageDate]);

  const hasImage = p?.case?.physician?.avatarUrl != null;

  return (
    <div
      className={twMerge(
        'relative flex flex-col border-l-4 border-b-2 pl-4 pr-2 pb-6 pt-2 border-b-gray-100 hover:bg-gray-50/50 hover:border-l-[6px] hover:pl-3.5',
        p.isSelected ? 'border-l-accent-300' : 'border-l-gray-100'
      )}
    >
      <div className="flex justify-end items-center gap-2">
        <p className="font-dmsans text-xs text-gray-500">{lastMessageDate}</p>
        {hasUnread && (
          <div className="rounded-full bg-accent-200 w-2.5 h-2.5" />
        )}
      </div>
      <div className="flex items-center space-x-3">
        <div className="flex-shrink-0">
          {p?.case?.physician && hasImage ? (
            <Avatar
              user={p.case.physician}
              className="h-12 w-12 sm:h-[58px] sm:w-[58px]"
            />
          ) : (
            <Image
              className="h-12 w-12 sm:h-[58px] sm:w-[58px]"
              src="/assets/cortina-medical-badge.svg"
              width={58}
              height={58}
              alt=""
            />
          )}
        </div>
        <button
          className="min-w-0 flex-1 text-start font-dmsans pr-2"
          onClick={handleClick}
        >
          <span className="absolute inset-0" aria-hidden="true" />
          <p className="text-sm font-medium text-gray-700">
            {hasPhysician
              ? `Dr. ${getFullName(
                  p.case?.physician?.firstName,
                  p.case?.physician?.lastName,
                  'Your Physician'
                )}`
              : content.no_physician_thread_title}
          </p>

          <p className="truncate text-xs text-gray-500">
            {`${content.last_message_text} ${lastMessageDate}`}
          </p>
          <p className="truncate text-xs text-gray-500">
            {getRecentMessageContent}
          </p>
        </button>
      </div>
    </div>
  );
};

export default MedicalThread;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/threads/threads-list.tsx

import React from 'react';

import MedicalThread from '@messaging/threads/medical-thread';
import SupportThread from '@messaging/threads/support-thread';
import { ThreadCustomType } from '@models/extensions/messaging';
import { ThreadStatus, ThreadType } from '@prisma/client';

interface IThreadsListProps {
  threads: ThreadCustomType[];
  selectedThread: ThreadCustomType | null;
  onSelect: (thread: ThreadCustomType) => void;
}

const sortThreads = (a: ThreadCustomType, b: ThreadCustomType) => {
  const compareDateA = a.messages?.[0]?.sentWhen ?? a.updatedAt;
  const compareDateB = b.messages?.[0]?.sentWhen ?? b.updatedAt;

  if (a.status === b.status) {
    return compareDateA < compareDateB ? 1 : -1;
  } else {
    return a.status === ThreadStatus.ACTIVE ? -1 : 1;
  }
};

const ThreadsList: React.FC<IThreadsListProps> = (p) => {
  const medicalThreads =
    p.threads
      .filter((thread) => thread.type === ThreadType.MEDICAL)
      .sort(sortThreads) ?? [];

  const supportThreads =
    p.threads
      .filter((thread) => thread.type === ThreadType.SUPPORT)
      .sort(sortThreads) ?? [];

  return (
    <div className="overflow-y-auto flex-1">
      {medicalThreads.map((thread) => (
        <MedicalThread
          key={thread.id}
          {...thread}
          isSelected={p.selectedThread?.id === thread.id}
          onSelect={p.onSelect}
        />
      ))}
      {supportThreads.length > 0 && (
        <SupportThread
          selectedThread={p.selectedThread}
          onSelect={p.onSelect}
          threads={supportThreads}
        />
      )}
    </div>
  );
};

export default ThreadsList;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/message-input-bar/banner.tsx

import React from 'react';

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { RichText } from '@/app/shared/components/text/rich-text';
import { XMarkIcon } from '@heroicons/react/20/solid';
import {
  KeyTextField,
  RichTextField,
  LinkField,
  isFilled,
} from '@prismicio/client';
import { JSXMapSerializer } from '@prismicio/react';

interface IBannerProps {
  text: RichTextField;
  ctaText: KeyTextField;
  ctaLink: LinkField;
  richTextComponents?: JSXMapSerializer;
}

const Banner: React.FC<IBannerProps> = (p) => {
  const [show, setShow] = React.useState(true);

  const dismiss = () => {
    setShow(false);
  };

  return (
    show && (
      <>
        <div className="">
          <div className="font-dmsans flex items-center gap-x-6 bg-accent-100 px-6 py-2.5 sm:px-3.5">
            <RichText
              className="text-sm leading-6 text-accent-700"
              field={p.text}
              components={p.richTextComponents}
            />
            <div className="flex flex-1 justify-end">
              {isFilled.link(p.ctaLink) && (
                <CustomPrismicLink
                  field={p.ctaLink}
                  variant="outline-gray"
                  className="text-sm mr-2 py-2 min-w-[140px] text-center"
                >
                  {p.ctaText}
                </CustomPrismicLink>
              )}
              <button
                type="button"
                className="-m-3 p-3 focus-visible:outline-offset-[-4px]"
                onClick={dismiss}
              >
                <span className="sr-only">Dismiss</span>
                <XMarkIcon
                  className="h-5 w-5 text-accent-700"
                  aria-hidden="true"
                />
              </button>
            </div>
          </div>
        </div>
      </>
    )
  );
};

export default Banner;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/message-input-bar/chat-bar.tsx

import dayjs from 'dayjs';
import React from 'react';

import { ThreadCustomType } from '@/app/shared/models/extensions/messaging';
import { Message, ThreadStatus, ThreadType } from '@prisma/client';
import { JSXMapSerializer } from '@prismicio/react';

import { useMessagingContext } from '../../hooks/use-messaging-context';
import Banner from './banner';
import ClosedChatBar from './closed-chat-bar';
import MessageInput from './message-input';

interface IChatBarProps {
  thread: ThreadCustomType;
  scrollToBottom: () => void;
  draftMessage?: Message | null;
}

const ChatBar: React.FC<IChatBarProps> = (p) => {
  const { user, content } = useMessagingContext();

  const isMedical = p.thread.type === ThreadType.MEDICAL;

  if (isMedical && !p.thread?.case?.hasPhysicianAccess) {
    return (
      <Banner
        text={content.access_expired_text}
        ctaLink={content.access_expired_cta}
        ctaText={content.access_expired_cta_text}
      />
    );
  }
  const daysLeft = p.thread?.case?.nonConciergeAccessExpiresOn
    ? dayjs(p.thread?.case?.nonConciergeAccessExpiresOn).diff(dayjs(), 'days') +
      1
    : null;

  const showDaysLeftBanner =
    isMedical && !user.hasConcierge && daysLeft && daysLeft <= 3;

  const daysLeftText =
    daysLeft && daysLeft > 1 ? `${daysLeft} days` : `${daysLeft} day`;

  const richTextComponents: JSXMapSerializer = {
    label: ({ node }) => {
      if (node.data.label === 'daysLeft') {
        const labelText = ((node as any)?.text ?? '').replace(
          '{{ daysLeft }}',
          daysLeftText
        );
        return <>{labelText}</>;
      }
    },
  };

  if (p.thread.status === ThreadStatus.ACTIVE) {
    return (
      <>
        {showDaysLeftBanner && (
          <Banner
            text={content.access_expiring_text}
            ctaLink={content.access_expiring_cta}
            ctaText={content.access_expired_cta_text}
            richTextComponents={richTextComponents}
          />
        )}
        <MessageInput
          key={p.thread.id}
          draftMessage={null}
          threadId={p.thread.id}
          scrollToBottom={p.scrollToBottom}
        />
      </>
    );
  }

  return <ClosedChatBar />;
};

export default ChatBar;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/message-input-bar/textarea-with-toolbar.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import ButtonBase from '@components/buttons/button-base';
import { useAutosizeTextArea } from '@hooks/use-autosize-textarea';
import MediaUploadModal from '@messaging/media-upload-modal/media-upload-modal';
import { Message } from '@prisma/client';
import { Image03 } from '@untitled-ui/icons-react';

interface ITextAreaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  id?: string;
  name?: string;
  className?: string;
  value: string;
  onChange?: (e: React.ChangeEvent<HTMLTextAreaElement>) => void;
  onBlur?: (e: React.FocusEvent<HTMLTextAreaElement>) => void;
  placeholder?: string;
  disabled?: boolean;
  isInvalid?: boolean;
  helperTextTitle?: string;
  helperText?: string;
  label?: string;
  draftMessage: Message;
}

const TextAreaWithToolbar: React.FC<ITextAreaProps> = (p) => {
  const { id, maxLength, className, isInvalid, draftMessage, ...others } = p;
  const generatedId = React.useId();
  const [openMediaModal, setOpenMediaModal] = React.useState(false);
  const textAreaRef = React.useRef<HTMLTextAreaElement>(null);

  useAutosizeTextArea(textAreaRef.current, p.value, 300);

  const inputId = id ?? generatedId;

  const errorStyle = isInvalid
    ? 'ring-1 ring-error-300 focus:ring-error-300'
    : '';

  return (
    <>
      <div className="relative mt-2 flex items-center">
        <textarea
          id={inputId}
          ref={textAreaRef}
          maxLength={maxLength ?? 2000}
          rows={1}
          className={twMerge([
            `resize-none block w-full min-h-[44px] rounded-lg border-0 py-2.5 pl-2.5 pr-10 text-base text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-500 focus:ring-2 focus:shadow-drop focus:ring-accent-300`,
            errorStyle,
            className,
          ])}
          {...others}
        />
        <ButtonBase
          className="absolute bottom-0 right-0 flex py-1.5 pr-4"
          onClick={() => setOpenMediaModal(true)}
        >
          <Image03 className="w-7 h-7 text-gray-400" viewBox="0 0 24 24" />
        </ButtonBase>
      </div>
      <MediaUploadModal
        open={openMediaModal}
        setOpen={setOpenMediaModal}
        draftMessage={draftMessage}
      />
    </>
  );
};

export default TextAreaWithToolbar;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/message-input-bar/message-input.tsx

import { debounce, get } from 'lodash';
import React from 'react';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import ErrorToast from '@/app/shared/components/error-toast';
import { getFamilyMemberHeader } from '@/utils/utils';
import ButtonSolid from '@components/buttons/button-solid';
import { queryClient } from '@components/context-wrapper';
import { XMarkIcon } from '@heroicons/react/20/solid';
import MessageInputSkeleton from '@messaging/loading-skeletons/message-input-skeleton';
import MediaAttachment from '@messaging/media-attachment/media-attachment';
import TextAreaWithToolbar from '@messaging/message-input-bar/textarea-with-toolbar';
import { Message, MessageMedia } from '@prisma/client';
import { useMutation, useQuery } from '@tanstack/react-query';
import { Send01 } from '@untitled-ui/icons-react';

interface IMessageInput {
  threadId: string;
  scrollToBottom: () => void;
  draftMessage?: Message | null;
}

const findOrCreateDraft = async (threadId: string) => {
  const result = await fetch(
    `/api/messaging/threads/${threadId}/messages/draft/find-or-create`,
    {
      method: 'POST',
      headers: getFamilyMemberHeader(),
    }
  );

  return (await result.json()) as Message;
};

const updateDraft = (messageId: string, message = '') => {
  return fetch(`/api/messaging/messages/${messageId}/update-draft`, {
    method: 'PATCH',
    body: JSON.stringify({ message }),
    headers: getFamilyMemberHeader(),
  });
};

const removeMedia = (messageId: string, media: MessageMedia) => {
  return fetch(`/api/messaging/messages/${messageId}/remove-media`, {
    method: 'PATCH',
    body: JSON.stringify({ media }),
    headers: getFamilyMemberHeader(),
  });
};

const sendDraftWithMessage = (messageId: string, message: string) => {
  return fetch(`/api/messaging/messages/${messageId}/save-and-send`, {
    method: 'PATCH',
    body: JSON.stringify({ message }),
    headers: getFamilyMemberHeader(),
  });
};

const sendDraft = (messageId: string) => {
  return fetch(`/api/messaging/messages/${messageId}/send`, {
    method: 'PATCH',
    headers: getFamilyMemberHeader(),
  });
};

const MessageInput: React.FC<IMessageInput> = (p) => {
  const { content } = useMessagingContext();
  const [message, setMessage] = React.useState('');
  const [sending, setSending] = React.useState(false);
  const [error, setError] = React.useState(false);
  const [errorMessage, setErrorMessage] = React.useState('');

  const onErrorToastClose = () => {
    setError(false);
  };

  const { isLoading, data } = useQuery(
    ['draft', p.threadId],
    () => findOrCreateDraft(p.threadId),
    {
      refetchOnWindowFocus: false,
    }
  );

  React.useEffect(() => {
    if (!message || message.length < 1) {
      setMessage(data?.content ?? '');
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [data]);

  const saveDraft = useMutation({
    mutationFn: async (msg: { message: string; messageId: string }) => {
      const res = await updateDraft(msg.messageId, msg.message);
      return (await res.json()) as Message;
    },
  });

  const removeMediaFromDraft = useMutation({
    mutationFn: async (msg: { media: MessageMedia; messageId: string }) => {
      const res = await removeMedia(msg.messageId, msg.media);
      return (await res.json()) as Message;
    },
  });

  const sendMessage = useMutation({
    mutationFn: async (msg: { messageId: string; message: string }) => {
      let res: Response;

      if (message.length > 0)
        res = await sendDraftWithMessage(msg.messageId, msg.message);
      else res = await sendDraft(msg.messageId);

      return (await res.json()) as Message;
    },
    // On successful send, refetch messages
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['messages', p.threadId] });
      queryClient.invalidateQueries({ queryKey: ['draft', p.threadId] });
    },
  });

  const reset = () => {
    setMessage('');
  };

  const handleSendMessage = async () => {
    debouncedSave.cancel();

    if (!data?.id) {
      setError(true);
      return;
    }

    setSending(true);
    await sendMessage.mutateAsync(
      { messageId: data.id, message },
      {
        onSettled: () => {
          setSending(false);
        },
        onSuccess: () => {
          reset();
          p.scrollToBottom();
        },
        onError: () => {
          setErrorMessage(
            get(content, 'message_send_error_text', '') as string
          );
          setError(true);
        },
      }
    );
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      handleSendMessage();
    }
  };

  const handleSaveDraft = async (messageValue: string) => {
    if (data?.id) {
      await saveDraft.mutateAsync(
        {
          messageId: data.id,
          message: messageValue,
        },
        {
          onError: () => {
            console.log('Unable to save message');
          },
        }
      );
    }
  };

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const debouncedSave = React.useCallback(debounce(handleSaveDraft, 1500), [
    data,
  ]);

  const handleMessageChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setMessage(e.target.value);

    debouncedSave(e.target.value);
  };

  const removeImageAttachment = async (media: MessageMedia) => {
    if (!data?.id) {
      return;
    }

    await removeMediaFromDraft.mutateAsync(
      {
        messageId: data.id,
        media,
      },
      {
        onSuccess: () => {
          queryClient.invalidateQueries(['draft', p.threadId]);
        },
        onError: () => {
          setErrorMessage(
            get(content, 'message_remove_media_error_text', '') as string
          );
          setError(true);
        },
      }
    );
  };

  if (isLoading) {
    return <MessageInputSkeleton />;
  }

  return !isLoading && data ? (
    <div className="bg-gray-50 py-3 px-4">
      <div className="flex flex-row items-end gap-4 w-full">
        <div className="w-full">
          <TextAreaWithToolbar
            className="w-full" // h-11"
            value={message}
            onChange={handleMessageChange}
            placeholder={
              get(content, 'message_input_placeholder', '') as string
            }
            onKeyDown={handleKeyDown}
            disabled={sending}
            draftMessage={data}
          />
        </div>
        <ButtonSolid
          variant="accent"
          className="p-3"
          onClick={handleSendMessage}
          disabled={sending}
        >
          <Send01 height="20px" width="20px" viewBox="0 0 24 24" />
        </ButtonSolid>
      </div>
      <div className="flex flex-row gap-4">
        {data.media?.map((mediaObject, i) => (
          <div key={`${mediaObject.mediaUrl}-${i}`}>
            {mediaObject?.mediaUrl && (
              <div className="relative h-24 w-24 my-2">
                <MediaAttachment
                  mediaUrl={mediaObject.mediaUrl}
                  mediaType={mediaObject.mediaType}
                  threadId={p.threadId}
                />
                <div className="absolute bottom-0 right-0 m-1">
                  <button
                    className="rounded-md p-1 bg-gray-50/90 text-error-500 hover:text-error-600 hover:bg-gray-100 focus:outline-none focus:ring-1 focus:ring-gray-200"
                    onClick={() => removeImageAttachment(mediaObject)}
                  >
                    <span className="sr-only">Remove</span>
                    <XMarkIcon className=" h-4 w-4" aria-hidden="true" />
                  </button>
                </div>
              </div>
            )}
          </div>
        ))}
      </div>
      <ErrorToast
        show={error}
        text={errorMessage}
        onClose={onErrorToastClose}
      />
    </div>
  ) : null;
};

export default MessageInput;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/message-input-bar/closed-chat-bar.tsx

import React from 'react';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import ButtonOutline from '@/app/shared/components/buttons/button-outline';

import { useModalContext } from '../../hooks/use-modal-context';

const ClosedChatBar: React.FC = () => {
  const { content } = useMessagingContext();
  const { setOpen } = useModalContext();

  const handleSupportClick = () => {
    setOpen(true, 2);
  };

  return (
    <div className="bg-gray-50 py-3 px-4">
      <div className="flex flex-row items-center min-h-[44px] py-1 gap-2 sm:gap-4 w-full">
        <p className="font-dmsans text-base text-gray-700">
          {content.closed_chat_text}
        </p>
        <ButtonOutline
          variant="accent"
          className="py-2"
          onClick={handleSupportClick}
        >
          {content.closed_chat_cta_button_text}
        </ButtonOutline>
      </div>
    </div>
  );
};

export default ClosedChatBar;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/loading-skeletons/threads-list-skeleton.tsx

import React from 'react';

interface IThreadsListSkeletonProps {
  numberOfThreads: number;
}

const ThreadsListSkeleton: React.FC<IThreadsListSkeletonProps> = ({
  numberOfThreads = 1,
}) => {
  return (
    <div className="overflow-y-auto flex-1 animate-pulse">
      {[...Array(numberOfThreads)].map((_e, i) => (
        <div key={i} className="flex border-b pl-4 pr-2 pb-6 pt-2">
          <div className="mr-3 mt-3 flex-shrink-0">
            <div className="rounded-full h-14 w-14 bg-gray-200" />
          </div>
          <div className="flex flex-col gap-2 w-full">
            <div className="bg-gray-200 rounded-3xl h-3 w-12 self-end" />

            <div className="flex flex-col gap-2 w-full max-w-md pr-4">
              <div className="bg-gray-200 rounded-3xl h-3.5 w-3/4" />
              <div className="bg-gray-200 rounded-3xl h-3.5 w-1/2" />
              <div className="bg-gray-200 rounded-3xl h-3.5 w-full" />
            </div>
          </div>
        </div>
      ))}
    </div>
  );
};

export default ThreadsListSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/loading-skeletons/message-input-skeleton.tsx

import React from 'react';

const MessageInputSkeleton: React.FC = () => {
  return (
    <div className="bg-gray-50 py-3 px-4 animate-pulse">
      <div className="flex flex-row items-end gap-4 w-full">
        <div className="w-full">
          <div className="bg-gray-200 h-11 w-full rounded-lg" />
        </div>
        <div className="h-11 w-11 bg-gray-200 rounded-lg" />
      </div>
    </div>
  );
};

export default MessageInputSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/loading-skeletons/dashboard-skeleton.tsx

import React from 'react';

import MessageInputSkeleton from '@messaging/loading-skeletons/message-input-skeleton';
import MessageListSkeleton from '@messaging/loading-skeletons/message-list-skeleton';
import ThreadsListSkeleton from '@messaging/loading-skeletons/threads-list-skeleton';

const DashboardSkeleton: React.FC = () => {
  return (
    <div className="h-screen">
      {/* Mobile */}
      <div className="relative block md:hidden h-full overflow-hidden">
        <div className="h-full relative w-full">
          <div className="w-full absolute top-0 left-0 h-full flex-col flex">
            <div className="border-b border-gray-200 py-5 px-3 h-[70px] flex flex-row items-center justify-between animate-pulse">
              <div className="ml-2 bg-gray-200 w-full max-w-[130px] rounded-lg h-3.5" />
            </div>

            <ThreadsListSkeleton numberOfThreads={2} />
            <MessageInputSkeleton />
          </div>
        </div>
      </div>
      {/* Desktop */}
      <div className="h-full hidden md:block">
        <div className="border-b border-gray-200 ">
          <div className="w-full grid grid-cols-[284px_1fr_284px] py-4 px-5 animate-pulse">
            <div className="pr-4">
              <div className="bg-gray-200 w-full h-10 rounded-lg" />
            </div>
            <div className="bg-gray-200 w-full max-w-lg h-10 rounded-lg" />
          </div>
        </div>

        <div className="h-[calc(100%-73px)] flex flex-row">
          <div className="w-[300px] flex-shrink-0 h-full overflow-y-auto border-r border-gray-200 block">
            <div className="border-b border-gray-200 py-5 px-3 h-[70px] flex flex-row items-center justify-between animate-pulse">
              <div className="ml-2 bg-gray-200 w-full max-w-[130px] rounded-lg h-3.5" />
            </div>
            {/* Threads */}
            <ThreadsListSkeleton numberOfThreads={2} />
          </div>

          <div className="h-full relative w-full">
            <div className="w-full absolute top-0 left-0 h-full flex-col flex">
              {/* Messages Header */}
              <div className="border-b border-gray-200 py-5 h-[70px]">
                <div className="flex flex-row justify-between h-full items-center px-5 animate-pulse">
                  <div className="bg-gray-200 w-full max-w-[130px] rounded-lg h-3.5" />
                  <div className=" bg-gray-200 w-full max-w-[130px] rounded-lg h-3.5" />
                </div>
              </div>
              {/* Messages */}
              <MessageListSkeleton numberOfMessages={3} />
              <MessageInputSkeleton />
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default DashboardSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/loading-skeletons/message-list-skeleton.tsx

import React from 'react';

interface IMessageListSkeletonProps {
  numberOfMessages: number;
}

const MessageListSkeleton: React.FC<IMessageListSkeletonProps> = ({
  numberOfMessages = 1,
}) => {
  return (
    <div className="flex flex-1 flex-col gap-6 px-10 py-8 animate-pulse">
      {[...Array(numberOfMessages)].map((_e, i) => (
        <div className="flex" key={i}>
          <div className="mr-3 flex-shrink-0">
            <div className="rounded-full h-14 w-14 bg-gray-200" />
          </div>
          <div className="flex flex-col gap-2 mt-2 w-full max-w-md">
            <div className="flex flex-row gap-2">
              <div className="bg-gray-200 rounded-3xl h-3.5 w-32" />
              <div className="bg-gray-200 rounded-3xl h-3.5 w-12" />
            </div>
            <div className="bg-gray-200 rounded-3xl h-3.5 w-full" />
            <div className="bg-gray-200 rounded-3xl h-3.5 w-3/4" />
            <div className="bg-gray-200 rounded-3xl h-3.5 w-1/2" />
          </div>
        </div>
      ))}
    </div>
  );
};

export default MessageListSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/message-list/message-list.tsx

'use client';

import dayjs from 'dayjs';
import groupBy from 'lodash.groupby';
import React from 'react';
import { VirtuosoHandle } from 'react-virtuoso';

import { ThreadCustomType } from '@/app/shared/models/extensions/messaging';
import { getFamilyMemberHeader } from '@/utils/utils';
import MessageListSkeleton from '@messaging/loading-skeletons/message-list-skeleton';
import VirtualizedWindow from '@messaging/message-list/virtualized-window';
import NoMessagesView from '@messaging/no-messages-view';
import { User } from '@prisma/client';
import { useInfiniteQuery } from '@tanstack/react-query';

import ChatBar from '../message-input-bar/chat-bar';
import MessageListErrorView from './message-list-error-view';

const PAGE_SIZE = 20;

const START_INDEX = 10000;

export interface IMessageListProps {
  user: User;
  thread: ThreadCustomType;
  searchedMessageId?: string;
}

type UserQueryParams = {
  threadId: string;
  take?: number;
  lastCursor?: string;
  messageId?: string;
};

const fetchMessageList = async ({
  threadId,
  take,
  lastCursor,
  messageId,
}: UserQueryParams) => {
  const response = await fetch(
    `/api/messaging/threads/${threadId}/messages/paginated?` +
      new URLSearchParams({
        ...{ ...(messageId ? { messageId } : {}) },
        take: take?.toString() ?? '',
        lastCursor: lastCursor ?? '',
      }),
    {
      method: 'GET',
      headers: getFamilyMemberHeader(),
    }
  );

  return await response.json();
};

const MessageList: React.FC<IMessageListProps> = (p) => {
  const ref = React.useRef<VirtuosoHandle>(null);
  const [firstItemIndex, setFirstItemIndex] = React.useState(START_INDEX);

  const {
    status,
    data,
    hasNextPage,
    fetchNextPage,
    isFetching,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryFn: async (ctx) => {
      // If pageParam is undefined, then it's the initial fetch. Fetch initial by searched ID if defined.
      // Otherwise, leave messageId undefined and fetch page normally.
      const messageId = ctx.pageParam ? undefined : p.searchedMessageId;
      return await fetchMessageList({
        threadId: p.thread.id,
        take: PAGE_SIZE,
        lastCursor: ctx.pageParam ?? '',
        messageId,
      });
    },
    queryKey: ['messages', p.thread.id],
    refetchOnWindowFocus: true,
    refetchInterval: 15000,
    getNextPageParam: (lastPage) => {
      return lastPage?.metaData.lastCursor;
    },
  });

  const messages = React.useMemo(() => {
    const pageData =
      data?.pages
        .flatMap((p) => p.data)
        .sort((a, b) => (a.sentWhen < b.sentWhen ? 1 : -1)) ?? [];

    // Reset top most item to let Virtuoso know when 'start' is reached
    setFirstItemIndex(START_INDEX - (pageData.length - 1));
    return pageData;
  }, [data]);

  // Group messages by date and return number of groups and the text titles for each group
  const { groupCounts, groups } = React.useMemo(() => {
    const groupedMessages = groupBy(
      [...messages].sort((a, b) => (a.sentWhen > b.sentWhen ? 1 : -1)),
      (message) => {
        if (dayjs(message.sentWhen).isSame(dayjs(), 'd')) {
          return 'Today';
        } else if (dayjs(message.sentWhen).isSame(dayjs().add(-1, 'd'), 'd')) {
          return 'Yesterday';
        } else {
          return dayjs(message.sentWhen).format('MMM D, YYYY');
        }
      }
    );
    const groupCounts = Object.values(groupedMessages).map(
      (msgs) => msgs.length
    );
    const groups = Object.keys(groupedMessages);

    return { groupCounts, groups };
  }, [messages]);

  const scrollToBottom = React.useCallback(() => {
    if (ref?.current) {
      ref.current.scrollToIndex({
        index: messages.length - 1,
        behavior: 'smooth',
      });
    }
  }, [messages]);

  return (
    <>
      <div className="flex flex-1 flex-col gap-6">
        {status === 'loading' && <MessageListSkeleton numberOfMessages={3} />}
        {status === 'error' && <MessageListErrorView />}
        {status === 'success' && (
          <>
            {messages.length > 0 && groups.length > 0 ? (
              <VirtualizedWindow
                key={p.thread.id}
                ref={ref}
                messages={messages}
                isFetchingNextPage={isFetchingNextPage}
                groups={groups}
                hasNextPage={hasNextPage}
                groupCounts={groupCounts}
                fetchNextPage={fetchNextPage}
                isFetching={isFetching}
                firstItemIndex={firstItemIndex}
                {...p}
              />
            ) : (
              <NoMessagesView threadType={p.thread.type} />
            )}
          </>
        )}
      </div>
      <ChatBar
        thread={p.thread}
        draftMessage={null}
        scrollToBottom={scrollToBottom}
      />
    </>
  );
};

export default MessageList;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/message-list/window-header.tsx

import React from 'react';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';

interface IWindowHeader {
  context?: {
    isFetchingNextPage: boolean;
    hasNextPage?: boolean;
    groups: string[];
  };
}

const WindowHeader: React.FC<IWindowHeader> = ({ context }) => {
  const { content } = useMessagingContext();

  return context ? (
    <div className="text-gray-500 font-dmsans text-sm italic py-4 text-center">
      {context.isFetchingNextPage
        ? content.fetching_next_messages_text
        : !context.hasNextPage
        ? content.no_more_messages_text
        : ''}
    </div>
  ) : null;
};

export default WindowHeader;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/message-list/virtualized-window.tsx

import React from 'react';
import { GroupedVirtuoso, VirtuosoHandle } from 'react-virtuoso';
import { twMerge } from 'tailwind-merge';

import { IMessageListProps } from '@messaging/message-list/message-list';
import Message from '@messaging/messages/message';
import NoMessagesView from '@messaging/no-messages-view';

import WindowHeader from './window-header';

interface IVirtualizedWindowProps extends IMessageListProps {
  messages: any[];
  groups: string[];
  groupCounts: number[];
  isFetchingNextPage: boolean;
  hasNextPage?: boolean;
  fetchNextPage: () => void;
  isFetching?: boolean;
  firstItemIndex: number;
}

const VirtualizedWindow = React.forwardRef(function (
  {
    messages,
    isFetchingNextPage,
    groups,
    hasNextPage,
    groupCounts,
    fetchNextPage,
    isFetching,
    firstItemIndex,
    searchedMessageId,
    user,
    thread,
  }: IVirtualizedWindowProps,
  ref: React.Ref<VirtuosoHandle>
) {
  const [scrollOnRender, setScrollOnRender] = React.useState(
    !!searchedMessageId
  );

  const messageBubble = React.useMemo(
    () =>
      function MessageBubble(_i: number, message: any) {
        return message ? (
          <div
            key={message.id}
            className={twMerge([
              'px-6 py-3',
              searchedMessageId === message.id && 'bg-gray-50',
            ])}
          >
            <Message user={user} {...message} selectedThread={thread} />
          </div>
        ) : null;
      },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [searchedMessageId, user, thread.id]
  );

  const messageGroupHeading = React.useMemo(
    () =>
      function MessageGroupHeading(index: number) {
        return (
          <div className="relative p-4 bg-white/95">
            <div
              className="absolute inset-0 flex items-center justify-center"
              aria-hidden="true"
            >
              <div className="w-full border-t border-gray-300 max-w-sm" />
            </div>
            <div className="relative flex justify-center">
              <span className="bg-white px-2 text-sm text-gray-500">
                {groups[index]}
              </span>
            </div>
          </div>
        );
      },
    [groups]
  );

  const initialTopMostItem = React.useMemo(() => {
    if (scrollOnRender) {
      const messageIndex = [...messages]
        .sort((a, b) => (a.sentWhen > b.sentWhen ? 1 : -1))
        .findIndex((msg) => msg.id === searchedMessageId);

      if (messageIndex > -1) {
        setScrollOnRender(false);
        return messageIndex;
      }
    }
    return messages.length - 1;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [messages.length, setScrollOnRender, searchedMessageId]);

  const handleNextPageFetch = React.useCallback(() => {
    if (hasNextPage && !isFetchingNextPage && !isFetching) {
      fetchNextPage();
    }
  }, [hasNextPage, isFetchingNextPage, isFetching, fetchNextPage]);

  return (
    <>
      <div className="flex flex-1 flex-col gap-6">
        {messages.length > 0 && groups.length > 0 ? (
          <GroupedVirtuoso
            context={{ isFetchingNextPage, hasNextPage, groups }}
            ref={ref}
            className="flex flex-col gap-6"
            initialTopMostItemIndex={initialTopMostItem}
            firstItemIndex={Math.max(0, firstItemIndex)}
            followOutput="smooth"
            groupCounts={groupCounts}
            groupContent={messageGroupHeading}
            itemContent={(index) => {
              return messageBubble(index, messages[10000 - index]);
            }}
            startReached={handleNextPageFetch}
            alignToBottom
            components={{
              Header: WindowHeader,
              Footer: () => <div className="h-8 w-full" />,
            }}
          />
        ) : (
          <NoMessagesView threadType={thread.type} />
        )}
      </div>
    </>
  );
});

VirtualizedWindow.displayName = 'VirtualizedWindow';

export default VirtualizedWindow;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/components/message-list/message-list-error-view.tsx

import Image from 'next/image';
import { useRouter } from 'next/navigation';
import React from 'react';

import { useMessagingContext } from '@/app/(account)/account/messaging/hooks/use-messaging-context';
import ButtonSolid from '@/app/shared/components/buttons/button-solid';

const MessageListErrorView: React.FC = () => {
  const { content } = useMessagingContext();
  const router = useRouter();

  return (
    <div className="flex flex-1 overflow-y-auto justify-center p-4">
      <div
        className="relative flex flex-col justify-center items-center text-center w-full h-full md:max-w-[480px] md:max-h-[480px]"
        style={{
          backgroundImage: `url(/assets/background-ripple.svg)`,
          backgroundPosition: '50%',
          backgroundRepeat: 'no-repeat,repeat',
        }}
      >
        <div className="relative h-[56px] w-full flex items-center justify-center">
          <Image
            src="/assets/icons/chat-box-icon.svg"
            alt=""
            className="w-11 h-11 sm:w-14 sm:h-14"
            width={56}
            height={56}
          />
          <div className="absolute top-full w-full mt-2 sm:mt-3.5 flex flex-col items-center">
            <p className="font-dmsans font-medium text-lg sm:text-3xl text-gray-900">
              {content.error_loading_messages_title}
            </p>
            <p className="mt-1 font-dmsans text-sm sm:text-md text-gray-600 max-w-sm">
              {content.error_loading_messages_description}
            </p>
            <ButtonSolid
              variant="accent"
              size="base"
              className="mt-3 py-1"
              onClick={() => router.refresh()}
            >
              {content.error_loading_messages_cta_text}
            </ButtonSolid>
          </div>
        </div>
      </div>
    </div>
  );
};

export default MessageListErrorView;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/hooks/use-messaging-context.tsx

import React from 'react';

import { MessagingContext } from '@/app/(account)/account/messaging/contexts/messaging-context';

export function useMessagingContext() {
  const context = React.useContext(MessagingContext);
  if (!context) {
    throw new Error(
      'useMessagingContext must be used within the MessagingContextProvider'
    );
  }
  return context;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(account)/account/messaging/hooks/use-modal-context.tsx

import React from 'react';

import { ModalContext } from '@messaging-contexts/modal-context';

export function useModalContext() {
  const context = React.useContext(ModalContext);
  if (!context) {
    throw new Error(
      'useModalContext must be used within the ModalContextProvider'
    );
  }
  return context;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shop/layout.tsx

import { notFound } from 'next/navigation';
import { AccountNavigationDocument } from 'prismicio-types';

import { createClient } from '@/prismicio';
import '@/styles/globals.css';
import {
  getUserAvatar,
  getUserNoRedirect,
  isUserLoggedIn,
} from '@/utils/helpers/helpers';
import { PrismicCustomType } from '@/utils/prismic/enums';
import WindowDOM from '@components/analytics/windowDOM/window-dom';

import DatadogUser from '../(account)/account/datadog-user';
import CartSlider from '../shared/components/cart/cart-slider';
import DatadogSessionPlayer from '../shared/components/datadog-init/datadog-session-player';
import AccountNavigation from '../shared/components/navigation/account-navigation/account-navigation';

export const dynamic = 'force-dynamic';

const ShopLayout = async ({ children }: { children: React.ReactNode }) => {
  const [user, avatar] = await Promise.all([
    getUserNoRedirect(),
    getUserAvatar(),
  ]);

  if (user && isUserLoggedIn(user)) {
    const menuData = await getAccountMenuData();

    return (
      <AccountNavigation
        {...menuData}
        user={user}
        userAvatarS3Url={avatar.s3Url}
      >
        <WindowDOM user={user} />
        <DatadogSessionPlayer />
        <div>{children}</div>
        <CartSlider />
        <DatadogUser user={user} />
      </AccountNavigation>
    );
  }

  return (
    <>
      <WindowDOM />
      {children}
    </>
  );
};

const getAccountMenuData = async () => {
  const client = createClient();
  return await client
    .getSingle<AccountNavigationDocument>(PrismicCustomType.ACCOUNT_NAVIGATION)
    .catch(() => notFound());
};

export default ShopLayout;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shop/loading.tsx

import LoadingCircles from '../shared/components/loading-indicators/loading-circles';

export default function Loading() {
  return <LoadingCircles />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shop/page.tsx

import { notFound } from 'next/navigation';
import { ShopHomeDocument } from 'prismicio-types';

import { createClient } from '@/prismicio';
import { components } from '@/slices';
import {
  getProductsWithContent,
  getUserNoRedirect,
  isUserLoggedIn,
} from '@/utils/helpers/helpers';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import NavigationWrapper from '@components/navigation-wrapper';
import { SliceZone } from '@prismicio/react';
import { PrismicPageType } from '@utils/prismic/enums';

import AccountHeader from '../shared/components/account-header';

export default async function Page() {
  const [user, page, products] = await Promise.all([
    getUserNoRedirect(),
    queryPage(),
    getProductsWithContent(),
  ]);

  const isLoggedIn = isUserLoggedIn(user);

  return (
    <NavigationWrapper
      shouldShow={!isLoggedIn}
      initialNavigationLinkedItem={page.data.initial_header_theme}
      scrollNavigationLinkedItem={page.data.scroll_header_theme}
    >
      {isLoggedIn && (
        <AccountHeader
          title={`${page.data.page_title}`}
          breadcrumbs={page.data?.breadcrumbs}
          mobileBreadcrumbs={page.data?.mobile_breadcrumbs}
        />
      )}
      <h1 className="sr-only">Shop Cortina Skincare Products</h1>
      <SliceZone
        slices={page.data.slices}
        components={components}
        context={{ user, products }}
      />
    </NavigationWrapper>
  );
}

export async function generateMetadata() {
  const page = await queryPage();
  return prismicPageToMetadata(page, '/shop');
}

const queryPage = () => {
  const client = createClient();
  return client
    .getSingle<ShopHomeDocument>(PrismicPageType.SHOP_HOME)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shop/products/loading.tsx

import LoadingCircles from '@/app/shared/components/loading-indicators/loading-circles';

export default function Loading() {
  return <LoadingCircles />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shop/products/page.tsx

import { notFound } from 'next/navigation';
import { ShopPageDocument } from 'prismicio-types';

import AccountHeader from '@/app/shared/components/account-header';
import NavigationWrapper from '@/app/shared/components/navigation-wrapper';
import { createClient } from '@/prismicio';
import { components } from '@/slices';
import {
  getProductsWithContent,
  getUserNoRedirect,
  isUserLoggedIn,
} from '@/utils/helpers/helpers';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { SliceZone } from '@prismicio/react';
import { PrismicPageType } from '@utils/prismic/enums';

export default async function Page({
  searchParams,
}: {
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  const [page, user, products] = await Promise.all([
    queryPage(),
    getUserNoRedirect(),
    getProductsWithContent(),
  ]);

  const isLoggedIn = isUserLoggedIn(user);

  return (
    <NavigationWrapper
      shouldShow={!isLoggedIn}
      initialNavigationLinkedItem={page.data.initial_header_theme}
      scrollNavigationLinkedItem={page.data.scroll_header_theme}
    >
      {isLoggedIn && (
        <AccountHeader
          title={`${page.data.page_title}`}
          breadcrumbs={page.data?.breadcrumbs}
          mobileBreadcrumbs={page.data?.mobile_breadcrumbs}
        />
      )}
      <SliceZone
        slices={page.data.slices}
        components={components}
        context={{ searchParams, user, products }}
      />
    </NavigationWrapper>
  );
}

export async function generateMetadata() {
  const page = await queryPage();
  return prismicPageToMetadata(page, '/shop/products');
}

const queryPage = async () => {
  const client = createClient();

  return await client
    .getByUID<ShopPageDocument>(PrismicPageType.SHOP_PAGE, 'products')
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shop/products/[uid]/loading.tsx

export default function Loading() {
  return (
    <div className="w-full mx-auto max-w-5xl pt-24 pb-16 px-4 sm:px-6 lg:px-8 animate-pulse">
      <div className="mx-auto max-w-2xl lg:max-w-none">
        {/* Product */}
        <div className="lg:grid lg:grid-cols-2 lg:items-start lg:gap-x-8">
          <div className="hidden sm:block lg:hidden mb-4">
            <div className="bg-gray-200 w-40 h-8" />
          </div>
          {/* Image gallery */}
          <div className="flex flex-col-reverse">
            {/* Image selector */}
            <div className="mx-auto mt-6 hidden w-full max-w-2xl sm:block lg:max-w-none">
              <div className="grid grid-cols-2 gap-6">
                {[...Array(4)].map((image, i) => (
                  <div
                    key={`gallery-image-${i}`}
                    className="relative flex h-48 items-center justify-center rounded-lg bg-gray-200 text-sm font-medium uppercase text-gray-900 hover:bg-gray-50 focus:outline-none"
                  ></div>
                ))}
              </div>
            </div>

            <div className="aspect-h-7 aspect-w-6 w-full">
              <div className="h-[400px] w-full object-cover object-center bg-gray-200 rounded-lg" />
            </div>
          </div>

          {/* Product info */}
          <div className="mt-10 px-4 sm:mt-16 sm:px-0 lg:mt-0">
            {/* Title */}
            <div className="bg-gray-200 w-full h-8 rounded" />
            {/* Description */}
            <div className="mt-6 bg-gray-200 w-full h-4 rounded" />
            <div className="mt-2 bg-gray-200 w-full h-4 rounded" />
            <div className="mt-2 bg-gray-200 w-full h-4 rounded" />
            <div className="mt-2 bg-gray-200 w-1/2 h-4 rounded" />
            {/* Price */}
            <div className="mt-8 flex justify-between items-center">
              <div className="w-full max-w-[8rem]">
                <div className="mt-2 bg-gray-200 w-20 h-5 rounded" />
                <div className="mt-2 w-full bg-gray-200 h-10 rounded" />
              </div>
              <div className="h-8 w-20 bg-gray-200 rounded" />
            </div>
            <div className="mt-8 bg-gray-200 rounded-md w-full h-10" />
          </div>
        </div>
      </div>
    </div>
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shop/products/[uid]/page.tsx

import { notFound } from 'next/navigation';
import { ProductPageDocument } from 'prismicio-types';

import AccountHeader from '@/app/shared/components/account-header';
import NavigationWrapper from '@/app/shared/components/navigation-wrapper';
import { createClient } from '@/prismicio';
import { components } from '@/slices';
import { getPrismicProductId } from '@/utils/get-prismic-product-id';
import {
  getProductByID,
  getProductsWithContent,
  getUserNoRedirect,
  isUserLoggedIn,
} from '@/utils/helpers/helpers';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { SliceZone } from '@prismicio/react';
import { PrismicPageType } from '@utils/prismic/enums';

type Params = { uid: string };
export default async function Page({
  params,
  searchParams,
}: {
  params: Params;
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  const [page, user, products] = await Promise.all([
    queryPage(params.uid),
    getUserNoRedirect(),
    getProductsWithContent(),
  ]);

  if (!page.data.is_shop_product) {
    return notFound();
  }

  const productId = getPrismicProductId(page.data);
  const product = productId ? await getProductByID(productId) : null;

  const isLoggedIn = isUserLoggedIn(user);

  return (
    <NavigationWrapper
      shouldShow={!isLoggedIn}
      initialNavigationLinkedItem={page.data.initial_header_theme}
      scrollNavigationLinkedItem={page.data.scroll_header_theme}
    >
      {isLoggedIn ? (
        <AccountHeader
          title={`${page.data.page_title}`}
          breadcrumbs={page.data?.breadcrumbs}
          mobileBreadcrumbs={page.data?.mobile_breadcrumbs}
        />
      ) : (
        <div className="p-10 lg:p-14" />
      )}
      <SliceZone
        slices={page.data.slices}
        components={components}
        context={{ searchParams, user, products, product }}
      />
    </NavigationWrapper>
  );
}

export async function generateMetadata({ params }: { params: Params }) {
  const page = await queryPage(params.uid);
  return prismicPageToMetadata(page, `/shop/products/${params.uid}`);
}

export async function generateStaticParams() {
  const client = createClient();
  const pages = await client.getAllByType(PrismicPageType.PRODUCT_PAGE);

  return pages.map((page) => {
    return { uid: page.uid };
  });
}

const queryPage = async (uid: string) => {
  const client = createClient();

  return await client
    .getByUID<ProductPageDocument>(PrismicPageType.PRODUCT_PAGE, uid)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shop/checkout/loading.tsx

import LoadingCircles from '@/app/shared/components/loading-indicators/loading-circles';

export default function Loading() {
  return <LoadingCircles />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shop/checkout/page.tsx

import { notFound } from 'next/navigation';
import { ShopPageDocument } from 'prismicio-types';

import RedirectIfNotAuthorized from '@/app/(features)/(authentication)/signin/components/redirect-to-authprovider';
import AccountHeader from '@/app/shared/components/account-header';
import NavigationWrapper from '@/app/shared/components/navigation-wrapper';
import { createClient } from '@/prismicio';
import { components } from '@/slices';
import {
  getUser,
  isUserLoggedIn,
  registerUserWithPaymentVendor,
} from '@/utils/helpers/helpers';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { UserEventNames } from '@/utils/user-events/enums';
import UserEventsClient from '@/utils/user-events/user-events-client';
import { SliceZone } from '@prismicio/react';
import { PrismicPageType } from '@utils/prismic/enums';

export default async function Page({
  searchParams,
}: {
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  const [page, user] = await Promise.all([queryPage(), getUser()]);

  const isLoggedIn = isUserLoggedIn(user);

  if (!isLoggedIn) {
    return <RedirectIfNotAuthorized />;
  }

  // TODO: This is an anti-pattern that needs remediation
  if (user && user.email && user.stripeId === null) {
    await registerUserWithPaymentVendor();
    await UserEventsClient.addEvent(
      user,
      UserEventNames.DERMI_ACCOUNT_CREATED,
      {}
    );
  }

  return (
    <NavigationWrapper
      shouldShow={!isLoggedIn}
      initialNavigationLinkedItem={page.data.initial_header_theme}
      scrollNavigationLinkedItem={page.data.scroll_header_theme}
    >
      <AccountHeader
        title={`${page.data.page_title}`}
        showBreadcrumb={false}
        showCart={false}
      />
      <SliceZone
        slices={page.data.slices}
        components={components}
        context={{ searchParams, user }}
      />
    </NavigationWrapper>
  );
}

export async function generateMetadata() {
  const page = await queryPage();
  return prismicPageToMetadata(page, '/shop/checkout');
}

const queryPage = async () => {
  const client = createClient();

  return await client
    .getByUID<ShopPageDocument>(PrismicPageType.SHOP_PAGE, 'checkout')
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shop/[uid]/loading.tsx

import LoadingCircles from '@/app/shared/components/loading-indicators/loading-circles';

export default function Loading() {
  return <LoadingCircles />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shop/[uid]/page.tsx

import { notFound } from 'next/navigation';
import { ShopPageDocument } from 'prismicio-types';

import AccountHeader from '@/app/shared/components/account-header';
import NavigationWrapper from '@/app/shared/components/navigation-wrapper';
import { createClient } from '@/prismicio';
import { components } from '@/slices';
import {
  getProductsWithContent,
  getUserNoRedirect,
  isUserLoggedIn,
} from '@/utils/helpers/helpers';
import { prismicPageToMetadata } from '@/utils/prismic/prismic';
import { SliceZone } from '@prismicio/react';
import { PrismicPageType } from '@utils/prismic/enums';

type Params = { uid: string };
export default async function Page({
  params,
  searchParams,
}: {
  params: Params;
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  const [page, user, product] = await Promise.all([
    queryPage(params.uid),
    getUserNoRedirect(),
    getProductsWithContent(),
  ]);

  const isLoggedIn = isUserLoggedIn(user);

  return (
    <NavigationWrapper
      shouldShow={!isLoggedIn}
      initialNavigationLinkedItem={page.data.initial_header_theme}
      scrollNavigationLinkedItem={page.data.scroll_header_theme}
    >
      {isLoggedIn && (
        <AccountHeader
          title={`${page.data.page_title}`}
          breadcrumbs={page.data?.breadcrumbs}
          mobileBreadcrumbs={page.data?.mobile_breadcrumbs}
        />
      )}
      <SliceZone
        slices={page.data.slices}
        components={components}
        context={{ searchParams, user, product }}
      />
    </NavigationWrapper>
  );
}

export async function generateMetadata({ params }: { params: Params }) {
  const page = await queryPage(params.uid);
  return prismicPageToMetadata(page, `/shop/${params.uid}`);
}

export async function generateStaticParams() {
  const client = createClient();
  const pages = await client.getAllByType(PrismicPageType.SHOP_PAGE);

  return pages.map((page) => {
    return { uid: page.uid };
  });
}

const queryPage = async (uid: string) => {
  const client = createClient();

  return await client
    .getByUID<ShopPageDocument>(PrismicPageType.SHOP_PAGE, uid)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/messages/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { UserRole } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/messages:
 *   get:
 *     tags: [Messages]
 *     summary: Get all messages
 *     description: Retrieve a list of all messages.
 *     responses:
 *       200:
 *         description: Successful response containing a list of messages.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Message'
 *       404:
 *         description: No messages found.
 *         content:
 *           application/json:
 *             example:
 *               message: No messages found.
 *       500:
 *         description: An error occurred while retrieving the messages.
 *         content:
 *           application/json:
 *             example:
 *               message: An error occurred while retrieving the messages.
 */
const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.message.findMany({});

    if (!result)
      throw ApiErrorHandler.handle404Error({
        message: 'No messages found.',
        reqUrl: request.url,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while retrieving the messages.',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/messages/search/route.ts

import { sanitize } from 'isomorphic-dompurify';
import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { messagingClient } from '@models/extensions/messaging';
import { ThreadStatus, MessageStatus } from '@prisma/client';

const refineContent = (content: string, searchQuery: string) => {
  const maxTotalChars = 50; // Maximum characters in the refined content
  const queryLength = searchQuery.length;
  const remainingChars = Math.floor((maxTotalChars - queryLength) / 2);
  const additionalChars = Math.max(remainingChars, 0);

  const lowerContent = content.toLowerCase();
  const lowerSearchQuery = searchQuery.toLowerCase();

  const queryStartIndex = lowerContent.search(lowerSearchQuery);
  if (queryStartIndex === -1) {
    return content; // If the search query is not found, return the original content
  }

  // Calculate the start and end indices for the refined content
  const startIndex = Math.max(queryStartIndex - additionalChars, 0);
  const endIndex = queryStartIndex + queryLength + additionalChars;

  // Extract the portions of text before and after the search query
  const before = content.substring(startIndex, queryStartIndex);
  const after = content.substring(queryStartIndex + queryLength, endIndex);

  // Extract the word directly preceding the query
  const precedingWords = content.substring(0, startIndex).split(' ');
  const directPreceding = precedingWords.pop();
  const directBefore =
    directPreceding && directPreceding.length > 0 ? directPreceding : '';

  // Build the refined content by combining the components
  let refinedContent = directBefore + before + searchQuery + after;

  // Add ellipsis at the beginning if content was truncated
  if (startIndex - directBefore.length > 0) {
    refinedContent = `...${refinedContent}`;
  }

  // Add ellipsis at the end if the content continues after the refined portion
  if (endIndex < content.length) {
    refinedContent = `${refinedContent}...`;
  }

  return refinedContent;
};

/**
 * @swagger
 * /api/messaging/messages/search:
 *   get:
 *     summary: Search messages
 *     description: Searchs the current user's messages for a given query string and returns the results up to the amount specified by the take parameter.
 *     tags:
 *       - Messages
 *     parameters:
 *       - in: query
 *         name: q
 *         description: The query string.
 *         required: true
 *         schema:
 *           type: string
 *       - in: query
 *         name: take
 *         description: The max search results to return.
 *         default: 5
 *         required: false
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: Search results returned. An empty array indicates no results found.
 *         content:
 *           application/json:
 *             schema:
 *               items:
 *                 $ref: '#/components/schemas/MessageSearchResult'
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while searching the messages.
 */
const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({ request });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const { user } = userInfo;
    const params = request.nextUrl.searchParams;

    const query = params.get('q');
    const takeParam = params.get('take');

    if (!query) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A query parameter is required.',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const take =
      takeParam && !Number.isNaN(parseInt(takeParam)) ? parseInt(takeParam) : 5;

    const unencoded = decodeURI(query);

    const sanitizedQuery = sanitize(unencoded);

    const threads = await messagingClient.thread.findMany({
      where: {
        userId: user.id,
        status: { not: ThreadStatus.DELETED },
      },
    });

    if (threads && threads.length > 0) {
      const messages = await prisma.message.aggregateRaw({
        pipeline: [
          {
            $search: {
              index: 'default',
              compound: {
                must: [
                  {
                    autocomplete: {
                      query: sanitizedQuery,
                      path: 'content',
                    },
                  },
                ],
                filter: [
                  {
                    queryString: {
                      query: MessageStatus.SENT,
                      defaultPath: 'status',
                    },
                  },
                  {
                    in: {
                      value: threads.map((thread) => ({
                        $oid: thread.id,
                      })),
                      path: 'threadId',
                    },
                  },
                ],
              },
              scoreDetails: true,
            },
          },
          { $limit: take },
          {
            $addFields: {
              id: { $toString: '$_id' },
              fromUserId: { $toString: '$fromUserId' },
              threadId: { $toString: '$threadId' },
              sentWhen: { $toString: '$sentWhen' },
              in: 'Messages',
            },
          },
          {
            $project: {
              _id: 0,
              id: 1,
              content: 1,
              fromUserId: 1,
              sentWhen: 1,
              threadId: 1,
              in: 1,
              score: { $meta: 'searchScore' },
            },
          },
        ],
      });

      const refined = (JSON.parse(JSON.stringify(messages)) ?? []).map(
        (msg: any) => ({
          ...msg,
          phrase: refineContent(msg.content, query),
        })
      );
      return NextResponse.json(refined, { status: 200 });
    }

    return NextResponse.json([], { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while searching the messages.',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/messages/[messageId]/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { UserRole } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/messages/{messageId}:
 *   get:
 *     summary: Get Message
 *     description: Retrieves a message with the specified messageId.
 *     tags:
 *       - Messages
 *     parameters:
 *       - in: path
 *         name: messageId
 *         description: The ID of the message to be retrieved.
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: Message successfully retrieved
 *         content:
 *           application/json:
 *             schema:
 *               items:
 *                 $ref: '#/components/schemas/Message'
 *       '404':
 *         description: Message Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No message found with that messageId.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while retrieving the message.
 */
const GET = async (
  request: NextRequest,
  { params }: { params: { messageId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.message.checkUserIsParticipant,
      beforeUserParams: [params.messageId],
      afterUserParams: [true],
      roleAccess: [UserRole.ADMIN],
      customErrorMessage:
        'User is not an admin, participant, thread owner, or physician on this thread.',
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.message.getMessage(
      params.messageId,
      userInfo.user
    );

    if (!result)
      throw ApiErrorHandler.handle404Error({
        message: 'Unable to find a message with that messageId.',
        reqUrl: request.url,
      });

    // if this is a memo message, do not return it to the user it is associated with.
    if (result.memo?.id && result.memo.userId === userInfo.user.id)
      return ApiErrorHandler.handleBadRequest({
        message: 'User cannot view memos that are associated with them.',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while retrieving the message.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/messages/[messageId]/update-draft/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { MessageMedia } from '@prisma/client';

const checkIsMediaValid = (media: any) => {
  return (
    media &&
    media.length > 0 &&
    media.every((mediaObject: any) => mediaObject satisfies MessageMedia)
  );
};

/**
 * @swagger
 * /api/messaging/messages/{messageId}/update-draft:
 *   patch:
 *     summary: Update Draft Message
 *     description: Update a draft message with the specified messageId.
 *     tags:
 *       - Messages
 *     parameters:
 *       - in: path
 *         name: messageId
 *         description: The ID of the draft message to be updated.
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       description: The updated message content and media.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               message:
 *                 type: string
 *                 description: The updated message text.
 *               media:
 *                 $ref: '#/components/schemas/MessageMedia'
 *           example:
 *             message: "Updated draft message content"
 *             media:
 *               // Define your MessageMedia schema here
 *     responses:
 *       '200':
 *         description: Draft message successfully updated
 *         content:
 *           application/json:
 *             example:
 *               status: "success"
 *               message: Draft message updated successfully
 *       '400':
 *         description: Bad Request
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: message or media is required to update the draft. media must be a formatted MessageMedia object.
 *       '404':
 *         description: Draft Message Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No draft message found to update.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while updating the draft message.
 */
const PATCH = async (
  request: NextRequest,
  { params }: { params: { messageId: string } }
) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const message = safeBody.jsonBody['message'];
    const media = safeBody.jsonBody['media'];

    let hasMessage = false;
    if (message === '' || (message && message.length > 0)) {
      hasMessage = true;
    }

    if (!hasMessage && !checkIsMediaValid(media)) {
      return ApiErrorHandler.handleBadRequest({
        message: 'Must include a message or media',
        reqUrl: request.url,
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.message.userIsAuthor,
      beforeUserParams: [params.messageId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.message.saveDraft(
      params.messageId,
      userInfo.user,
      safeBody.jsonBody.message,
      safeBody.jsonBody.media
    );

    if (!result)
      return ApiErrorHandler.handle404Error({
        message: 'No message found to update.',
        reqUrl: request.url,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to update the draft message.',
      reqUrl: request.url,
      reqBody: safeBody.txtBody,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/messages/[messageId]/mark-read/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';

/**
 * @swagger
 * /api/messaging/messages/{messageId}/mark-read:
 *   patch:
 *     summary: Mark Message as Read
 *     description: Marks a message as read for a specific user.
 *     tags:
 *       - Messages
 *     parameters:
 *       - in: path
 *         name: messageId
 *         description: The ID of the message to be marked as read.
 *         required: true
 *         schema:
 *           type: string
 *       - in: body
 *         name: body
 *         description: User ID to mark the message as read.
 *         required: true
 *         schema:
 *           type: object
 *           properties:
 *             userId:
 *               type: string
 *         example:
 *           userId: "user123"
 *     responses:
 *       '200':
 *         description: Message successfully marked as read
 *         content:
 *           application/json:
 *             example:
 *               status: "success"
 *               message: Message marked as read successfully
 *       '400':
 *         description: Bad Request
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: User ID is required.
 *       '404':
 *         description: Message Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: Unable to find a message with that messageId.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while marking the message as read.
 */
const PATCH = async (
  request: NextRequest,
  { params }: { params: { messageId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.message.checkUserIsParticipant,
      beforeUserParams: [params.messageId],
      afterUserParams: [true],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.message.markMessageAsRead(
      params.messageId,
      userInfo.user
    );

    if (!result)
      throw ApiErrorHandler.handle404Error({
        message: 'Unable to find a message with that messageId.',
        reqUrl: request.url,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while marking the message as read.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/messages/[messageId]/archive/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { UserRole } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/messages/{messageId}/archive:
 *   patch:
 *     summary: Archive Message
 *     description: Archives a message with the given messageId.
 *     tags:
 *       - Messages
 *     parameters:
 *       - in: path
 *         name: messageId
 *         description: The ID of the message to be archived.
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: Message successfully archived
 *         content:
 *           application/json:
 *             example:
 *               status: "success"
 *               message: Message archived successfully
 *       '404':
 *         description: Message Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No message found to archive
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while archiving the message
 */
const PATCH = async (
  request: NextRequest,
  { params }: { params: { messageId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
      authMethod: messagingClient.message.userIsAuthor,
      beforeUserParams: [params.messageId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.message.archiveMessage(
      params.messageId,
      userInfo.user
    );

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while archiving the message',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/messages/[messageId]/delete/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { UserRole } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/messages/{messageId}/delete:
 *   patch:
 *     summary: Delete Message
 *     description: Deletes a message by marking it as deleted.
 *     tags:
 *       - Messages
 *     parameters:
 *       - in: path
 *         name: messageId
 *         description: The ID of the message to be deleted.
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: Message successfully deleted
 *         content:
 *           application/json:
 *             example:
 *               status: "success"
 *               message: Message deleted successfully
 *       '404':
 *         description: Message Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No message found to delete
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while deleting the message
 */
const PATCH = async (
  request: NextRequest,
  { params }: { params: { messageId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
      authMethod: messagingClient.message.userIsAuthor,
      beforeUserParams: [params.messageId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.message.deleteMessage(
      params.messageId,
      userInfo.user
    );

    if (!result)
      ApiErrorHandler.handle404Error({
        message: 'No message found to delete.',
        reqUrl: request.url,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while deleting the message.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/messages/[messageId]/unsend/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { UserRole } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/messages/{messageId}/unsend:
 *   patch:
 *     summary: Unsend Message
 *     description: Unsends a message with the specified messageId.
 *     tags:
 *       - Messages
 *     parameters:
 *       - in: path
 *         name: messageId
 *         description: The ID of the message to be unsent.
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: Message successfully unsent
 *         content:
 *           application/json:
 *             example:
 *               status: "success"
 *               message: Message unsent successfully
 *       '404':
 *         description: Message Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No message found to unsend.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while unsending the message.
 */
const PATCH = async (
  request: NextRequest,
  { params }: { params: { messageId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
      authMethod: messagingClient.message.userIsAuthor,
      beforeUserParams: [params.messageId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.message.unSendMessage(
      params.messageId,
      userInfo.user
    );

    if (!result)
      ApiErrorHandler.handle404Error({
        message: 'No message found to send.',
        reqUrl: request.url,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while unsending the message.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/messages/[messageId]/comment/route.ts

import { NextRequest } from 'next/server';

import { isUserAuthorized } from '@/utils/auth/auth';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { messagingClient } from '@models/extensions/messaging';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

/**
 * @swagger
 * /api/messaging/messages/{messageId}/comment:
 *   post:
 *     tags: [Messages]
 *     summary: Create a comment for a message
 *     description: Create a comment associated with a specific message using the messagingClient API.
 *     parameters:
 *       - in: path
 *         name: messageId
 *         required: true
 *         description: The ID of the message to create a comment for.
 *         schema:
 *           type: string
 *     requestBody:
 *       description: JSON payload containing details of the comment to create.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               comment:
 *                 type: string
 *           example:
 *             comment: "Support Team, please review this message and advise the user on how to proceed."
 *     responses:
 *       201:
 *         description: Comment created successfully.
 *         content:
 *           application/json:
 *             schema:
 *              $ref: '#/components/schemas/Memo'
 *       400:
 *         description: Bad request. Missing comment body.
 *         content:
 *           application/json:
 *             example:
 *               status: 400
 *               message: Missing fromUserId parameter.
 *       500:
 *         description: An error occurred while creating the comment.
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: An error occurred creating the comment.
 */
export const PATCH = async (
  request: NextRequest,
  { params: { messageId } }: { params: { messageId: string } }
) => {
  const requestBody = await getSafeRequestBody(request);
  if (!requestBody.isValidJson) return requestBody.badRequestResponse;

  try {
    if (!requestBody.jsonBody['comment']) {
      return ApiErrorHandler.handleBadRequest({
        message: 'Missing comment body.',
        reqUrl: request.url,
        reqBody: requestBody.txtBody,
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.message.checkUserIsParticipant,
      beforeUserParams: [messageId],
      afterUserParams: [true],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (
      !isUserAuthorized(userInfo.user, [
        UserRole.CORTINA_SUPPORT,
        UserRole.PHYSICIAN,
      ])
    ) {
      return ApiErrorHandler.handleUnauthorizedError({
        message: 'You are not authorized to create a comment.',
        reqUrl: request.url,
        reqBody: requestBody.txtBody,
      });
    }

    const updatedMessage = await messagingClient.message.update({
      where: {
        id: messageId,
      },
      data: {
        comments: {
          create: {
            content: requestBody.jsonBody['comment'],
            user: { connect: { id: userInfo.user.id } },
          },
        },
      },
    });

    return createCookieResponse(updatedMessage, userInfo.cookieJar);
  } catch (e) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred creating the memo.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      reqBody: requestBody.txtBody,
      error: e,
    });
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/messages/[messageId]/save-and-send/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { checkBodyForParams } from '@/utils/requests/checkBodyForParams';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { raiseMessageSentUserEvent } from '@/utils/user-events/user-event-utils';
import { MessageMedia } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/messages/{messageId}/save-and-send:
 *   patch:
 *     summary: Save and Send Message
 *     description: Saves and sends a message with optional media.
 *     tags:
 *       - Messages
 *     parameters:
 *       - in: path
 *         name: messageId
 *         description: The ID of the message to be saved and sent.
 *         required: true
 *         schema:
 *           type: string
 *       - in: body
 *         name: body
 *         description: Message content and optional media.
 *         required: true
 *         schema:
 *           type: object
 *           properties:
 *             message:
 *               type: string
 *             media:
 *               type: object
 *         example:
 *           message: "Hello, world!"
 *           media: { mediaUrl: "https://example.com/image.jpg", mediaId: "12345", mediaType: "image/jpeg" }
 *     responses:
 *       '200':
 *         description: Message successfully saved and sent
 *         content:
 *           application/json:
 *             example:
 *               status: "success"
 *               message: Message saved and sent successfully
 *       '400':
 *         description: Bad Request
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: Invalid message or media format
 *       '404':
 *         description: Message Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No message found to save and send.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while saving and sending the message.
 */
const PATCH = async (
  request: NextRequest,
  { params: { messageId } }: { params: { messageId: string } }
) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.message.userIsAuthor,
      beforeUserParams: [messageId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const checkBodyParams = await checkBodyForParams(request, safeBody, [
      { prop: 'message', orProps: ['media'] },
      {
        prop: 'media',
        validator: (media: any) => media satisfies MessageMedia,
        orProps: ['message'],
      },
    ]);

    if (!checkBodyParams.success) return checkBodyParams.badRequestResponse;

    const result = await messagingClient.message.saveAndSend(
      messageId,
      userInfo.user,
      safeBody.jsonBody.message,
      safeBody.jsonBody.media
    );

    if (!result)
      return ApiErrorHandler.handle404Error({
        message: 'No message found to save and send.',
        reqUrl: request.url,
      });

    await raiseMessageSentUserEvent(result, userInfo.user);

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred while attempting to save and send',
      reqUrl: request.url,
      reqBody: safeBody.txtBody,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/messages/[messageId]/remove-media/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { MessageMedia } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/messages/{messageId}/update-draft:
 *   patch:
 *     summary: Update Draft Message
 *     description: Update a draft message with the specified messageId.
 *     tags:
 *       - Messages
 *     parameters:
 *       - in: path
 *         name: messageId
 *         description: The ID of the draft message to be updated.
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       description: The updated message content and media.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               message:
 *                 type: string
 *                 description: The updated message text.
 *               media:
 *                 $ref: '#/components/schemas/MessageMedia'
 *           example:
 *             message: "Updated draft message content"
 *             media:
 *               // Define your MessageMedia schema here
 *     responses:
 *       '200':
 *         description: Draft message successfully updated
 *         content:
 *           application/json:
 *             example:
 *               status: "success"
 *               message: Draft message updated successfully
 *       '400':
 *         description: Bad Request
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: message or media is required to update the draft. media must be a formatted MessageMedia object.
 *       '404':
 *         description: Draft Message Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No draft message found to update.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while updating the draft message.
 */
const PATCH = async (
  request: NextRequest,
  { params }: { params: { messageId: string } }
) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const media = safeBody.jsonBody['media'];

    if (!media || !(media satisfies MessageMedia)) {
      return ApiErrorHandler.handleBadRequest({
        message: 'Must include a media object',
        reqUrl: request.url,
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.message.userIsAuthor,
      beforeUserParams: [params.messageId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.message.removeMedia(
      params.messageId,
      userInfo.user,
      safeBody.jsonBody.media
    );

    if (!result)
      return ApiErrorHandler.handle404Error({
        message: 'No message found to update.',
        reqUrl: request.url,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message:
        'An error ocurred trying to remove the media attachment from the message.',
      reqUrl: request.url,
      reqBody: safeBody.txtBody,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/messages/[messageId]/send/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { raiseMessageSentUserEvent } from '@/utils/user-events/user-event-utils';

/**
 * @swagger
 * /api/messaging/messages/{messageId}/send:
 *   patch:
 *     summary: Send Message
 *     description: Sends a message with the specified messageId.
 *     tags:
 *       - Messages
 *     parameters:
 *       - in: path
 *         name: messageId
 *         description: The ID of the message to be sent.
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: Message successfully sent
 *         content:
 *           application/json:
 *             example:
 *               status: "success"
 *               message: Message sent successfully
 *       '404':
 *         description: Message Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No message found to send.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while sending the message.
 */
const PATCH = async (
  request: NextRequest,
  { params }: { params: { messageId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.message.userIsAuthor,
      beforeUserParams: [params.messageId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.message.sendMessage(
      params.messageId,
      userInfo.user
    );

    if (!result)
      ApiErrorHandler.handle404Error({
        message: 'No message found to send.',
        reqUrl: request.url,
      });

    await raiseMessageSentUserEvent(result, userInfo.user);

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Failed to send message',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/messages/[messageId]/media/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { uploadFileToS3 } from '@/utils/file-upload/file-upload';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { S3Client } from '@aws-sdk/client-s3';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const Bucket = process.env.MESSAGE_MEDIA_BUCKET ?? 'dev-dermi-messaging-media';
const s3 = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.MESSAGE_MEDIA_AWS_ACCESS_KEY as string,
    secretAccessKey: process.env.MESSAGE_MEDIA_SECRET_ACCESS_KEY as string,
  },
});

/**
 * @swagger
 * /api/messaging/messages/{messageId}/media:
 *   post:
 *     summary: Upload media images for a message to s3.
 *     description: Upload media images to s3 to a draft message.
 *     tags:
 *       - Messages
 *     parameters:
 *       - in: path
 *         name: messageId
 *         description: The message ID.
 *         required: true
 *         schema:
 *           type: string
 *       - in: formData
 *         type: file
 *         description: The file to upload.
 *     responses:
 *       '200':
 *         description: The media upload status.
 *         content:
 *           application/json:
 *             schema:
 *              items:
 *                $ref: '#/components/schemas/FileUploadResult'
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: There was a problem uploading the file
 */
const POST = async (
  request: NextRequest,
  { params: { messageId } }: { params: { messageId: string } }
) => {
  try {
    if (!messageId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'You must include a valid messageId',
        reqUrl: request.url,
        reqBody: '',
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.message.userIsAuthor,
      beforeUserParams: [messageId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const formData = await request.formData();
    const files = formData.getAll('file') as File[];

    const response = await Promise.all(
      files.map(async (file) => {
        const s3Key = `${userInfo.user.id}/${messageId}/${file.name}`;
        return uploadFileToS3(Bucket, s3Key, file, s3);
      })
    );

    return createCookieResponse(response, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem uploading the file',
      reqUrl: request.url,
      reqBody: '',
      error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/memos/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { UserRole } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/memos:
 *   get:
 *     tags: [Memos]
 *     summary: Get all memos
 *     description: Retrieve all memos using the messagingClient API.
 *     responses:
 *       200:
 *         description: Memos retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Memo'
 *       404:
 *         description: No memos found.
 *         content:
 *           application/json:
 *             example:
 *               status: 404
 *               message: No memos found.
 *       500:
 *         description: An error occurred while retrieving memos.
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: Failed to retrieve memos.
 */
const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    }); //admin only route

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const allMemos = await messagingClient.memo.findMany({
      include: {
        content: true,
      },
    });

    if (allMemos.length < 1)
      return ApiErrorHandler.handle404Error({
        message: 'No memos found.',
        reqUrl: request.url,
      });

    return createCookieResponse(allMemos, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Failed to retrieve memos.',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/memos/[memoId]/route.ts

import { NextRequest } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { messagingClient } from '@models/extensions/messaging';

/**
 * @swagger
 * /api/messaging/memos/{memoId}:
 *   get:
 *     tags: [Memos]
 *     summary: Get a memo by ID
 *     description: Retrieve a memo by its unique ID using the messagingClient API.
 *     parameters:
 *       - in: path
 *         name: memoId
 *         required: true
 *         description: The ID of the memo to retrieve.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Memo retrieved successfully.
 *         content:
 *           application/json:
 *             example:
 *               memoId: "12345"
 *               title: "Sample Memo"
 *               content: "This is a sample memo."
 *       404:
 *         description: Memo not found.
 *         content:
 *           application/json:
 *             example:
 *               status: 404
 *               message: No memo with that id has been found.
 *       500:
 *         description: An error occurred while retrieving the memo.
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: Failed to retrieve memo.
 */
const GET = async (
  request: NextRequest,
  { params: { memoId } }: { params: { memoId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.memo.checkUserAccess,
      beforeUserParams: [memoId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.memo.getMemoById(
      memoId,
      userInfo.user
    );

    if (!result)
      return ApiErrorHandler.handle404Error({
        message: 'No memo with that id has been found.',
        reqUrl: request.url,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Failed to retrieve memo.',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/memos/[memoId]/save-and-publish/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { checkBodyForParams } from '@/utils/requests/checkBodyForParams';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { MessageMedia } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/memos/{memoId}/save-and-publish:
 *   patch:
 *     summary: Save and Publish Memo
 *     description: Saves and publishes a memo with the given memoId.
 *     tags:
 *       - Memos
 *     parameters:
 *       - in: path
 *         name: memoId
 *         description: The ID of the memo to be saved and published.
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       description: The message and media to save and publish.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               message:
 *                 type: string
 *                 description: The content of the message.
 *               media:
 *                 $ref: '#/components/schemas/MessageMedia'
 *     responses:
 *       '200':
 *         description: Memo successfully saved and published
 *         content:
 *           application/json:
 *             example:
 *               status: "success"
 *               message: Memo saved and published successfully
 *       '400':
 *         description: Bad Request
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: message or media are required. media must be a formatted MessageMedia object.
 *       '404':
 *         description: Memo Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No memo found to save and publish
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while saving and publishing the memo
 */
const PATCH = async (
  request: NextRequest,
  { params: { memoId } }: { params: { memoId: string } }
): Promise<NextResponse> => {
  const requestBody = await getSafeRequestBody(request);
  if (!requestBody.isValidJson && requestBody.badRequestResponse)
    return requestBody.badRequestResponse;

  try {
    const body = requestBody.jsonBody;
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.memo.userIsAuthor,
      beforeUserParams: [memoId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const requiredBodyParams = [
      { prop: 'message', orProp: 'media' },
      {
        prop: 'media',
        validator: (media: any) => media satisfies MessageMedia,
        orProp: 'message',
      },
    ];

    const validBody = await checkBodyForParams(
      request,
      requestBody,
      requiredBodyParams
    );

    if (!validBody.success && validBody.badRequestResponse)
      return validBody.badRequestResponse;

    const result = await messagingClient.memo.saveAndPublishMemo(
      memoId,
      userInfo.user,
      body.message,
      body.media
    );

    if (!result)
      return ApiErrorHandler.handle404Error({
        message: 'No memo found to save and publish.',
        reqUrl: request.url,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while saving and publishing the memo.',
      reqUrl: request.url,
      reqBody: requestBody.txtBody,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/memos/[memoId]/update-draft/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { MessageMedia } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/memos/{memoId}/update-draft:
 *   patch:
 *     summary: Update Draft Memo
 *     description: Updates a draft memo with the given memoId.
 *     tags:
 *       - Memos
 *     parameters:
 *       - in: path
 *         name: memoId
 *         description: The ID of the draft memo to be updated.
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       description: The message and media to update the draft memo.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               message:
 *                 type: string
 *                 description: The content of the message.
 *               media:
 *                 $ref: '#/components/schemas/MessageMedia'
 *     responses:
 *       '201':
 *         description: Draft memo successfully updated
 *         content:
 *           application/json:
 *             example:
 *               status: "success"
 *               message: Draft memo updated successfully
 *       '400':
 *         description: Bad Request
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: message or media are required. media must be a formatted MessageMedia object.
 *       '404':
 *         description: Memo Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No draft memo found to update
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while updating the draft memo
 */
const PATCH = async (
  request: NextRequest,
  { params }: { params: { memoId: string } }
) => {
  const requestBody = await getSafeRequestBody(request);
  if (!requestBody.isValidJson) return requestBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.memo.userIsAuthor,
      beforeUserParams: [params.memoId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = requestBody.jsonBody;

    if (!body.message || !body.media || !(body.media satisfies MessageMedia))
      return ApiErrorHandler.handleBadRequest({
        message:
          'message or media are required. media must be a formatted MessageMedia object.',
        reqUrl: request.url,
        reqBody: requestBody.txtBody,
      });

    const result = await messagingClient.memo.updateDraftMemo(
      params.memoId,
      userInfo.user,
      body.message,
      body.media
    );

    if (!result)
      return ApiErrorHandler.handle404Error({
        message: 'No memo found to update.',
        reqUrl: request.url,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while updating the draft memo.',
      reqUrl: request.url,
      reqBody: requestBody.txtBody,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/memos/[memoId]/archive/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { UserRole } from '@prisma/client';

/**
 * @swagger
 *   /api/messaging/memos/{memoId}/archive:
 *   patch:
 *     tags: [Memos]
 *     summary: Archive Memo
 *     description: Archives a memo by marking it as archived.
 *     parameters:
 *       - in: path
 *         name: memoId
 *         description: The ID of the memo to be archived
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       '201':
 *         description: Memo successfully archived
 *         content:
 *           application/json:
 *             example:
 *               status: "success"
 *               message: Memo archived successfully
 *       '404':
 *         description: Memo Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No memo found to archive
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while archiving the memo
 */
const PATCH = async (
  request: NextRequest,
  { params: { memoId } }: { params: { memoId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
      authMethod: messagingClient.memo.userIsAuthor,
      beforeUserParams: [memoId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.memo.archiveMemo(
      memoId,
      userInfo.user
    );

    if (!result)
      return ApiErrorHandler.handle404Error({
        message: 'No memo found to archive.',
        reqUrl: request.url,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred attempting to archive the memo.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/memos/[memoId]/delete/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { UserRole } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/memos/{memoId}/delete:
 *   patch:
 *     summary: Delete Memo
 *     description: Deletes a memo by marking it as deleted.
 *     tags:
 *       - Memos
 *     parameters:
 *       - in: path
 *         name: memoId
 *         description: The ID of the memo to be deleted
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: Memo successfully deleted
 *         content:
 *           application/json:
 *             example:
 *               status: "success"
 *               message: Memo deleted successfully
 *       '404':
 *         description: Memo Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No memo found to delete
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while deleting the memo
 */
const PATCH = async (
  request: NextRequest,
  { params: { memoId } }: { params: { memoId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
      authMethod: messagingClient.memo.userIsAuthor,
      beforeUserParams: [memoId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.memo.deleteMemo(memoId, userInfo.user);

    if (!result)
      return ApiErrorHandler.handle404Error({
        message: 'No memo found to delete.',
        reqUrl: request.url,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred attempting to delete the memo.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/memos/[memoId]/publish/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';

/**
 * @swagger
 * /api/messaging/memos/{memoId}/publish:
 *   patch:
 *     summary: Publish Memo
 *     description: Publishes a memo with the given memoId.
 *     tags:
 *       - Memos
 *     parameters:
 *       - in: path
 *         name: memoId
 *         description: The ID of the memo to be published.
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: Memo successfully published
 *         content:
 *           application/json:
 *             example:
 *               status: "success"
 *               message: Memo published successfully
 *       '404':
 *         description: Memo Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No memo found to publish
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while publishing the memo
 */
const PATCH = async (
  request: NextRequest,
  { params: { memoId } }: { params: { memoId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.memo.userIsAuthor,
      beforeUserParams: [memoId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.memo.publishMemo(
      memoId,
      userInfo.user
    );

    if (!result)
      return ApiErrorHandler.handle404Error({
        message: 'No memo found to publish.',
        reqUrl: request.url,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while publishing the memo.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { ErrorNextResponse } from '@/utils/errors/apiErrorHandler';
import {
  IExtendedCase,
  getCasePhysicianAccess,
} from '@/utils/get-case-physician-access';
import { getUserAttributes } from '@/utils/helpers/helpers';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import {
  CookieJar,
  createCookieResponse,
} from '@/utils/responses/responseHelpers';
import { messagingClient } from '@models/extensions/messaging';
import {
  ThreadType,
  ThreadStatus,
  MessageStatus,
  ThreadParticipantStatus,
  CaseStatus,
  UserRole,
  Thread,
  Case,
  User,
  Message,
} from '@prisma/client';

type ThreadSelectResult = Pick<
  Thread,
  'id' | 'createdAt' | 'type' | 'status' | 'caseId'
> & { case: CaseSelectResult | null } & {
  messages: Pick<Message, 'sentWhen' | 'updatedAt' | 'content'>[];
} & {
  _count: { messages: number };
};

type CaseSelectResult =
  | Pick<Case, 'id' | 'createdAt' | 'complaint' | 'status'> & {
      physician: Pick<
        User,
        'id' | 'avatarUrl' | 'firstName' | 'lastName' | 'email'
      > | null;
    };

type ThreadReturnType = ThreadSelectResult & {
  case: Pick<
    IExtendedCase<Case>,
    'hasPhysicianAccess' | 'nonConciergeAccessExpiresOn'
  > | null;
};

const GET = async (
  request: NextRequest
): Promise<NextResponse<ThreadReturnType[] | ErrorNextResponse>> => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const query = request.nextUrl.searchParams;

    let status: ThreadStatus | undefined = undefined;

    if (query.has('status')) {
      status = query.get('status') as ThreadStatus;
    }

    const userAttributes = await getUserAttributes(userInfo.user);

    const threads: ThreadSelectResult[] = await messagingClient.thread.findMany(
      {
        where: {
          userId: userInfo.user.id,
          status: status ?? { not: ThreadStatus.DELETED },
        },
        include: {
          case: {
            select: {
              id: true,
              createdAt: true,
              complaint: true,
              status: true,
              physician: {
                select: {
                  id: true,
                  avatarUrl: true,
                  firstName: true,
                  lastName: true,
                  email: true,
                },
              },
            },
          },
          messages: {
            where: {
              status: MessageStatus.SENT,
            },
            orderBy: { sentWhen: 'desc' },
            take: 1,
            select: {
              sentWhen: true,
              updatedAt: true,
              content: true,
            },
          },
          _count: {
            select: {
              messages: {
                where: {
                  status: MessageStatus.SENT,
                  NOT: {
                    readByIds: {
                      has: userInfo.user.id,
                    },
                  },
                },
              },
            },
          },
        },
      }
    );

    const closedCaseStatus: CaseStatus[] = [
      CaseStatus.DELETED,
      CaseStatus.ARCHIVED,
      CaseStatus.EXPIRED,
    ];

    const threadsWithCaseAccess: ThreadReturnType[] = threads.reduce(
      (acc: ThreadReturnType[], thread) => {
        // filter based on status
        if (
          thread.type === ThreadType.MEDICAL &&
          thread.case &&
          closedCaseStatus.includes(thread.case.status)
        )
          return acc;

        acc.push({
          ...thread,
          case: thread.case
            ? getCasePhysicianAccess<CaseSelectResult>(
                thread.case,
                userAttributes
              )
            : null,
        });
        return acc;
      },
      []
    );

    if (!threads) return NextResponse.json([], { status: 200 });

    return NextResponse.json(threadsWithCaseAccess, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while retrieving the threads.',
      reqUrl: request.url,
      error: error,
    });
  }
};

/**
 * @swagger
 * /api/messaging/threads:
 *   put:
 *     summary: Create Thread
 *     description: Creates a new thread.
 *     tags:
 *       - Threads
 *     requestBody:
 *       description: Thread data to be created
 *       required: true
 *       content:
 *         application/json:
 *           example:
 *             userId: "12345"
 *             type: "MEDICAL"
 *             participants: ["user1", "user2"]
 *             initialMessage: "Hello, this is the initial message."
 *             caseRef: "case123"
 *     responses:
 *       '201':
 *         description: Thread successfully created
 *         content:
 *           application/json:
 *             schema:
 *                 $ref: '#/components/schemas/Thread'
 *
 *       '400':
 *         description: Bad Request
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: Invalid thread data.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while creating the thread.
 */
const PUT = async (request: NextRequest) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const cookieJar: CookieJar = { cookies: [] };
    const userResult = await getUserAndCheckAuthorized({
      request,
    });

    if (!userResult.success) return userResult.unAuthorizedResponse;

    if (!isPostedThread(safeBody.jsonBody))
      return ApiErrorHandler.handleBadRequest({
        message: 'Invalid thread data.',
        reqUrl: request.url,
        reqBody: safeBody.txtBody,
      });

    const { type, caseRef, participants, initialMessage } = safeBody.jsonBody;

    const mappedParticipants = participants
      ? participants.map((participant: string) => ({
          userId: participant,
          status: ThreadParticipantStatus.ACTIVE,
        }))
      : undefined;

    let threadUserId = userResult.user.id;

    if (type === ThreadType.MEDICAL) {
      const foundCase = await prisma.case.findUnique({
        where: { id: caseRef },
      });

      if (!foundCase)
        return ApiErrorHandler.handleBadRequest({
          message: 'Case with the provided id not found.',
          reqUrl: request.url,
          reqBody: safeBody.txtBody,
        });

      if (
        foundCase.userId !== userResult.user.id &&
        !userResult.user.roles.includes(UserRole.ADMIN)
      )
        return ApiErrorHandler.handleUnauthorizedError({
          message: 'User is not authorized to create a thread on this case.',
          reqUrl: request.url,
          reqHeaders: request.headers,
          additionalContext: {
            caseUserId: foundCase.userId,
            user: userResult.user,
            requiredRoles: UserRole.ADMIN,
          },
        });

      threadUserId = foundCase.userId;
    }

    const thread = await messagingClient.thread.createThread(
      threadUserId,
      type,
      caseRef,
      mappedParticipants ?? undefined,
      initialMessage ?? undefined
    );

    if (!thread) throw new Error('Thread was not created.');

    return createCookieResponse(thread, cookieJar, 201);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while creating the thread.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      reqBody: safeBody.txtBody,
      error: error,
    });
  }
};

const isPostedThread = (postedData: any) => {
  const isValid =
    postedData.type &&
    (postedData.type === ThreadType.SUPPORT ||
      (postedData.type === ThreadType.MEDICAL && postedData.caseRef));

  return isValid;
};

export { GET, PUT };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/participant/route.ts

import { NextRequest } from 'next/server';

import { getUserInfo } from '@/utils/auth/auth';
import { ApiErrorHandler } from '@/utils/errors';
import {
  CookieJar,
  createCookieResponse,
} from '@/utils/responses/responseHelpers';
import { messagingClient } from '@models/extensions/messaging';
import { MessageStatus, ThreadStatus } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/threads/participant:
 *   get:
 *     summary: Get Participant Threads
 *     description: Retrieves a list of threads.
 *     tags:
 *       - Threads
 *     responses:
 *       '200':
 *         description: Threads successfully retrieved
 *         content:
 *           application/json:
 *             schema:
 *              type: array
 *              items:
 *                $ref: '#/components/schemas/Thread'
 *       '404':
 *         description: Threads Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No threads found.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while retrieving the threads.
 */
const GET = async (request: NextRequest) => {
  try {
    const cookieJar: CookieJar = { cookies: [] };
    const user = await getUserInfo(request, cookieJar);

    const query = request.nextUrl.searchParams;

    let status: ThreadStatus | undefined = undefined;

    if (query.has('status')) {
      status = query.get('status') as ThreadStatus;
    }

    const threadParticipants = await messagingClient.threadParticipant.findMany(
      {
        where: {
          userId: user.id,
        },
        select: {
          id: true,
          threadId: true,
        },
      }
    );

    const threads = await messagingClient.thread.findMany({
      where: {
        id: { in: threadParticipants.map((x) => x.threadId) },
        status: status ?? ThreadStatus.ACTIVE,
      },
      select: {
        id: true,
        status: true,
        createdAt: true,
        updatedAt: true,
        userId: true,
        user: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        messages: {
          where: {
            status: MessageStatus.SENT,
          },
          orderBy: { sentWhen: 'desc' },
          take: 1,
          select: {
            fromUserId: true,
            content: true,
            sentWhen: true,
          },
        },
        _count: {
          select: {
            messages: {
              where: {
                status: MessageStatus.SENT,
                NOT: {
                  readByIds: {
                    has: user.id,
                  },
                },
              },
            },
          },
        },
      },
    });

    if (!threads)
      return ApiErrorHandler.handle404Error({
        message: 'No threads found.',
        reqUrl: request.url,
      });

    return createCookieResponse(threads, cookieJar, 200);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while retrieving the threads.',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/admin/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { messagingClient } from '@models/extensions/messaging';
import {
  ThreadType,
  ThreadStatus,
  UserRole,
  MessageStatus,
} from '@prisma/client';

const safeParseJSON = (str: string, defaultReturn?: any) => {
  try {
    return JSON.parse(str);
  } catch (error) {
    return defaultReturn;
  }
};

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN, UserRole.CORTINA_SUPPORT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;
    const query = request.nextUrl.searchParams;

    const whereQuery: { status?: any; userId?: string } = {};

    if (query.has('status')) {
      const status = query.get('status') ?? '';
      const parsed = safeParseJSON(status, status);
      if (
        Array.isArray(parsed) &&
        parsed.every((stat) => stat in ThreadStatus)
      ) {
        whereQuery.status = { in: parsed as ThreadStatus[] };
      } else {
        whereQuery.status = query.get('status') as ThreadStatus;
      }
    }

    if (query.has('userId')) {
      whereQuery.userId = query.get('userId') as string;
    }

    const threads = await messagingClient.thread.findMany({
      where: {
        type: ThreadType.SUPPORT,
        ...whereQuery,
      },
      include: {
        user: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        participants: {
          include: {
            user: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
          },
        },
        messages: {
          where: {
            status: MessageStatus.SENT,
          },
          orderBy: { sentWhen: 'desc' },
          take: 1,
        },
      },
    });

    return NextResponse.json(threads, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while retrieving the threads.',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { ApiErrorHandler } from '@utils/errors';

/**
 * @swagger
 * /api/messaging/threads/{threadId}:
 *   get:
 *     tags: [Threads]
 *     summary: Get a thread by ID
 *     description: Retrieve a thread by its unique ID using the messagingClient API.
 *     parameters:
 *       - in: path
 *         name: threadId
 *         required: true
 *         description: The ID of the thread to retrieve.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Thread retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *              $ref: '#/components/schemas/Thread'
 *       404:
 *         description: Thread not found.
 *         content:
 *           application/json:
 *             example:
 *               status: 404
 *               message: No thread found for that thread id.
 *       500:
 *         description: An error occurred while retrieving the thread.
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: An error occurred while retrieving the thread.
 */
const GET = async (
  request: NextRequest,
  { params }: { params: { threadId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.thread.checkUserAccess,
      beforeUserParams: [params.threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.thread.getThread(params.threadId);

    if (!result)
      throw ApiErrorHandler.handle404Error({
        message: 'No thread found for that thread id.',
        reqUrl: request.url,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while retrieving the thread.',
      reqUrl: request.url,
      error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/participants/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';

/**
 * @swagger
 * /api/messaging/threads/{threadId}/participants:
 *   get:
 *     tags: [Threads]
 *     summary: Get active participants of a thread
 *     description: Retrieve participants of a specific thread using the messagingClient API.
 *     parameters:
 *       - in: path
 *         name: threadId
 *         required: true
 *         description: The ID of the thread to retrieve participants for.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Participants of the thread retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *              $ref: '#/components/schemas/Thread'
 *       404:
 *         description: Participants not found for the thread or thread not found.
 *         content:
 *           application/json:
 *             example:
 *               status: 404
 *               message: No participants found for that thread.
 *       500:
 *         description: An error occurred while retrieving the thread participants.
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: An error occurred while retrieving the thread participants.
 */
const GET = async (
  request: NextRequest,
  { params: { threadId } }: { params: { threadId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.thread.checkUserAccess,
      beforeUserParams: [threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.thread.getActiveThreadParticipants(
      threadId
    );

    if (!result)
      return ApiErrorHandler.handle404Error({
        message: 'No participants found for that thread.',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while retrieving the thread participants.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/participants/deactivate/route.ts

import { NextRequest } from 'next/server';

import { checkBodyForParams } from '@/utils/requests/checkBodyForParams';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { messagingClient } from '@models/extensions/messaging';
import { ApiErrorHandler } from '@utils/errors';

/**
 * @swagger
 * /api/messaging/threads/{threadId}/participants:
 *   patch:
 *     tags: [Threads]
 *     summary: Remove a participant from a thread
 *     description: Remove a participant from a specific thread using the messagingClient API.
 *     parameters:
 *       - in: path
 *         name: threadId
 *         required: true
 *         description: The ID of the thread to remove a participant from.
 *         schema:
 *           type: string
 *     requestBody:
 *       description: JSON payload containing the userId of the participant to remove.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               userId:
 *                 type: string
 *           example:
 *             userId: "user123"
 *     responses:
 *       201:
 *         description: Participant removed from the thread successfully.
 *         content:
 *           application/json:
 *             schema:
 *              $ref: '#/components/schemas/Thread'
 *       400:
 *         description: Bad request. Missing userId parameter.
 *         content:
 *           application/json:
 *             example:
 *               status: 400
 *               message: userId is required.
 *       500:
 *         description: An error occurred while removing the participant from the thread.
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: Unable to remove participant from thread.
 */
const PATCH = async (
  request: NextRequest,
  { params }: { params: { threadId: string } }
) => {
  const requestBody = await getSafeRequestBody(request);
  if (!requestBody.isValidJson) return requestBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.thread.isSupportOrParticipant,
      beforeUserParams: [params.threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const requiredBodyParams = [
      {
        prop: 'userId',
      },
    ];

    const hasBodyParams = await checkBodyForParams(
      request,
      requestBody,
      requiredBodyParams
    );

    if (!hasBodyParams.success) return hasBodyParams.badRequestResponse;

    const result = await messagingClient.thread.removeParticipant(
      requestBody.jsonBody.userId,
      params.threadId,
      userInfo.user
    );

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Unable to remove participant from thread',
      reqUrl: request.url,
      reqBody: requestBody.txtBody,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/participants/activate/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { checkBodyForParams } from '@/utils/requests/checkBodyForParams';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';

/**
 * @swagger
 * /api/messaging/threads/{threadId}/participants/activate:
 *   post:
 *     tags: [Threads]
 *     summary: Add a participant to a thread
 *     description: Add a participant to a specific thread using the messagingClient API.
 *     parameters:
 *       - in: path
 *         name: threadId
 *         required: true
 *         description: The ID of the thread to add a participant to.
 *         schema:
 *           type: string
 *     requestBody:
 *       description: JSON payload containing the userId of the participant to add.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               userId:
 *                 type: string
 *           example:
 *             userId: "user123"
 *     responses:
 *       201:
 *         description: Participant added to the thread successfully.
 *         content:
 *           application/json:
 *             schema:
 *              $ref: '#/components/schemas/Thread'
 *       400:
 *         description: Bad request. Missing userId parameter.
 *         content:
 *           application/json:
 *             example:
 *               status: 400
 *               message: userId is required.
 *       500:
 *         description: An error occurred while adding the participant to the thread.
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: Unable to add participant to thread.
 */
const PATCH = async (
  request: NextRequest,
  { params: { threadId } }: { params: { threadId: string } }
) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.thread.isSupportOrParticipant,
      beforeUserParams: [threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const checkBodyParams = await checkBodyForParams(request, safeBody, [
      {
        prop: 'userId',
      },
    ]);
    if (!checkBodyParams.success) return checkBodyParams.badRequestResponse;

    const result = await messagingClient.thread.addParticipant(
      safeBody.jsonBody.userId,
      threadId,
      userInfo.user
    );

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Unable to add participant to thread',
      reqUrl: request.url,
      reqBody: safeBody.txtBody,
      reqHeaders: request.headers,
      error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/participants/avatars/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getS3Url } from '@/utils/file-upload/file-upload';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { S3Client } from '@aws-sdk/client-s3';
import { messagingClient } from '@models/extensions/messaging';

const s3 = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.PROFILE_AVATAR_AWS_ACCESS_KEY as string,
    secretAccessKey: process.env.PROFILE_AVATAR_SECRET_ACCESS_KEY as string,
  },
});

const GET = async (
  request: NextRequest,
  { params: { threadId } }: { params: { threadId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.thread.checkUserAccess,
      beforeUserParams: [threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const thread = await messagingClient.thread.findUnique({
      where: {
        id: threadId,
      },
      include: {
        case: {
          include: {
            physician: {
              select: {
                id: true,
                avatarUrl: true,
              },
            },
          },
        },
        user: true,
        participants: {
          include: {
            user: {
              select: {
                id: true,
                avatarUrl: true,
              },
            },
          },
        },
      },
    });

    if (!thread)
      return ApiErrorHandler.handle404Error({
        message: 'No threads found.',
        reqUrl: request.url,
      });

    const addUserAsParticipant = !thread.participants.some(
      (participant) => participant.userId === thread.user.id
    );
    const addPhysicianAsParticipant = !thread.participants.some(
      (participant) => participant.userId === thread.case?.physician?.id
    );

    if (addUserAsParticipant) {
      const newParticipant = await messagingClient.thread.addParticipant(
        thread.user.id,
        threadId,
        userInfo.user
      );

      thread.participants.push(newParticipant);
    }

    if (addPhysicianAsParticipant && !!thread.case?.physician?.id) {
      const newParticipant = await messagingClient.thread.addParticipant(
        thread.case.physician.id,
        threadId,
        userInfo.user
      );

      thread.participants.push(newParticipant);
    }

    const participantAvatars = await Promise.all(
      thread.participants.map(async (participant) => {
        const response = await getS3Url({
          mediaUrl: participant.user.avatarUrl ?? undefined,
          expiresIn: 3600,
          s3Client: s3,
          source: 'get_participant_avatars',
        });

        const returnObj = {
          userId: participant.userId,
          s3Url: !response || response.error ? null : response.s3Url,
        };

        return returnObj;
      })
    );

    return NextResponse.json(participantAvatars, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while retrieving the threads.',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/messages/route.ts

import { NextRequest } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { messagingClient } from '@models/extensions/messaging';
import { MessageStatus } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/threads/{threadId}/messages:
 *   get:
 *     tags: [Messages]
 *     summary: Get messages for a thread
 *     description: Retrieve all messages for a thread.
 *     parameters:
 *       - in: path
 *         name: threadId
 *         required: true
 *         description: The ID of the thread to retrieve messages for.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Messages for the thread retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *             type: array
 *             items:
 *              $ref: '#/components/schemas/Message'
 *       404:
 *         description: No messages associated with the thread or thread not found.
 *         content:
 *           application/json:
 *             example:
 *               status: 404
 *               message: No messages associated with this thread.
 *       500:
 *         description: An error occurred while retrieving messages for the thread.
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: Unable to retrieve messages for thread.
 */
export const GET = async (
  request: NextRequest,
  { params: { threadId } }: { params: { threadId: string } }
) => {
  try {
    const url = new URL(request.url);
    const searchParams = new URLSearchParams(url.search);
    const status = searchParams.get('status');

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.thread.checkUserAccess,
      beforeUserParams: [threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const isValidStatus = !!status && status in MessageStatus;

    // GET ALL MESSAGES
    const messages = await messagingClient.message.getMessagesForThread(
      threadId,
      userInfo.user,
      isValidStatus ? (status as MessageStatus) : undefined
    );

    if (!messages)
      return ApiErrorHandler.handle404Error({
        message: 'No messages associated with this thread.',
        reqUrl: request.url,
      });

    return createCookieResponse(messages, userInfo.cookieJar);
  } catch (e) {
    return ApiErrorHandler.handleServerError({
      message: 'Unable to retrieve messages for thread.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: e,
    });
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/messages/draft/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import HttpStatusCode from '@/utils/statusCodes';
import { ApiErrorHandler } from '@utils/errors';

/**
 * @swagger
 * /api/messaging/threads/{threadId}/messages/draft:
 *   put:
 *     tags: [Messages]
 *     summary: Create a draft message for a thread
 *     description: Create a draft message for a specific thread using the messagingClient API.
 *     parameters:
 *       - in: path
 *         name: threadId
 *         required: true
 *         description: The ID of the thread to create a draft message for.
 *         schema:
 *           type: string
 *     requestBody:
 *       description: JSON payload containing details of the draft message to create.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromUserId:
 *                 type: string
 *               messageReference:
 *                 description: The ID of the message this is in reply to.
 *                 type: string
 *           example:
 *             fromUserId: "user123"
 *             messageReference: "ref456"
 *     responses:
 *       201:
 *         description: Draft message created successfully.
 *         content:
 *           application/json:
 *             schema:
 *              $ref: '#/components/schemas/Message'
 *       400:
 *         description: Bad request. Missing fromUserId parameter.
 *         content:
 *           application/json:
 *             example:
 *               status: 400
 *               message: fromUserId is required.
 *       500:
 *         description: An error occurred while creating the draft message.
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: An error occurred creating the message.
 */
const PUT = async (
  request: NextRequest,
  { params: { threadId } }: { params: { threadId: string } }
) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson && safeBody.txtBody.length > 0)
    return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.thread.checkUserAccess,
      beforeUserParams: [threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const message = await messagingClient.thread.addDraftMessage({
      threadId: threadId,
      fromUser: userInfo.user,
      respondingTo: safeBody?.jsonBody?.respondingTo ?? undefined, // RE: message
      mentionedUsers: safeBody?.jsonBody?.mentionedUsers ?? undefined, // @user
    });

    return createCookieResponse(
      message,
      userInfo.cookieJar,
      HttpStatusCode.CREATED
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred creating the message.',
      reqUrl: request.url,
      reqBody: safeBody.txtBody,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PUT };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/messages/draft/find-or-create/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { ApiErrorHandler } from '@utils/errors';

/**
 * @swagger
 * /api/messaging/threads/{threadId}/messages/draft/find-or-create:
 *   put:
 *     tags: [Messages]
 *     summary: Find or create a draft message for a thread.
 *     description: Finds the most recent draft started by the user in a thread or create a draft message if none are found.
 *     parameters:
 *       - in: path
 *         name: threadId
 *         required: true
 *         description: The ID of the thread to create a draft message for.
 *         schema:
 *           type: string
 *     requestBody:
 *       description: JSON payload containing details of the draft message to create.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               messageReference:
 *                 description: The ID of the message this is in reply to.
 *                 type: string
 *           example:
 *             messageReference: "ref456"
 *     responses:
 *       201:
 *         description: Draft message created successfully.
 *         content:
 *           application/json:
 *             schema:
 *              $ref: '#/components/schemas/Message'
 *       500:
 *         description: An error occurred while finding or creating the draft message.
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: An error occurred creating the message.
 */
const POST = async (
  request: NextRequest,
  { params: { threadId } }: { params: { threadId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.thread.checkUserAccess,
      beforeUserParams: [threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    // GET Latest draft
    let message = await messagingClient.message.getLatestDraftMessageForThread(
      threadId,
      userInfo.user
    );

    if (!message) {
      // CREATE draft
      message = await messagingClient.thread.addDraftMessage({
        threadId: threadId,
        fromUser: userInfo.user,
      });
    }

    return createCookieResponse(message, userInfo.cookieJar, 200);
  } catch (e) {
    return ApiErrorHandler.handleServerError({
      message: 'Unable to find or create a draft message for thread.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: e,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/messages/paginated/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { MessagesResponse } from '@/app/shared/models/extensions/messaging/messageExtensions';
import { ApiErrorHandler } from '@/utils/errors';
import { ErrorNextResponse } from '@/utils/errors/apiErrorHandler';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { messagingClient } from '@models/extensions/messaging';

const getTakeValue = (takeParam: string | null) => {
  return takeParam && !Number.isNaN(parseInt(takeParam))
    ? parseInt(takeParam)
    : 10;
};

interface MessageResponseNextResponse {
  data: MessagesResponse[];
  metaData: {
    lastCursor: string;
    hasNextPage: boolean;
  };
}

export const GET = async (
  request: NextRequest,
  { params: { threadId } }: { params: { threadId: string } }
): Promise<NextResponse<MessageResponseNextResponse | ErrorNextResponse>> => {
  try {
    const url = new URL(request.url);
    const searchParams = new URLSearchParams(url.search);
    const takeParam = searchParams.get('take');
    const messageId = searchParams.get('messageId');
    const lastCursor = searchParams.get('lastCursor');

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.thread.checkUserAccess,
      beforeUserParams: [threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const take = getTakeValue(takeParam);

    let result;
    if (messageId && !lastCursor) {
      result = await messagingClient.message.getAllMessagesSentAfterId(
        threadId,
        messageId,
        take,
        userInfo.user
      );
    } else {
      result = await messagingClient.message.getPaginatedMessagesForThread(
        threadId,
        take,
        lastCursor ?? '',
        userInfo.user
      );
    }

    if (!result || (result && result.length == 0)) {
      return new NextResponse(
        JSON.stringify({
          data: [],
          metaData: {
            lastCursor: null,
            hasNextPage: false,
          },
        }),
        { status: 200 }
      );
    }

    const lastPostInResults: any = result[result.length - 1];
    const cursor: any = lastPostInResults.id;

    const nextPage =
      await messagingClient.message.getPaginatedMessagesForThread(
        threadId,
        take,
        cursor,
        userInfo.user
      );

    const data = {
      data: result,
      metaData: {
        lastCursor: cursor,
        hasNextPage: nextPage ? nextPage.length > 0 : false,
      },
    };

    return NextResponse.json(data);
  } catch (e) {
    return ApiErrorHandler.handleServerError({
      message: 'Unable to retrieve messages for thread.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: e,
    });
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/messages/unread/route.ts

import { NextRequest } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { messagingClient } from '@models/extensions/messaging';

/**
 * @swagger
 * /api/messaging/threads/{threadId}/messages/unread]:
 *   get:
 *     tags: [Messages]
 *     summary: Get unread messages for a thread
 *     description: Retrieve unread messages associated with a specific thread using the messagingClient API.
 *     parameters:
 *       - in: path
 *         name: threadId
 *         required: true
 *         description: The ID of the thread to retrieve messages for.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Messages for the thread retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *             type: array
 *             items:
 *              $ref: '#/components/schemas/Message'
 *       404:
 *         description: No messages associated with the thread or thread not found.
 *         content:
 *           application/json:
 *             example:
 *               status: 404
 *               message: No messages associated with this thread.
 *       500:
 *         description: An error occurred while retrieving messages for the thread.
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: Unable to retrieve messages for thread.
 */
export const GET = async (
  request: NextRequest,
  { params: { threadId } }: { params: { threadId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.thread.checkUserAccess,
      beforeUserParams: [threadId],
      customErrorMessage: 'User does not have access to the provided thread.',
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const messages = await messagingClient.message.getUnreadMessagesForThread(
      threadId,
      userInfo.user
    );

    if (!messages)
      return ApiErrorHandler.handle404Error({
        message: 'No messages associated with this thread.',
        reqUrl: request.url,
      });

    return createCookieResponse(messages, userInfo.cookieJar);
  } catch (e) {
    return ApiErrorHandler.handleServerError({
      message: 'Unable to retrieve messages for thread.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: e,
    });
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/rating/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { checkBodyForParams } from '@/utils/requests/checkBodyForParams';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';

/**
 * @swagger
 * /api/messaging/threads/{threadId}/rating:
 *   patch:
 *     summary: Rate Thread
 *     description: Rates a thread with a numerical rating.
 *     tags:
 *       - Threads
 *     parameters:
 *       - in: path
 *         name: threadId
 *         description: The ID of the thread to be rated
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       description: The rating value to assign to the thread.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               rating:
 *                 type: number
 *                 description: The numerical rating to assign to the thread.
 *     responses:
 *       '200':
 *         description: Thread successfully rated
 *         content:
 *           application/json:
 *             schema:
 *              $ref: '#/components/schemas/Thread'
 *       '400':
 *         description: Bad Request
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: Invalid or missing user session.
 *       '401':
 *         description: Unauthorized
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: Unauthorized, user does not have access to this thread.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while rating the thread.
 */
const PATCH = async (
  request: NextRequest,
  { params: { threadId } }: { params: { threadId: string } }
) => {
  const requestBody = await getSafeRequestBody(request);
  if (!requestBody.isValidJson) return requestBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.thread.checkUserCanRateThread,
      beforeUserParams: [threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const requiredBodyParams = [
      {
        prop: 'rating',
        validator: (rating: any) => !isNaN(Number(rating)),
      },
    ];

    const hasBodyParams = await checkBodyForParams(
      request,
      requestBody,
      requiredBodyParams
    );

    if (!hasBodyParams.success) return hasBodyParams.badRequestResponse;

    const result = await messagingClient.thread.rateThread(
      threadId,
      requestBody.jsonBody.rating,
      userInfo.user
    );

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to rate the thread.',
      reqUrl: request.url,
      reqBody: requestBody.txtBody,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/memos/route.ts

import { NextRequest } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { messagingClient } from '@models/extensions/messaging';

/**
 * @swagger
 * /api/messaging/memos/{threadId}:
 *   get:
 *     tags: [Memos]
 *     summary: Get memos for a thread
 *     description: Retrieve memos associated with a specific thread using the messagingClient API.
 *     parameters:
 *       - in: path
 *         name: threadId
 *         required: true
 *         description: The ID of the thread to retrieve memos for.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Memos for the thread retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *              type: array
 *              items:
 *                $ref: '#/components/schemas/Memo'
 *       404:
 *         description: No memos associated with the thread or thread not found.
 *         content:
 *           application/json:
 *             example:
 *               status: 404
 *               message: No memos associated with this thread.
 *       500:
 *         description: An error occurred while retrieving memos for the thread.
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: Unable to retrieve memos for thread.
 */
export const GET = async (
  request: NextRequest,
  { params: { threadId } }: { params: { threadId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.thread.isSupportOrParticipant,
      beforeUserParams: [threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const memos = await messagingClient.memo.getMemosForThread(
      threadId,
      userInfo.user
    );

    if (!memos)
      return ApiErrorHandler.handle404Error({
        message: 'No memos associated with this thread.',
        reqUrl: request.url,
      });

    return createCookieResponse(memos, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Unable to retrieve memos for thread.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/memos/draft/route.ts

import { NextRequest } from 'next/server';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { messagingClient } from '@models/extensions/messaging';
import { ApiErrorHandler } from '@utils/errors';

/**
 * @swagger
 * /api/messaging/thread/{threadId}/memos/draft:
 *   post:
 *     tags: [Memos]
 *     summary: Create a draft memo for a thread
 *     description: Create a draft memo associated with a specific thread using the messagingClient API.
 *     parameters:
 *       - in: path
 *         name: threadId
 *         required: true
 *         description: The ID of the thread to create a memo for.
 *         schema:
 *           type: string
 *     requestBody:
 *       description: JSON payload containing details of the memo to create.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromUserId:
 *                 type: string
 *           example:
 *             fromUserId: "user123"
 *     responses:
 *       201:
 *         description: Draft memo created successfully.
 *         content:
 *           application/json:
 *             schema:
 *              $ref: '#/components/schemas/Memo'
 *       400:
 *         description: Bad request. Missing fromUserId parameter.
 *         content:
 *           application/json:
 *             example:
 *               status: 400
 *               message: Missing fromUserId parameter.
 *       500:
 *         description: An error occurred while creating the memo.
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: An error occurred creating the memo.
 */
export const POST = async (
  request: NextRequest,
  { params: { threadId } }: { params: { threadId: string } }
) => {
  const requestBody = await getSafeRequestBody(request);
  if (!requestBody.isValidJson) return requestBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.thread.isSupportOrParticipant,
      beforeUserParams: [threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const draftMemo = await messagingClient.memo.createMemo(
      userInfo.user,
      threadId
    );

    return createCookieResponse(draftMemo, userInfo.cookieJar);
  } catch (e) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred creating the memo.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      reqBody: requestBody.txtBody,
      error: e,
    });
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/reactivate/route.ts

import { NextRequest } from 'next/server';

import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { messagingClient } from '@models/extensions/messaging';
import { ApiErrorHandler } from '@utils/errors';

/**
 * @swagger
 * /api/messaging/threads/{threadId}/reactivate:
 *   patch:
 *     tags: [Threads]
 *     summary: Reactivate Thread
 *     description: Reactivate a thread that has been archived / deleted or otherwise moved out of "active" status.
 *     parameters:
 *       - in: path
 *         name: threadId
 *         description: The ID of the thread to be archived
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: Thread successfully archived
 *         content:
 *           application/json:
 *             schema:
 *              $ref: '#/components/schemas/Thread'
 *       '401':
 *         description: Unauthorized
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: Unauthorized, user does not have access to this thread
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while archiving the thread
 */
const PATCH = async (
  request: NextRequest,
  { params }: { params: { threadId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: messagingClient.thread.checkUserAccess,
      beforeUserParams: [params.threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.thread.reactivateThread(
      params.threadId,
      userInfo.user
    );

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while archiving the thread.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/archive/route.ts

import { NextRequest } from 'next/server';

import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { messagingClient } from '@models/extensions/messaging';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

/**
 * @swagger
 * /api/messaging/threads/{threadId}/archive:
 *   patch:
 *     tags: [Threads]
 *     summary: Archive Thread
 *     description: Archives a thread by marking it as archived.
 *     parameters:
 *       - in: path
 *         name: threadId
 *         description: The ID of the thread to be archived
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: Thread successfully archived
 *         content:
 *           application/json:
 *             schema:
 *              $ref: '#/components/schemas/Thread'
 *       '401':
 *         description: Unauthorized
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: Unauthorized, user does not have access to this thread
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while archiving the thread
 */
const PATCH = async (
  request: NextRequest,
  { params }: { params: { threadId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
      authMethod: messagingClient.thread.checkUserAccess,
      beforeUserParams: [params.threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.thread.archiveThread(
      params.threadId,
      userInfo.user
    );

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while archiving the thread.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/delete/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { UserRole } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/threads/{threadId}/delete:
 *   patch:
 *     summary: Delete Thread
 *     description: Deletes a thread by marking it as deleted.
 *     tags:
 *       - Threads
 *     parameters:
 *       - in: path
 *         name: threadId
 *         description: The ID of the thread to be deleted
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: Thread successfully deleted
 *         content:
 *           application/json:
 *             schema:
 *              $ref: '#/components/schemas/Thread'
 *       '400':
 *         description: Bad Request
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: Unauthorized, invalid or missing user session.
 *       '401':
 *         description: Unauthorized
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: Unauthorized, user does not have access to this thread.
 *       '404':
 *         description: Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No thread was found with the specified ID.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while deleting the thread.
 */
const PATCH = async (
  request: NextRequest,
  { params: { threadId } }: { params: { threadId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
      authMethod: messagingClient.thread.checkUserAccess,
      beforeUserParams: [threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.thread.deleteThread(
      threadId,
      userInfo.user
    );

    if (!result)
      return ApiErrorHandler.handle404Error({
        message: 'No thread was found with the specified ID.',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while deleting the thread.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/mark-resolved/route.ts

import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { UserRole } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/threads/{threadId}/mark-resolved:
 *   patch:
 *     summary: Mark Thread as Resolved
 *     description: Marks a thread as resolved.
 *     tags:
 *       - Threads
 *     parameters:
 *       - in: path
 *         name: threadId
 *         description: The ID of the thread to be marked as resolved
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: Thread successfully marked as resolved
 *         content:
 *           application/json:
 *             schema:
 *              $ref: '#/components/schemas/Thread'
 *       '400':
 *         description: Bad Request
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: Unauthorized, invalid or missing user session.
 *       '401':
 *         description: Unauthorized
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: Unauthorized, user does not have access to this thread.
 *       '404':
 *         description: Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No thread found.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while marking the thread as resolved.
 */
const PATCH = async (
  request: NextRequest,
  { params }: { params: { threadId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN, UserRole.CORTINA_SUPPORT],
      authMethod: messagingClient.thread.checkUserAccess,
      beforeUserParams: [params.threadId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const result = await messagingClient.thread.markResolved(
      params.threadId,
      userInfo.user
    );

    //TODO: trigger some sort of notification to the other participants

    if (!result)
      return ApiErrorHandler.handle404Error({
        message: 'No thread found.',
        reqUrl: request.url,
      });

    return createCookieResponse(result, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while marking the thread as resolved.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/[threadId]/media/route.ts

import { headers } from 'next/headers';
import { NextRequest } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { getS3Url } from '@/utils/file-upload/file-upload';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { S3Client } from '@aws-sdk/client-s3';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const s3 = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.MESSAGE_MEDIA_AWS_ACCESS_KEY as string,
    secretAccessKey: process.env.MESSAGE_MEDIA_SECRET_ACCESS_KEY as string,
  },
});

/**
 * @swagger
 * /api/messaging/threads/{threadId}/media:
 *   get:
 *     summary: Get a signed url from s3 thread media.
 *     description: Generates an s3Url for a media url to securely display in a user's session.
 *     tags:
 *       - Threads
 *     parameters:
 *       - in: path
 *         name: threadId
 *         description: The thread ID.
 *         required: true
 *         schema:
 *           type: string
 *       - in: header
 *         name: s3url
 *         description: The s3 object url.
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: The s3Url for the media. Expires in 3600 seconds or 1 hour.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 s3Url: string
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while generating the s3Url.
 */
async function GET(
  request: NextRequest,
  { params: { threadId } }: { params: { threadId: string } }
) {
  const headerList = headers();
  const s3url = headerList.get('s3url');

  if (!s3url) {
    return ApiErrorHandler.handleBadRequest({
      message: 'You must include an s3 url',
      reqUrl: request.url,
      reqBody: '',
    });
  }

  const userInfo = await getUserAndCheckAuthorized({
    request: request,
    authMethod: messagingClient.thread.checkUserAccess,
    beforeUserParams: [threadId],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  const response = await getS3Url({
    mediaUrl: s3url,
    expiresIn: 3600,
    s3Client: s3,
    source: 'get_media_message',
  });

  if (response.error) {
    return ApiErrorHandler.handleServerError({
      message: response.errorMessage ?? 'Error getting file',
      reqUrl: request.url,
      reqBody: '',
    });
  }

  return createCookieResponse({ s3Url: response.s3Url }, userInfo.cookieJar);
}

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/patient/[patientId]/route.ts

import { NextRequest } from 'next/server';

import { getUserInfo, isUserAuthorized } from '@/utils/auth/auth';
import { ApiErrorHandler } from '@/utils/errors';
import {
  CookieJar,
  createCookieResponse,
} from '@/utils/responses/responseHelpers';
import { messagingClient } from '@models/extensions/messaging';
import { ThreadStatus, UserRole } from '@prisma/client';

/**
 * @swagger
 * /api/messaging/threads:
 *   get:
 *     summary: Get Patient Threads based on user access
 *     description: Retrieves a list of threads.
 *     tags:
 *       - Threads
 *     responses:
 *       '200':
 *         description: Threads successfully retrieved
 *         content:
 *           application/json:
 *             schema:
 *              type: array
 *              items:
 *                $ref: '#/components/schemas/Thread'
 *       '404':
 *         description: Threads Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No threads found.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while retrieving the threads.
 */
const GET = async (
  request: NextRequest,
  { params: { patientId } }: { params: { patientId: string } }
) => {
  try {
    const query = request.nextUrl.searchParams;
    const cookieJar: CookieJar = { cookies: [] };
    const user = await getUserInfo(request, cookieJar);

    const fullAccessRoles = [UserRole.ADMIN];

    let status: ThreadStatus | undefined = undefined;

    if (query.has('status')) {
      status = query.get('status') as ThreadStatus;
    }

    let threads = await messagingClient.thread.findMany({
      where: {
        userId: patientId,
        status: status ?? ThreadStatus.ACTIVE,
      },
      include: {
        messages: true,
        participants: true,
      },
    });

    if (!isUserAuthorized(user, fullAccessRoles)) {
      threads = threads?.filter((thread) => {
        thread.participants.some(
          (participant) => participant.userId === user.id
        );
      });
    }

    if (!threads)
      return ApiErrorHandler.handle404Error({
        message: 'No threads found.',
        reqUrl: request.url,
      });

    return createCookieResponse(threads, cookieJar, 200);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while retrieving the threads.',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/latest-message/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';

const GET = async (
  request: NextRequest,
  { params }: { params: { threadId: string } }
): Promise<NextResponse> => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const userHasAccess = await messagingClient.thread.checkUserAccess(
      params.threadId,
      userInfo.user
    );

    if (!userHasAccess)
      return ApiErrorHandler.handleUnauthorizedError({
        message: `User does not have access to thread with id ${params.threadId}`,
        reqUrl: request.url,
        reqHeaders: request.headers,
      });

    const latestMessage = await messagingClient.message.findFirst({
      where: {
        threadId: params.threadId,
      },
      orderBy: {
        createdAt: 'desc',
      },
      include: {
        thread: {
          include: {
            participants: true,
          },
        },
      },
    });

    if (!latestMessage) {
      return ApiErrorHandler.handleBadRequest({
        reqUrl: request.url,
        reqHeaders: request.headers,
        message: `No message found for thread with id ${params.threadId}`,
      });
    }

    return NextResponse.json(latestMessage, { status: 200 });
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(messaging)/api/messaging/threads/unread/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { messagingClient } from '@models/extensions/messaging';

/**
 * @swagger
 * /api/messaging/threads/unread:
 *   get:
 *     summary: Get threads with messages that the current user has not read
 *     description: Retrieves a list of threads.
 *     tags:
 *       - Threads
 *     responses:
 *       '200':
 *         description: Threads successfully retrieved
 *         content:
 *           application/json:
 *             schema:
 *              type: array
 *              items:
 *                $ref: '#/components/schemas/Thread'
 *       '404':
 *         description: Threads Not Found
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: No threads found.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while retrieving the threads.
 */
const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const threads = await messagingClient.thread.getThreadsWithUnreadMessages(
      userInfo.user.id
    );

    if (!threads)
      return ApiErrorHandler.handle404Error({
        message: 'No threads found.',
        reqUrl: request.url,
      });

    return NextResponse.json(threads, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while retrieving the threads.',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signout/getSignoutUrl.ts

'use server';

// get signout redirect url to logout of cognito and redirect back
export const getSignoutUrl = async () => {
  const redirectUrl = String(process.env.NEXT_PUBLIC_BASE_URL);

  const logoutUrl =
    process.env.COGNITO_DOMAIN +
    '/logout?client_id=' +
    process.env.COGNITO_CLIENT_ID +
    '&logout_uri=' +
    encodeURIComponent(redirectUrl);

  return logoutUrl;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signout/page.tsx

import { RedirectToSignout } from './components/redirect-to-signout';
import { getSignoutUrl } from './getSignoutUrl';

export default async function Signout() {
  const callbackUrl = await getSignoutUrl();

  return <RedirectToSignout callbackUrl={callbackUrl} />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signout/components/redirect-to-signout.tsx

'use client';

import { signOut } from 'next-auth/react';
import { useEffect } from 'react';

export const RedirectToSignout: React.FC<{ callbackUrl: string }> = ({
  callbackUrl,
}) => {
  useEffect(() => {
    // send logout event to GA
    const dataLayer = window?.dataLayer || [];
    dataLayer.push({
      event: 'logout',
    });
    signOut({ callbackUrl });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return null;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/page.tsx

import { getServerSession } from 'next-auth';
import { getProviders } from 'next-auth/react';
import { cookies } from 'next/headers';
import Image from 'next/image';
import { notFound, redirect } from 'next/navigation';
import { SigninDocument } from 'prismicio-types';

import { createClient } from '@/prismicio';
import { authOptions } from '@/utils/auth/auth';
import { PrismicPageType } from '@/utils/prismic/enums';

import { getPartners } from './actions/getPartners';
import { LoginForm } from './components/login';
import PartnerBanner, {
  PartnerBannerProps,
} from './components/partner/partnerBanner';
import PartnerLoginImage, {
  PartnerLoginImageProps,
} from './components/partner/partnerLoginImage';
import RandomLoginImage from './components/randomImage';
import RandomLoginImageWithTransition from './components/randomImageWithTransition';
import RedirectToAuthProvider from './components/redirect-to-authprovider';
import { LoginWithGoogle } from './components/social/google-login';

export default async function Page({
  searchParams,
}: {
  searchParams: Record<string, string | string[] | undefined>;
}) {
  const prismicSiginPage = await queryPage();

  const session = await getServerSession(authOptions);

  if (session) {
    const callbackUrl = searchParams['callbackUrl'];

    redirect(callbackUrl ? (callbackUrl as string) : '/account');
  }

  const cognitoProvider = (await getProviders())?.cognito;

  if (searchParams && searchParams['partnerLogin']) {
    const partners = await getPartners();

    const partnerName = searchParams['partnerLogin'] as string;

    if (partners.includes(partnerName)) {
      return (
        <RedirectToAuthProvider
          provider={cognitoProvider ?? undefined}
          partnerName={partnerName ?? undefined}
        />
      );
    }
  }

  const cortinaPartnersCookie = cookies().get('cortina-partners')?.value;

  let partnerData: {
    bannerProps: PartnerBannerProps;
    imageProps: PartnerLoginImageProps;
  } | null = null;

  if (cortinaPartnersCookie) {
    const partner = prismicSiginPage.data.partner_data.find(
      (p) => p.partner_name?.toLowerCase() === cortinaPartnersCookie
    );
    if (partner) {
      partnerData = {
        bannerProps: {
          partnerBannerColor: partner.partner_banner_background,
          partnerTextColor: partner.partner_banner_text_color,
          partnerBannerText: partner.partner_banner_text,
        },
        imageProps: {
          partnerImage: partner.partner_hero_image,
        },
      };
    }
  }

  return (
    <section className="h-screen">
      <div className="flex h-full w-full">
        <div className="flex flex-row h-full flex-nowrap justify-center w-full">
          <div className="md:flex-col w-10/12 md:w-8/12 lg:ms-6 lg:w-5/12 pl-2 pr-2 md:pl-6 md:pr-10 md:py-24 py-10 md:overflow-y-auto md:no-scrollbar">
            {cortinaPartnersCookie && partnerData && (
              <PartnerBanner {...partnerData.bannerProps} />
            )}
            <div className="flex items-center w-full justify-center mb-10">
              <Image
                src="/assets/cortina-logo-dark.svg"
                width="200"
                height="100"
                alt="Cortina Logo"
              />
            </div>

            <LoginForm signInPage={prismicSiginPage.data} />
            <div className="my-4 flex items-center before:mt-0.5 before:flex-1 before:border-t before:border-neutral-300 after:mt-0.5 after:flex-1 after:border-t after:border-neutral-300 dark:before:border-neutral-500 dark:after:border-neutral-500">
              <p className="mx-4 mb-0 text-center font-semibold dark:text-neutral-200">
                OR
              </p>
            </div>

            <LoginWithGoogle
              cognitoProvider={cognitoProvider}
              signInPage={prismicSiginPage.data}
            />
          </div>
          <div className="flex-col hidden lg:block lg:w-7/12 h-full overflow-hidden">
            {cortinaPartnersCookie && partnerData ? (
              <PartnerLoginImage {...partnerData.imageProps} />
            ) : (
              <RandomLoginImageWithTransition
                heroImages={prismicSiginPage.data.hero_images}
              />
            )}
          </div>
        </div>
      </div>
    </section>
  );
}

const queryPage = async () => {
  const client = createClient();
  return await client
    .getSingle<SigninDocument>(PrismicPageType.SIGNIN)
    .catch(() => notFound());
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/types/authTypes.ts

import { AppRouterInstance } from 'next/dist/shared/lib/app-router-context.shared-runtime';

export interface AuthFormStates {
  setSuccess: (state: boolean) => void;
  success: boolean;
  error: boolean;
  setError: (state: boolean) => void;
  errorMessage: string | null;
  setErrorMessage: (state: string) => void;
  router: AppRouterInstance;
  setSignIn: (state: boolean) => void;
}

export interface SignUpParams {
  email: string;
  password: string;
  confirmPassword: string;
}

export enum SigninState {
  SIGNIN,
  FORGOT_PASSWORD,
  CONFIRM_FORGOT_PASSWORD,
}

export interface SigninParams {
  email: string;
  password: string;
}

export interface SigninStates {
  setSigninState: (state: SigninState) => void;
  credentials: {
    email: string;
    password?: string;
  } | null;
  setCredentials: (state: { email: string; password?: string } | null) => void;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/components/randomImage.tsx

'use client';

import Image, { StaticImageData } from 'next/image';

import login_1 from './images/login_1.jpg';
import login_2 from './images/login_2.jpg';
import login_3 from './images/login_3.jpg';
import login_4 from './images/login_4.jpg';

interface IImageProps {
  src: StaticImageData;
  alt: string;
  className: string;
}

const loginImages: IImageProps[] = [
  {
    src: login_1,
    alt: 'Image of young woman applying makeup',
    className: 'object-cover object-center h-full',
  },
  {
    src: login_2,
    alt: 'Image of man showing full head of gray hair',
    className: 'object-cover object-bottom h-full',
  },
  {
    src: login_3,
    alt: 'Image of older blond woman with coffee mug',
    className: 'object-cover object-center h-full scale-150',
  },
  {
    src: login_4,
    alt: 'Image of woman touching clear skin on face',
    className: 'object-cover object-cener h-full',
  },
];

const RandomLoginImage: React.FC = () => {
  const randomNumber = Math.floor(Math.random() * 100) % loginImages.length;
  return (
    <Image
      src={loginImages[randomNumber].src}
      alt={loginImages[randomNumber].alt}
      className={loginImages[randomNumber].className}
      priority={true}
    />
  );
};

export default RandomLoginImage;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/components/login.tsx

'use client';

import { useRouter, useSearchParams } from 'next/navigation';
import { SigninDocument, SigninDocumentData, Simplify } from 'prismicio-types';
import React, { useEffect, useState } from 'react';

import ButtonOutline from '@/app/shared/components/buttons/button-outline';

import { SigninForm } from './signin';
import { SignupForm } from './signup';

interface LoginFormProps {
  signInPage: Simplify<SigninDocumentData>;
}

export const LoginForm: React.FC<LoginFormProps> = (p: LoginFormProps) => {
  const [signIn, setSignIn] = useState(true);
  const [error, setError] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);

  const router = useRouter();

  const searchparams = useSearchParams();

  const isSignup = searchparams.get('signup') ? true : false;

  useEffect(() => {
    setSignIn(!isSignup);
  }, [isSignup]);

  const props = {
    setError,
    error,
    setErrorMessage,
    errorMessage,
    setSuccess,
    success,
    router,
    setSignIn,
    signInPage: p.signInPage,
  };

  return (
    <>
      {signIn && <SigninForm {...props} />}
      {!signIn && <SignupForm {...props} />}
      <ButtonOutline
        className="w-full mt-5"
        onClick={() => {
          setError(false);
          setErrorMessage(null);
          setSignIn(!signIn);
        }}
      >
        {signIn ? p.signInPage.button_signup : p.signInPage.button_login}
      </ButtonOutline>
    </>
  );
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/components/signup.tsx

'use client';

import { Field, FieldProps, Form, Formik } from 'formik';
import Link from 'next/link';
import { SigninDocumentData, Simplify } from 'prismicio-types';
import React, { useState } from 'react';

import ButtonOutline from '@/app/shared/components/buttons/button-outline';
import ButtonSolid from '@/app/shared/components/buttons/button-solid';
import TextField from '@/app/shared/components/form-controls/text-field';

import { signinFormAction } from '../actions/signinAction';
import {
  requestNewConfirmationCode,
  signUpConfirmationAction,
  signUpFormAction,
} from '../actions/signupAction';
import { validateField } from '../helpers/helpers';
import { SigninParams, AuthFormStates } from '../types/authTypes';
import { ErrorAlert } from './shared/errorAlert';
import { InformationAlert } from './shared/informationAlert';
import { renderErrorMessage } from './shared/renderErrorMessage';
import StyledBasicLabel from './shared/styledBasicLabel';

export enum SignupState {
  START,
  CONFIRM,
}

type SignupFormProps = AuthFormStates & {
  signInPage: Simplify<SigninDocumentData>;
};

export const SignupForm: React.FC<SignupFormProps> = ({
  setError,
  error,
  setSuccess,
  success,
  setErrorMessage,
  errorMessage,
  router,
  setSignIn,
  signInPage,
}: SignupFormProps) => {
  const [credentials, setCredentials] = useState<SigninParams | null>(null);
  const [signupState, setSignupState] = useState<SignupState>(
    SignupState.START
  );

  return signupState === SignupState.START ? (
    <Formik
      key="signupForm"
      initialValues={{
        email: '',
        password: '',
        confirmPassword: '',
      }}
      onSubmit={async (values, actions) => {
        setSuccess(false);
        setError(false);
        actions.setSubmitting(true);

        const signupResult = await signUpFormAction(values);

        actions.setSubmitting(false);

        if (!signupResult.success) {
          setError(true);
          setErrorMessage(signupResult.errorMessage);
        } else {
          setCredentials({ email: values.email, password: values.password });
          await actions.setFieldValue('password', '', false);
          await actions.setFieldValue('confirmPassword', '', false);
          setSignupState(SignupState.CONFIRM);
        }
      }}
    >
      {({ touched, values, errors, isSubmitting, setSubmitting }) => (
        <Form id="signup" name="signup">
          <div className="relative mb-6" data-twe-input-wrapper-init>
            <StyledBasicLabel
              htmlFor="email"
              label={signInPage.label_email_address}
            />
            <Field
              name="email"
              validate={(value: string) => validateField(value, 'email')}
            >
              {({ field }: FieldProps) => (
                <TextField
                  id="email"
                  isInvalid={!!errors.email && touched.email}
                  className=" autofill:bg-white"
                  autoComplete="username"
                  disabled={isSubmitting || success}
                  {...field}
                />
              )}
            </Field>
            {errors.email && touched.email && (
              <ErrorAlert errorMessage={renderErrorMessage(errors.email)} />
            )}
          </div>

          <div className="relative mb-6" data-twe-input-wrapper-init>
            <StyledBasicLabel
              htmlFor="password"
              label={signInPage.label_password}
            />
            <Field
              name="password"
              validate={(value: string) => validateField(value, 'password')}
            >
              {({ field }: FieldProps) => (
                <TextField
                  id="password"
                  isInvalid={!!errors.password && touched.password}
                  type="password"
                  autoComplete="new-password"
                  className="autofill:bg-white"
                  disabled={isSubmitting || success}
                  {...field}
                />
              )}
            </Field>
            {errors.password && touched.password && (
              <ErrorAlert errorMessage={renderErrorMessage(errors.password)} />
            )}
          </div>

          <div className="relative mb-6" data-twe-input-wrapper-init>
            <StyledBasicLabel
              htmlFor="confirmPassword"
              label={signInPage.label_confirm_password}
            />
            <Field
              name="confirmPassword"
              validate={(value: string) =>
                validateField(value, 'confirmPassword', values.password)
              }
            >
              {({ field }: FieldProps) => (
                <TextField
                  id="confirmPassword"
                  isInvalid={
                    !!errors.confirmPassword && touched.confirmPassword
                  }
                  type="password"
                  autoComplete="new-password"
                  className="autofill:bg-white"
                  disabled={isSubmitting || success}
                  {...field}
                />
              )}
            </Field>
            {errors.confirmPassword && touched.confirmPassword && (
              <ErrorAlert
                errorMessage={renderErrorMessage(errors.confirmPassword)}
              />
            )}
          </div>
          {error && errorMessage && <ErrorAlert errorMessage={errorMessage} />}
          <ButtonSolid
            type="submit"
            className={`w-full`}
            variant="accent"
            disabled={
              !!errors.email ||
              !!errors.password ||
              !!errors.confirmPassword ||
              isSubmitting ||
              success
            }
            data-twe-ripple-init
          >
            {signInPage.button_signup}
          </ButtonSolid>
        </Form>
      )}
    </Formik>
  ) : (
    <Formik
      key="confirmForm"
      initialValues={{
        code: '',
        email: credentials?.email ?? '',
      }}
      onSubmit={async (values, actions) => {
        setError(false);
        actions.setSubmitting(true);
        const result = await signUpConfirmationAction({
          email: values.email,
          confirmationCode: values.code,
        });

        if (!result.success) {
          setError(true);
          setErrorMessage(result.errorMessage);
        } else {
          if (credentials?.email && credentials?.password) {
            const result = await signinFormAction(
              credentials?.email,
              credentials?.password
            );
            if (result.success) {
              // send sign_up event to GA
              const dataLayer = window?.dataLayer || [];
              dataLayer.push({
                event: 'sign_up',
              });

              router.push(result.callbackUrl);
            } else {
              actions.setSubmitting(false);
              setSignIn(true);
            }
          } else {
            actions.setSubmitting(false);
            setSignIn(true);
          }
        }
      }}
    >
      {({ touched, values, errors, isSubmitting, setSubmitting }) => {
        return (
          <Form id="confirm" name="confirm">
            <div className="relative mb-6" data-twe-input-wrapper-init>
              <div className="py-5">
                <Link
                  className="font-dmsans font-semibold rounded-lg focus-visible:outline focus-visible:outline-2 focus-visible:outline-gray-200 disabled:cursor-not-allowed text-xs md:text-sm text-accent-700 hover:text-accent-800 disabled:text-accent-300"
                  href=""
                  onClick={(e) => {
                    e.preventDefault();
                    setSignupState(SignupState.START);
                  }}
                >
                  Back to signup
                </Link>
              </div>
              <InformationAlert
                infoMessage="A confirmation code was emailed to the address you provided,
            please enter it below."
              />
              <StyledBasicLabel
                htmlFor="email"
                label={signInPage.label_email_address}
              />
              <Field
                name="email"
                validate={(value: string) => validateField(value, 'email')}
              >
                {({ field }: FieldProps) => (
                  <TextField
                    id="email"
                    isInvalid={!!errors.email && touched.email}
                    className=" autofill:bg-white"
                    autoComplete="username"
                    disabled={isSubmitting || success}
                    {...field}
                  />
                )}
              </Field>
              {errors.email && touched.email && (
                <ErrorAlert errorMessage={renderErrorMessage(errors.email)} />
              )}
            </div>
            <div className="relative mb-6" data-twe-input-wrapper-init>
              <StyledBasicLabel
                htmlFor="code"
                label={signInPage.label_confirmation_code}
              />
              <Field
                name="code"
                validate={(value: string) => validateField(value, 'code')}
              >
                {({ field }: FieldProps) => (
                  <TextField
                    id="code"
                    isInvalid={!!errors.code && touched.code}
                    autoComplete="off"
                    disabled={isSubmitting || success}
                    {...field}
                  />
                )}
              </Field>
              {errors.code && touched.code && (
                <ErrorAlert errorMessage={renderErrorMessage(errors.code)} />
              )}
            </div>
            {error && errorMessage && (
              <ErrorAlert errorMessage={errorMessage} />
            )}
            <ButtonSolid
              type="submit"
              className={`w-full mb-2`}
              variant="accent"
              disabled={!!errors.code || isSubmitting || success}
              data-twe-ripple-init
            >
              {signInPage.button_confirm_account}
            </ButtonSolid>
            <ButtonOutline
              onClick={async () => {
                const result = await requestNewConfirmationCode({
                  email: values.email,
                });

                if (result.success) return;
                else {
                  setError(true);
                  setErrorMessage(result.errorMessage);
                }
              }}
              className={`w-full`}
              variant="accent"
              disabled={isSubmitting || success}
              data-twe-ripple-init
            >
              {signInPage.button_request_new_code}
            </ButtonOutline>
          </Form>
        );
      }}
    </Formik>
  );
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/components/redirect-to-authprovider.tsx

'use client';

import { ClientSafeProvider, signIn } from 'next-auth/react';
import React, { useEffect } from 'react';

const RedirectToAuthProvider: React.FC<{
  provider?: ClientSafeProvider;
  partnerName?: string;
}> = ({ provider, partnerName }) => {
  // send login event to GA
  useEffect(() => {
    const dataLayer = window?.dataLayer || [];
    dataLayer.push({
      event: 'login',
      method: partnerName,
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    const params = partnerName ? { identity_provider: partnerName } : undefined;
    provider ? signIn(provider.id, undefined, params) : signIn();
  }, [provider, partnerName]);

  return null;
};

export default RedirectToAuthProvider;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/components/randomImageWithTransition.tsx

'use client';

import { SigninDocumentDataHeroImagesItem } from 'prismicio-types';
import { useEffect, useState } from 'react';

import { PrismicNextImage } from '@prismicio/next';

interface RandomLoginImageWithTransitionProps {
  heroImages: SigninDocumentDataHeroImagesItem[];
  extraClasses?: string;
}

const RandomLoginImageWithTransition: React.FC<
  RandomLoginImageWithTransitionProps
> = (p: RandomLoginImageWithTransitionProps) => {
  const getRandomNumber = (exclude: number[]) => {
    let newRandomNumber;
    do {
      newRandomNumber = Math.floor(Math.random() * 100) % p.heroImages.length;
    } while (exclude.includes(newRandomNumber));
    return newRandomNumber;
  };

  const initialRandomNumber = getRandomNumber([]);
  const [randomNumber, setRandomNumber] = useState<number>(initialRandomNumber);
  const [nextRandomNumber, setNextRandomNumber] = useState<number>(
    getRandomNumber([initialRandomNumber])
  );
  const [fadeIn, setFadeIn] = useState<boolean>(true);

  const fadeMs = 500;

  useEffect(() => {
    const interval = setInterval(() => {
      setFadeIn(false);
      setTimeout(() => {
        setRandomNumber((prevRandomNumber) => {
          const newRandomNumber = nextRandomNumber;
          setNextRandomNumber(
            getRandomNumber([newRandomNumber, prevRandomNumber])
          );

          setFadeIn(true);
          return newRandomNumber;
        });
      }, fadeMs);
    }, 10000);

    return () => clearInterval(interval);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [nextRandomNumber, fadeMs, p.heroImages.length]);

  return (
    <div
      className={`inset-0 h-full w-full transition-opacity duration-[${fadeMs}]${
        p.extraClasses ? ' ' + p.extraClasses : ''
      } ${fadeIn ? 'opacity-100' : 'opacity-0'}`}
    >
      <PrismicNextImage
        field={p.heroImages[randomNumber].hero_image}
        priority={true}
        style={{
          objectFit: 'cover',
          objectPosition: 'center',
          position: 'relative',
          height: '100%',
        }}
      ></PrismicNextImage>

      <div className="absolute inset-0 opacity-0 pointer-events-none">
        <PrismicNextImage
          field={p.heroImages[nextRandomNumber].hero_image}
          priority={false}
        ></PrismicNextImage>
      </div>
    </div>
  );
};

export default RandomLoginImageWithTransition;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/components/signin.tsx

'use client';

import { Field, FieldProps, Form, Formik } from 'formik';
import Link from 'next/link';
import { SigninDocumentData, Simplify } from 'prismicio-types';
import React, { useState } from 'react';

import ButtonSolid from '@/app/shared/components/buttons/button-solid';
import CustomLink from '@/app/shared/components/buttons/custom-link';
import TextField from '@/app/shared/components/form-controls/text-field';

import {
  confirmForgotPasswordAction,
  forgotPasswordAction,
} from '../actions/forgotPasswordActions';
import { signinFormAction } from '../actions/signinAction';
import { validateField } from '../helpers/helpers';
import { AuthFormStates, SigninState, SigninStates } from '../types/authTypes';
import { ErrorAlert } from './shared/errorAlert';
import { InformationAlert } from './shared/informationAlert';
import { renderErrorMessage } from './shared/renderErrorMessage';
import StyledBasicLabel from './shared/styledBasicLabel';

type SigninFormProps = AuthFormStates & {
  signInPage: Simplify<SigninDocumentData>;
};

export const SigninForm: React.FC<SigninFormProps> = (
  props: SigninFormProps
) => {
  const [signInState, setSigninState] = useState<SigninState>(
    SigninState.SIGNIN
  );
  const [credentials, setCredentials] = useState<{
    email: string;
    password?: string;
  } | null>(null);

  switch (signInState) {
    case SigninState.SIGNIN:
      return signinForm({
        ...props,
        setSigninState,
        credentials,
        setCredentials,
      });
    case SigninState.FORGOT_PASSWORD:
      return forgotPasswordForm({
        ...props,
        setSigninState,
        credentials,
        setCredentials,
      });
    case SigninState.CONFIRM_FORGOT_PASSWORD:
      return confirmForgotPasswordForm({
        ...props,
        setSigninState,
        credentials,
        setCredentials,
      });
  }
};

const forgotPasswordForm = (props: SigninFormProps & SigninStates) => {
  const {
    setError,
    error,
    setSuccess,
    success,
    setErrorMessage,
    errorMessage,
    router,
    setSigninState,
    credentials,
    setCredentials,
  } = props;
  return (
    <Formik
      key="forgotPasswordForm"
      initialValues={{ email: credentials?.email ?? '' }}
      onSubmit={async (values, actions) => {
        const result = await forgotPasswordAction(values.email);

        if (result.success) {
          actions.setSubmitting(false);
          setCredentials({ email: values.email });
          setSigninState(SigninState.CONFIRM_FORGOT_PASSWORD);
        } else {
          actions.setSubmitting(false);
          setError(true);
          setErrorMessage(result.errorMessage);
        }
      }}
    >
      {({
        touched,
        values,
        errors,
        isSubmitting,
        setErrors,
        setFieldError,
        setSubmitting,
      }) => (
        <Form>
          <div className="relative mb-6" data-twe-input-wrapper-init>
            <div className="py-5">
              <Link
                className="font-dmsans font-semibold rounded-lg focus-visible:outline focus-visible:outline-2 focus-visible:outline-gray-200 disabled:cursor-not-allowed text-xs md:text-sm text-accent-700 hover:text-accent-800 disabled:text-accent-300"
                href=""
                onClick={(e) => {
                  e.preventDefault();
                  setSigninState(SigninState.SIGNIN);
                }}
              >
                Back to signin
              </Link>
            </div>
            <StyledBasicLabel
              htmlFor="email"
              label={props.signInPage.label_email_address}
            />
            <Field
              name="email"
              validate={(value: string) => validateField(value, 'email')}
            >
              {({ field }: FieldProps) => (
                <TextField
                  id="email"
                  isInvalid={!!errors.email && touched.email}
                  className=" autofill:bg-white"
                  autoComplete="username"
                  disabled={isSubmitting || success}
                  {...field}
                />
              )}
            </Field>
            {errors.email && touched.email && (
              <ErrorAlert errorMessage={renderErrorMessage(errors.email)} />
            )}
          </div>
          {error && errorMessage && <ErrorAlert errorMessage={errorMessage} />}
          <ButtonSolid
            type="submit"
            className="w-full"
            variant="accent"
            data-twe-ripple-init
          >
            {props.signInPage.button_request_password_reset_code}
          </ButtonSolid>
        </Form>
      )}
    </Formik>
  );
};

const confirmForgotPasswordForm = ({
  setError,
  error,
  setSuccess,
  success,
  setErrorMessage,
  errorMessage,
  router,
  setSigninState,
  credentials,
  setCredentials,
  signInPage,
}: SigninFormProps & SigninStates) => (
  <Formik
    key="confirmForgotPasswordForm"
    initialValues={{
      email: credentials?.email ?? '',
      code: '',
      password: '',
      confirmPassword: '',
    }}
    onSubmit={async (values, actions) => {
      const result = await confirmForgotPasswordAction({
        email: values.email,
        password: values.password,
        confirmationCode: values.code,
      });

      if (result.success) {
        if (values.email && values.password) {
          // try to auto login with credentials
          const result = await signinFormAction(values.email, values.password);
          if (result.success) {
            // send login event to GA
            const dataLayer = window?.dataLayer || [];
            dataLayer.push({
              event: 'login',
            });

            router.push(result.callbackUrl);
          } else setSigninState(SigninState.SIGNIN);
        } else setSigninState(SigninState.SIGNIN);
      } else {
        setError(true);
        setErrorMessage(result.errorMessage);
      }
    }}
  >
    {({
      touched,
      values,
      errors,
      isSubmitting,
      setErrors,
      setFieldError,
      setSubmitting,
    }) => (
      <Form>
        <div className="relative mb-6" data-twe-input-wrapper-init>
          <div className="py-5">
            <Link
              className="font-dmsans font-semibold rounded-lg focus-visible:outline focus-visible:outline-2 focus-visible:outline-gray-200 disabled:cursor-not-allowed text-xs md:text-sm text-accent-700 hover:text-accent-800 disabled:text-accent-300"
              href=""
              onClick={(e) => {
                e.preventDefault();
                setSigninState(SigninState.SIGNIN);
              }}
            >
              {signInPage.button_back_to_signin}
            </Link>
          </div>
          <InformationAlert
            infoMessage="If the email you provided exists in our system, a reset password code was emailed to the address you provided,
              please enter it below along with a new password to complete
              password reset."
          />
          <StyledBasicLabel
            htmlFor="email"
            label={signInPage.label_email_address}
          />
          <Field
            name="email"
            validate={(value: string) => validateField(value, 'email')}
          >
            {({ field }: FieldProps) => (
              <TextField
                id="email"
                isInvalid={!!errors.email && touched.email}
                className=" autofill:bg-white"
                autoComplete="username"
                disabled={isSubmitting || success}
                {...field}
              />
            )}
          </Field>
          {errors.email && touched.email && (
            <ErrorAlert errorMessage={renderErrorMessage(errors.email)} />
          )}
        </div>
        <div className="relative mb-6" data-twe-input-wrapper-init>
          <StyledBasicLabel
            htmlFor="code"
            label={signInPage.label_confirmation_code}
          />
          <Field
            name="code"
            validate={(value: string) => validateField(value, 'code')}
          >
            {({ field }: FieldProps) => (
              <TextField
                id="code"
                isInvalid={!!errors.code && touched.code}
                autoComplete="off"
                disabled={isSubmitting || success}
                {...field}
              />
            )}
          </Field>
          {errors.code && touched.code && (
            <ErrorAlert errorMessage={renderErrorMessage(errors.code)} />
          )}
        </div>
        <div className="relative mb-6" data-twe-input-wrapper-init>
          <StyledBasicLabel
            htmlFor="password"
            label={signInPage.label_password}
          />
          <Field
            name="password"
            validate={(value: string) => validateField(value, 'password')}
          >
            {({ field }: FieldProps) => (
              <TextField
                id="password"
                isInvalid={!!errors.password && touched.password}
                type="password"
                autoComplete="new-password"
                className="autofill:bg-white"
                disabled={isSubmitting || success}
                {...field}
              />
            )}
          </Field>
          {errors.password && touched.password && (
            <ErrorAlert errorMessage={renderErrorMessage(errors.password)} />
          )}
        </div>

        <div className="relative mb-6" data-twe-input-wrapper-init>
          <StyledBasicLabel
            htmlFor="confirmPassword"
            label={signInPage.label_confirm_password}
          />
          <Field
            name="confirmPassword"
            validate={(value: string) =>
              validateField(value, 'confirmPassword', values.password)
            }
          >
            {({ field }: FieldProps) => (
              <TextField
                id="confirmPassword"
                isInvalid={!!errors.confirmPassword && touched.confirmPassword}
                type="password"
                autoComplete="new-password"
                className="autofill:bg-white"
                disabled={isSubmitting || success}
                {...field}
              />
            )}
          </Field>
          {errors.confirmPassword && touched.confirmPassword && (
            <ErrorAlert
              errorMessage={renderErrorMessage(errors.confirmPassword)}
            />
          )}
        </div>
        <div className="mb-5 flex">
          <CustomLink
            className="w-44 ml-auto text-gray-500"
            onClick={(e) => {
              e.preventDefault();
              forgotPasswordAction(credentials?.email ?? '');
            }}
            href=""
            variant="gray-outline"
          >
            {signInPage.button_request_new_code}
          </CustomLink>
        </div>
        {error && errorMessage && <ErrorAlert errorMessage={errorMessage} />}
        <ButtonSolid
          type="submit"
          className="w-full"
          variant="accent"
          data-twe-ripple-init
        >
          {signInPage.button_reset_password}
        </ButtonSolid>
      </Form>
    )}
  </Formik>
);

const signinForm = (props: SigninFormProps & SigninStates) => {
  const {
    error,
    errorMessage,
    setErrorMessage,
    setError,
    setSuccess,
    success,
    router,
    setSigninState,
    setCredentials,
    signInPage,
  } = props;

  return (
    <Formik
      key="signinForm"
      initialValues={{ email: '', password: '' }}
      onSubmit={async (values, actions) => {
        actions.setSubmitting(true);

        const result = await signinFormAction(values.email, values.password);

        actions.setSubmitting(false);

        if (result.success) router.push(result.callbackUrl);
        else {
          setError(true);
          setErrorMessage(result.errorMessage);
        }
      }}
    >
      {({
        touched,
        values,
        errors,
        isSubmitting,
        setErrors,
        setFieldError,
        setSubmitting,
      }) => (
        <Form>
          <div className="relative mb-6" data-twe-input-wrapper-init>
            <StyledBasicLabel
              htmlFor="email"
              label={signInPage.label_email_address}
            />
            <Field
              name="email"
              validate={(value: string) => validateField(value, 'email')}
            >
              {({ field }: FieldProps) => (
                <TextField
                  id="email"
                  isInvalid={!!errors.email && touched.email}
                  className=" autofill:bg-white"
                  autoComplete="username"
                  disabled={isSubmitting || success}
                  {...field}
                />
              )}
            </Field>
            {errors.email && touched.email && (
              <ErrorAlert errorMessage={renderErrorMessage(errors.email)} />
            )}
          </div>

          <div className="relative mb-6" data-twe-input-wrapper-init>
            <StyledBasicLabel
              htmlFor="password"
              label={signInPage.label_password}
            />
            <Field
              name="password"
              validate={(value: string) => validateField(value, 'password')}
            >
              {({ field }: FieldProps) => (
                <TextField
                  id="password"
                  isInvalid={!!errors.password && touched.password}
                  autoComplete="current-password"
                  type="password"
                  disabled={isSubmitting || success}
                  className="autofill:bg-white"
                  {...field}
                />
              )}
            </Field>
            {errors.password && touched?.password && (
              <ErrorAlert errorMessage={renderErrorMessage(errors.password)} />
            )}
          </div>

          <div className="mb-5 flex">
            <CustomLink
              className="w-44 ml-auto text-gray-500"
              onClick={(e) => {
                e.preventDefault();
                setCredentials({ email: values.email });
                setSigninState(SigninState.FORGOT_PASSWORD);
              }}
              href=""
              variant="gray-outline"
            >
              {signInPage.button_forgot_password}
            </CustomLink>
          </div>
          {error && errorMessage && <ErrorAlert errorMessage={errorMessage} />}
          <ButtonSolid
            type="submit"
            className="w-full"
            variant="accent"
            data-twe-ripple-init
          >
            {signInPage.button_login}
          </ButtonSolid>
        </Form>
      )}
    </Formik>
  );
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/components/shared/styledBasicLabel.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import HelpButton from '@components/buttons/help-button';

interface ILabelProps {
  label?: string | null;
  htmlFor?: string;
  id?: string;
  className?: string;
  labelClassName?: string;
  helperTextTitle?: string | null;
  helperText?: string | null;
}

const StyledBasicLabel: React.FC<ILabelProps> = ({
  id,
  label,
  htmlFor,
  className,
  labelClassName,
  helperTextTitle,
  helperText,
}) => {
  return label ? (
    <div className={twMerge(['mb-3 leading-5', className])}>
      <label
        id={`${id}-label`}
        htmlFor={htmlFor}
        className={twMerge(
          'inline mb-1 text-md text-gray-600 font-dmsans align-middle leading-6',
          labelClassName
        )}
      >
        {label}
      </label>

      {helperText && (
        <HelpButton
          title={helperTextTitle ?? label}
          content={helperText}
          className="inline-flex pl-1 align-middle"
        />
      )}
    </div>
  ) : null;
};

export default StyledBasicLabel;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/components/shared/informationAlert.tsx

import { ReactNode } from 'react';

export const InformationAlert = ({
  infoMessage,
}: {
  infoMessage: string | ReactNode;
}) => {
  return infoMessage ? (
    <div className="rounded-md bg-warning-25 p-4 my-5 border-warning-300 border">
      <div className="flex">
        <div className="ml-2">
          <h3 className=" font-dmsans font-normal text-sm text-warning-700">
            {infoMessage}
          </h3>
        </div>
      </div>
    </div>
  ) : null;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/components/shared/errorAlert.tsx

import { ReactNode } from 'react';

import { ExclamationCircleIcon } from '@heroicons/react/24/outline';

export const ErrorAlert = ({
  errorMessage,
}: {
  errorMessage: string | ReactNode | null;
}) => {
  return errorMessage ? (
    <div className="rounded-md bg-error-25 pl-3 p-4 my-5 border-error-300 border">
      <div className="flex">
        <div className="flex-shrink-0 w-5 h-5 p-0 overflow-hidden">
          <ExclamationCircleIcon
            className="text-error-700"
            aria-hidden="true"
          />
        </div>
        <div className="ml-2">
          <h3 className="text-sm font-semibold text-error-700">
            {errorMessage}
          </h3>
        </div>
      </div>
    </div>
  ) : null;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/components/shared/renderErrorMessage.tsx

import { ReactNode } from 'react';

export const renderErrorMessage = (errorMessage: string): ReactNode => {
  return errorMessage.split('<br />').flatMap((item, index) => {
    return (
      <span className="block" key={index}>
        {item}
      </span>
    );
  });
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/components/partner/partnerLoginImage.tsx

'use client';

import { ImageField } from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';

export interface PartnerLoginImageProps {
  partnerImage: ImageField;
  extraTwClasses?: string;
}

const PartnerLoginImage: React.FC<PartnerLoginImageProps> = (
  p: PartnerLoginImageProps
) => {
  return (
    <PrismicNextImage
      field={p.partnerImage}
      style={{
        objectFit: 'contain',
        objectPosition: 'center',
        height: '100%',
        position: 'relative',
      }}
      priority={true}
    />
  );
};

export default PartnerLoginImage;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/components/partner/partnerBanner.tsx

import { ColorField, RichTextField } from '@prismicio/client';
import { JSXMapSerializer, PrismicRichText } from '@prismicio/react';

export interface PartnerBannerProps {
  partnerBannerColor: ColorField;
  partnerTextColor: ColorField;
  partnerBannerText: RichTextField;
  partnerDataContext?: { [key: string]: unknown };
}

const PartnerBanner: React.FC<PartnerBannerProps> = (p: PartnerBannerProps) => {
  return (
    <div className="block lg:hidden">
      <div
        className={`absolute top-0 left-0 content-center items-center w-full justify-center mb-10 p-2 h-14 font-normal text-sm text-center [&_a]:underline`}
        style={{
          color: p.partnerTextColor ?? '#000000',
          backgroundColor: p.partnerBannerColor ?? '#FFFFFF',
        }}
      >
        <PrismicRichText
          field={p.partnerBannerText}
          components={partnerBannerRichTextResolver}
        />
      </div>
      <div className="flex flex-row items-center w-full justify-center p-0 h-14" />
    </div>
  );
};

export default PartnerBanner;

const partnerBannerRichTextResolver: JSXMapSerializer = {
  em: ({ children }) => <em className="italic">{children}</em>,
  strong: ({ children }) => <strong>{children}</strong>,
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/components/social/google-login.tsx

'use client';

import { ClientSafeProvider, signIn } from 'next-auth/react';
import Image from 'next/image';
import { SigninDocumentData, Simplify } from 'prismicio-types';

export const LoginWithGoogle: React.FC<{
  cognitoProvider?: ClientSafeProvider;
  signInPage: Simplify<SigninDocumentData>;
}> = ({ cognitoProvider, signInPage }) => {
  return (
    cognitoProvider && (
      <button
        onClick={() => {
          // send login event to GA
          const dataLayer = window?.dataLayer || [];
          dataLayer.push({
            event: 'login',
            method: 'Google',
          });
          signIn(cognitoProvider.id, {}, { identity_provider: 'Google' });
        }}
        className="w-full flex items-center justify-center space-x-2 font-dmsans font-semibold px-3.5 py-2.5 text-xs md:text-sm rounded-lg shadow-xs bg-white border text-primary-900 hover:bg-primary-900 hover:text-white disabled:bg-white disabled:border-primary-200 disabled:text-primary-300 disabled:cursor-not-allowed mt-2"
      >
        <Image
          src="/assets/icons/google-g-logo.svg"
          width="25"
          height="25"
          alt="Google Logo"
        />
        <span>{signInPage.button_signin_with_google}</span>
      </button>
    )
  );
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/actions/forgotPasswordActions.ts

'use server';

import { getSecretHash } from '@/utils/clients/cognito/cognitoClient';
import LoggerUtil from '@/utils/clients/logging/apiUtilLogger';
import {
  InvalidParameterException,
  UserNotFoundException,
  CodeDeliveryFailureException,
  ExpiredCodeException,
  CodeMismatchException,
  CognitoIdentityProvider,
} from '@aws-sdk/client-cognito-identity-provider';

const ClientId = String(process.env.COGNITO_CLIENT_ID);

const provider = new CognitoIdentityProvider({ region: 'us-east-2' });

export type ForgotPasswordResult =
  | {
      success: true;
    }
  | {
      success: false;
      errorMessage: string;
    };

export const forgotPasswordAction = async (
  email: string
): Promise<ForgotPasswordResult> => {
  try {
    const secretHash = getSecretHash(email);

    const result = await provider.forgotPassword({
      ClientId,
      Username: email,
      SecretHash: secretHash,
    });

    return { success: true };
  } catch (e) {
    await LoggerUtil.logError(
      'user_forgotPassword_error',
      'forgotPasswordAction',
      e,
      {
        email,
        e,
      }
    );

    let errorMessage =
      'There was a problem requesting a forgot password code. Please try again.';
    if (
      e instanceof InvalidParameterException ||
      e instanceof UserNotFoundException
    )
      errorMessage =
        'The email provided was not found. Please enter a valid email to continue.';
    else if (e instanceof CodeDeliveryFailureException)
      errorMessage =
        'Unable to deliver a message to the email provided. Please enter a valid email. ';

    return {
      success: false,
      errorMessage,
    };
  }
};

export type ConfirmForgotPasswordResult =
  | {
      success: true;
    }
  | {
      success: false;
      errorMessage: string;
    };

export const confirmForgotPasswordAction = async (props: {
  email: string;
  password: string;
  confirmationCode: string;
}): Promise<ConfirmForgotPasswordResult> => {
  const { email, password, confirmationCode } = props;

  try {
    const secretHash = getSecretHash(email);

    await provider.confirmForgotPassword({
      ClientId,
      Username: email,
      ConfirmationCode: confirmationCode,
      Password: password,
      SecretHash: secretHash,
    });

    return { success: true };
  } catch (e) {
    await LoggerUtil.logError(
      'user_confirmForgotPassword_error',
      'confirmForgotPasswordAction',
      e,
      {
        email,
        e,
      }
    );
    let errorMessage = 'There was a problem resetting your password.';
    if (
      e instanceof InvalidParameterException ||
      e instanceof UserNotFoundException
    )
      errorMessage =
        'The email provided was not found. Please enter a valid email to continue.';
    else if (e instanceof ExpiredCodeException)
      errorMessage =
        'The code you provided has expired, please request a new code.';
    else if (e instanceof CodeMismatchException)
      errorMessage =
        'The code you entered is not correct. Please use the latest code emailed to the provided email.';

    return {
      success: false,
      errorMessage,
    };
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/actions/getPartners.ts

'use server';

import { prisma } from '@/utils/clients/mongo/prismaClient';

export const getPartners = async () => {
  const partners = await prisma.partner.findMany();

  return partners.map((x) => x.cognitoId);
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/actions/signupAction.ts

'use server';

import {
  adminIdentityProvider,
  getSecretHash,
  userIdentityProvider,
} from '@/utils/clients/cognito/cognitoClient';
import LoggerUtil from '@/utils/clients/logging/apiUtilLogger';
import {
  AliasExistsException,
  CodeDeliveryFailureException,
  CodeMismatchException,
  ConfirmSignUpCommandOutput,
  ExpiredCodeException,
  InvalidPasswordException,
  SignUpCommandOutput,
  UserLambdaValidationException,
  UserNotFoundException,
  UsernameExistsException,
} from '@aws-sdk/client-cognito-identity-provider';

import { SignUpParams } from '../types/authTypes';

const ClientId = String(process.env.COGNITO_CLIENT_ID);
const UserPoolId = String(process.env.COGNITO_USER_POOL_ID);

type SignupResult<T> =
  | {
      success: true;
      result?: T;
    }
  | {
      success: false;
      errorMessage: string;
    };

export const signUpFormAction = async (
  values: SignUpParams
): Promise<SignupResult<SignUpCommandOutput>> => {
  try {
    const email = values.email.trim();
    const password = values.password.trim();

    const secretHash = getSecretHash(email);

    const signupResult = await userIdentityProvider.signUp({
      ClientId,
      Username: email,
      Password: password,
      SecretHash: secretHash,
      ClientMetadata: { provider: 'Cognito' },
    });

    return { success: true, result: signupResult };
  } catch (e) {
    await LoggerUtil.logError('user_signup_failure', 'signUpFormAction', e, {
      email: values.email.trim(),
      e,
    });

    let errorMessage =
      'An unknown problem occurred during signup. Please try again.';

    if (e instanceof CodeDeliveryFailureException)
      errorMessage =
        'Failed to deliver temporary code, please ensure the email you provided is valid.';
    else if (e instanceof InvalidPasswordException)
      errorMessage =
        'The password you provided does not meet the minimum requirements, please choose a new password.';
    else if (e instanceof UsernameExistsException) {
      const isUnconfirmed = await resendConfirmationCodeIfUnconfirmed(
        values.email
      );

      if (isUnconfirmed) return { success: true };

      errorMessage =
        'The username you provided already exists in our system. Please login instead.';
    } else if (
      e instanceof UserLambdaValidationException &&
      e.message.includes('Google')
    )
      errorMessage =
        'The email your provided was used to "Sign in  with Google" please sign in with Google instead.';

    return { success: false, errorMessage };
  }
};

export const signUpConfirmationAction = async (values: {
  email: string;
  confirmationCode: string;
}): Promise<SignupResult<ConfirmSignUpCommandOutput>> => {
  try {
    const email = values.email.trim();
    const confirmationCode = values.confirmationCode.trim();

    const secretHash = getSecretHash(email);

    const confirmationResult = await userIdentityProvider.confirmSignUp({
      ClientId,
      Username: email,
      ConfirmationCode: confirmationCode,
      SecretHash: secretHash,
      ClientMetadata: { provider: 'Cognito' },
    });

    return { success: true, result: confirmationResult };
  } catch (e) {
    await LoggerUtil.logError(
      'user_signup_confirmation_failure',
      'signUpConfirmationAction',
      e,
      {
        email: values.email.trim(),
        e,
      }
    );
    let errorMessage =
      'An unknown problem occurred during confirmation. Please try again.';

    if (e instanceof AliasExistsException)
      errorMessage = 'This account has already been confirmed. Please login. ';
    else if (e instanceof CodeMismatchException)
      errorMessage =
        'The code you entered does not match the most recent code sent to you.';
    else if (e instanceof ExpiredCodeException)
      errorMessage =
        'The code you have entered has expired. Please request a new confirmation code.';

    return { success: false, errorMessage };
  }
};

type resendConfirmationCodeResult =
  | {
      success: true;
    }
  | {
      success: false;
      errorMessage: string;
    };

export const requestNewConfirmationCode = async (values: {
  email: string;
}): Promise<resendConfirmationCodeResult> => {
  try {
    const email = values.email.trim();

    const secretHash = getSecretHash(email);

    await userIdentityProvider.resendConfirmationCode({
      ClientId,
      Username: email,
      SecretHash: secretHash,
      ClientMetadata: { provider: 'Cognito' },
    });

    return { success: true };
  } catch (e) {
    await LoggerUtil.logError(
      'user_request_new_confirmationCode_failure',
      'requestNewConfirmationCode',
      e,
      {
        email: values.email.trim(),
        e,
      }
    );
    let errorMessage =
      'An unknown problem ocurred during confirmation. Please try again.';

    if (e instanceof AliasExistsException)
      errorMessage = 'This account has already been confirmed. Please login. ';
    else if (e instanceof UserNotFoundException)
      errorMessage =
        'Account not found. Please provide valid account information or create one to continue. ';

    return { success: false, errorMessage };
  }
};

const resendConfirmationCodeIfUnconfirmed = async (email: string) => {
  try {
    const result = await adminIdentityProvider.adminGetUser({
      Username: email,
      UserPoolId,
    });

    if (result && result.UserStatus === 'UNCONFIRMED') {
      await requestNewConfirmationCode({ email });
      return true;
    }

    return false;
  } catch (e) {
    await LoggerUtil.logError(
      'user_request_resendConfirmationCodeIfUnconfirmed_failure',
      'resendConfirmationCodeIfUnconfirmed',
      e,
      {
        email,
        e,
      }
    );
    return false;
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/actions/signinAction.ts

'use client';

// must be client to have access to window object for signIn;
import { SignInResponse, getCsrfToken, signIn } from 'next-auth/react';

import LoggerUtil from '@/utils/clients/logging/apiUtilLogger';

export type SigninActionResult =
  | {
      success: true;
      callbackUrl: string;
    }
  | {
      success: false;
      errorMessage: string;
    };

export const signinFormAction = async (
  email: string,
  password: string
): Promise<SigninActionResult> => {
  try {
    const csrfToken = await getCsrfToken();

    const result: SignInResponse | undefined = await signIn('credentials', {
      redirect: false,
      username: email,
      password: password,
      csrfToken: csrfToken,
    });

    if (result?.ok) {
      const urlParams = new URLSearchParams(result.url?.split('?')[1]);
      const callbackUrl = urlParams.get('callbackUrl') ?? '/account';

      if (callbackUrl) urlParams.delete('callbackUrl');

      const queryString = urlParams.toString();

      return { success: true, callbackUrl: `${callbackUrl}?${queryString}` };
    } else {
      let errorMessage;

      switch (result?.status) {
        case 401:
          errorMessage = 'Invalid username or password.';
          break;
        default:
          errorMessage = 'There was a sign-in error. Please try again. ';
          break;
      }

      await LoggerUtil.logError(
        'user_signin_bad_response',
        'signInFormAction',
        new Error(errorMessage),
        {
          email,
          result,
        }
      );

      return { success: false, errorMessage };
    }
  } catch (e) {
    await LoggerUtil.logError('user_signin_error', 'signInFormAction', e, {
      email,
      e,
    });

    return {
      success: false,
      errorMessage:
        e instanceof Error
          ? e.message
          : 'There was a sign-in error. Please try again.',
    };
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(features)/(authentication)/signin/helpers/helpers.ts

import { z } from 'zod';

import { SignUpParams } from '../types/authTypes';

export const validateField = (
  value: string,
  field: keyof SignUpParams | string,
  compareValue?: string
): string | undefined => {
  let result: z.SafeParseReturnType<string, string> | undefined = undefined;

  switch (field) {
    case 'email':
      result = z
        .string()
        .email('The email you provided is not in a valid format.')
        .safeParse(value);
      break;
    case 'password':
      result = z
        .string()
        .regex(
          /^(?=.*\d)(?=.*[!@#$%^&*()\-_+=|\\{}[\]:;"'<>,.?/])(?=.*[A-Z])(?=.*[a-z]).{8,}$/,
          'Invalid password, please make sure your password:<br />' +
            'Contains at least 1 number<br />' +
            'Contains at least 1 special character<br />' +
            'Contains at least 1 uppercase letter<br />' +
            'Contains at least 1 lowercase letter<br />' +
            'Valid special characters: ^ $ * . [ ] { } ( ) ? - " ! @ # % & / \\ , > < \' : ; | _ ~ ` + ='
        )
        .safeParse(value);
      break;
    case 'confirmPassword':
      if (compareValue)
        result = z
          .string()
          .refine((value) => value === compareValue, 'Passwords do not match.')
          .safeParse(value);
      break;
    case 'code':
      result = z
        .string()
        .length(
          6,
          'Confirmation code was emailed to you and should be 6 digits.'
        )
        .safeParse(value);
      break;
    default:
      result = z.string().safeParse(value);
      break;
  }

  if (!result?.success) return result?.error.issues[0].message;
};

export const formLabelStyles =
  'inline mb-1 text-md text-gray-600 font-dmsans align-middle leading-6';


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/types/index.ts

import { ProductPageDocument } from 'prismicio-types';

import { PharmacyResult } from '@/utils/clients/dosespot/dosespotTypes';
import { PartnerData } from '@/utils/get-partner';
import {
  Prisma,
  Product,
  PromoCodes,
  SubscriptionProduct,
  UserSubscription,
} from '@prisma/client';

export const USER_INCLUDE = {
  partner: true,
  medicalProfile: true,
  dependents: { include: { medicalProfile: true } },
};

export type UserInclude = Prisma.UserGetPayload<{
  include: typeof USER_INCLUDE;
}>;

export interface ProductWithContent extends ProductPageDocument {
  category: string;
  active: boolean;
  price: number;
}

export type CartInclude = Prisma.CartGetPayload<{
  include: {
    cartProducts: { include: { product: true } };
    cartSubscriptionProducts: { include: { subscriptionProduct: true } };
  };
}> & { promo?: PromoCodes };

export type CartProductsInclude = Prisma.CartProductsGetPayload<{
  include: { product: true };
}>;

export type CartSubscriptionProductsInclude =
  Prisma.CartSubscriptionProductsGetPayload<{
    include: { subscriptionProduct: true };
  }>;

export type UserPrescriptionsWithProduct = Prisma.UserPrescriptionsGetPayload<{
  include: {
    product: true;
    subscriptionProduct: true;
  };
}>;

export type UserSubscriptionsInclude = Prisma.UserSubscriptionGetPayload<{
  include: {
    subscriptionProduct: true;
  };
}>;

export type UserPrescriptionWithPharmacy = Prisma.UserPrescriptionsGetPayload<{
  include: {
    product: true;
    subscriptionProduct: true;
  };
}> & {
  pharmacy?: PharmacyResult;
};

export interface TreatmentPlan {
  OTCProducts: Product[];
  OTCSubscriptionProducts: SubscriptionProduct[];
  cortinaRxPrescriptions: UserPrescriptionsWithProduct[];
  genericPrescriptions: UserPrescriptionWithPharmacy[];
}

export type OrderInclude = Prisma.OrderGetPayload<{
  include: {
    cartProducts: {
      select: {
        quantity: true;
        product: true;
      };
    };
    cartSubscriptionProducts: {
      select: {
        quantity: true;
        subscriptionProduct: true;
      };
    };
  };
}>;

export type CaseInclude = Prisma.CaseGetPayload<{
  include: {
    user: true;
    physician: true;
    prescriptions: true;
  };
}>;

export interface ExtendedUserAttributes {
  hasConcierge: boolean;
  activeConciergeSubscriptions: UserSubscription[];
  age: number | null;
  formattedDOB: string | null;
}

export type ExtendedUser = UserInclude & ExtendedUserAttributes;

export interface AccountHomeContext {
  user: ExtendedUser;
  cases: CaseInclude[];
}

export interface AccountPageContext {
  searchParams: { [key: string]: string | string[] | undefined };
  user?: ExtendedUser;
  slug?: string;
  partner?: PartnerData | null;
}

export type ICaseDiagnosedStat = Prisma.CaseGetPayload<{
  include: {
    user: true;
    physician: true;
  };
}>;

export type IShipmentStat = Prisma.ShipmentGetPayload<{
  include: {
    user: true;
    order: true;
    products: true;
    subscriptionProducts: true;
  };
}>;

export type ICaseExpiringStat = Prisma.CaseGetPayload<{
  include: {
    user: true;
  };
}>;

export type IUnreadThreadStat = Prisma.ThreadGetPayload<{
  include: {
    user: true;
  };
}> & {
  unreadMessagesForThread: number;
};

export interface IFamilyStatsResponse {
  casesDiagnosedInLast7Days: ICaseDiagnosedStat[];
  shippingChangesInLast7Days: IShipmentStat[];
  unreadThreads: IUnreadThreadStat[];
  casesWithConsultationExpiringWithin7Days: ICaseExpiringStat[];
  totalNotifications: number;
}

export interface IFamilyMember {
  isPrimary: boolean;
  id: string;
  email: string | null;
  avatarUrl: string | null;
  firstName: string | null;
  lastName: string | null;
  guardianId: string | null;
}

export type PartnerInclude = Prisma.PartnerGetPayload<{
  include: {
    preferences: true;
  };
}>;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/types/auth/next-auth.d.ts

import { DefaultUser } from 'next-auth';
import { DefaultJWT } from 'next-auth/jwt';

interface CognitoIdentities {
  userId: string;
  providerName: string;
  providerType: string;
  issuer: string;
  primary: boolean | string;
  dateCreated: number | string;
}
interface CortinaUserFields {
  cortinaId?: string;
  identities?: CognitoIdentities[];
  userName: string;
  sub: string;
}

declare module 'next-auth' {
  interface Session {
    user: {
      cortinaId?: string;
      identities?: CognitoIdentities[];
      userName: string;
      sub: string;
    } & DefaultSeession['user'];
  }

  interface User extends CortinaUserFields, DefaultUser {}
}

declare module 'next-auth/jwt' {
  interface JWT extends CortinaUserFields, DefaultJWT {
    sub: string; // intersection would cause this to be nullable, we want it to be required.
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/contexts/cart-slider-context.tsx

import React from 'react';

interface ICartSliderContext {
  showCart: boolean;
  setShowCart: (show: boolean) => void;
  toggleCart: () => void;
  isPending: boolean;
  startTransition: React.TransitionStartFunction;
}

export const CartSliderContext = React.createContext({
  showCart: false,
  setShowCart: () => {},
  toggleCart: () => {},
  isPending: false,
  startTransition: () => {},
} as ICartSliderContext);

export function CartSliderContextProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const [showCart, setShowCart] = React.useState(false);
  const [isPending, startTransition] = React.useTransition();

  const toggleCart = () => {
    setShowCart((prev) => !prev);
  };

  return (
    <CartSliderContext.Provider
      value={{
        showCart,
        setShowCart,
        toggleCart,
        isPending,
        startTransition,
      }}
    >
      {children}
    </CartSliderContext.Provider>
  );
}

export default CartSliderContextProvider;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/ecommerce/promoCodeFieldExtensions.ts

import moment from 'moment';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { Prisma, PromoCodeUsage } from '@prisma/client';

export const PromoCodeFieldExtensions = Prisma.defineExtension({
  name: 'promoCodeFieldExtensions',
  result: {
    promoCodes: {
      isActive: {
        needs: {
          code: true,
          active: true,
          startDateTime: true,
          endDateTime: true,
          numberUses: true,
          numberUsesPer: true,
        },
        compute({
          code,
          active,
          startDateTime,
          endDateTime,
          numberUses,
          numberUsesPer,
        }) {
          return async (userId: string) => {
            if (!active) return false;
            if (startDateTime && startDateTime > moment().utc().toDate())
              return false;
            if (endDateTime && endDateTime < moment().utc().toDate())
              return false;

            if (numberUses > 0) {
              const where =
                numberUsesPer === PromoCodeUsage.PROMO_CODE
                  ? { promoCodeCode: code }
                  : { userId, promoCodeCode: code };

              const codeUses = await prisma.order.count({ where });

              if (codeUses >= numberUses) return false;
            }

            return true;
          };
        },
      },
      isActiveWithinDateRange: {
        needs: {
          active: true,
          startDateTime: true,
          endDateTime: true,
        },
        compute({ active, startDateTime, endDateTime }) {
          return () => {
            if (!active) return false;
            if (startDateTime && startDateTime > moment().utc().toDate())
              return false;
            if (endDateTime && endDateTime < moment().utc().toDate())
              return false;

            return true;
          };
        },
      },
    },
  },
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/ecommerce/index.ts

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { PromoCodes } from '@prisma/client';

import { PromoCodeFieldExtensions } from './promoCodeFieldExtensions';

export type extendedPromoCode = PromoCodes & {
  isActive: boolean;
};

export const prismaEcomClient = prisma.$extends(PromoCodeFieldExtensions);


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/identity/userExtensions.ts

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { Prisma, UserRole } from '@prisma/client';

export const UserResultExtensions = Prisma.defineExtension({
  name: 'patientOnly',
  result: {
    user: {
      isPatient: {
        needs: {
          roles: true,
        },
        compute(user) {
          return user.roles.includes(UserRole.PATIENT);
        },
      },
      isExternalHr: {
        needs: {
          roles: true,
        },
        compute(user) {
          return user.roles.includes(UserRole.EXTERNAL_HR);
        },
      },
      isElevated: {
        needs: {
          roles: true,
        },
        compute(user) {
          return user.roles.some(
            (r) => r !== UserRole.PATIENT && r !== UserRole.EXTERNAL_HR
          );
        },
      },
      isPartnerUser: {
        needs: {
          partnerId: true,
        },
        compute(user) {
          return user.partnerId !== null;
        },
      },
    },
  },
});

export const UserGetExtensions = Prisma.defineExtension({
  model: {
    user: {
      async userHasRole(userId: string, role: UserRole) {
        const user = await prisma.user.findUnique({
          where: { id: userId },
          select: { roles: true },
        });

        if (!user) return false;

        return user.roles.includes(role);
      },
    },
  },
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/identity/index.ts

import { PrismaClient } from '@prisma/client';

import { UserGetExtensions, UserResultExtensions } from './userExtensions';

const userPrismaClient = new PrismaClient()
  .$extends(UserGetExtensions)
  .$extends(UserResultExtensions);

export { userPrismaClient };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/identity/types/identityTypes.ts

import { MedicalProfile, User } from '@prisma/client';

export type MedicalProfileWithoutUser = Omit<MedicalProfile, 'userId'>;

// these are added using result extensions
export type ExtendedUser = {
  isPatient?: boolean;
  isExternalHr?: boolean;
  isElevated?: boolean;
  isPartnerUser?: boolean;
  medicalProfile?: MedicalProfileWithoutUser | null;
  dependents?: User[];
} & User;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/cases/caseExtensions.ts

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { Prisma } from '@prisma/client';

import { ExtendedUser } from '../identity/types/identityTypes';
import { messagingClient } from '../messaging';

export const CaseResultExtensions = Prisma.defineExtension({});

export const CaseGetExtensions = Prisma.defineExtension({
  name: 'getCaseWithThreadByCaseId',
  model: {
    case: {
      async getCaseWithThreadByCaseId(caseId: string, user: ExtendedUser) {
        const foundCase = await prisma.case.findUnique({
          where: { id: caseId },
          include: {
            user: {
              include: {
                medicalProfile: true,
              },
            },
            thread: {
              include: {
                participants: {
                  select: { userId: true, status: true },
                },
                messages: true,
              },
            },
          },
        });

        if (!foundCase) return null;

        const isThreadParticipant = foundCase.thread[0].participants.some(
          (participant) => participant.userId === user.id
        );

        if (isThreadParticipant) return foundCase;

        if (foundCase.physicianId === user.id) {
          await messagingClient.thread.addParticipant(
            user.id,
            foundCase.thread[0].id,
            user
          );
          return foundCase;
        }

        return null;
      },
    },
  },
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/cases/index.ts

import { PrismaClient } from '@prisma/client';

import { CaseGetExtensions } from './caseExtensions';

const casePrismaClient = new PrismaClient().$extends(CaseGetExtensions);

export { casePrismaClient };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/b2b/organizationExtensions.ts

import {
  ActiveEnum,
  OrganizationContact,
  OrganizationLocation,
  Prisma,
  PrismaClient,
} from '@prisma/client';

import { organizationClient } from '.';
import { ExtendedUser } from '../identity/types/identityTypes';

const prismaClient = new PrismaClient();

export const OrganizationAccessExtensions = Prisma.defineExtension({
  model: {
    organization: {
      async canModifyOrgData(organizationId: string, user: ExtendedUser) {
        if (user.isElevated) return true;

        if (user.isExternalHr) return organizationId === user.organizationId;

        return false;
      },
    },
  },
});

export const OrganizationGetExtensions = Prisma.defineExtension({
  model: {
    organization: {
      async getEmployees(organizationId: string) {
        const employees = await prismaClient.employee.findMany({
          where: { organizationId: organizationId },
          include: { organization: true, user: true },
        });

        return employees;
      },
    },
  },
});

interface CreateOrganizationInput {
  name: string;
  logo: string;
  tiers?: string[];
  departments?: string[];
  roles?: string[];
  locations?: OrganizationLocation[];
  contacts?: OrganizationContact[];
}

export const OrganizationCreateExtensions = Prisma.defineExtension({
  model: {
    organization: {
      async createOrganization(input: CreateOrganizationInput) {
        const organization = await prismaClient.organization.create({
          data: {
            name: input.name,
            logo: input.logo,
            tiers: input.tiers ?? undefined,
            departments: input.departments ?? undefined,
            roles: input.roles ?? undefined,
            locations: input.locations ?? undefined,
            contacts: input.contacts ?? undefined,
            status: ActiveEnum.ACTIVE,
          },
        });

        return organization;
      },
    },
  },
});

interface UpdateOrganizationInput {
  id: string;
  name?: string;
  logo?: string;
  tiers?: string[];
  departments?: string[];
  roles?: string[];
  locations?: OrganizationLocation[];
  contacts?: OrganizationContact[];
}

export const OrganizationUpdateExtensions = Prisma.defineExtension({
  model: {
    organization: {
      async updateOrganization(input: UpdateOrganizationInput) {
        const organization = await prismaClient.organization.update({
          where: { id: input.id },
          data: {
            name: input.name ?? undefined,
            logo: input.logo ?? undefined,
            tiers: input.tiers ?? undefined,
            departments: input.departments ?? undefined,
            roles: input.roles ?? undefined,
            locations: input.locations ?? undefined,
            contacts: input.contacts ?? undefined,
            status: ActiveEnum.ACTIVE,
          },
        });

        return organization;
      },
      async addContactToOrganization(
        organizationId: string,
        contact: Prisma.OrganizationContactCreateInput
      ) {
        const organization = await organizationClient.organization.findUnique({
          where: {
            id: organizationId,
          },
        });

        if (
          organization?.contacts.some(
            (x) => x.contactIdentifier === contact.contactIdentifier
          )
        ) {
          //update
        } else {
          //create
        }
      },
      async deactivateOrganization(organizationId: string) {
        const organization = await prismaClient.organization.update({
          where: { id: organizationId },
          data: {
            status: ActiveEnum.INACTIVE,
          },
        });

        return organization;
      },
    },
  },
});

export const OrganizationDeleteExtensions = Prisma.defineExtension({});

type AddEmployeeInput = { id: string } & Prisma.EmployeeCreateInput;

export const OrganizationResultExtensions = Prisma.defineExtension({
  result: {
    organization: {
      addEmployee: {
        needs: { id: true },
        compute(data: AddEmployeeInput) {
          const { id: organizationId, ...employeeData } = data;
          return async () => {
            const newEmployee = await prismaClient.employee.create({
              data: {
                ...employeeData,
                organization: { connect: { id: organizationId } },
              },
              include: { organization: true },
            });

            return newEmployee;
          };
        },
      },
    },
  },
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/b2b/employeeExtensions.ts

import { Prisma, PrismaClient } from '@prisma/client';

const prismaClient = new PrismaClient();

export const ExmployeeGetExtensions = Prisma.defineExtension({
  model: {
    organization: {
      async getOrganization(employeeId: string) {
        const employees = await prismaClient.organization.findUnique({
          where: { id: employeeId },
        });

        return employees;
      },
    },
  },
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/b2b/index.ts

import { prisma } from '@/utils/clients/mongo/prismaClient';

import {
  OrganizationAccessExtensions,
  OrganizationCreateExtensions,
  OrganizationGetExtensions,
  OrganizationResultExtensions,
  OrganizationUpdateExtensions,
} from './organizationExtensions';
import { PublicOrganization } from './types/organizationTypes';

export type { PublicOrganization };
export const organizationClient = prisma
  .$extends(OrganizationResultExtensions)
  .$extends(OrganizationGetExtensions)
  .$extends(OrganizationCreateExtensions)
  .$extends(OrganizationUpdateExtensions)
  .$extends(OrganizationAccessExtensions);


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/b2b/types/organizationTypes.ts

import { Organization } from '@prisma/client';

// special type used to limit organization information available to employees
type PublicOrganization = Pick<
  Organization,
  'id' | 'name' | 'logo' | 'contacts'
>;

export type { PublicOrganization };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/messaging/threadExtensions.ts

import { isUserAuthorized } from '@/utils/auth/auth';
import { logger } from '@/utils/clients/logging/winstonClient';
import {
  MessageStatus,
  Prisma,
  ThreadAction,
  ThreadParticipantStatus,
  ThreadStatus,
  ThreadType,
  User,
  UserRole,
} from '@prisma/client';

import { messagingClient } from '.';

export const ThreadValidationExtension = Prisma.defineExtension({
  name: 'thread-validation', // validate medical threads always have a case reference
  query: {
    thread: {
      async create({ args, query }) {
        if (args.data.type === ThreadType.MEDICAL && !args.data.case)
          throw new Error('Medical threads must have a case reference');
        if (args.data.type === ThreadType.MEDICAL) {
          const caseId = args.data.caseId ?? args.data.case?.connect?.id;
          const userId = args.data.userId ?? args.data.user.connect?.id;

          if (!caseId || !userId)
            throw new Error(`Invalid caseId: ${caseId} or userId: ${userId}`);

          const hasMedicalThread = await messagingClient.thread.findFirst({
            where: {
              type: ThreadType.MEDICAL,
              userId,
              caseId,
            },
          });
          if (hasMedicalThread)
            throw new Error(
              `User already has a medical thread for that case, threadId: ${hasMedicalThread.id}`
            );
        }

        return query(args);
      },
    },
  },
});

export const ThreadCreateExtensions = Prisma.defineExtension({
  model: {
    thread: {
      async createThread(
        userId: string,
        threadType: ThreadType,
        caseRef?: string,
        participants?: Prisma.ThreadParticipantCreateManyInput,
        initialMessage?: string
      ) {
        const date = new Date();

        const createMessage = initialMessage
          ? {
              create: {
                fromUserId: userId,
                status: MessageStatus.SENT,
                content: initialMessage,
                sentWhen: date,
                readByIds: { set: [userId] },
              },
            }
          : undefined;

        let updateData: any = {
          user: { connect: { id: userId } },
          type: threadType,
          participants: {
            createMany: participants ? { data: participants } : undefined,
          },
          messages: createMessage,
          lastMessageDate: date,
          status: ThreadStatus.ACTIVE,
          history: {
            create: {
              triggeredById: userId,
              statusTo: ThreadStatus.ACTIVE,
              action: ThreadAction.CREATED,
            },
          },
        };

        if (caseRef) {
          updateData = { ...updateData, case: { connect: { id: caseRef } } };
        }

        const thread = await messagingClient.thread.create({
          data: updateData,
        });
        return thread;
      },
    },
  },
});

export type AddDraftMessage = {
  threadId: string;
  fromUser: User;
  respondingTo?: string;
  mentionedUsers?: string[];
};

export const ThreadUpdateExtensions = Prisma.defineExtension({
  model: {
    thread: {
      async addDraftMessage({
        threadId,
        fromUser,
        respondingTo,
        mentionedUsers,
      }: AddDraftMessage) {
        if (!this.checkUserAccess(threadId, fromUser))
          throw new Error('User does not have access to delete thread.');

        const message = await messagingClient.message.create({
          data: {
            threadId: threadId,
            fromUserId: fromUser.id,
            status: MessageStatus.DRAFT,
            respondingToId: respondingTo ?? undefined,
            mentioningUserIds: mentionedUsers ?? undefined,
          },
        });

        if (message) {
          await messagingClient.threadHistory.create({
            data: {
              threadId: threadId,
              triggeredById: fromUser.id,
              userAffectedId: fromUser.id,
              action: ThreadAction.MESSAGE_ADDED,
            },
          });
        }

        return message;
      },
      async addParticipant(
        userId: string,
        threadId: string,
        authenticatedUser: User
      ) {
        const roleAccess: UserRole[] = [
          UserRole.ADMIN,
          UserRole.CORTINA_NURSE,
          UserRole.CORTINA_SUPPORT,
          UserRole.PHYSICIAN,
          UserRole.PHYSICIAN_SUPPORT,
        ];

        const threadUser = await messagingClient.thread.findUnique({
          where: { id: threadId },
          select: { userId: true },
        });

        if (
          !isUserAuthorized(authenticatedUser, roleAccess) ||
          threadUser?.userId === authenticatedUser.id
        )
          throw new Error('User does not have access to addParticipants.');

        const result = await messagingClient.threadParticipant.upsert({
          where: {
            userId_threadId: {
              userId: userId,
              threadId: threadId,
            },
          },
          update: {
            status: ThreadParticipantStatus.ACTIVE,
          },
          create: {
            userId: userId,
            threadId: threadId,
            status: ThreadParticipantStatus.ACTIVE,
          },
          include: {
            user: true,
          },
        });

        await messagingClient.threadHistory.create({
          data: {
            threadId: threadId,
            triggeredById: authenticatedUser.id,
            userAffectedId: userId,
            action: ThreadAction.JOINEDTHREAD,
          },
        });

        return result;
      },
      async removeParticipant(
        userId: string,
        threadId: string,
        authenticatedUser: User
      ) {
        const roleAccess: UserRole[] = [
          UserRole.ADMIN,
          UserRole.CORTINA_NURSE,
          UserRole.CORTINA_SUPPORT,
          UserRole.PHYSICIAN,
          UserRole.PHYSICIAN_SUPPORT,
        ];

        const threadUser = await messagingClient.thread.findUnique({
          where: { id: threadId },
          select: { userId: true },
        });

        if (
          !isUserAuthorized(authenticatedUser, roleAccess) ||
          threadUser?.userId !== authenticatedUser.id
        )
          throw new Error('User does not have access to addParticipants.');

        const result = await messagingClient.threadParticipant.update({
          where: {
            userId_threadId: {
              userId: userId,
              threadId: threadId,
            },
          },
          data: {
            status: ThreadParticipantStatus.INACTIVE,
          },
        });

        await messagingClient.threadHistory.create({
          data: {
            threadId: threadId,
            triggeredById: authenticatedUser.id,
            userAffectedId: userId,
            action: ThreadAction.LEFTTHREAD,
          },
        });

        return result;
      },
      async markResolved(threadId: string, authenticatedUser: User) {
        if (!this.checkUserAccess(threadId, authenticatedUser))
          throw new Error('User does not have access to mark thread resolved.');

        const result = await messagingClient.thread.update({
          where: {
            id: threadId,
          },
          data: {
            status: ThreadStatus.RESOLVED,
            history: {
              create: {
                triggeredById: authenticatedUser.id,
                statusFrom: (
                  await messagingClient.thread.findUnique({
                    where: { id: threadId },
                    select: { status: true },
                  })
                )?.status,
                statusTo: ThreadStatus.RESOLVED,
                action: ThreadAction.RESOLVE,
              },
            },
          },
        });
        return result;
      },
      async rateThread(
        threadId: string,
        rating: number,
        authenticatedUser: User
      ) {
        const thread = await messagingClient.thread.findUnique({
          where: {
            id: threadId,
          },
          select: {
            userId: true,
          },
        });

        if (thread?.userId !== authenticatedUser.id)
          throw new Error('User does not have access to rate thread.');

        const result = await messagingClient.thread.update({
          where: {
            id: threadId,
          },
          data: {
            rating: rating,
            history: {
              create: {
                triggeredById: authenticatedUser.id,
                action: ThreadAction.RATED,
              },
            },
          },
        });

        //TODO: update operation history
        return result;
      },
      async reactivateThread(threadId: string, authenticatedUser: User) {
        if (!this.checkUserAccess(threadId, authenticatedUser))
          throw new Error('User does not have access to reactivate thread.');

        const result = await messagingClient.thread.update({
          where: {
            id: threadId,
          },
          data: {
            status: ThreadStatus.ACTIVE,
            history: {
              create: {
                triggeredById: authenticatedUser.id,
                statusFrom: (
                  await messagingClient.thread.findUnique({
                    where: { id: threadId },
                    select: { status: true },
                  })
                )?.status,
                statusTo: ThreadStatus.ACTIVE,
                action: ThreadAction.REOPEN,
              },
            },
          },
        });
        return result;
      },
      async archiveThread(threadId: string, authenticatedUser: User) {
        if (!this.checkUserAccess(threadId, authenticatedUser))
          throw new Error('User does not have access to archive thread.');

        const result = await messagingClient.thread.update({
          where: {
            id: threadId,
          },
          data: {
            status: ThreadStatus.ARCHIVED,
            history: {
              create: {
                triggeredById: authenticatedUser.id,
                statusFrom: (
                  await messagingClient.thread.findUnique({
                    where: { id: threadId },
                    select: { status: true },
                  })
                )?.status,
                statusTo: ThreadStatus.ARCHIVED,
                action: ThreadAction.ARCHIVE,
              },
            },
          },
        });
        return result;
      },
      async deleteThread(threadId: string, authenticatedUser: User) {
        if (!this.checkUserAccess(threadId, authenticatedUser))
          throw new Error('User does not have access to delete thread.');

        const result = await messagingClient.thread.update({
          where: {
            id: threadId,
          },
          data: {
            status: ThreadStatus.DELETED,
            history: {
              create: {
                triggeredById: authenticatedUser.id,
                statusFrom: (
                  await messagingClient.thread.findUnique({
                    where: { id: threadId },
                    select: { status: true },
                  })
                )?.status,
                statusTo: ThreadStatus.DELETED,
                action: ThreadAction.DELETE,
              },
            },
          },
        });
        return result;
      },
      async isSupportOrParticipant(threadId: string, authenticatedUser: User) {
        // these roles have access to create memos no matter what
        const fullAccessRoles: UserRole[] = [
          UserRole.ADMIN,
          UserRole.CORTINA_NURSE,
          UserRole.CORTINA_SUPPORT,
        ];
        // these roles must be a participant on the thread to create a memo
        const participantAccessRoles: UserRole[] = [
          UserRole.PHYSICIAN,
          UserRole.PHYSICIAN_SUPPORT,
        ];

        if (isUserAuthorized(authenticatedUser, fullAccessRoles)) return true;

        if (!isUserAuthorized(authenticatedUser, participantAccessRoles))
          return false;

        const threadParticipants =
          await messagingClient.thread.getActiveThreadParticipants(threadId);

        if (threadParticipants) {
          const isParticipant = threadParticipants.some(
            (p) => p.id === authenticatedUser.id
          ); // is the authenticated user a participant in the thread?

          if (isParticipant) return true;
        }

        return false;
      },
      async checkUserAccess(threadId: string, authenticatedUser: User) {
        try {
          const roleAccess: UserRole[] = [
            UserRole.ADMIN,
            UserRole.CORTINA_SUPPORT,
          ];

          if (isUserAuthorized(authenticatedUser, roleAccess)) return true; //admin has access to all threads

          const thread = await messagingClient.thread.findFirst({
            where: {
              id: threadId,
            },
            select: {
              userId: true,
              participants: {
                select: {
                  userId: true,
                  status: true,
                },
              },
              case: {
                select: {
                  physicianId: true,
                },
              },
            },
          });

          const userIsThreadOwner = thread?.userId === authenticatedUser.id;
          const userIsPhysician =
            thread?.case?.physicianId === authenticatedUser.id;
          const userIsParticipant = thread?.participants?.some(
            (t) =>
              t.userId === authenticatedUser.id &&
              t.status === ThreadParticipantStatus.ACTIVE
          );

          if (!userIsParticipant && userIsPhysician) {
            await messagingClient.thread.addParticipant(
              authenticatedUser.id,
              threadId,
              authenticatedUser
            );
            return true;
          } else if (userIsParticipant || userIsThreadOwner) {
            return true;
          }

          return false;
        } catch (error) {
          logger.error('thread_user_access_check_failure', {
            metadata: {
              source: 'messagingClient.thread.checkUserAccesss',
              context: { userId: authenticatedUser.id, threadId },
              error,
            },
          });
          return false;
        }
      },
    },
  },
});

export const ThreadGetExtensions = Prisma.defineExtension({
  model: {
    thread: {
      async getThread(threadId: string) {
        const thread = await messagingClient.thread.findUnique({
          where: {
            id: threadId,
          },
          include: {
            participants: {
              include: {
                user: true,
              },
            },
          },
        });
        return thread;
      },
      async getUserThreads(userId: string) {
        const threads = await messagingClient.thread.findMany({
          where: {
            userId: userId,
            AND: {
              status: ThreadStatus.ACTIVE,
            },
          },
        });
        return threads;
      },
      async getActiveParticipantThreads(userId: string) {
        //seperate calls to threadParticipants to avoid prisma nested where bug
        const threadParticipants =
          await messagingClient.threadParticipant.findMany({
            where: {
              userId,
              status: ThreadParticipantStatus.ACTIVE,
            },
            select: {
              threadId: true,
            },
          });

        const threads = await messagingClient.thread.findMany({
          where: {
            id: { in: threadParticipants.map((tp) => tp.threadId) },
            status: ThreadStatus.ACTIVE,
          },
        });

        return threads;
      },
      async getActiveThreadParticipants(threadId: string) {
        const participants = await messagingClient.threadParticipant.findMany({
          where: {
            threadId: threadId,
            status: ThreadParticipantStatus.ACTIVE,
          },
          include: {
            user: true,
          },
        });

        if (participants) {
          const users = participants.map((p) => p.user);
          return users;
        }

        return participants;
      },
      async getAllThreadParticipants(threadId: string) {
        const participants = await messagingClient.threadParticipant.findMany({
          where: {
            threadId: threadId,
          },
          include: {
            user: true,
          },
        });

        if (participants) {
          const users = participants.map((p) => p.user);
          return users;
        }

        return participants;
      },
      async threadWithUnreadMessagesCount(userId: string) {
        //seperate call to threadParticipants to work around prisma nested where bug
        const threadParticipants =
          await messagingClient.threadParticipant.findMany({
            where: {
              userId,
              status: ThreadParticipantStatus.ACTIVE,
            },
            select: {
              threadId: true,
            },
          });

        const threads = await messagingClient.thread.findMany({
          where: {
            AND: [
              {
                OR: [
                  {
                    id: {
                      in: threadParticipants.map((tp) => tp.threadId),
                    },
                  },
                  {
                    userId: userId,
                  },
                ],
              },
              { status: ThreadStatus.ACTIVE },
            ],
          },
          select: {
            messages: {
              select: {
                readByIds: true,
                fromUserId: true,
              },
              orderBy: {
                sentWhen: 'desc',
              },
              take: 10,
            },
          },
        });

        const filteredThreads = threads.filter((thread) => {
          thread.messages.some(
            (m) => !m.readByIds.includes(userId) && m.fromUserId !== userId
          );
        });

        return filteredThreads.length;
      },
      async getThreadsWithUnreadMessages(userId: string) {
        //seperate call to threadParticipants to work around prisma nested where bug
        const threadParticipants =
          await messagingClient.threadParticipant.findMany({
            where: {
              userId,
              status: ThreadParticipantStatus.ACTIVE,
            },
            select: {
              threadId: true,
            },
          });

        const threads = await messagingClient.thread.findMany({
          where: {
            AND: [
              {
                OR: [
                  {
                    id: {
                      in: threadParticipants.map((tp) => tp.threadId),
                    },
                  },
                  {
                    userId: userId,
                  },
                ],
              },
              { status: ThreadStatus.ACTIVE },
            ],
          },
          include: {
            messages: true,
          },
        });

        const filteredThreads = threads.filter((thread) => {
          thread.messages.some(
            (m) => !m.readByIds.includes(userId) && m.fromUserId !== userId
          );
        });

        return filteredThreads;
      },
      async checkUserIsThreadOwner(threadId: string, userId: string) {
        const thread = await messagingClient.thread.findUnique({
          where: {
            id: threadId,
          },
          select: {
            userId: true,
          },
        });

        if (thread?.userId === userId) return true;

        return false;
      },
      async checkUserCanRateThread(threadId: string, authenticatedUser: User) {
        const thread = await messagingClient.thread.findUnique({
          where: {
            id: threadId,
          },
          select: {
            userId: true,
            type: true,
          },
        });

        if (
          thread?.userId === authenticatedUser.id &&
          thread?.type === ThreadType.SUPPORT
        )
          return true;

        return false;
      },
    },
  },
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/messaging/memoExtensions.ts

import { isUserAuthorized } from '@/utils/auth/auth';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import {
  MessageMedia,
  MessageStatus,
  Prisma,
  User,
  UserRole,
} from '@prisma/client';

import { messagingClient } from '.';

export const MemoFieldExtensions = Prisma.defineExtension({
  result: {
    memo: {
      status: {
        needs: { contentId: true },
        async compute({ contentId }) {
          const msg: { status: MessageStatus } | null =
            await prisma.message.findUnique({
              where: { id: contentId },
              select: { status: true },
            });

          if (!msg) return null;

          return msg.status;
        },
      },
    },
  },
});

export const MemoGetExtensions = Prisma.defineExtension({
  model: {
    memo: {
      async getMemoById(memoId: string, authenticatedUser: User) {
        if (!this.checkUserAccess(memoId, authenticatedUser))
          throw new Error('User does not have access to this memo');

        const memo = await messagingClient.memo.findUnique({
          where: { id: memoId },
          include: { content: true },
        });

        return memo;
      },
      async getMemosForThread(threadId: string, authenticatedUser: User) {
        const memos = await messagingClient.memo.findMany({
          where: { threadId: threadId },
          include: { thread: true, content: true },
        });

        if (
          memos &&
          memos.some((memo) => memo.thread?.userId === authenticatedUser.id)
        )
          throw new Error('User cannot view their own memos');

        return memos;
      },
      async getMemosForUser(userId: string, authenticatedUser: User) {
        if (userId === authenticatedUser.id)
          throw new Error('User cannot view their own memos');

        const memos = await messagingClient.memo.findMany({
          where: { userId: userId },
          include: { content: true },
        });

        return memos;
      },
      async getMemosForCase(caseId: string, authenticatedUser: User) {
        const memos = await messagingClient.memo.findMany({
          where: { caseId: caseId },
          include: { case: true, content: true },
        });

        if (
          memos &&
          memos.some((memo) => memo.case?.userId === authenticatedUser.id)
        )
          throw new Error('User cannot view their own memos');

        return memos;
      },
      async userIsAuthor(memoId: string, authenticatedUser: User) {
        const memoUser = await messagingClient.memo.findUnique({
          where: { id: memoId },
          select: { createdById: true },
        });

        if (!memoUser) return false;

        return memoUser.createdById === authenticatedUser.id;
      },
      async checkUserAccess(
        memoId: string,
        authenticatedUser: User
      ): Promise<boolean> {
        const roleAccess: UserRole[] = [
          UserRole.ADMIN,
          UserRole.CORTINA_NURSE,
          UserRole.CORTINA_SUPPORT,
          UserRole.PHYSICIAN,
          UserRole.PHYSICIAN_SUPPORT,
        ]; // no patients

        if (!isUserAuthorized(authenticatedUser, roleAccess)) return false;

        const memo = await messagingClient.memo.findUnique({
          where: { id: memoId },
          select: { userId: true, caseId: true, threadId: true },
        });

        if (!memo) return true; // if the memo does not exist the operation will throw 404 later.

        if (memo.userId) return memo?.userId !== authenticatedUser.id; // dont allow users to see their own memos

        if (memo.caseId) {
          return true; // TODO: implement case access when case is built out.
        }

        if (memo.threadId) {
          const threadUser = await messagingClient.thread.findUnique({
            where: { id: memo.threadId },
            select: { userId: true },
          });

          if (!threadUser || threadUser.userId === authenticatedUser.id)
            return false;
        }
        return false; // it is not posisble for a memo to not have a userId, caseId, or threadId return false to satisfy the type checker.
      },
    },
  },
});
export const MemoUpdateExtensions = Prisma.defineExtension({
  model: {
    memo: {
      async saveAndPublishMemo(
        memoId: string,
        authenticatedUser: User,
        message?: string,
        media?: MessageMedia
      ) {
        const memoUser = await messagingClient.memo.findUnique({
          where: { id: memoId },
          select: { userId: true },
        });

        if (memoUser?.userId !== authenticatedUser.id)
          throw new Error(
            'User does not have access to save and publish this memo'
          );

        const updatedMemo = await messagingClient.memo.update({
          where: { id: memoId },
          data: {
            content: {
              update: {
                content: message,
                media: media,
                status: MessageStatus.SENT,
              },
            },
          },
          include: { content: true },
        });

        return updatedMemo;
      },
      async updateDraftMemo(
        memoId: string,
        authenticatedUser: User,
        message?: string,
        media?: MessageMedia
      ) {
        const memoUser = await messagingClient.memo.findUnique({
          where: { id: memoId },
          select: { userId: true },
        });

        if (memoUser?.userId !== authenticatedUser.id)
          throw new Error(
            'User does not have access to update the draft of this memo'
          );

        const updatedMemo = await messagingClient.memo.update({
          where: { id: memoId },
          data: {
            content: {
              update: {
                content: message,
                media: media,
              },
            },
          },
          include: { content: true },
        });

        return updatedMemo;
      },
      async publishMemo(memoId: string, authenticatedUser: User) {
        const memoUser = await messagingClient.memo.findUnique({
          where: { id: memoId },
          select: { userId: true },
        });

        if (memoUser?.userId !== authenticatedUser.id)
          throw new Error('User does not have access to publish this memo');

        const updatedMemo = await messagingClient.memo.update({
          where: { id: memoId },
          data: {
            content: {
              update: {
                status: MessageStatus.SENT,
              },
            },
          },
          include: { content: true },
        });

        return updatedMemo;
      },
      async archiveMemo(memoId: string, authenticatedUser: User) {
        const memoAccess = await messagingClient.memo.checkUserAccess(
          memoId,
          authenticatedUser
        );

        if (!memoAccess)
          throw new Error('User does not have access to archive this memo');

        const updatedMemo = await messagingClient.memo.update({
          where: { id: memoId },
          data: {
            content: {
              update: {
                status: MessageStatus.ARCHIVED,
              },
            },
          },
          include: { content: true },
        });

        return updatedMemo;
      },
      async deleteMemo(memoId: string, authenticatedUser: User) {
        const memoAccess = await messagingClient.memo.checkUserAccess(
          memoId,
          authenticatedUser
        );

        if (!memoAccess)
          throw new Error('User does not have access to delete this memo');

        const deletedMemo = await messagingClient.memo.update({
          where: { id: memoId },
          data: {
            content: {
              update: {
                status: MessageStatus.DELETED,
              },
            },
          },
          include: { content: true },
        });

        return deletedMemo;
      },
    },
  },
});
export const MemoCreateExtensions = Prisma.defineExtension({
  model: {
    memo: {
      async createMemo(
        authenticatedUser: User,
        threadId?: string,
        caseId?: string,
        userId?: string,
        message?: string | MessageMedia,
        respondingTo?: string,
        mentionedUsers?: string[]
      ) {
        if (!threadId && !caseId && !userId)
          throw new Error('Must provide either threadId, caseId, or userId');

        // ensure that only one of the three possible memo targets is provided
        const memoTargets = [threadId, caseId, userId].filter(
          (x) => x !== undefined && x !== null
        );

        if (memoTargets.length > 1)
          throw new Error(
            'A memo can only be created for one of threadId, caseId, or userId'
          );

        const txtContent = typeof message === 'string' ? message : null;
        const mediaContent =
          typeof message === 'object' ? (message as MessageMedia) : null;

        const createdMessage = await messagingClient.message.create({
          data: {
            content: txtContent,
            media: mediaContent ? [mediaContent] : [],
            status: MessageStatus.DRAFT,
            fromUserId: authenticatedUser.id,
            respondingToId: respondingTo,
            mentioningUserIds: mentionedUsers,
          },
        });

        if (!createdMessage)
          throw new Error('Unable to create message for memo');

        const memo = await messagingClient.memo.create({
          data: {
            createdById: authenticatedUser.id,
            threadId: threadId,
            caseId: caseId,
            userId: userId,
            contentId: createdMessage.id,
          },
        });

        return memo;
      },
    },
  },
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/messaging/index.ts

import { CaseInclude } from '@/app/shared/types';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { IExtendedCase } from '@/utils/get-case-physician-access';
import { Prisma } from '@prisma/client';

import {
  MemoCreateExtensions,
  MemoFieldExtensions,
  MemoGetExtensions,
  MemoUpdateExtensions,
} from './memoExtensions';
import {
  MessageCreateExtensions,
  MessageGetExtensions,
  MessageUpdateExtensions,
  MessageValidation,
} from './messageExtensions';
import {
  ThreadCreateExtensions,
  ThreadGetExtensions,
  ThreadUpdateExtensions,
  ThreadValidationExtension,
} from './threadExtensions';

export const messagingClient = prisma
  .$extends(MessageValidation)
  .$extends(MessageGetExtensions)
  .$extends(MessageUpdateExtensions)
  .$extends(MessageCreateExtensions)
  .$extends(ThreadValidationExtension)
  .$extends(ThreadGetExtensions)
  .$extends(ThreadUpdateExtensions)
  .$extends(ThreadCreateExtensions)
  .$extends(MemoFieldExtensions)
  .$extends(MemoGetExtensions)
  .$extends(MemoUpdateExtensions)
  .$extends(MemoCreateExtensions);

/* Include & Select Types */

export type MessageUserInclude = Prisma.MessageGetPayload<{
  include: { fromUser: true };
}>;

export type ThreadInclude = Prisma.ThreadGetPayload<{
  include: {
    messages: true;
    _count: {
      select: {
        messages: true;
      };
    };
  };
}>;

export type ThreadCustomType = ThreadInclude & {
  case: IExtendedCase<CaseInclude> | null;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/models/extensions/messaging/messageExtensions.ts

import { isUserAuthorized } from '@/utils/auth/auth';
import { logger } from '@/utils/clients/logging/winstonClient';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { WithRequiredProperty } from '@/utils/utility-types/withRequiredProperty';
import {
  Comment,
  Message,
  MessageMedia,
  MessageStatus,
  Prisma,
  ThreadParticipantStatus,
  User,
  UserRole,
} from '@prisma/client';
import { MessagePartial, UserPartial } from '@prisma/generated/zod';

import { messagingClient } from '.';

// validation extensions
export const MessageValidation = Prisma.defineExtension({
  name: 'message-validation',
  query: {
    message: {
      async update({ args, query }) {
        if (!args.data.media && !args.data.content) {
          const msg = await messagingClient.message.findUnique({
            where: { id: args.where.id },
            select: { media: true, content: true },
          });
          if (!msg || (!msg.content && !msg.media))
            throw new Error('Message must have either media or content');
        }

        return query(args);
      },
    },
  },
});

// response type
export type MessagesResponse = Pick<
  Message,
  | 'id'
  | 'createdAt'
  | 'updatedAt'
  | 'sentWhen'
  | 'content'
  | 'media'
  | 'readByIds'
> & {
  fromUser: Pick<
    User,
    'id' | 'avatarUrl' | 'firstName' | 'lastName' | 'email' | 'roles'
  >;
} & {
  comments: (Pick<Comment, 'id' | 'content' | 'createdAt'> & {
    user: Pick<User, 'id' | 'firstName' | 'lastName'>;
  })[];
};

// select to get above response
const MessageArrayInclude = {
  fromUser: {
    select: {
      id: true,
      avatarUrl: true,
      firstName: true,
      lastName: true,
      email: true,
      roles: true,
    },
  },
  comments: {
    include: {
      user: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
        },
      },
    },
  },
};

// create new client with the message validation
const prismaWithValidation = prisma.$extends(MessageValidation);

// extensions
export const MessageGetExtensions = Prisma.defineExtension({
  model: {
    message: {
      async getMessagesWithFromUsers<T extends MessagePartial>(
        msgs: WithRequiredProperty<T, 'fromUserId'>[]
      ): Promise<(T & { fromUser: UserPartial })[]> {
        const fromUserIds = msgs.map((msg) => msg.fromUserId);

        const fromUsers = await prisma.user.findMany({
          where: {
            id: {
              in: fromUserIds,
            },
          },
          select: {
            id: true,
            avatarUrl: true,
            firstName: true,
            lastName: true,
            email: true,
            roles: true,
          },
        });

        if (!fromUsers) throw new Error('Error getting fromUsers');

        const fromUserMap = new Map(
          fromUsers.map((fromUser) => [fromUser.id, fromUser])
        );

        return msgs.map((msg) => {
          const fromUser = fromUserMap.get(msg.fromUserId);

          if (!fromUser) throw new Error('Error getting fromUser for message');

          return {
            ...msg,
            fromUser,
          };
        });
      },
      async getMessage(messageId: string, authenticatedUser: User) {
        const userHasAccess =
          this.checkUserIsParticipant(messageId, authenticatedUser) ||
          isUserAuthorized(authenticatedUser, [UserRole.ADMIN]);

        if (!userHasAccess)
          throw new Error('User does not have access to this message');

        const message = await prismaWithValidation.message.findUnique({
          where: {
            id: messageId,
          },
          include: {
            memo: true,
          },
        });

        if (message?.memo?.id) {
          const userHasAccess = await messagingClient.memo.checkUserAccess(
            message.memo.id,
            authenticatedUser
          );

          if (!userHasAccess)
            throw new Error(
              'Cannot return a message from a memo that the user does not have access to'
            );
        }
        return message;
      },
      async getMessagesForThread(
        threadId: string,
        authenticatedUser: User,
        status?: MessageStatus
      ): Promise<MessagesResponse[] | null> {
        const roleAccess: UserRole[] = [UserRole.ADMIN];

        const userHasAccess =
          isUserAuthorized(authenticatedUser, roleAccess) ||
          messagingClient.thread.checkUserAccess(threadId, authenticatedUser);

        if (!userHasAccess)
          throw new Error("User doesn't have access to this thread");

        const messages = await prismaWithValidation.message.findMany({
          where: {
            threadId: threadId,
            status,
          },
          include: MessageArrayInclude,
        });

        return messages;
      },
      async getLatestDraftMessageForThread(
        threadId: string,
        authenticatedUser: User
      ): Promise<Message | null> {
        const roleAccess: UserRole[] = [UserRole.ADMIN];

        const userHasAccess =
          isUserAuthorized(authenticatedUser, roleAccess) ||
          messagingClient.thread.checkUserAccess(threadId, authenticatedUser);

        if (!userHasAccess)
          throw new Error("User doesn't have access to this thread");

        const messages = await prismaWithValidation.message.findMany({
          where: {
            threadId: threadId,
            fromUserId: authenticatedUser.id,
            status: 'DRAFT',
          },
          orderBy: {
            updatedAt: 'desc',
          },
          take: 1,
        });

        return messages[0];
      },
      async getPaginatedMessagesForThread(
        threadId: string,
        take: number,
        lastCursor: string,
        authenticatedUser: User
      ): Promise<MessagesResponse[] | null> {
        const roleAccess: UserRole[] = [UserRole.ADMIN];

        const userHasAccess =
          isUserAuthorized(authenticatedUser, roleAccess) ||
          messagingClient.thread.checkUserAccess(threadId, authenticatedUser);

        if (!userHasAccess)
          throw new Error("User doesn't have access to this thread");

        const messages = await prismaWithValidation.message.findMany({
          where: { threadId, status: MessageStatus.SENT },
          include: MessageArrayInclude,
          take,
          ...(lastCursor && {
            skip: 1, // Do not include the cursor itself in the query result.
            cursor: {
              id: lastCursor as string,
            },
          }),
          orderBy: {
            sentWhen: 'desc',
          },
        });
        return messages;
      },
      async getAllMessagesSentAfterId(
        threadId: string,
        messageId: string,
        take: number,
        authenticatedUser: User
      ): Promise<MessagesResponse[] | null> {
        const roleAccess: UserRole[] = [UserRole.ADMIN];

        const userHasAccess =
          isUserAuthorized(authenticatedUser, roleAccess) ||
          messagingClient.thread.checkUserAccess(threadId, authenticatedUser);

        if (!userHasAccess)
          throw new Error("User doesn't have access to this thread");

        const startMessage = await prismaWithValidation.message.findUnique({
          where: { id: messageId },
        });

        if (startMessage && startMessage.sentWhen) {
          const messages = await prismaWithValidation.message.findMany({
            where: {
              threadId,
              status: MessageStatus.SENT,
              sentWhen: { gte: startMessage.sentWhen },
            },
            include: MessageArrayInclude,
            orderBy: {
              sentWhen: 'desc',
            },
          });
          let rest: any = [];
          if (messages && messages.length < take) {
            rest = await prismaWithValidation.message.findMany({
              where: { threadId, status: MessageStatus.SENT },
              include: MessageArrayInclude,
              take: take - messages.length, // Take any additional messages to make up take param
              skip: 1,
              cursor: {
                id: messageId as string, // Set start message id as cursor
              },
              orderBy: {
                sentWhen: 'desc',
              },
            });
          }
          return [...messages, ...rest];
        }

        return [];
      },
      async getUnreadMessagesForThread(
        threadId: string,
        authenticatedUser: User
      ) {
        const roleAccess: UserRole[] = [UserRole.ADMIN];

        const userHasAccess =
          isUserAuthorized(authenticatedUser, roleAccess) ||
          messagingClient.thread.checkUserAccess(threadId, authenticatedUser);

        if (!userHasAccess)
          throw new Error("User doesn't have access to this thread");

        const messages = await prismaWithValidation.message.findMany({
          where: {
            threadId: threadId,
            fromUserId: {
              not: authenticatedUser.id,
            },
            NOT: {
              readByIds: {
                has: authenticatedUser.id,
              },
            },
          },
        });
        return messages;
      },
      async userIsAuthor(messageId: string, authenticatedUser: User) {
        const message = await prismaWithValidation.message.findUnique({
          where: {
            id: messageId,
          },
          select: {
            fromUserId: true,
          },
        });

        if (!message || message.fromUserId !== authenticatedUser.id) {
          return false;
        }

        return true;
      },
      async checkUserIsParticipant(
        messageId: string,
        authenticatedUser: User,
        allowThreadOwner = false
      ) {
        try {
          const message = await messagingClient.message.findUnique({
            where: {
              id: messageId,
            },
            include: {
              thread: {
                select: {
                  id: true,
                  participants: {
                    select: {
                      userId: true,
                      status: true,
                    },
                  },
                  case: {
                    select: {
                      physicianId: true,
                    },
                  },
                },
              },
            },
          });

          const userIsThreadOwner =
            allowThreadOwner && message?.fromUserId === authenticatedUser.id;
          const userIsPhysician =
            message?.thread?.case?.physicianId === authenticatedUser.id;
          const userIsParticipant = message?.thread?.participants?.some(
            (t) =>
              t.userId === authenticatedUser.id &&
              t.status === ThreadParticipantStatus.ACTIVE
          );

          if (
            !userIsParticipant &&
            (userIsPhysician || userIsThreadOwner) &&
            message.threadId
          ) {
            await messagingClient.thread.addParticipant(
              authenticatedUser.id,
              message.threadId,
              authenticatedUser
            );
            return true;
          } else if (userIsParticipant) return true;

          return false;
        } catch (error) {
          logger.error('messaging_participant_check_failure', {
            metadata: {
              source: 'messagingClient.message.checkUserIsParticipant',
              context: { userId: authenticatedUser.id, messageId },
              error,
            },
          });
          return false;
        }
      },
    },
  },
});

export const MessageUpdateExtensions = Prisma.defineExtension({
  model: {
    message: {
      async saveDraft(
        messageId: string,
        authenticatedUser: User,
        content?: string,
        media?: MessageMedia[]
      ) {
        validateMessage(content, media);

        const userAuth = await messagingClient.message.userIsAuthor(
          messageId,
          authenticatedUser
        );

        if (!userAuth)
          throw new Error('User is not authorized to send this message');

        const message = await prismaWithValidation.message.update({
          where: {
            id: messageId,
          },
          data: {
            content: content,
            media: { push: media ?? [] },
          },
        });
        return message;
      },
      async removeMedia(
        messageId: string,
        authenticatedUser: User,
        media: MessageMedia
      ) {
        const userAuth = await messagingClient.message.userIsAuthor(
          messageId,
          authenticatedUser
        );

        if (!userAuth)
          throw new Error('User is not authorized to send this message');

        const message = await prismaWithValidation.message.findUnique({
          where: {
            id: messageId,
          },
        });

        const updated = await prismaWithValidation.message.update({
          where: {
            id: messageId,
          },
          data: {
            media: {
              set: message?.media.filter((m) => m.mediaUrl !== media.mediaUrl),
            },
          },
        });
        return updated;
      },
      async saveAndSend(
        messageId: string,
        authenticatedUser: User,
        content?: string,
        media?: MessageMedia[]
      ) {
        validateMessage(content, media);

        const userAuth = await messagingClient.message.userIsAuthor(
          messageId,
          authenticatedUser
        );

        if (!userAuth)
          throw new Error('User is not authorized to send this message');

        const message = await prismaWithValidation.message.update({
          where: {
            id: messageId,
          },
          data: {
            content: content,
            media: { push: media ?? [] },
            status: MessageStatus.SENT,
            sentWhen: new Date(),
            readByIds: {
              push: authenticatedUser.id,
            },
          },
        });
        return message;
      },
      async sendMessage(messageId: string, authenticatedUser: User) {
        const canSend = await messagingClient.message.userIsAuthor(
          messageId,
          authenticatedUser
        );

        if (!canSend)
          throw new Error(
            'User can only send messages that they are the author of.'
          );

        const message = await prismaWithValidation.message.update({
          where: {
            id: messageId,
          },
          data: {
            status: MessageStatus.SENT,
            sentWhen: new Date(),
            readByIds: {
              push: authenticatedUser.id,
            },
          },
        });
        return message;
      },
      async unSendMessage(messageId: string, authenticatedUser: User) {
        const roleAccess = isUserAuthorized(authenticatedUser, [
          UserRole.ADMIN,
        ]);

        const canUnSend = await messagingClient.message.userIsAuthor(
          messageId,
          authenticatedUser
        );

        if (!canUnSend && !roleAccess)
          throw new Error(
            'Only admins or the author of the message can unsend messages.'
          );

        const message = await prismaWithValidation.message.update({
          where: {
            id: messageId,
            status: MessageStatus.SENT,
            updatedAt: {
              gt: new Date(Date.now() - Number(process.env.UNSEND_TIMEOUT)),
            },
          },
          data: {
            status: MessageStatus.DRAFT,
          },
        });

        if (!message)
          throw new Error(
            'Message cannot be unsent: Incorrect message id, status or timemout exceeded.'
          );

        return message;
      },
      async markMessageAsRead(messageId: string, authenticatedUser: User) {
        const userIsParticipant =
          await messagingClient.message.checkUserIsParticipant(
            messageId,
            authenticatedUser,
            true
          );

        if (!userIsParticipant)
          throw new Error(
            'User must be a participant in the thread to mark a message as read'
          );

        const message = await prismaWithValidation.message.update({
          where: {
            id: messageId,
          },
          data: {
            readByIds: {
              push: authenticatedUser.id,
            },
          },
        });
        return message;
      },
      async archiveMessage(messageId: string, authenticatedUser: User) {
        const roleAccess = isUserAuthorized(authenticatedUser, [
          UserRole.ADMIN,
        ]);

        const userHasAccess = await messagingClient.message.userIsAuthor(
          messageId,
          authenticatedUser
        );

        if (!userHasAccess && !roleAccess)
          throw new Error(
            'User does not have the proper access to archive this message.'
          );

        const message = messagingClient.message.update({
          where: {
            id: messageId,
          },
          data: {
            status: MessageStatus.ARCHIVED,
          },
        });
        return message;
      },
      async deleteMessage(messageId: string, authenticatedUser: User) {
        const roleAccess = isUserAuthorized(authenticatedUser, [
          UserRole.ADMIN,
        ]);

        const userHasAccess = messagingClient.message.userIsAuthor(
          messageId,
          authenticatedUser
        );

        if (!userHasAccess && !roleAccess)
          throw new Error(
            'User does not have the proper access to delete this message.'
          );

        const message = messagingClient.message.update({
          where: {
            id: messageId,
          },
          data: {
            status: MessageStatus.DELETED,
          },
        });
        return message;
      },
    },
  },
});

export const MessageCreateExtensions = Prisma.defineExtension({
  model: {
    message: {
      async createDraftMessage(userId: string) {
        const message = await prismaWithValidation.message.create({
          data: {
            fromUserId: userId,
            status: MessageStatus.DRAFT,
          },
        });
        return message;
      },
    },
  },
});

const validateMessage = async (content?: string, media?: MessageMedia[]) => {
  const isMessageValid = content === '' || (content && content.length > 0);
  const isMediaValid = media && media && media.length > 0;

  if (!isMessageValid && !isMediaValid) {
    throw new Error('Message must have either media or content');
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/concierge-icon.tsx

import { SVGProps } from 'react';

const ConciergeIcon = (props: SVGProps<SVGSVGElement>) => {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="currentColor"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M5.21973 11.7746C5.21973 5.97219 9.45054 2.24292 14.6406 2.24292C17.1737 2.24292 19.6576 3.12686 21.1587 4.84024L21.3059 8.48683L21.1093 8.54225C19.8549 5.42075 17.8378 3.70737 15.0337 3.70737C11.6391 3.70737 8.98306 6.85704 8.98306 11.7746C8.98306 16.6921 11.5906 19.8145 15.1081 19.8145C17.8386 19.8145 19.7077 18.6544 21.1102 16.4441L21.2824 16.4995L21.2088 18.7098C19.757 20.3124 17.3719 21.3072 14.7401 21.3072C9.45216 21.3072 5.22134 17.5225 5.22134 11.7755L5.21973 11.7746Z"
        fill="currentColor"
      />
      <path
        d="M6.44114 3.79858C3.91284 5.39658 2.24268 8.22283 2.24268 11.8676C2.24268 15.5124 3.9088 18.3069 6.45731 19.9176C4.83244 17.9462 3.83762 15.1826 3.83762 11.8676C3.83762 8.55261 4.83002 5.76179 6.44114 3.79858Z"
        fill="currentColor"
      />
    </svg>
  );
};

export default ConciergeIcon;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/context-wrapper.tsx

'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

export interface IContextWrapperProps {
  children: React.ReactNode;
}

export const queryClient = new QueryClient();

const ContextWrapper: React.FC<IContextWrapperProps> = ({ children }) => {
  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
};

export default ContextWrapper;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/markdown-element.tsx

'use client';

import DOMPurify from 'isomorphic-dompurify';
import React from 'react';
import ReactMarkdown from 'react-markdown';
import remarkBreaks from 'remark-breaks';
import remarkGfm from 'remark-gfm';

import Blockquote from '@components/custom-markdown-overrides/blockquote';
import Link from '@components/custom-markdown-overrides/link';
import Paragraph from '@components/text/paragraph';
import { useHandlebars } from '@hooks/use-handlebars';

interface IMarkdownElementProps {
  overridePTag?: boolean;
  dataContext?: { [key: string]: unknown };
  className?: string;
  children?: string;
}

const components: { [key: string]: (props: any) => React.JSX.Element } = {
  a: ({ node, ...props }: any) => {
    const href = node.properties?.href ?? '';
    return <Link href={href}>{props.children}</Link>;
  },
  blockquote: ({ children }: { children: React.ReactNode }) => (
    <Blockquote>{children}</Blockquote>
  ),
  h1: ({ children }: { children: React.ReactNode }) => (
    <Paragraph variant="h1">{children}</Paragraph>
  ),
  h2: ({ children }: { children: React.ReactNode }) => (
    <Paragraph variant="h2">{children}</Paragraph>
  ),
  h3: ({ children }: { children: React.ReactNode }) => (
    <Paragraph variant="h3">{children}</Paragraph>
  ),
  h5: ({ children }: { children: React.ReactNode }) => (
    <Paragraph variant="h5">{children}</Paragraph>
  ),
  ul: ({ children }: { children: React.ReactNode }) => (
    <ul className="list-disc ml-6 space-y-1.5">{children}</ul>
  ),
  li: ({ children }: { children: React.ReactNode }) => (
    <li className="text-sm">{children}</li>
  ),
};

const pTagComponent = ({ children }: { children: React.ReactNode }) => (
  <Paragraph size="lg">{children}</Paragraph>
);

const MarkdownElement: React.FC<IMarkdownElementProps> = (p) => {
  const { overridePTag = true } = p;
  const compileText = useHandlebars(p.children, p.dataContext);

  let overrideComponents = components;
  if (overridePTag) {
    overrideComponents = {
      ...components,
      p: pTagComponent,
    };
  }

  const renderMarkdown = () => {
    const sanitizedMarkdown = DOMPurify.sanitize(compileText, {
      USE_PROFILES: { html: true }, // Enable HTML sanitization
    });

    return (
      <ReactMarkdown
        className={p.className}
        remarkPlugins={[remarkBreaks, remarkGfm]}
        components={overrideComponents}
      >
        {sanitizedMarkdown}
      </ReactMarkdown>
    );
  };

  return <div className="markdown">{renderMarkdown()}</div>;
};

export default MarkdownElement;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/signup.tsx

'use client';

import { Field, FieldProps, Form, Formik } from 'formik';
import React from 'react';
import { twMerge } from 'tailwind-merge';
import z from 'zod';

import ButtonSolid from '@/app/shared/components/buttons/button-solid';
import TextField from '@/app/shared/components/form-controls/text-field';
import LoadingSpinner from '@components/loading-indicators/loading-spinner';
import { XCircleIcon } from '@heroicons/react/20/solid';
import { KeyTextField } from '@prismicio/client';
import { Check } from '@untitled-ui/icons-react';

interface StyleProps {
  className: string;
  style: React.CSSProperties;
}

interface SignupProps {
  invalid_email_text?: KeyTextField;
  api_endpoint?: KeyTextField;
  label_text?: KeyTextField;
  input_placeholder?: KeyTextField;
  submit_text?: KeyTextField;
  submitting_text?: KeyTextField;
  submitted_text?: KeyTextField;
  showLabel?: boolean;
  labelProps?: StyleProps;
  buttonProps?: StyleProps;
  className?: string;
}

const Signup: React.FC<SignupProps> = (p) => {
  const [error, setError] = React.useState(false);
  const [success, setSuccess] = React.useState(false);

  const validate = (values: { email: string }) => {
    const errors: { email?: string } = {};

    const schema = z.string().email();
    const result = schema.safeParse(values.email);

    if (!result.success) {
      errors.email = p.invalid_email_text ?? 'Invalid email address';
    }

    return errors;
  };

  return (
    <Formik
      initialValues={{ email: '' }}
      validate={validate}
      onSubmit={async (values, { setSubmitting }) => {
        setError(false);
        try {
          const result = await fetch(p.api_endpoint ?? '/api/newsletter', {
            method: 'POST',
            body: JSON.stringify({
              email: values.email,
            }),
          });

          // Treat 409 (email address already registered) as a success
          if (![200, 409].includes(result.status)) {
            throw new Error();
          }

          setSuccess(true);
        } catch (e) {
          setError(true);
        } finally {
          setSubmitting(false);
        }
      }}
    >
      {({ touched, errors, isSubmitting }) => (
        <Form className="mx-auto max-w-md">
          <div
            className={twMerge(
              'w-full mt-8  flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-center',
              p.className
            )}
          >
            <div className="w-full">
              <label
                htmlFor="email-address"
                className={twMerge(
                  p.showLabel ? '' : 'sr-only',
                  p.labelProps?.className
                )}
                style={p.labelProps?.style}
              >
                {p.label_text ?? 'Email Address'}
              </label>
              <Field name="email">
                {({ field }: FieldProps) => (
                  <TextField
                    type="email"
                    id="email-address"
                    autoComplete="email"
                    placeholder={p.input_placeholder ?? 'Enter your email'}
                    disabled={isSubmitting || success}
                    {...field}
                  />
                )}
              </Field>
            </div>
            <ButtonSolid
              type="submit"
              variant="accent"
              size="lg"
              className={twMerge(
                'flex-none px-3.5 py-[11px] text-accent-700 rounded-md w-full max-w-none sm:max-w-[150px]',
                p.buttonProps?.className
              )}
              style={p.buttonProps?.style}
              disabled={isSubmitting || success}
            >
              <ActionButtonContent
                isSubmitting={isSubmitting}
                success={success}
                content={p}
              />
            </ButtonSolid>
          </div>
          <div id="subscribe-email-error" className="mt-2.5">
            <ErrorAlert
              formError={error}
              touched={touched.email}
              validationError={errors.email}
            />
          </div>
        </Form>
      )}
    </Formik>
  );
};

const ErrorAlert = ({
  formError,
  touched,
  validationError,
  submissionError = 'There was a problem submitting. Please try again later.',
}: {
  formError: boolean;
  touched?: boolean;
  validationError?: string;
  submissionError?: string;
}) => {
  if (formError || (touched && validationError)) {
    return (
      <div className="rounded-md bg-red-100 p-2">
        <div className="flex">
          <div className="flex-shrink-0">
            <XCircleIcon className="h-5 w-5 text-red-400" aria-hidden="true" />
          </div>
          <div className="ml-3">
            <h3 className="text-sm font-medium text-red-800">
              {formError ? submissionError : validationError}
            </h3>
          </div>
        </div>
      </div>
    );
  }

  return null;
};

const ActionButtonContent = ({
  isSubmitting,
  success,
  content,
}: {
  isSubmitting: boolean;
  success: boolean;
  content: SignupProps;
}) => {
  if (success) {
    return (
      <>
        <Check className="h-5 w-5 inline" viewBox="0 0 24 24" />
        <p className="ml-1 inline">{content.submitted_text ?? 'Subscribed'}</p>
      </>
    );
  }

  if (isSubmitting) {
    return (
      <div className="flex flex-row gap-1 justify-center items-center text-center">
        <LoadingSpinner size="sm" fillClass="inline fill-accent-700" />
        <span className="">{content.submitting_text ?? 'Subscribing'}</span>
      </div>
    );
  }

  return <>{content.submit_text ?? 'Subscribe'}</>;
};

export default Signup;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/navigation-wrapper.tsx

import { cookies } from 'next/headers';
import { NavigationDocument } from 'prismicio-types';

import Navigation from '@/app/shared/components/navigation/navigation';
import { userCartReturn } from '@/utils/ecommerce/cartUtils';
import { getBaseUrl } from '@/utils/getBaseUrl';
import { queryNavigationItems } from '@/utils/prismic/prismic';
import { ContentRelationshipField } from '@prismicio/client';

import CartSlider from './cart/cart-slider';
import Footer from './footer/footer';

interface IPrismicPageWithNavbarProps {
  initialNavigationLinkedItem: ContentRelationshipField<NavigationDocument>;
  scrollNavigationLinkedItem: ContentRelationshipField<NavigationDocument>;
  shouldShow: boolean;
  children: React.ReactNode;
}

const getCart = async () => {
  const res = await fetch(`${getBaseUrl()}/api/ecommerce/cart`, {
    method: 'GET',
    headers: { Cookie: cookies().toString() },
    cache: 'no-store',
  });

  return (await res.json()) as userCartReturn;
};

const NavigationWrapper = async ({
  initialNavigationLinkedItem,
  scrollNavigationLinkedItem,
  shouldShow,
  children,
}: IPrismicPageWithNavbarProps) => {
  if (!shouldShow) {
    return <div className="pb-40">{children}</div>;
  }
  const [nav, cart] = await Promise.all([
    queryNavigationItems(
      initialNavigationLinkedItem,
      scrollNavigationLinkedItem
    ),
    getCart(),
  ]);

  return (
    <>
      {nav.initialNavigationData && nav.scrollNavigationData && (
        <Navigation
          initialNavigation={nav.initialNavigationData}
          scrollNavigation={nav.scrollNavigationData}
          cart={cart}
        />
      )}
      {children}
      <CartSlider />
      {nav.footer && <Footer {...nav.footer} />}
    </>
  );
};

export default NavigationWrapper;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/error-view.tsx

'use client';

import React from 'react';

import ButtonSolid from '@/app/shared/components/buttons/button-solid';
import LoadingSpinner from '@components/loading-indicators/loading-spinner';
import { AlertCircle } from '@untitled-ui/icons-react';

const ErrorView: React.FC = () => {
  const [refreshing, setRefreshing] = React.useState(false);

  const refresh = () => {
    setRefreshing(true);
    setTimeout(() => {
      window.location.reload();
    }, 400);
  };

  return (
    <div className="flex h-[480px]">
      <div className="pt-20 flex flex-1 overflow-visible justify-center">
        <div
          className="relative flex flex-col justify-center items-center text-center w-full h-full md:justify-center md:max-w-[480px] md:max-h-[480px]"
          style={{
            backgroundImage: `url(/assets/background-ripple.svg)`,
            backgroundPosition: '50%',
            backgroundRepeat: 'no-repeat,repeat',
          }}
        >
          <div className="relative h-[56px] w-full flex items-center justify-center">
            <div className="bg-white border border-gray-200 shadow-sm rounded-md p-1.5">
              <AlertCircle
                className="w-7 h-7 text-gray-700"
                viewBox="0 0 24 24"
              />
            </div>
            <div className="absolute top-full w-full mt-3.5 flex flex-col items-center px-4">
              <p className="font-dmsans font-medium text-xl sm:text-3xl text-gray-900">
                Something went wrong
              </p>
              <p className="mt-2 font-dmsans text-sm sm:text-md text-gray-600 max-w-sm">
                We are working to resolve this issue as soon as possible. Please
                check back later to continue.
              </p>
              <div className="mt-6">
                <ButtonSolid
                  className="min-w-[180px]"
                  variant="accent"
                  onClick={refresh}
                >
                  {refreshing ? (
                    <div className="flex items-center justify-center">
                      <LoadingSpinner size="sm" fillClass="text-accent-700" />
                      Reloading
                    </div>
                  ) : (
                    'Reload'
                  )}
                </ButtonSolid>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ErrorView;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/not-found-view.tsx

import Link from 'next/link';
import React from 'react';

const NotFoundView: React.FC<{ href?: string; linkText?: string }> = ({
  href,
  linkText,
}) => {
  return (
    <div className="font-dmsans bg-white py-24 sm:py-32">
      <div className="mx-auto max-w-7xl px-6 lg:px-8">
        <div className="mx-auto max-w-2xl lg:mx-0">
          <p className="text-base font-semibold leading-7 text-accent-700">
            404 error
          </p>
          <h2 className="mt-2 text-4xl font-semibold tracking-tight text-gray-900 sm:text-6xl">
            We can&apos;t find that page
          </h2>
          <p className="mt-4 text-lg leading-8 text-gray-600  sm:text-xl">
            Sorry, the page you are looking for doesn&apos;t exist or has been
            moved.
          </p>
          <div className="mt-8 flex items-center gap-x-6">
            <Link
              className="rounded-md bg-accent px-3.5 text-accent-700 bg-accent-200 border border-accent-200
                hover:bg-accent-300 hover:text-accent-700 py-2.5 text-sm font-semibold shadow-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-accent-300"
              href={href ?? '/'}
            >
              {linkText ?? 'Take me home'}
            </Link>
          </div>
        </div>
      </div>
    </div>
  );
};

export default NotFoundView;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/account-header.tsx

import Link from 'next/link';
import React from 'react';

import { ChevronLeftIcon, ChevronRightIcon } from '@heroicons/react/20/solid';
import { KeyTextField, LinkField } from '@prismicio/client';
import { PrismicNextLink } from '@prismicio/next';
import { HomeLine } from '@untitled-ui/icons-react';

import CartButton from './cart/cart-button';

interface IAccountHeaderProps {
  title: string;
  breadcrumbs?: {
    link: LinkField;
    name: KeyTextField;
  }[];
  mobileBreadcrumbs?: {
    link: LinkField;
    name: KeyTextField;
  }[];
  showCart?: boolean;
  showBreadcrumb?: boolean;
}

const AccountHeader: React.FC<IAccountHeaderProps> = ({
  title,
  breadcrumbs,
  mobileBreadcrumbs,
  showCart = true,
  showBreadcrumb = true,
}) => {
  return (
    <div className="account-header px-6 pt-6 pb-4 border-b border-gray-200">
      {showBreadcrumb && (
        <nav className="flex mb-4" aria-label="Breadcrumb">
          {/* Desktop Breadcrumbs */}
          <ol
            role="list"
            className="hidden md:flex items-center space-x-2 flex-wrap gap-y-6"
          >
            <li>
              <div>
                <Link
                  href="/account"
                  className="text-gray-400 hover:text-gray-500"
                >
                  <HomeLine
                    className="h-5 w-5 flex-shrink-0"
                    aria-hidden="true"
                    viewBox="0 0 24 24"
                  />
                  <span className="sr-only">Home</span>
                </Link>
              </div>
            </li>
            {breadcrumbs &&
              breadcrumbs.map((breadcrumb) => (
                <li key={breadcrumb.name}>
                  <div className="flex items-center">
                    <ChevronRightIcon
                      className="h-5 w-5 flex-shrink-0 text-gray-400"
                      aria-hidden="true"
                    />
                    <PrismicNextLink
                      field={breadcrumb.link}
                      className="ml-2 text-sm font-medium text-gray-500 hover:text-gray-700"
                    >
                      {breadcrumb.name}
                    </PrismicNextLink>
                  </div>
                </li>
              ))}
          </ol>
          {/* Mobile Breadcrumbs */}
          <ol
            role="list"
            className="flex md:hidden items-center space-x-2 flex-wrap gap-y-6"
          >
            {mobileBreadcrumbs && mobileBreadcrumbs.length > 0 ? (
              <>
                {mobileBreadcrumbs.map((breadcrumb) => (
                  <li key={breadcrumb.name}>
                    <div className="flex items-center">
                      <ChevronLeftIcon
                        className="h-5 w-5 flex-shrink-0 text-gray-400"
                        aria-hidden="true"
                      />
                      <PrismicNextLink
                        field={breadcrumb.link}
                        className="ml-2 text-sm font-medium text-gray-500 hover:text-gray-700"
                      >
                        {breadcrumb.name}
                      </PrismicNextLink>
                    </div>
                  </li>
                ))}
              </>
            ) : (
              <></>
            )}
          </ol>
        </nav>
      )}
      <div className="flex flex-row justify-between items-center gap-4">
        <div className="font-dmsans text-2xl sm:text-3xl font-semibold text-gray-900">
          {title}
        </div>
        {showCart && <CartButton />}
      </div>
    </div>
  );
};

export default AccountHeader;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/error-toast.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

interface IErrorToastProps {
  show: boolean;
  text: string;
  onClose: (show: boolean) => void;
  position?: 'fixed' | 'absolute';
}

const ErrorToast: React.FC<IErrorToastProps> = ({
  show,
  text,
  onClose,
  position,
}) => {
  const [showErrorToast, setShowErrorToast] = React.useState<boolean>(false);

  const closeErrorToast = () => {
    setShowErrorToast(false);
    onClose(false);
  };

  const autoCloseErrorToast = () => {
    setTimeout(() => {
      closeErrorToast();
    }, 10000);
  };

  React.useEffect(() => {
    if (show) {
      setShowErrorToast(true);
      autoCloseErrorToast();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [show]);

  return showErrorToast ? (
    <div
      className={twMerge(
        'z-10 flex items-center w-full max-w-xs p-4 mb-4 text-gray-500 bg-red-100 rounded-lg shadow',
        position === 'fixed' ? 'fixed top-5 right-5' : 'absolute top-5 right-5'
      )}
      role="alert"
    >
      <div className="inline-flex items-center justify-center flex-shrink-0 w-8 h-8 text-red-500 rounded-lg">
        <svg
          className="w-5 h-5"
          aria-hidden="true"
          xmlns="http://www.w3.org/2000/svg"
          fill="currentColor"
          viewBox="0 0 20 20"
        >
          <path d="M10 .5a9.5 9.5 0 1 0 9.5 9.5A9.51 9.51 0 0 0 10 .5Zm3.707 11.793a1 1 0 1 1-1.414 1.414L10 11.414l-2.293 2.293a1 1 0 0 1-1.414-1.414L8.586 10 6.293 7.707a1 1 0 0 1 1.414-1.414L10 8.586l2.293-2.293a1 1 0 0 1 1.414 1.414L11.414 10l2.293 2.293Z" />
        </svg>
        <span className="sr-only">Error icon</span>
      </div>
      <div className="ml-3 text-sm font-normal">{text}</div>
      <button
        type="button"
        className="ml-auto -mx-1.5 -my-1.5 text-gray-400 hover:text-gray-900 rounded focus:ring-2 focus:ring-gray-300 p-1.5 hover:bg-red-200 inline-flex items-center justify-center h-8 w-8"
        aria-label="Close"
        onClick={closeErrorToast}
      >
        <span className="sr-only">Close</span>
        <svg
          className="w-3 h-3"
          aria-hidden="true"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 14 14"
        >
          <path
            stroke="currentColor"
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="2"
            d="m1 1 6 6m0 0 6 6M7 7l6-6M7 7l-6 6"
          />
        </svg>
      </button>
    </div>
  ) : null;
};

export default ErrorToast;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/loading-indicators/skeleton-card.tsx

export const SkeletonCard = () => {
  return (
    <>
      <div className="flex w-full flex-1 flex-col items-center  px-20">
        <div className="mt-12 w-1/2 animate-pulse flex-row items-center justify-center space-x-1 rounded-xl border p-6 ">
          <div className="flex flex-col space-y-2">
            <div className="h-6 w-11/12 rounded-md bg-gray-300 "></div>
            <div className="h-6 w-10/12 rounded-md bg-gray-300 "></div>
            <div className="h-6 w-9/12 rounded-md bg-gray-300 "></div>
            <div className="h-6 w-9/12 rounded-md bg-gray-300 "></div>
          </div>
        </div>
      </div>
    </>
  );
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/loading-indicators/loading-spinner.tsx

import React from 'react';

interface ILoadingSpinnerProps {
  fillClass?: string;
  size?: 'sm' | 'md' | 'lg';
}

const LoadingSpinner: React.FC<ILoadingSpinnerProps> = ({
  fillClass,
  size,
}) => {
  const sizeClass =
    size === 'sm' ? 'w-4 h-4' : size === 'lg' ? 'w-12 h-12' : 'w-8 h-8';
  return (
    <div role="status" className={fillClass}>
      <svg
        aria-hidden="true"
        className={`${sizeClass} text-gray-200 animate-spin dark:text-gray-600 fill-inherit`}
        viewBox="0 0 100 101"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z"
          fill="currentColor"
        />
        <path
          d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z"
          fill="currentFill"
        />
      </svg>
      <span className="sr-only">Loading...</span>
    </div>
  );
};

export default LoadingSpinner;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/loading-indicators/loading-circles.tsx

import { twMerge } from 'tailwind-merge';

export default function LoadingCircles({ className }: { className?: string }) {
  return (
    <div
      className={twMerge('flex justify-center h-screen bg-white', className)}
    >
      <div className="relative mt-[20%]">
        <div className="h-20 w-20 rounded-full border-t-8 border-b-8 border-gray-200 animate-spin"></div>
        <div className="absolute top-0 left-0 h-20 w-20 rounded-full border-t-8 border-b-8 border-accent-500 animate-spin"></div>
        <div className="flex flex-row items-baseline font-dmsans text-base text-gray-600 font-medium mt-4 text-center">
          Loading
          <div className="ml-1 flex space-x-1 justify-center items-center">
            <div className="h-1 w-1 bg-gray-600 rounded-full animate-bounce [animation-delay:-0.3s]"></div>
            <div className="h-1 w-1 bg-gray-600 rounded-full animate-bounce [animation-delay:-0.15s]"></div>
            <div className="h-1 w-1 bg-gray-600 rounded-full animate-bounce"></div>
          </div>
        </div>
      </div>
    </div>
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/footer/footer.tsx

'use client';

import get from 'lodash.get';
import Image from 'next/image';
import { FooterDocument } from 'prismicio-types';
import React from 'react';
import { twMerge } from 'tailwind-merge';
import { tss } from 'tss-react';

import PrismicNextLink from '@components/buttons/custom-prismic-link';
import { PrismicImage } from '@prismicio/react';

import Signup from './signup';

/**
 * Dynamic Styles for Footer
 */
export const useStyles = tss
  .withParams<{ footer: FooterDocument }>()
  .create(({ footer }) => ({
    link: {
      color: get(footer, 'data.group_link_color', 'black'),
      '&:hover': {
        color: get(footer, 'data.group_link_hover_color', 'black'),
      },
    },
    signupButton: {
      backgroundColor: get(
        footer,
        'data.button_background_color',
        'transparent'
      ),
      color: get(footer, 'data.button_text_color', 'black'),
      '&:hover': {
        backgroundColor: get(
          footer,
          'data.button_background_hover_color',
          'black'
        ),
        color: get(footer, 'data.button_text_hover_color', 'white'),
      },
    },
    item: {
      color: get(footer, 'data.item_color', 'black'),
      '&:hover': {
        color: get(footer, 'data.item_hover_color', 'black'),
      },
    },
  }));

const Footer: React.FC<FooterDocument> = (p) => {
  const { classes } = useStyles({ footer: p });

  return (
    <footer className="bg-white" aria-labelledby="footer-heading">
      <h2 id="footer-heading" className="sr-only">
        Cortina Health, Inc.
      </h2>
      <div className="mx-auto max-w-7xl px-6 pb-8 pt-20 sm:pt-8 lg:px-8 lg:pt-10">
        <div className="lg:grid lg:grid-cols-4 lg:gap-8">
          <div className="mb-4 lg:mb-0">
            <a
              href="https://legitscript.com"
              target="_blank"
              title="Verify LegitScript Approval"
            >
              <Image
                src="https://static.legitscript.com/seals/11452495.png"
                alt="LegitScript approved"
                width="140"
                height="120"
              />
            </a>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-8 col-span-2">
            {p.data.slices.map((slice) => (
              <div key={slice.id} className="ml-4 mt-4 lg:ml-0 lg:mt-0">
                <h3
                  className="font-dmsans text-sm font-semibold leading-6"
                  style={{
                    color: get(p, 'data.group_title_color', '#263A61'),
                  }}
                >
                  {slice.primary.title}
                </h3>
                <ul role="list" className="mt-3 space-y-4">
                  {slice.items.map((item, index) =>
                    item.link_icon?.url ? (
                      <PrismicNextLink
                        key={`${slice.id}-item-${index}`}
                        field={item.link}
                        className="inline-flex items-center justify-center mr-3"
                        prefetch={item.prefetch}
                      >
                        <PrismicImage
                          className="h-6 w-6"
                          field={item.link_icon}
                        />
                      </PrismicNextLink>
                    ) : (
                      <li key={`${slice.id}-item-${index}`}>
                        <PrismicNextLink
                          field={item.link}
                          className={twMerge(
                            'font-dmsans text-sm leading-6',
                            classes.link
                          )}
                          prefetch={item.prefetch}
                        >
                          {item.link_text}
                        </PrismicNextLink>
                      </li>
                    )
                  )}
                </ul>
              </div>
            ))}
          </div>
          <div className="ml-4 mt-10 lg:ml-0 lg:mt-0">
            <h3
              className="font-dmsans text-sm font-semibold leading-6"
              style={{
                color: get(p, 'data.group_title_color', '#263A61'),
              }}
            >
              {p.data.signup_group_title}
            </h3>
            <Signup {...p} />
          </div>
        </div>
        <div className="font-dmsans flex flex-col mt-8 pt-6 md:flex md:flex-row items-center justify-center gap-4 lg:gap-6">
          {p.data.item.map((item) =>
            item.type === 'Link' ? (
              <PrismicNextLink
                key={item.name}
                field={item.link}
                className="text-gray-400 hover:text-gray-500"
                prefetch={item.prefetch}
              >
                <span
                  className={twMerge(
                    'mt-8 text-xs leading-5 md:mt-0',
                    classes.item
                  )}
                >
                  {item.name}
                </span>
              </PrismicNextLink>
            ) : (
              <p
                key={item.name}
                className={twMerge(
                  'mt-8 text-xs leading-5 md:mt-0',
                  classes.item
                )}
              >
                {item.name}
              </p>
            )
          )}
        </div>
      </div>
    </footer>
  );
};

export default Footer;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/footer/signup.tsx

'use client';

import { Field, Form, Formik } from 'formik';
import get from 'lodash.get';
import { FooterDocument } from 'prismicio-types';
import React from 'react';
import { twMerge } from 'tailwind-merge';
import z from 'zod';

import { CheckCircleIcon } from '@heroicons/react/24/outline';

import LoadingSpinner from '../loading-indicators/loading-spinner';
import { useStyles } from './footer';

const Signup: React.FC<FooterDocument> = (p) => {
  const { classes } = useStyles({ footer: p });
  const [error, setError] = React.useState(false);
  const [success, setSuccess] = React.useState(false);

  const validate = (values: { email: string }) => {
    const errors: { email?: string } = {};

    const schema = z.string().email();
    const result = schema.safeParse(values.email);

    if (!result.success) {
      errors.email = p.data.invalid_email_text ?? 'Invalid email address';
    }

    return errors;
  };

  return (
    <Formik
      initialValues={{ email: '' }}
      validate={validate}
      onSubmit={async (values, { setSubmitting }) => {
        setError(false);
        try {
          const result = await fetch('/api/newsletter', {
            method: 'POST',
            body: JSON.stringify({
              email: values.email,
            }),
          });

          // Treat 409 (email address already registered) as a success
          if (![200, 409].includes(result.status)) {
            throw new Error();
          }

          setSuccess(true);
        } catch (e) {
          setError(true);
        } finally {
          setSubmitting(false);
        }
      }}
    >
      {({ touched, errors, isSubmitting }) => (
        <Form className="mt-3 flex flex-col sm:max-w-md">
          <label
            htmlFor="footer-email-address"
            className="font-dmsans font-medium text-sm mb-2"
            style={{
              color: get(p, 'data.signup_label_color', '#263A61'),
            }}
          >
            {p.data.signup_label}
          </label>
          <Field
            name="email"
            type="email"
            id="footer-email-address"
            autoComplete="email"
            required
            className="w-full min-w-0 appearance-none rounded-md border-0 font-dmsans bg-white px-3 py-1.5 text-base text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-gray-300 sm:text-sm sm:leading-6"
            placeholder={p.data.signup_placeholder ?? 'Enter your email'}
            disabled={isSubmitting || success}
          />
          {touched.email && errors.email && (
            <p
              className="mt-1 text-xs"
              style={{ color: get(p, 'data.error_color', '#ef4444') }}
            >
              {errors.email}
            </p>
          )}
          <div className="mt-4 sm:flex-shrink-0 self-start">
            {success ? (
              <div
                className="flex items-center justify-center gap-1"
                style={{
                  color: get(p, 'data.success_color', '#0e9383'),
                }}
              >
                <CheckCircleIcon className="h-4 w-4" />
                <p className="text-xs">{p.data.submitted_text}</p>
              </div>
            ) : (
              <button
                type="submit"
                className={twMerge(
                  'flex items-center justify-center font-dmsans rounded-md px-3 py-2 text-sm font-semibold shadow-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-gray-300',
                  classes.signupButton
                )}
                disabled={isSubmitting}
              >
                {isSubmitting ? (
                  <>
                    <LoadingSpinner size="sm" />
                    {p.data.submitting_text}
                  </>
                ) : (
                  <>{p.data.signup_button_text}</>
                )}
              </button>
            )}
            {error && (
              <p
                className="mt-1 text-xs"
                style={{ color: get(p, 'data.error_color', '#ef4444') }}
              >
                {p.data.submission_error_text}
              </p>
            )}
          </div>
        </Form>
      )}
    </Formik>
  );
};

export default Signup;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/buttons/button-solid.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import ButtonBase, { type ButtonProps } from '@components/buttons/button-base';

const solidVariantMap = {
  primary: `bg-primary-900 border text-white 
            hover:bg-primary-950 hover:text-white
            disabled:border-primary-200 disabled:bg-primary-200 disabled:text-primary-100 disabled:cursor-not-allowed`,
  accent: `text-accent-700 bg-accent-200 border border-accent-200
           hover:bg-accent-300 hover:text-accent-700
           disabled:border-accent-100 disabled:bg-accent-100 disabled:text-accent-300 disabled:cursor-not-allowed`,
  error: `bg-error-700 border border-error-700 text-white
          hover:bg-error-800 hover:text-white
          disabled:border-error-200 disabled:bg-error-200 disabled:text-error-300 disabled:cursor-not-allowed`,
  gray: `bg-gray-700 border border-gray-700 text-white
         hover:bg-gray-800 hover:text-white
         disabled:bg-gray-300 disabled:border-gray-300 disabled:text-gray-100 disabled:cursor-not-allowed`,
};

const ButtonSolid = React.forwardRef(function (
  p: ButtonProps,
  ref: React.Ref<HTMLButtonElement>
) {
  const { variant = 'primary', className, ...others } = p;

  const variantClassNames = solidVariantMap[variant ?? 'primary'];

  return (
    <ButtonBase
      {...others}
      ref={ref}
      className={twMerge([
        'rounded-lg shadow-xs',
        variantClassNames,
        className,
      ])}
    />
  );
});

ButtonSolid.displayName = 'ButtonSolid';

export default ButtonSolid;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/buttons/help-button.tsx

'use client';

import React from 'react';
import { twMerge } from 'tailwind-merge';

import Popover from '@components/overlays/popover';
import {
  useDismiss,
  useInteractions,
  useFloating,
  autoPlacement,
  autoUpdate,
  offset,
} from '@floating-ui/react';
import { HelpCircle } from '@untitled-ui/icons-react';

interface IHelpButtonProps {
  title: string;
  content: string;
  className?: string;
}

const HelpButton: React.FC<IHelpButtonProps> = (p) => {
  const [showPopover, setShowPopover] = React.useState(false);

  const togglePopover = () => {
    setShowPopover(!showPopover);
  };

  // Floating UI (dynamic positioning/auto-dismiss on click away)
  const { refs, x, y, strategy, context } = useFloating({
    open: showPopover,
    onOpenChange: setShowPopover,
    placement: 'top-end',
    middleware: [
      offset(5),
      autoPlacement({
        allowedPlacements: [
          'top-start',
          'top-end',
          'top',
          'bottom-start',
          'bottom',
          'bottom-end',
        ],
      }),
    ],
    whileElementsMounted: autoUpdate,
  });
  const dismiss = useDismiss(context);

  const { getReferenceProps, getFloatingProps } = useInteractions([dismiss]);

  return (
    <span
      className={twMerge([`flex items-center`, p.className])}
      ref={refs.setReference}
      {...getReferenceProps()}
    >
      <a className="inline-block" onClick={togglePopover}>
        <HelpCircle
          className="text-gray-400"
          width={16}
          height={16}
          viewBox="0 0 24 24"
        />
      </a>
      {showPopover && (
        <Popover
          ref={refs.setFloating}
          {...p}
          position={{
            x,
            y,
            strategy,
          }}
          getFloatingProps={getFloatingProps}
          callback={togglePopover}
        />
      )}
    </span>
  );
};

export default HelpButton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/buttons/custom-link.tsx

import Link, { LinkProps } from 'next/link';
import React from 'react';
import { twMerge } from 'tailwind-merge';

export interface ICustomLinkProps extends LinkProps {
  className?: string;
  id?: string;
  variant?:
    | 'primary'
    | 'accent'
    | 'gray'
    | 'error'
    | 'gray-outline'
    | 'error-outline'
    | 'primary-outline'
    | 'accent-outline';
  size?: 'sm' | 'base' | 'lg';
  children?: React.ReactNode;
}

const baseSizeMap = {
  sm: 'px-2.5 py-1.5 text-xs',
  base: 'px-3.5 py-2.5 text-xs md:text-sm',
  lg: 'px-4 py-3.5 text-sm md:text-base ',
};

const variantMap = {
  primary: `bg-primary-900 border text-white 
              hover:bg-primary-950 hover:text-white
              disabled:border-primary-200 disabled:bg-primary-200 disabled:text-primary-100 disabled:cursor-not-allowed`,
  accent: `text-accent-700 bg-accent-200 border border-accent-300
             hover:bg-accent-300 hover:text-accent-700
             disabled:border-accent-100 disabled:bg-accent-100 disabled:text-accent-300 disabled:cursor-not-allowed`,
  error: `bg-error-700 border border-error-700 text-white
            hover:bg-error-800 hover:text-white
            disabled:border-error-200 disabled:bg-error-200 disabled:text-error-300 disabled:cursor-not-allowed`,
  gray: `bg-gray-700 border border-gray-700 text-white
           hover:bg-gray-800 hover:text-white
           disabled:bg-gray-300 disabled:border-gray-300 disabled:text-gray-100 disabled:cursor-not-allowed`,
  'gray-outline': `bg-white border border-gray-300 text-gray-700 
           hover:bg-gray-50 hover:text-hray-700
           disabled:bg-white disabled:border-gray-200 disabled:text-gray-300 disabled:cursor-not-allowed`,
  'error-outline': `bg-white border border-error-300 text-error-700 
            hover:bg-error-700 hover:text-white
            disabled:bg-white disabled:border-error-200 disabled:text-error-300 disabled:cursor-not-allowed`,
  'primary-outline': `bg-white border border-primary-900 text-primary-900 
              hover:bg-primary-900 hover:text-white 
              disabled:bg-white disabled:border-primary-200 disabled:text-primary-300 disabled:cursor-not-allowed`,
  'accent-outline': `bg-white border border-accent-500 text-accent-500 
             hover:bg-accent-300 hover:border-accent-300 hover:text-accent-700
             disabled:bg-white disabled:border-accent-200 disabled:text-accent-200 disabled:cursor-not-allowed`,
};

const CustomLink = React.forwardRef(function (
  p: ICustomLinkProps,
  ref: React.Ref<HTMLAnchorElement>
) {
  const { children, size = 'base', ...others } = p;

  const linkSize = baseSizeMap[size];
  const variantStyle = variantMap[p.variant ?? 'primary'];

  return (
    <Link
      ref={ref}
      {...others}
      className={twMerge([
        `flex text-center items-center justify-center font-dmsans font-semibold text-gray-700 rounded-lg
         focus-visible:outline focus-visible:outline-2 focus-visible:outline-gray-200
         disabled:cursor-not-allowed transition duration-150 ease-in-out`,
        linkSize,
        variantStyle,
        p.className,
      ])}
    >
      {children}
    </Link>
  );
});

CustomLink.displayName = 'CustomLink';

export default CustomLink;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/buttons/button-base.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

export interface ButtonProps {
  onClick?: (e: React.MouseEvent<HTMLButtonElement>) => Promise<void> | void;
  className?: string;
  id?: string;
  type?: 'button' | 'submit' | 'reset';
  variant?: 'primary' | 'accent' | 'gray' | 'error';
  size?: 'sm' | 'base' | 'lg';
  additionalProps?: { [key: string]: any };
  disabled?: boolean;
  children?: React.ReactNode;
  style?: React.CSSProperties;
}

const baseSizeMap = {
  sm: 'px-2.5 py-1.5 text-xs',
  base: 'px-3.5 py-2.5 text-xs md:text-sm',
  lg: 'px-4 py-3.5 text-sm md:text-base ',
};

const variantMap = {
  primary: 'text-primary-900 hover:text-primary-950 disabled:text-primary-200',
  accent: 'text-accent-700 hover:text-accent-800 disabled:text-accent-300',
  gray: 'text-gray-700 hover:text-gray-800 disabled:text-gray-400',
  error: 'text-error-700 hover:text-error-800 disabled:text-error-300',
};

const ButtonBase = React.forwardRef(function (
  p: ButtonProps,
  ref: React.Ref<HTMLButtonElement>
) {
  const { children, type = 'button', size = 'base', ...others } = p;

  const buttonSize = baseSizeMap[size];
  const variantStyle = variantMap[p.variant ?? 'primary'];

  return (
    <button
      type={type}
      ref={ref}
      {...others}
      className={twMerge([
        `font-dmsans font-semibold text-gray-700 rounded-lg
         focus-visible:outline focus-visible:outline-2 focus-visible:outline-gray-200
         disabled:cursor-not-allowed`,
        buttonSize,
        variantStyle,
        p.className,
      ])}
    >
      {children}
    </button>
  );
});

ButtonBase.displayName = 'ButtonBase';

export default ButtonBase;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/buttons/custom-prismic-link.tsx

import { twMerge } from 'tailwind-merge';

import { PrismicNextLink, PrismicNextLinkProps } from '@prismicio/next';

const variantStyles: { [key: string]: string } = {
  'solid-black':
    'block border text-center border-black font-dmsans py-2.5 px-4 bg-black rounded-lg text-base text-white font-bold hover:bg-gray-800 hover:border-gray-800 transition duration-150 ease-in-out',
  'solid-accent':
    'block border text-center border-accent-300 font-dmsans py-2 px-4 bg-accent-200 rounded-lg text-base text-accent-700 font-semibold hover:bg-accent-300 transition duration-150 ease-in-out',
  'solid-gray':
    'block border text-center border-gray-300 font-dmsans py-2 px-4 bg-white rounded-lg text-base text-gray-700 font-semibold hover:bg-gray-100 transition duration-150 ease-in-out',

  'outline-gray':
    'block border border-gray-300 font-dmsans py-2 px-4 bg-white rounded-lg text-base text-gray-700 font-semibold hover:bg-gray-50 transition duration-150 ease-in-out',
};

const CustomPrismicLink = (p: PrismicNextLinkProps & { variant?: string }) => {
  const variantClass =
    p.variant && p.variant in variantStyles ? variantStyles[p.variant] : '';

  return (
    <PrismicNextLink {...p} className={twMerge(variantClass, p.className)}>
      {p.children}
    </PrismicNextLink>
  );
};

export default CustomPrismicLink;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/buttons/button-outline.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import ButtonBase, { type ButtonProps } from '@components/buttons/button-base';

const outlineVariantMap = {
  gray: `bg-white border border-gray-300 text-gray-700 
         hover:bg-gray-50 hover:text-hray-700
         disabled:bg-white disabled:border-gray-200 disabled:text-gray-300 disabled:cursor-not-allowed`,
  error: `bg-white border border-error-300 text-error-700 
          hover:bg-error-700 hover:text-white
          disabled:bg-white disabled:border-error-200 disabled:text-error-300 disabled:cursor-not-allowed`,
  primary: `bg-white border border-primary-900 text-primary-900 
            hover:bg-primary-900 hover:text-white 
            disabled:bg-white disabled:border-primary-200 disabled:text-primary-300 disabled:cursor-not-allowed`,
  accent: `bg-white border border-accent-500 text-accent-500 
           hover:bg-accent-300 hover:border-accent-300 hover:text-accent-700
           disabled:bg-white disabled:border-accent-200 disabled:text-accent-200 disabled:cursor-not-allowed`,
};

const ButtonOutline = React.forwardRef(function (
  p: ButtonProps,
  ref: React.Ref<HTMLButtonElement>
) {
  const { variant = 'primary', className, ...others } = p;

  const variantClassNames = outlineVariantMap[variant ?? 'primary'];

  return (
    <ButtonBase
      ref={ref}
      {...others}
      className={twMerge([
        `rounded-lg shadow-xs`,
        variantClassNames,
        className,
      ])}
    />
  );
});

ButtonOutline.displayName = 'ButtonOutline';

export default ButtonOutline;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/buttons/share-buttons/inline-share-button.tsx

'use client';

import React from 'react';
import { InlineShareButtons as ShareThisInlineButtons } from 'sharethis-reactjs';

const InlineShareButtons: React.FC = () => {
  return (
    <div className="sharethis-share-buttons">
      <ShareThisInlineButtons
        config={{
          alignment: 'center', // alignment of buttons (left, center, right)
          color: 'social', // set the color of buttons (social, white)
          enabled: true, // show/hide buttons (true, false)
          font_size: 16, // font size for the buttons
          labels: null, // button labels (cta, counts, null)
          language: 'en', // which language to use (see LANGUAGES)
          networks: ['sharethis', 'facebook'],
          padding: 10, // padding within buttons (INTEGER)
          radius: 12, // the corner radius on each button (INTEGER)
          show_total: false,
          size: 32, // the size of each button (INTEGER)
        }}
      />
    </div>
  );
};

export default InlineShareButtons;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/custom-markdown-overrides/link.tsx

import DOMPurify from 'isomorphic-dompurify';
import NextLink from 'next/link';
import React from 'react';

import { useFormModal } from '@form/hooks/use-form-modal';

interface ILinkProps {
  href: string | number | boolean | (string | number)[] | null | undefined;
  children: React.ReactNode;
}

const clean = (str: string) => {
  return str.replace(/[^0-9a-zA-Z-]/g, '');
};

const Link: React.FC<ILinkProps> = ({ href, children }) => {
  const modalContext = useFormModal();

  const handleLinkClick = (
    e: React.MouseEvent<HTMLButtonElement, MouseEvent>,
    modalId: string
  ) => {
    e.stopPropagation();
    e.preventDefault();
    modalContext?.openModal?.(clean(modalId));
  };
  if (!href || typeof href !== 'string') return null;
  const sanitizedHref = DOMPurify.sanitize(href);
  const protocal = sanitizedHref.split(':')[0];
  const resource = sanitizedHref.split(':')[1];

  if (!!modalContext && protocal === 'modal-id') {
    return (
      <button
        type="button"
        className="text-accent-700"
        onClick={(e) => handleLinkClick(e, clean(resource))}
      >
        {children}
      </button>
    );
  } else if (protocal === 'internal') {
    return (
      <NextLink className="text-accent-700" href={resource}>
        {children}
      </NextLink>
    );
  }

  return (
    <a
      href={sanitizedHref}
      className="text-accent-700"
      target="_blank"
      rel="noopener noreferrer"
    >
      {children}
    </a>
  );
};

export default Link;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/custom-markdown-overrides/blockquote.tsx

interface IBlockquoteProps {
  children: React.ReactNode;
}

const Blockquote: React.FC<IBlockquoteProps> = ({ children }) => {
  return (
    <div className="bg-white p-6 shadow-md rounded-md form-markdown leading-none">
      {children}
    </div>
  );
};

export default Blockquote;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/overlays/popover.tsx

import React from 'react';

import { Strategy } from '@floating-ui/react';
import { HelpCircle, XClose } from '@untitled-ui/icons-react';

import OverlayBackground from './overlay-background';

interface IPopoverProps {
  title: string;
  content: string;
  position: {
    x: number;
    y: number;
    strategy: Strategy;
  };
  getFloatingProps: (
    userProps?: React.HTMLProps<HTMLElement> | undefined
  ) => Record<string, unknown>;
  callback: () => void;
}

const Popover = React.forwardRef(function (
  p: IPopoverProps,
  ref: React.ForwardedRef<HTMLDivElement | null>
) {
  const style: React.CSSProperties = {
    position: p.position.strategy,
    top: p.position.y,
    left: p.position.x,
  };

  const isMobile = window.matchMedia('(max-width: 640px)').matches;

  if (isMobile) {
    style.position = 'fixed';
    style.top = '50%';
    style.left = '50%';
    style.transform = 'translate(-50%, -50%)';
    style.width = '90%';
  }
  return (
    <>
      <OverlayBackground hidden={!isMobile} />
      <div
        aria-live="assertive"
        className="w-[400px] z-50 flex items-end sm:items-start"
        ref={ref}
        {...p.getFloatingProps}
        style={style}
      >
        <div className="flex w-full flex-col items-center space-y-4 sm:items-end">
          <div className="pointer-events-auto w-full max-w-sm overflow-hidden rounded-xl bg-white shadow-lg ring-1 ring-black ring-opacity-5">
            <div className="p-4">
              <div className="flex items-start">
                <div className="flex-shrink-0">
                  <HelpCircle
                    className="text-accent-700"
                    width={20}
                    height={20}
                    viewBox="0 0 24 24"
                  />
                </div>
                <div className="ml-3 w-0 flex-1 pt-0.5">
                  <p className="text-sm font-semibold text-gray-700">
                    {p.title}
                  </p>
                  <p className="mt-1 text-sm text-gray-600">{p.content}</p>
                </div>
                <div className="ml-4 flex flex-shrink-0">
                  <button
                    type="button"
                    className="inline-flex rounded-md bg-white text-gray-400 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-300 focus:ring-offset-2"
                    onClick={p.callback}
                  >
                    <span className="sr-only">Close</span>
                    <XClose
                      className="text-gray-500 hover:text-gray-700"
                      width={20}
                      height={20}
                      viewBox="0 0 24 24"
                    />
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </>
  );
});

Popover.displayName = 'Popover';

export default Popover;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/overlays/overlay-background.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

interface IOverlayBackgroundProps
  extends React.DetailedHTMLProps<
    React.HTMLAttributes<HTMLDivElement>,
    HTMLDivElement
  > {
  hidden?: boolean;
}

const OverlayBackground: React.FC<IOverlayBackgroundProps> = ({
  hidden,
  className,
  ...others
}) => {
  return (
    <div
      className={twMerge([
        `fixed left-0 top-0 z-50 w-full h-full bg-gray-500 opacity-80`,
        hidden && `hidden`,
        className,
      ])}
      {...others}
    />
  );
};

export default OverlayBackground;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/overlays/modal.tsx

import { Fragment } from 'react';

import { Dialog, Transition } from '@headlessui/react';
import { XClose } from '@untitled-ui/icons-react';

import MarkdownElement from '../markdown-element';

interface IModalProps {
  show: boolean;
  title?: string;
  content?: string;
  contentRenderer?: () => React.ReactNode;
  onClose: () => void;
}

const Modal: React.FC<IModalProps> = (p) => {
  return (
    <Transition.Root show={p.show} as={Fragment}>
      <Dialog as="div" className="relative z-50" onClose={p.onClose}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity" />
        </Transition.Child>

        <div className="fixed inset-0 z-50 w-screen overflow-y-auto">
          <div className="flex min-h-full items-start justify-center p-4 text-center sm:items-center sm:p-0">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
              enterTo="opacity-100 translate-y-0 sm:scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 translate-y-0 sm:scale-100"
              leaveTo="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
            >
              <Dialog.Panel className="relative w-screen transform overflow-hidden rounded-lg bg-white px-4 pb-4 pt-5 text-left shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-lg sm:p-6">
                <div className="absolute right-0 top-0 pr-4 pt-4 block">
                  <button
                    type="button"
                    className="rounded-md bg-white text-gray-400 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-300 focus:ring-offset-2"
                    onClick={p.onClose}
                  >
                    <span className="sr-only">Close</span>
                    <XClose
                      className="text-gray-500 hover:text-gray-700 h-6 w-6"
                      aria-hidden="true"
                      viewBox="0 0 24 24"
                    />
                  </button>
                </div>
                <div className="mt-3 sm:ml-4 sm:mt-0 text-left">
                  <Dialog.Title
                    as="div"
                    className="text-lg font-semibold leading-6 text-gray-700"
                  >
                    {p.title}
                  </Dialog.Title>
                  <div className="mt-3 w-full">
                    {p.contentRenderer ? (
                      p.contentRenderer()
                    ) : (
                      <div className="text-sm text-gray-600">
                        <MarkdownElement>{p.content}</MarkdownElement>
                      </div>
                    )}
                  </div>
                </div>
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition.Root>
  );
};

export default Modal;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/overlays/flyout-menu/menu-item.tsx

import React from 'react';

import type { IMenuItem } from '@/app/shared/components/overlays/flyout-menu/flyout-menu';
import * as Icons from '@untitled-ui/icons-react';

const transformIconName = (iconName?: string | null) => {
  if (!iconName) return undefined;

  return iconName
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
};

const MenuItem: React.FC<
  IMenuItem & {
    onChange: (
      e: React.MouseEvent<HTMLButtonElement, MouseEvent>,
      item: IMenuItem
    ) => void;
    close: (
      focusableElement?:
        | HTMLElement
        | React.MutableRefObject<HTMLElement | null>
        | undefined
    ) => void;
  }
> = ({ onChange, close, ...item }) => {
  const iconName = transformIconName(item.icon);

  const iconKey =
    iconName && iconName in Icons
      ? (iconName as keyof typeof Icons)
      : undefined;

  const Icon = iconKey && Icons[iconKey];

  const handleClick = (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {
    if (item.onClick) {
      item.onClick();
    } else {
      onChange(e, item);
    }
    close();
  };

  return (
    <div
      key={item.name}
      className="font-dmsans group relative flex gap-x-4 rounded-lg p-3 hover:bg-gray-50"
    >
      {Icon && (
        <div className="mt-1 flex h-10 w-10 flex-none items-center justify-center rounded-lg bg-white shadow-xs border border-gray-200 group-hover:bg-white">
          <Icon
            width="20px"
            height="20px"
            viewBox="0 0 24 24"
            className="text-gray-400 group-hover:text-accent-400"
          />
        </div>
      )}
      <div>
        {item.href ? (
          <a href={item.href} className="font-semibold text-gray-900">
            {item.name}
            <span className="absolute inset-0" />
          </a>
        ) : (
          <button
            type="button"
            onClick={handleClick}
            className="font-semibold text-gray-900"
          >
            {item.name}
            <span className="absolute inset-0" />
          </button>
        )}
        <p className="text-gray-600">{item.description}</p>
      </div>
    </div>
  );
};

export default MenuItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/overlays/flyout-menu/flyout-menu.tsx

import React, { Fragment } from 'react';
import { twMerge } from 'tailwind-merge';

import MenuItem from '@components/overlays/flyout-menu/menu-item';
import { Popover, Transition } from '@headlessui/react';
import { ChevronDown } from '@untitled-ui/icons-react';

export interface IMenuItem {
  name: string;
  description?: string | null;
  href?: string;
  onClick?: () => void;
  icon?: string | null;
  id?: string;
}

interface IFlyoutMenuProps {
  id?: string;
  items: IMenuItem[];
  dropdownLabel?: string; // for uncontrolled. if controlled, use value

  value?: string;
  onChange?: (item: IMenuItem) => void;
  selectClassName?: string;
  panelClassName?: string;
}

const FlyoutMenu: React.FC<IFlyoutMenuProps> = (p) => {
  const [selected, setSelected] = React.useState(p.value ?? p.dropdownLabel);

  React.useEffect(() => {
    if (p.value) {
      setSelected(p.value);
    }
  }, [p.value]);

  const handleOnChange = (
    e: React.MouseEvent<HTMLButtonElement, MouseEvent>,
    item: IMenuItem
  ) => {
    e.preventDefault();
    setSelected(item.name);
    p.onChange?.(item);
  };

  return p.items ? (
    <Popover className="relative mx-3">
      <Popover.Button
        id={p.id}
        type="button"
        className={twMerge(
          'inline-flex items-center bg-white py-2.5 px-3.5 rounded-lg w-full justify-between max-w-[320px] gap-x-1 text-sm font-semibold leading-6 text-gray-900',
          p.selectClassName
        )}
      >
        <span>{selected}</span>
        <ChevronDown
          className="text-gray-700"
          aria-hidden="true"
          height="20px"
          width="20px"
          viewBox="0 0 24 24"
        />
      </Popover.Button>

      <Transition
        as={Fragment}
        enter="transition ease-out duration-200"
        enterFrom="opacity-0 translate-y-1"
        enterTo="opacity-100 translate-y-0"
        leave="transition ease-in duration-150"
        leaveFrom="opacity-100 translate-y-0"
        leaveTo="opacity-0 translate-y-1"
      >
        <Popover.Panel
          className={twMerge(
            'absolute left-1/2 z-10 mt-9 flex w-screen max-w-max -translate-x-1/2 px-4',
            p.panelClassName
          )}
        >
          {({ close }) => (
            <div className="w-screen max-w-md flex-auto overflow-hidden rounded-3xl bg-white text-sm leading-6 shadow-lg ring-1 ring-gray-900/5">
              <div className="p-8">
                {p.items.map((item) => (
                  <MenuItem
                    key={item.name}
                    {...item}
                    onChange={handleOnChange}
                    close={close}
                  />
                ))}
              </div>
            </div>
          )}
        </Popover.Panel>
      </Transition>
    </Popover>
  ) : null;
};

export default FlyoutMenu;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/overlays/fixed-info-popover/fixed-info-popover.tsx

'use client';

import { useSearchParams } from 'next/navigation';
import React from 'react';

import { ExtendedUser } from '@/app/shared/types';
import CustomPrismicLink from '@components/buttons/custom-prismic-link';
import DependentLinkDropdown from '@components/dropdowns/dependent-dropdown';
import {
  FilledContentRelationshipField,
  ImageField,
  KeyTextField,
  LinkField,
  LinkResolverFunction,
  RichTextField,
  SelectField,
  isFilled,
} from '@prismicio/client';
import { PrismicNextImage } from '@prismicio/next';
import { JSXMapSerializer, PrismicRichText } from '@prismicio/react';

interface FixedInfoPopoverProps {
  user?: ExtendedUser;
  mediaType?: string;
  image?: ImageField;
  videoLink?: KeyTextField;
  title: KeyTextField;
  content: RichTextField;
  primaryCtaLink: LinkField;
  primaryCtaType?: SelectField<'Button' | 'Dependent Dropdown'>;
  primaryCtaText: KeyTextField;
  primaryCtaStyle?: SelectField;
  secondaryCtaLink?: LinkField;
  secondaryCtaType?: SelectField<'Button' | 'Dependent Dropdown'>;
  secondaryCtaText?: KeyTextField;
  secondaryCtaStyle?: SelectField;
  backgroundImage?: ImageField;
}

const FixedInfoPopover: React.FC<FixedInfoPopoverProps> = (p) => {
  const richTextComponents: JSXMapSerializer = {
    label: ({ node }) => {
      if (node.data.label === 'userFirstName') {
        const labelText = ((node as any)?.text ?? '').replace(
          '{{ userFirstName }}',
          p.user?.firstName ?? ''
        );
        return <>{labelText}</>;
      }
    },
  };

  const showVideo = p.mediaType === 'video' && isFilled.keyText(p.videoLink);

  return (
    <div>
      <div className="fixed top-0 left-0 z-1 w-screen h-screen bg-custom-gradient backdrop-blur-md overflow-auto flex justify-center items-start lg:items-center lg:pt-[0px] pt-[140px]">
        <div className="bg-white mb-40 p-4 mx-6 w-full sm:w-[500px] sm:p-6 sm:mb-10 shadow-lg flex flex-col items-center overflow-visible h-auto rounded-lg lg:ml-[280px]">
          {showVideo ? (
            <div
              className="relative overflow-hidden w-full aspect-video rounded-lg border border-white border-inset mb-3 sm:mb-6"
              style={{ paddingBottom: 'calc(56.25% - 1px)' }}
            >
              <iframe
                loading="lazy"
                className="absolute top-0 left-0 w-full h-full"
                src={`${p.videoLink}`}
                allow="accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture; fullscreen"
                allowFullScreen
                title="Cortina Getting Started"
                style={{
                  position: 'absolute',
                  width: '100%',
                  height: '100%',
                  top: 0,
                  left: 0,
                  bottom: 0,
                  right: 0,
                  border: 'none',
                  padding: 0,
                  margin: 0,
                  overflow: 'hidden',
                }}
              />
            </div>
          ) : (
            <div className="bg-[#e6e6e6] w-full rounded-lg mb-3 sm:mb-6">
              <PrismicNextImage
                field={p.image}
                height={208}
                alt=""
                className="w-full object-cover rounded-lg"
              />
            </div>
          )}
          <div className="flex flex-col items-center px-2">
            <h2 className="font-dmserif font-medium text-gray-900 text-center text-2xl sm:text-[32px]">
              {p.title}
            </h2>
            <div className="font-dmsans text-base text-gray-700 mt-3 sm:mt-6">
              <PrismicRichText
                field={p.content}
                components={richTextComponents}
              />
            </div>
            <div className="mt-6 flex flex-col sm:flex-row w-full gap-4">
              <CtaLink
                user={p.user}
                link={p.primaryCtaLink}
                text={p.primaryCtaText}
                style={p.primaryCtaStyle}
                ctaType={p.primaryCtaType}
              />
              <CtaLink
                user={p.user}
                link={p.secondaryCtaLink}
                text={p.secondaryCtaText}
                style={p.secondaryCtaStyle}
                ctaType={p.secondaryCtaType}
              />
            </div>
          </div>
        </div>
      </div>

      {isFilled.image(p.backgroundImage) && (
        <div className="px-14 py-20">
          <PrismicNextImage
            field={p.backgroundImage}
            width={1160}
            height={583}
            alt=""
            className="lg:block hidden"
          />
        </div>
      )}
    </div>
  );
};

const CtaLink = (p: {
  user?: ExtendedUser;
  link?: LinkField;
  text?: KeyTextField;
  style?: SelectField;
  ctaType?: SelectField<'Button' | 'Dependent Dropdown'>;
}) => {
  const linkIsFilled = isFilled.link(p.link);

  const searchParams = useSearchParams();

  const queryParamResolver: LinkResolverFunction = (
    linkToDocumentField: FilledContentRelationshipField<string, string, unknown>
  ) => {
    if (!linkToDocumentField.url) return null;

    const prismicUrl = new URL(
      linkToDocumentField.url,
      process.env.NEXT_PUBLIC_BASE_URL
    );

    searchParams.forEach((value, key) =>
      prismicUrl.searchParams.set(key, value)
    );

    return `${prismicUrl.pathname}${prismicUrl.search}`;
  };

  if (!linkIsFilled) {
    return null;
  }

  if (p.link && p.ctaType === 'Dependent Dropdown') {
    return (
      <DependentLinkDropdown
        user={p.user}
        link={p.link}
        dropdownText={p.text}
        linkResolver={queryParamResolver}
      />
    );
  }

  return (
    <CustomPrismicLink
      field={p.link}
      variant={p.style ? p.style : 'outline-gray'}
      className="py-2 w-full text-center"
      linkResolver={queryParamResolver}
    >
      {p.text}
    </CustomPrismicLink>
  );
};

export default FixedInfoPopover;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/layout/container.tsx

import { HTMLProps } from 'react';
import { twMerge } from 'tailwind-merge';

export function Container({ className, ...props }: HTMLProps<HTMLDivElement>) {
  return <div className={twMerge('mx-auto max-w-8xl', className)} {...props} />;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/datadog-init/datadog-init.tsx

'use client';

import { datadogRum } from '@datadog/browser-rum';

datadogRum.init({
  applicationId: process.env.NEXT_PUBLIC_DATADOG_APPLICTION_ID ?? '',
  clientToken: process.env.NEXT_PUBLIC_DATADOG_CLIENT_TOKEN ?? '',
  site: 'datadoghq.com',
  service: process.env.NEXT_PUBLIC_APPLICATION_NAME ?? 'cortina-app',
  env: process.env.NEXT_PUBLIC_ENVIRONMENT_NAME ?? 'development',
  version: '1.0.0',
  sessionSampleRate: 100,
  sessionReplaySampleRate: 20,
  startSessionReplayRecordingManually: true,
  trackUserInteractions: true,
  trackResources: true,
  trackLongTasks: true,
  defaultPrivacyLevel: 'mask-user-input',
});

export default function DatadogInit() {
  // Render nothing - this component is only included so that the init code
  // above will run client-side
  return null;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/datadog-init/datadog-session-player.tsx

'use client';

import { datadogRum } from '@datadog/browser-rum';

datadogRum.startSessionReplayRecording();

export default function DatadogSessionPlayer() {
  // Render nothing - this component is only included so that the code
  // above will run client-side
  return null;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/family-selector/family-selector.tsx

'use client';

import { usePathname, useRouter, useSearchParams } from 'next/navigation';
import React, { Fragment } from 'react';
import { twMerge } from 'tailwind-merge';

import { Listbox, Transition } from '@headlessui/react';
import {
  CheckIcon,
  ChevronDownIcon,
  ChevronUpIcon,
} from '@heroicons/react/20/solid';
import { User } from '@prisma/client';

import { UserInclude } from '../../types';

interface IFamilySelectorProps {
  user?: UserInclude;
  className?: string;
}

const FamilySelector: React.FC<IFamilySelectorProps> = ({
  user,
  className,
}) => {
  const memberOptions = React.useMemo(
    () => (user ? [user, ...(user?.dependents ?? [])] : []),
    [user]
  );

  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  const [selectedFamilyMember, setSelectedFamilyMember] =
    React.useState<User | null>(memberOptions[0]);

  const handleFamilyMemberSelection = (newFamilyMember: User) => {
    setSelectedFamilyMember(newFamilyMember);
    const newSearchParams = new URLSearchParams(searchParams);
    newSearchParams.set('mid', newFamilyMember.id);
    router.replace(`${pathname}?${newSearchParams}`);
  };

  React.useEffect(() => {
    const mid = searchParams.get('mid');
    if (mid) {
      const selected = memberOptions.find((m) => m.id === mid);
      if (selected) {
        setSelectedFamilyMember(selected);
      }
    }
  }, [searchParams, memberOptions]);

  const isPrimary = selectedFamilyMember?.id === user?.id;

  return (
    <div className="flex flex-col min-w-[280px]">
      <Listbox
        value={selectedFamilyMember}
        onChange={handleFamilyMemberSelection}
        defaultValue={memberOptions[0]}
      >
        {({ open }) => (
          <>
            <Listbox.Label className="mb-1 whitespace-nowrap font-dmsans font-medium text-sm text-gray-700">
              Select Family Member
            </Listbox.Label>
            <div className="relative w-full flex">
              <Listbox.Button
                className={twMerge(
                  'relative w-full cursor-default text-left rounded-md border-0 h-10 focus:shadow-drop bg-white py-1.5 pl-3 pr-10 font-medium text-gray-900 shadow-sm ring-1 ring-gray-300 focus:ring-1 focus:ring-accent-300 sm:text-sm sm:leading-6',
                  className
                )}
              >
                <span className="inline-flex w-full truncate items-center gap-2">
                  <span className="truncate font-dmsans text-gray-900">
                    {`${selectedFamilyMember?.firstName} ${selectedFamilyMember?.lastName}`}
                  </span>
                  {isPrimary && (
                    <span className="bg-gray-50 border border-gray-200 rounded-xl py-0.5 px-2.5 text-xs font-medium text-gray-700">
                      Primary
                    </span>
                  )}
                </span>
                <span className="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-2">
                  {open ? (
                    <ChevronUpIcon
                      className="h-5 w-5 text-gray-400"
                      aria-hidden="true"
                    />
                  ) : (
                    <ChevronDownIcon
                      className="h-5 w-5 text-gray-400"
                      aria-hidden="true"
                    />
                  )}
                </span>
              </Listbox.Button>

              <Transition
                show={open}
                as={Fragment}
                leave="transition ease-in duration-100"
                leaveFrom="opacity-100"
                leaveTo="opacity-0"
              >
                <Listbox.Options className="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-gray-300 ring-opacity-5 focus:outline-none sm:text-sm">
                  {memberOptions.map((member) => (
                    <Listbox.Option
                      key={member.id}
                      className={({ selected, active }) =>
                        twMerge(
                          selected || active ? 'bg-gray-50' : 'bg-white',
                          'relative cursor-default select-none py-2 pl-3 pr-9 text-gray-900'
                        )
                      }
                      value={member}
                    >
                      {({ selected }) => (
                        <>
                          <span className="font-dmsans inline-flex w-full truncate items-center gap-2">
                            <span
                              className={twMerge(
                                selected ? 'font-semibold' : 'font-normal',
                                'truncate'
                              )}
                            >
                              {`${member?.firstName} ${member?.lastName}`}
                            </span>
                            {member.id === user?.id && (
                              <span className="bg-gray-50 border border-gray-200 rounded-xl py-0.5 px-2.5 text-xs font-medium text-gray-700">
                                Primary
                              </span>
                            )}
                          </span>

                          {selected && (
                            <span
                              className={twMerge(
                                selected ? 'text-accent-400' : 'hidden',
                                'absolute inset-y-0 right-0 flex items-center pr-4'
                              )}
                            >
                              <CheckIcon
                                className="h-5 w-5"
                                aria-hidden="true"
                              />
                            </span>
                          )}
                        </>
                      )}
                    </Listbox.Option>
                  ))}
                </Listbox.Options>
              </Transition>
            </div>
          </>
        )}
      </Listbox>
    </div>
  );
};

export default FamilySelector;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/status-badge/status-badge.tsx

'use client';

import React from 'react';

import { IFamilyStatsResponse } from '@/app/shared/types';
import { useQuery } from '@tanstack/react-query';

interface IStatusBadgeProps {
  dataKey: string;
}

const getFamilyStats = async () => {
  const response = await fetch(`/api/user/family-stats`);
  const stats = (await response.json()) as IFamilyStatsResponse;
  return stats.totalNotifications;
};

const dataKeyToFetchCallMap: { [key: string]: () => Promise<number> } = {
  notifications: getFamilyStats,
};

const StatusBadgeComponent: React.FC<
  IStatusBadgeProps & { fetchCall: () => Promise<number> }
> = ({ dataKey, fetchCall }) => {
  const { data } = useQuery([dataKey], () => fetchCall(), {
    refetchOnWindowFocus: false,
    refetchInterval: 300000,
    cacheTime: 300000,
    staleTime: 300000,
  });

  return data && data > 0 ? (
    <span className="ml-auto items-center rounded-full bg-accent-50 px-2.5 py-1 text-xs font-bold text-accent-500 ring-1 ring-inset ring-accent-200">
      {data}
    </span>
  ) : null;
};

const StatusBadge: React.FC<IStatusBadgeProps> = ({ dataKey }) => {
  if (!(dataKey in dataKeyToFetchCallMap)) return null;

  const fetchCall = dataKeyToFetchCallMap[dataKey];

  return <StatusBadgeComponent dataKey={dataKey} fetchCall={fetchCall} />;
};

export default StatusBadge;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/navigation/useStyles.tsx

import get from 'lodash.get';
import { NavigationDocument } from 'prismicio-types';
import { tss } from 'tss-react';

/**
 * Dynamic Styles for Navigation
 */
export const useStyles = tss
  .withParams<{ nav: NavigationDocument }>()
  .create(({ nav }) => ({
    navButton: {
      backgroundColor: get(nav, 'data.button_color', 'transparent'),
      color: get(nav, 'data.button_text_color', 'black'),
      '&:hover': {
        backgroundColor: get(nav, 'data.button_hover_color', 'transparent'),
      },
    },
    navLink: {
      color: get(nav, 'data.link_color', 'black'),
      '&:hover': {
        color: get(nav, 'data.link_hover_color', 'black'),
      },
    },
    navPopover: {
      backgroundColor: get(nav, 'data.popover_color', 'white'),
    },
    navPopoverLink: {
      color: get(nav, 'data.popover_link_color', 'black'),
      '&:hover': {
        backgroundColor: get(nav, 'data.popover_hover_color', 'transparent'),
        color: get(nav, 'data.popover_link_hover_color', 'black'),
      },
    },
    mobileNavButton: {
      backgroundColor: get(nav, 'data.mobile_button_color', 'transparent'),
      color: get(nav, 'data.mobile_button_text_color', 'black'),
      '&:hover': {
        backgroundColor: get(
          nav,
          'data.mobile_button_active_color',
          'transparent'
        ),
      },
    },
  }));


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/navigation/navigation.tsx

'use client';

import { NavigationDocument } from 'prismicio-types';
import { useState } from 'react';
import { twMerge } from 'tailwind-merge';

import { userCartReturn } from '@/utils/ecommerce/cartUtils';
import PrismicNextLink from '@components/buttons/custom-prismic-link';
import { useStyles } from '@components/navigation/useStyles';
import { Dialog } from '@headlessui/react';
import { Bars3Icon, XMarkIcon } from '@heroicons/react/24/outline';
import { useHasScrolled } from '@hooks/useHasScrolled';
import { PrismicNextImage } from '@prismicio/next';
import MobileNavigationItem from '@slices/NavigationItem/variants/mobile-navigation-item';
import NavigationItem from '@slices/NavigationItem/variants/navigation-item';

import GlobalBanner from '../banner/global-banner';
import ClientCartButton from '../cart/cart-button/client-cart-button';

const Navigation: React.FC<{
  initialNavigation: NavigationDocument;
  scrollNavigation: NavigationDocument;
  cart?: userCartReturn;
}> = ({ initialNavigation, scrollNavigation, cart }) => {
  const hasScrolled = useHasScrolled(20, 'scroll-window');
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

  const navigation = hasScrolled ? scrollNavigation : initialNavigation;

  const { classes } = useStyles({ nav: navigation });

  const leftSideNavigation = navigation.data.slices.filter(
    (item) =>
      item.variation !== 'accountNavigationItem' &&
      item.primary.header_position === 'Left'
  );
  const rightSideNavigation = navigation.data.slices.filter(
    (item) =>
      item.variation !== 'accountNavigationItem' &&
      item.primary.header_position === 'Right'
  );

  return (
    <>
      <div className="w-screen max-w-full">
        <GlobalBanner />
      </div>
      <header
        className="nav-bar -mb-[72px] min-h-[72px] lg:-mb-[88px] lg:min-h-[88px] sticky w-full top-0 z-10 transition-colors duration-300 ease-in"
        style={{
          backgroundColor: navigation.data.background_color ?? 'transparent',
        }}
      >
        <nav
          className="mx-auto flex max-w-8xl items-center justify-between p-6 lg:px-8"
          aria-label="Global"
        >
          <div className="flex items-center gap-x-12">
            {/* Mobile - Open menu button */}
            <div className="flex lg:hidden">
              <button
                type="button"
                className={twMerge(
                  '-m-2.5 inline-flex items-center justify-center rounded-sm p-2.5',
                  classes.mobileNavButton
                )}
                onClick={() => setMobileMenuOpen(true)}
              >
                <span className="sr-only">Open main menu</span>
                <Bars3Icon className="h-6 w-6" aria-hidden="true" />
              </button>
            </div>

            {/* Cortina Logo */}
            <PrismicNextLink
              href="/"
              className="-m-1.5 mr-auto rounded-lg p-1.5 focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-gray-200"
            >
              <span className="sr-only">Cortina</span>
              <PrismicNextImage
                field={navigation.data.logo}
                className="h-6 w-auto"
              />
            </PrismicNextLink>

            {/* Desktop - Left side of menu links */}
            <div className="hidden lg:flex lg:gap-x-5 xl:gap-x-10 lg:items-center">
              {leftSideNavigation.map((item) => (
                <NavigationItem
                  key={item.id}
                  item={item}
                  navigation={navigation}
                />
              ))}
            </div>
          </div>

          {/* Desktop - Right side of menu links */}
          <div className="hidden lg:flex lg:items-center lg:gap-x-6">
            {rightSideNavigation.map((item) => (
              <NavigationItem
                key={item.id}
                item={item}
                navigation={navigation}
              />
            ))}
            {cart && (
              <div className="-ml-3">
                <ClientCartButton cart={cart} />
              </div>
            )}
          </div>
        </nav>

        {/* Mobile menu */}
        <Dialog
          as="div"
          className="lg:hidden"
          open={mobileMenuOpen}
          onClose={setMobileMenuOpen}
        >
          <div className="fixed inset-0" />

          <Dialog.Panel
            className="fixed inset-y-0 left-0 w-full overflow-y-auto px-8 py-6 sm:max-w-sm sm:ring-1 sm:ring-gray-900/10 z-10"
            style={{
              backgroundColor: scrollNavigation.data.popover_color ?? 'white',
            }}
          >
            <div className="flex items-center justify-between">
              <PrismicNextLink href="/" className="-m-1.5 p-1.5">
                <span className="sr-only">Cortina</span>
                <PrismicNextImage
                  field={scrollNavigation.data.logo}
                  className="h-8 w-auto"
                />
              </PrismicNextLink>
              <button
                type="button"
                className="-m-2.5 rounded-md p-2.5 text-gray-700"
                onClick={() => setMobileMenuOpen(false)}
              >
                <span className="sr-only">Close menu</span>
                <XMarkIcon className="h-6 w-6" aria-hidden="true" />
              </button>
            </div>
            <div className="mt-6 space-y-2">
              {navigation.data.slices.map((item) => (
                <MobileNavigationItem
                  key={item.id}
                  item={item}
                  navigation={scrollNavigation}
                />
              ))}
            </div>
          </Dialog.Panel>
        </Dialog>
      </header>
    </>
  );
};

export default Navigation;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/navigation/account-navigation/account-menu-item.tsx

'use client';

import { NavigationBarSlice } from 'prismicio-types';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import ConciergeIcon from '@components/concierge-icon';
import StatusBadge from '@components/status-badge/status-badge';
import { PrismicNextLink } from '@prismicio/next';
import {
  Bell01,
  Droplets03,
  HomeLine,
  LifeBuoy01,
  LineChartUp02,
  LogOut01,
  MedicalCircle,
  MessageTextSquare02,
  Package,
  Settings01,
  User03,
  Users02,
} from '@untitled-ui/icons-react';

const iconMap = {
  home: HomeLine,
  message: MessageTextSquare02,
  bell: Bell01,
  'line-chart-up': LineChartUp02,
  'user-group': Users02,
  settings: Settings01,
  support: LifeBuoy01,
  logout: LogOut01,
  'concierge-c': ConciergeIcon,
  'medical-circle': MedicalCircle,
  droplets: Droplets03,
  user: User03,
  package: Package,
};

const AccountMenuItem: React.FC<NavigationBarSlice & { current: string }> = ({
  current,
  ...item
}) => {
  if (item.variation !== 'accountNavigationItem') {
    return null;
  }

  const Icon = iconMap?.[item.primary?.icon ?? 'home'] ?? HomeLine;
  const isCurrent = (item.primary.link as { url?: string })?.url === current;

  return (
    <li>
      <PrismicNextLink
        field={item.primary.link}
        className={twMerge(
          isCurrent
            ? 'bg-accent-50 text-gray-900 font-medium'
            : 'text-gray-700 hover:text-gray-900 hover:font-medium hover:bg-gray-50 font-normal',
          'group flex items-center gap-x-3 rounded-md p-2 text-sm leading-6'
        )}
      >
        <Icon
          className={twMerge(
            isCurrent
              ? 'text-accent-500'
              : 'text-gray-500 group-hover:text-accent-500',
            'h-6 w-6 shrink-0'
          )}
          aria-hidden="true"
        />
        {item.primary.name}
        {item.primary.status_badge && (
          <StatusBadge dataKey={item.primary.status_badge} />
        )}
      </PrismicNextLink>
      {item.primary.has_divider_below && (
        <div className="m-2 h-px bg-gray-200" />
      )}
    </li>
  );
};

export default AccountMenuItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/navigation/account-navigation/account-navigation.tsx

'use client';

import { usePathname } from 'next/navigation';
import { AccountNavigationDocument } from 'prismicio-types';
import React, { Fragment } from 'react';

import { UserInclude } from '@/app/shared/types';
import '@/styles/globals.css';
import { Dialog, Transition } from '@headlessui/react';
import { Bars3Icon, XMarkIcon } from '@heroicons/react/24/outline';

import GlobalBanner from '../../banner/global-banner';
import UserContextSwitch from '../user-context-switch/user-context-switch';
import AccountMenu from './account-menu';

interface IAccountMenu extends AccountNavigationDocument {
  user: UserInclude;
  userAvatarS3Url?: string;
  children: React.ReactNode;
}

const AccountNavigation: React.FC<IAccountMenu> = (p) => {
  const { data, user } = p;
  const pathname = usePathname();
  const [sidebarOpen, setSidebarOpen] = React.useState(false);

  const mainMenu = data.slices.filter(
    (slice) =>
      slice.variation === 'accountNavigationItem' &&
      slice.primary.position === 'Main'
  );
  const secondaryMenu = data.slices.filter(
    (slice) =>
      slice.variation === 'accountNavigationItem' &&
      slice.primary.position === 'Secondary'
  );

  React.useEffect(() => {
    setSidebarOpen(false);
  }, [pathname]);

  return (
    <>
      <div className="z-10 lg:pl-72 w-screen max-w-full">
        <GlobalBanner />
      </div>
      <div className="account-folder-layout flex flex-col flex-1">
        <Transition.Root show={sidebarOpen} as={Fragment}>
          <Dialog
            as="div"
            className="relative z-50 lg:hidden"
            onClose={setSidebarOpen}
          >
            <Transition.Child
              as={Fragment}
              enter="transition-opacity ease-linear duration-300"
              enterFrom="opacity-0"
              enterTo="opacity-100"
              leave="transition-opacity ease-linear duration-300"
              leaveFrom="opacity-100"
              leaveTo="opacity-0"
            >
              <div className="fixed inset-0 bg-gray-900/80" />
            </Transition.Child>

            <div className="fixed inset-0 flex">
              <Transition.Child
                as={Fragment}
                enter="transition ease-in-out duration-300 transform"
                enterFrom="-translate-x-full"
                enterTo="translate-x-0"
                leave="transition ease-in-out duration-300 transform"
                leaveFrom="translate-x-0"
                leaveTo="-translate-x-full"
              >
                <Dialog.Panel className="relative mr-16 flex w-full max-w-xs flex-1">
                  <Transition.Child
                    as={Fragment}
                    enter="ease-in-out duration-300"
                    enterFrom="opacity-0"
                    enterTo="opacity-100"
                    leave="ease-in-out duration-300"
                    leaveFrom="opacity-100"
                    leaveTo="opacity-0"
                  >
                    <div className="absolute left-full top-0 flex w-16 justify-center pt-5">
                      <button
                        type="button"
                        className="-m-2.5 p-2.5"
                        onClick={() => setSidebarOpen(false)}
                      >
                        <span className="sr-only">Close sidebar</span>
                        <XMarkIcon
                          className="h-6 w-6 text-white"
                          aria-hidden="true"
                        />
                      </button>
                    </div>
                  </Transition.Child>
                  {/* Sidebar component, swap this element with another sidebar if you like */}
                  <div className="flex grow flex-col gap-y-5 overflow-y-auto bg-white px-6 pb-2">
                    <AccountMenu
                      mainMenu={mainMenu}
                      secondaryMenu={secondaryMenu}
                      pathname={pathname}
                      user={user}
                      userAvatarS3Url={p.userAvatarS3Url}
                      content={data}
                    />
                  </div>
                </Dialog.Panel>
              </Transition.Child>
            </div>
          </Dialog>
        </Transition.Root>

        {/* Static sidebar for desktop */}
        <div className="hidden lg:fixed lg:inset-y-0 lg:z-50 lg:flex lg:w-72 lg:flex-col">
          {/* Sidebar component, swap this element with another sidebar if you like */}
          <div className="flex grow flex-col gap-y-5 overflow-y-auto border-r border-gray-200 bg-white px-6">
            <AccountMenu
              mainMenu={mainMenu}
              secondaryMenu={secondaryMenu}
              pathname={pathname}
              user={user}
              userAvatarS3Url={p.userAvatarS3Url}
              content={data}
            />
          </div>
        </div>

        <div className="sticky top-0 z-40 flex items-center justify-between gap-x-6 bg-white px-4 py-4 shadow-sm sm:px-6 lg:hidden">
          <button
            type="button"
            className="-m-2.5 p-2.5 text-gray-700 lg:hidden"
            onClick={() => setSidebarOpen(true)}
          >
            <span className="sr-only">Open sidebar</span>
            <Bars3Icon className="h-6 w-6" aria-hidden="true" />
          </button>
          <div className="flex items-center gap-3 w-full justify-end">
            <div className="w-full max-w-[280px]">
              <UserContextSwitch
                addLink={data.add_family_link}
                addText={data.add_family_link_text}
                navLinks={data.dropdown_links}
                logoutText={data.dropdown_logout_text}
                accountSwitchDividerText={data.dropdown_divider_text}
              />
            </div>
          </div>
        </div>
        {/* </div> */}

        <main className="account-layout lg:pl-72 flex flex-col flex-1">
          {p.children}
        </main>
      </div>
    </>
  );
};

export default AccountNavigation;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/navigation/account-navigation/account-menu.tsx

'use client';

import { signOut } from 'next-auth/react';
import {
  AccountNavigationDocumentData,
  NavigationBarSlice,
  Simplify,
} from 'prismicio-types';
import React from 'react';

import { getSignoutUrl } from '@/app/(features)/(authentication)/signout/getSignoutUrl';
import { UserInclude } from '@/app/shared/types';
import { PrismicNextImage } from '@prismicio/next';
import { PopupButton } from '@typeform/embed-react';
import { HelpCircle, LogOut01 } from '@untitled-ui/icons-react';
import { getFullName } from '@utils/get-full-name';

import ButtonBase from '../../buttons/button-base';
import CustomPrismicLink from '../../buttons/custom-prismic-link';
import UserAvatar from '../../user-avatar/user-avatar';
import UserContextSwitch from '../user-context-switch/user-context-switch';
import AccountMenuItem from './account-menu-item';

interface IAccountMenu {
  mainMenu: NavigationBarSlice[];
  secondaryMenu: NavigationBarSlice[];
  pathname: string;
  user: UserInclude;
  userAvatarS3Url?: string;
  content: Simplify<AccountNavigationDocumentData>;
}

const AccountMenu: React.FC<IAccountMenu> = ({
  mainMenu,
  secondaryMenu,
  pathname,
  user,
  userAvatarS3Url,
  content,
}) => {
  return (
    <>
      <div className="flex h-16 shrink-0 items-center">
        <PrismicNextImage
          className="h-8 w-auto"
          field={content.logo}
          width="256"
          height="256"
        />
      </div>
      <nav className="flex flex-1 flex-col">
        <ul role="list" className="flex flex-1 flex-col gap-y-6">
          <li>
            <ul role="list" className="-mx-2 space-y-1">
              <li className="mb-4 mx-3">
                <UserContextSwitch
                  addLink={content.add_family_link}
                  addText={content.add_family_link_text}
                  navLinks={content.dropdown_links}
                  logoutText={content.dropdown_logout_text}
                  accountSwitchDividerText={content.dropdown_divider_text}
                />
              </li>
              <div className="m-2 h-px bg-gray-200" />
              {mainMenu.map((item, i) => (
                <AccountMenuItem
                  key={`${item.id}-${i}`}
                  {...item}
                  current={pathname}
                />
              ))}
            </ul>
          </li>
          <div className="mt-auto">
            <PopupButton
              id={content.survey_form_id}
              hidden={{
                email: user.email,
              }}
              className="px-3.5 py-2 focus-visible:outline focus-visible:outline-2 focus-visible:outline-gray-200 bg-white border border-gray-300 text-gray-700 hover:bg-gray-50 hover:text-gray-700 rounded-lg shadow-xs"
            >
              <HelpCircle
                className="mr-2 h-5 w-5 inline text-accent-700"
                viewBox="0 0 24 24"
              />
              <span className="align-middle font-dmsans font-semibold text-sm md:text-base">
                {content.survey_button_text}
              </span>
            </PopupButton>
          </div>
          <li>
            <ul role="list">
              {secondaryMenu.map((item, i) => (
                <AccountMenuItem
                  key={`${item.id}-${i}`}
                  {...item}
                  current={pathname}
                />
              ))}
            </ul>
          </li>

          <li className="-mx-6">
            <div className="mx-6 border-t border-gray-200" />
            <div className="flex px-6 pt-6 pb-8 justify-between">
              <CustomPrismicLink
                field={content.profile_link}
                className="group flex flex-shrink-0 items-center"
              >
                <div>
                  <UserAvatar user={user} userAvatarS3Url={userAvatarS3Url} />
                </div>
                <div className="ml-3 max-w-[150px]">
                  <p className="text-sm font-medium text-gray-700 group-hover:text-gray-900 text-left">
                    {getFullName(user.firstName, user.lastName, 'Your Profile')}
                  </p>
                  <p className="text-xs font-medium text-gray-500 group-hover:text-gray-700 text-left truncate">
                    {user?.email}
                  </p>
                </div>
              </CustomPrismicLink>
              <ButtonBase
                className="text-gray-500 p-3 rounded-md hover:ring-1 hover:ring-gray-200 hover:ring-inset hover:bg-gray-50 hover:text-accent-500"
                onClick={async () => {
                  const callbackUrl = await getSignoutUrl();
                  signOut({ redirect: true, callbackUrl });
                }}
              >
                <span className="sr-only">Logout</span>
                <LogOut01 className="" />
              </ButtonBase>
            </div>
          </li>
        </ul>
      </nav>
    </>
  );
};

export default AccountMenu;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/navigation/user-context-switch/user-context-dropdown.tsx

'use client';

import { signOut } from 'next-auth/react';
import { useSearchParams } from 'next/navigation';
import React, { Fragment } from 'react';
import { twMerge } from 'tailwind-merge';
import Cookies from 'universal-cookie';

import Avatar from '@/app/(account)/account/messaging/components/avatar';
import { getSignoutUrl } from '@/app/(features)/(authentication)/signout/getSignoutUrl';
import { IFamilyMember } from '@/app/shared/types';
import { COOKIE_KEYS } from '@/utils/enums';
import ButtonBase from '@components/buttons/button-base';
import StatusBadge from '@components/status-badge/status-badge';
import { Menu, Transition } from '@headlessui/react';
import { CheckIcon, ChevronDownIcon } from '@heroicons/react/20/solid';
import { KeyTextField, LinkField, isFilled } from '@prismicio/client';
import { PrismicNextLink } from '@prismicio/next';
import { PlusCircle } from '@untitled-ui/icons-react';

interface IUserContextDropdownProps {
  users: IFamilyMember[];
  className?: string;
  addText?: KeyTextField;
  addLink?: LinkField;
  navLinks?: {
    link: LinkField;
    text: KeyTextField;
    status_badge: KeyTextField;
  }[];
  logoutText?: KeyTextField;
  accountSwitchDividerText?: KeyTextField;
}

const UserContextDropdown: React.FC<IUserContextDropdownProps> = (p) => {
  const searchParams = useSearchParams();

  const defaultUser =
    p.users.length > 0
      ? p.users?.find((user) => user.isPrimary) ?? p.users[0]
      : null;

  const [selectedFamilyMember, setSelectedFamilyMember] =
    React.useState<IFamilyMember | null>(defaultUser);

  const handleFamilyMemberSelection = (newFamilyMember: IFamilyMember) => {
    const cookies = new Cookies();
    if (newFamilyMember.isPrimary) {
      cookies.remove(COOKIE_KEYS.FAMILY_MEMBER, { path: '/' });
    } else {
      cookies.set(COOKIE_KEYS.FAMILY_MEMBER, newFamilyMember.id, { path: '/' });
    }
    window.location.reload();
  };

  React.useEffect(() => {
    const cookies = new Cookies();
    const selectedUser = cookies.get(COOKIE_KEYS.FAMILY_MEMBER);
    if (selectedUser) {
      const selected = p.users.find((m) => m.id === selectedUser);
      if (selected) {
        setSelectedFamilyMember(selected);
      }
    }
  }, [searchParams, p.users]);

  return (
    <Menu as="div" className="relative inline-block text-left w-full">
      <div>
        <Menu.Button className="font-dmsans inline-flex w-full items-center justify-between gap-x-1.5 rounded-md bg-white px-3 py-2 text-base font-medium text-gray-700 shadow-sm ring-1 ring-gray-300 hover:bg-gray-50">
          {selectedFamilyMember ? (
            <span className="flex items-center">
              <Avatar
                className="w-8 h-8"
                user={selectedFamilyMember}
                isPrimary={selectedFamilyMember?.isPrimary}
              />
              <span className="ml-2 text-left">
                {selectedFamilyMember?.firstName ?? 'Primary'}
              </span>
            </span>
          ) : (
            <span>Primary User</span>
          )}
          <ChevronDownIcon
            className="-mr-1 h-5 w-5 text-gray-400"
            aria-hidden="true"
          />
        </Menu.Button>
      </div>

      <Transition
        as={Fragment}
        enter="transition ease-out duration-100"
        enterFrom="transform opacity-0 scale-95"
        enterTo="transform opacity-100 scale-100"
        leave="transition ease-in duration-75"
        leaveFrom="transform opacity-100 scale-100"
        leaveTo="transform opacity-0 scale-95"
      >
        <Menu.Items className="absolute right-0 bottom-auto z-50 mt-2 w-full max-w-xs origin-top-right rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none">
          <div className="py-1.5">
            {(p.navLinks ?? []).map((navItem) => (
              <React.Fragment key={navItem.text}>
                {isFilled.link(navItem.link) && (
                  <div className="relative w-full px-1">
                    <Menu.Item key={navItem.text}>
                      {({ active }) => (
                        <PrismicNextLink
                          field={navItem.link}
                          className={twMerge(
                            active && 'bg-gray-100',
                            'flex items-center justify-between w-full rounded-md px-4 py-2 font-dmsans text-base text-gray-600 font-medium'
                          )}
                        >
                          <span>{navItem.text}</span>
                          {navItem.status_badge && (
                            <StatusBadge dataKey={navItem.status_badge} />
                          )}
                        </PrismicNextLink>
                      )}
                    </Menu.Item>
                  </div>
                )}
              </React.Fragment>
            ))}
            <Menu.Item>
              {({ active }) => (
                <div className="relative w-full px-1">
                  <ButtonBase
                    className={twMerge(
                      active && 'bg-gray-100',
                      'block text-left rounded-md w-full px-4 py-2 font-dmsans text-base md:text-base text-gray-600 font-medium hover:text-gray-600'
                    )}
                    onClick={async () => {
                      const callbackUrl = await getSignoutUrl();
                      signOut({ redirect: true, callbackUrl });
                    }}
                  >
                    {p.logoutText}
                  </ButtonBase>
                </div>
              )}
            </Menu.Item>
            <div className="my-1.5 px-4 py-2.5 bg-gray-100">
              <span className="font-dmsans text-gray-600 font-medium text-base">
                {p.accountSwitchDividerText}
              </span>
            </div>
            <div className="px-2">
              {(p.users ?? []).map((dependent) => {
                const isSelected = dependent.id === selectedFamilyMember?.id;
                return (
                  <Menu.Item key={dependent.id}>
                    {({ active }) => (
                      <div className="relative w-full px-1">
                        <ButtonBase
                          onClick={() => handleFamilyMemberSelection(dependent)}
                          className={twMerge(
                            active && 'bg-gray-100',
                            'flex items-center text-left w-full px-4 py-2'
                          )}
                        >
                          <Avatar
                            className="w-8 h-8"
                            user={dependent}
                            isPrimary={dependent.isPrimary}
                          />
                          <span className="ml-2 font-dmsans text-base text-gray-600 font-medium">
                            {dependent?.firstName ?? 'Primary'}
                          </span>
                          {isSelected ? (
                            <span className="text-accent-400 absolute inset-y-0 right-0 flex items-center pr-4">
                              <CheckIcon
                                className="h-5 w-5"
                                aria-hidden="true"
                              />
                            </span>
                          ) : null}
                        </ButtonBase>
                      </div>
                    )}
                  </Menu.Item>
                );
              })}
              {isFilled.link(p.addLink) && (
                <Menu.Item>
                  {({ active }) => (
                    <div className="mt-3 w-full px-1">
                      <PrismicNextLink
                        field={p.addLink}
                        className={twMerge(
                          active ? 'bg-accent-100' : 'bg-accent-50',
                          'flex w-full rounded-md text-left justify-between items-center gap-1 px-4 py-2 font-dmsans text-base text-accent-900 font-medium'
                        )}
                      >
                        <span>{p.addText}</span>
                        <PlusCircle
                          className="h-5 w-5 text-accent-700"
                          viewBox="0 0 24 24"
                        />
                      </PrismicNextLink>
                    </div>
                  )}
                </Menu.Item>
              )}
            </div>
          </div>
        </Menu.Items>
      </Transition>
    </Menu>
  );
};

export default UserContextDropdown;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/navigation/user-context-switch/user-context-switch.tsx

'use client';

import React from 'react';

import { IFamilyMember } from '@/app/shared/types';
import { KeyTextField, LinkField } from '@prismicio/client';
import { useQuery } from '@tanstack/react-query';

import UserContextDropdown from './user-context-dropdown';

interface IUserContextSwitchProps {
  className?: string;
  addText?: KeyTextField;
  addLink?: LinkField;
  navLinks?: {
    link: LinkField;
    text: KeyTextField;
    status_badge: KeyTextField;
  }[];
  logoutText?: KeyTextField;
  accountSwitchDividerText?: KeyTextField;
}

const getFamily = async () => {
  const family = await fetch('/api/user/get-family');
  return (await family.json()) as IFamilyMember[];
};

const UserContextSwitch: React.FC<IUserContextSwitchProps> = (p) => {
  const { isLoading, data, error } = useQuery(
    ['family-members'],
    () => getFamily(),
    {
      refetchOnWindowFocus: false,
      cacheTime: 300000,
      staleTime: 300000,
    }
  );

  if (isLoading)
    return (
      <div className="animate-pulse">
        <div className="bg-gray-200 rounded-lg w-full h-10" />
      </div>
    );
  if (error) return null;

  return (
    data && (
      <UserContextDropdown
        users={data}
        addText={p.addText}
        addLink={p.addLink}
        navLinks={p.navLinks}
        logoutText={p.logoutText}
        accountSwitchDividerText={p.accountSwitchDividerText}
        className={p.className}
      />
    )
  );
};

export default UserContextSwitch;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/case-picker/listbox-option.tsx

import { twMerge } from 'tailwind-merge';

import { Listbox } from '@headlessui/react';
import { CheckIcon } from '@heroicons/react/20/solid';
import { Case } from '@prisma/client';

interface IListboxOptionProps {
  value: Case | null;
  children: React.ReactNode;
}

const ListboxOption: React.FC<IListboxOptionProps> = (p) => {
  return (
    <Listbox.Option
      className={({ selected, active }) =>
        twMerge(
          selected || active ? 'bg-gray-50' : 'bg-white',
          'relative cursor-default select-none py-2 pl-3 pr-9 text-gray-900'
        )
      }
      value={p.value}
    >
      {({ selected }) => (
        <>
          <span
            className={twMerge(
              selected ? 'font-semibold' : 'font-normal',
              'block truncate'
            )}
          >
            {p.children}
          </span>

          {selected && (
            <span
              className={twMerge(
                selected ? 'text-accent-400' : 'hidden',
                'absolute inset-y-0 right-0 flex items-center pr-4'
              )}
            >
              <CheckIcon className="h-5 w-5" aria-hidden="true" />
            </span>
          )}
        </>
      )}
    </Listbox.Option>
  );
};

export default ListboxOption;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/case-picker/case-selector-label.tsx

import { CaseInclude } from '../../types';

const CaseSelectorLabel = ({ selectedCase }: { selectedCase: CaseInclude }) => {
  const { user, complaint, createdAt } = selectedCase;

  if (!complaint) {
    return 'No complaint';
  }

  return `${user?.firstName} (${complaint} - ${new Date(
    createdAt
  ).toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric',
  })})`;
};

export default CaseSelectorLabel;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/case-picker/download-report-modal.tsx

import {
  CheckCircleIcon,
  ExclamationCircleIcon,
} from '@heroicons/react/20/solid';

import LoadingSpinner from '../loading-indicators/loading-spinner';

const DownloadReportModal = (p: {
  loading: boolean;
  error: boolean;
  reportUrl: string | null;
}) => {
  if (p.loading) {
    return (
      <div className="font-dmsans text-center py-6">
        <div className="flex justify-center items-center mb-4">
          <LoadingSpinner fillClass="fill-accent-500" />
        </div>
        <p className="font-semibold text-xl text-gray-900 mb-2">
          Generating Report
        </p>
        <p className="text-base text-gray-600">
          Please wait while we generate your consultation report. This could
          take a moment.
        </p>
      </div>
    );
  }

  if (p.error || !p.reportUrl) {
    return (
      <div className="font-dmsans text-center py-6">
        <div className="flex justify-center items-center mb-4">
          <ExclamationCircleIcon className="w-12 h-12 text-warning-500" />
        </div>
        <p className="font-semibold text-xl text-gray-900 mb-2">
          Unable to Generate Report
        </p>
        <p className="text-base text-gray-600">
          Please try again later or contact support if the issue persists.
        </p>
      </div>
    );
  }

  return (
    <div className="font-dmsans text-center py-6">
      <div className="flex justify-center items-center mb-4">
        <CheckCircleIcon className="w-12 h-12 text-success-500" />
      </div>
      <p className="font-semibold text-xl text-gray-900 mb-2">
        Your Report is Ready!
      </p>
      <p className="text-base text-gray-600">
        Your consultation report should have automatically downloaded.
      </p>
      <div className="mt-4 mb-3 w-10 h-0.5 rounded-xl bg-accent-700 mx-auto" />
      <p className="italic text-xs text-gray-600 mb-1">
        Not seeing the file? Click the link below to download.
      </p>
      <a
        href={p.reportUrl}
        className="text-sm font-semibold underline text-accent-700"
        download="Cortina - Consultation Report.pdf"
      >
        Consulation Report PDF
      </a>
    </div>
  );
};

export default DownloadReportModal;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/case-picker/case-filter.tsx

'use client';

import { Fragment, useState } from 'react';
import { twMerge } from 'tailwind-merge';

import { Listbox, Transition } from '@headlessui/react';
import { ChevronUpIcon, ChevronDownIcon } from '@heroicons/react/20/solid';
import { Case } from '@prisma/client';

import { CaseInclude } from '../../types';
import CaseSelectorLabel from './case-selector-label';
import ListboxOption from './listbox-option';

export interface ICaseFilterProps {
  cases: CaseInclude[];
  currentCase?: CaseInclude | null;
  onCaseChange?: (selectedCase: CaseInclude) => void;
  className?: string;
}

const CaseFilter: React.FC<ICaseFilterProps> = ({
  cases,
  currentCase,
  onCaseChange,
  className,
}) => {
  const [selectedCase, setSelectedCase] = useState(currentCase);

  const handleCaseSelectionChange = (newCase: CaseInclude) => {
    setSelectedCase(newCase);
    onCaseChange?.(newCase);
  };

  return (
    <div className="comp-case-picker w-full h-full">
      <Listbox value={selectedCase} onChange={handleCaseSelectionChange}>
        {({ open }) => (
          <>
            <Listbox.Label className="sr-only">Select a case</Listbox.Label>
            <div className="relative w-full flex">
              <Listbox.Button
                className={twMerge(
                  'relative w-full cursor-default text-left rounded-md border-0 h-10 focus:shadow-drop bg-white py-1.5 pl-3 pr-10 font-medium text-gray-900 shadow-sm ring-1 ring-gray-300 focus:ring-1 focus:ring-accent-300 sm:text-sm sm:leading-6',
                  className
                )}
              >
                <span className="block truncate font-dmsans text-gray-900">
                  {selectedCase == null ? (
                    'All Cases'
                  ) : (
                    <CaseSelectorLabel selectedCase={selectedCase} />
                  )}
                </span>
                <span className="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-2">
                  {open ? (
                    <ChevronUpIcon
                      className="h-5 w-5 text-gray-400"
                      aria-hidden="true"
                    />
                  ) : (
                    <ChevronDownIcon
                      className="h-5 w-5 text-gray-400"
                      aria-hidden="true"
                    />
                  )}
                </span>
              </Listbox.Button>

              <Transition
                show={open}
                as={Fragment}
                leave="transition ease-in duration-100"
                leaveFrom="opacity-100"
                leaveTo="opacity-0"
              >
                <Listbox.Options className="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-gray-300 ring-opacity-5 focus:outline-none sm:text-sm">
                  {cases.map((caseItem) => (
                    <ListboxOption key={caseItem.id} value={caseItem}>
                      <CaseSelectorLabel selectedCase={caseItem} />
                    </ListboxOption>
                  ))}
                  <ListboxOption value={null}>All Cases</ListboxOption>
                </Listbox.Options>
              </Transition>
            </div>
          </>
        )}
      </Listbox>
    </div>
  );
};

export default CaseFilter;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/case-picker/case-picker.tsx

'use client';

import { Fragment, useState } from 'react';
import { twMerge } from 'tailwind-merge';

import { getFamilyMemberHeader } from '@/utils/utils';
import { Listbox, Transition } from '@headlessui/react';
import { ChevronUpIcon, ChevronDownIcon } from '@heroicons/react/20/solid';
import { Download02 } from '@untitled-ui/icons-react';

import { CaseInclude } from '../../types';
import Modal from '../overlays/modal';
import CaseSelectorLabel from './case-selector-label';
import DownloadReportModal from './download-report-modal';
import ListboxOption from './listbox-option';

export interface ICasePickerProps {
  cases: CaseInclude[];
  placeholder?: string;
  currentCase?: CaseInclude | null;
  onCaseChange?: (selectedCase: CaseInclude) => void;
  listBoxOnly?: boolean;
  className?: string;
}

const CasePicker: React.FC<ICasePickerProps> = ({
  cases,
  placeholder,
  currentCase,
  onCaseChange,
  listBoxOnly,
  className,
}) => {
  const [selectedCase, setSelectedCase] = useState(currentCase);
  const [showDownloadModal, setShowDownloadModal] = useState(false);
  const [reportGenerating, setReportGenerating] = useState(false);
  const [reportError, setReportError] = useState(false);
  const [reportUrl, setReportUrl] = useState<string | null>(null);

  const handleCaseSelectionChange = (newCase: CaseInclude) => {
    setSelectedCase(newCase);
    onCaseChange?.(newCase);
  };

  const handleDownloadReport = async () => {
    if (selectedCase == null) {
      return;
    }
    setReportError(false);
    setReportUrl(null);
    setReportGenerating(true);
    setShowDownloadModal(true);

    const res = await fetch(`/api/case/${selectedCase.id}/generate-report`, {
      method: 'GET',
      headers: getFamilyMemberHeader(),
    });

    if (res.ok) {
      const blob = await res.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'Cortina - Consultation Report.pdf';
      a.click();

      setReportUrl(url);
    } else {
      setReportError(true);
    }
    setReportGenerating(false);
  };

  const showDownloadButton = !listBoxOnly && selectedCase?.diagnosisICD != null;

  return (
    <div className="comp-case-picker w-full h-full">
      <div className="flex w-full lg:items-center lg:flex-row flex-col gap-x-4 gap-y-2">
        <Listbox value={selectedCase} onChange={handleCaseSelectionChange}>
          {({ open }) => (
            <>
              {listBoxOnly ? (
                <Listbox.Label className="sr-only">Select a case</Listbox.Label>
              ) : (
                <Listbox.Label className="whitespace-nowrap text-md font-dmsans font-bold leading-6 text-[#101828] lg:text-center pr-3">
                  Consultation Report
                </Listbox.Label>
              )}
              <div className="relative w-full flex">
                <Listbox.Button
                  className={twMerge(
                    'relative w-full cursor-default text-left rounded-md border-0 h-10 focus:shadow-drop bg-white py-1.5 pl-3 pr-10 font-medium text-gray-900 shadow-sm ring-1 ring-gray-300 focus:ring-1 focus:ring-accent-300 sm:text-sm sm:leading-6',
                    className
                  )}
                >
                  <span className="block truncate font-dmsans text-gray-900">
                    {selectedCase == null ? (
                      <>{placeholder ?? 'No cases found'}</>
                    ) : (
                      <CaseSelectorLabel selectedCase={selectedCase} />
                    )}
                  </span>
                  <span className="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-2">
                    {open ? (
                      <ChevronUpIcon
                        className="h-5 w-5 text-gray-400"
                        aria-hidden="true"
                      />
                    ) : (
                      <ChevronDownIcon
                        className="h-5 w-5 text-gray-400"
                        aria-hidden="true"
                      />
                    )}
                  </span>
                </Listbox.Button>

                <Transition
                  show={open}
                  as={Fragment}
                  leave="transition ease-in duration-100"
                  leaveFrom="opacity-100"
                  leaveTo="opacity-0"
                >
                  <Listbox.Options className="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-gray-300 ring-opacity-5 focus:outline-none sm:text-sm">
                    {cases.map((caseItem) => (
                      <ListboxOption key={caseItem.id} value={caseItem}>
                        <CaseSelectorLabel selectedCase={caseItem} />
                      </ListboxOption>
                    ))}
                  </Listbox.Options>
                </Transition>

                {showDownloadButton && (
                  <div className="lg:ml-4 lg:block hidden">
                    {selectedCase == null ? (
                      <div>&nbsp;</div>
                    ) : (
                      <span className="isolate inline-flex rounded-md ">
                        <button
                          type="button"
                          className="relative inline-flex items-center rounded-md bg-white px-2 py-2.5 text-gray-500 ring-gray-300 hover:bg-gray-50 focus:z-10"
                          onClick={handleDownloadReport}
                          title="Download Report"
                        >
                          <span className="sr-only">Download Report</span>
                          <Download02
                            className="h-5 w-5"
                            aria-hidden="true"
                            viewBox="0 0 24 24"
                          />
                        </button>
                      </span>
                    )}
                  </div>
                )}
              </div>
            </>
          )}
        </Listbox>
      </div>
      <Modal
        show={showDownloadModal}
        content="Modal Content"
        contentRenderer={() => (
          <DownloadReportModal
            loading={reportGenerating}
            error={reportError}
            reportUrl={reportUrl}
          />
        )}
        onClose={() => {
          setShowDownloadModal(false);
        }}
      />
    </div>
  );
};

export default CasePicker;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/text-area.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import HelpButton from '@components/buttons/help-button';
import Label from '@components/form-controls/label';
import { AlertCircle } from '@untitled-ui/icons-react';

interface ITextAreaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  id: string;
  name?: string;
  className?: string;
  value?: string;
  onChange?: (e: React.ChangeEvent<HTMLTextAreaElement>) => void;
  onBlur?: (e: React.FocusEvent<HTMLTextAreaElement>) => void;
  placeholder?: string;
  disabled?: boolean;
  isInvalid?: boolean;
  helperTextTitle?: string;
  helperText?: string;
  label?: string;
}
const TextArea: React.FC<ITextAreaProps> = (p) => {
  const {
    id,
    rows,
    maxLength,
    className,
    isInvalid,
    helperTextTitle,
    helperText = '',
    label = '',
    ...others
  } = p;
  const generatedId = React.useId();

  const errorStyle = isInvalid
    ? 'ring-1 ring-error-300 focus:ring-error-300'
    : '';

  const inputId = id ?? generatedId;

  return (
    <>
      <Label id={inputId} htmlFor={inputId} label={p.label} />
      <div className="relative">
        <textarea
          id={inputId}
          rows={rows ?? 3}
          maxLength={maxLength ?? 500}
          className={twMerge([
            `resize-none block w-full rounded-lg border-0 py-3 px-3.5 font-dmsans text-base text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-500 focus:ring-2 focus:shadow-drop focus:ring-accent-300`,
            errorStyle,
            className,
          ])}
          {...others}
        />
        {p.helperText && !isInvalid && (
          <div className="absolute bottom-0 right-0 flex pr-2 pb-2">
            <HelpButton title={helperTextTitle ?? label} content={helperText} />
          </div>
        )}
        {isInvalid && (
          <div className="absolute bottom-0 right-0 flex pr-2 pb-2">
            <AlertCircle
              className="text-error-500"
              width={16}
              height={16}
              viewBox="0 0 24 24"
            />
          </div>
        )}
      </div>
    </>
  );
};

export default TextArea;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/legend.tsx

import React from 'react';

import MarkdownElement from '@components/markdown-element';
import { FormStateContext } from '@form/contexts/form-context';

interface ILegendProps {
  id?: string;
  legend?: string;
}

const Legend: React.FC<ILegendProps> = ({ id, legend }) => {
  const formContext = React.useContext(FormStateContext);

  let dataContext: any = {};

  if (formContext?.dataContext) {
    dataContext = { ...formContext.dataContext };
  }

  return legend ? (
    <legend
      id={`${id}-legend`}
      className="block mb-1 text-sm font-medium text-gray-700 font-dmsans"
    >
      <MarkdownElement overridePTag={false} dataContext={dataContext}>
        {legend}
      </MarkdownElement>
    </legend>
  ) : null;
};

export default Legend;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/text-field.tsx

import React from 'react';
import InputMask from 'react-input-mask';
import { twMerge } from 'tailwind-merge';

import HelpButton from '@components/buttons/help-button';
import Label from '@components/form-controls/label';
import { AlertCircle } from '@untitled-ui/icons-react';

interface ITextFieldProps extends React.InputHTMLAttributes<HTMLInputElement> {
  id?: string;
  name?: string;
  label?: string;
  type?: string;
  maskType?: string | null;
  className?: string;
  placeholder?: string;
  value?: string;
  helperTextTitle?: string;
  helperText?: string;
  onChange?: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onBlur?: (e: React.FocusEvent<HTMLInputElement>) => void;
  onKeyDown?: (e: React.KeyboardEvent<HTMLInputElement>) => void;
  disabled?: boolean;
  isInvalid?: boolean;
}

const TextField = React.forwardRef(function (
  p: ITextFieldProps,
  ref: React.Ref<HTMLInputElement>
) {
  const {
    id,
    type = 'text',
    className,
    isInvalid,
    helperTextTitle,
    helperText,
    maskType,
    label = '',
    ...others
  } = p;
  const generatedId = React.useId();

  const errorStyle = isInvalid
    ? 'ring-1 ring-error-300 focus:ring-error-300'
    : '';

  const getMaskProps = React.useCallback(() => {
    switch (maskType) {
      case 'MM/DD/YYYY':
        return { mask: '99/99/9999', alwaysShowMask: true };
      default:
        return null;
    }
  }, [maskType]);

  const maskProps = getMaskProps();

  const inputId = id ?? generatedId;

  return (
    <>
      <Label id={inputId} htmlFor={inputId} label={label} />
      <div className="relative">
        {maskProps ? (
          <InputMask
            id={inputId}
            name={others.name}
            type={type}
            className={twMerge([
              `block w-full h-12 text-base font-dmsans rounded-md border-0 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 
           placeholder:text-gray-500 focus:ring-2 focus:ring-accent-300 focus:shadow-drop disabled:cursor-not-allowed disabled:bg-gray-50 disabled:text-gray-500`,
              className,
              errorStyle,
            ])}
            {...maskProps}
            placeholder={others.placeholder}
            value={others.value}
            onChange={others.onChange}
            onBlur={others.onBlur}
            onKeyDown={others.onKeyDown}
            disabled={others.disabled}
          />
        ) : (
          <input
            id={inputId}
            ref={ref}
            className={twMerge([
              `block w-full h-12 text-base font-dmsans rounded-md border-0 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 
           placeholder:text-gray-500 focus:ring-2 focus:ring-accent-300 focus:shadow-drop disabled:cursor-not-allowed disabled:bg-gray-50 disabled:text-gray-500`,
              className,
              errorStyle,
            ])}
            type={type}
            {...others}
          />
        )}
        {helperText && !isInvalid && (
          <div className="absolute inset-y-0 right-0 flex pr-3">
            <HelpButton title={helperTextTitle ?? label} content={helperText} />
          </div>
        )}
        {isInvalid && (
          <div className="absolute inset-y-0 right-0 flex pr-3">
            <div className="flex items-center">
              <AlertCircle
                className="text-error-500"
                width={16}
                height={16}
                viewBox="0 0 24 24"
              />
            </div>
          </div>
        )}
      </div>
    </>
  );
});

TextField.displayName = 'TextField';

export default TextField;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/label.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import HelpButton from '@components/buttons/help-button';
import MarkdownElement from '@components/markdown-element';
import { FormStateContext } from '@form/contexts/form-context';

interface ILabelProps {
  label?: string | null;
  htmlFor?: string;
  id?: string;
  className?: string;
  labelClassName?: string;
  helperTextTitle?: string | null;
  helperText?: string | null;
}

const Label: React.FC<ILabelProps> = ({
  id,
  label,
  htmlFor,
  className,
  labelClassName,
  helperTextTitle,
  helperText,
}) => {
  const formContext = React.useContext(FormStateContext);

  let dataContext: any = {};

  if (formContext?.dataContext) {
    dataContext = { ...formContext.dataContext };
  }

  return label ? (
    <div className={twMerge(['mb-3 leading-5', className])}>
      <label
        id={`${id}-label`}
        htmlFor={htmlFor}
        onClick={(e) => {
          // REMOVED prevent default to fix accessibility issues, can bring back in specific cases if new use cases come up.
          // Check if the clicked element (or its parent, if needed) is a link
          // if (
          //   !(
          //     e.target instanceof HTMLElement &&
          //     (e.target.tagName === 'A' || e.target.closest('a'))
          //   )
          // ) {
          //   e.preventDefault();
          //   // Optionally, handle other non-link clicks here
          // }
          // If the target or its parent is a link, do nothing special,
          // allowing the default link behavior.
        }}
        className={twMerge(
          'inline mb-1 text-md text-gray-600 font-dmsans align-middle leading-6',
          labelClassName
        )}
      >
        <MarkdownElement overridePTag={false} dataContext={dataContext}>
          {label}
        </MarkdownElement>
      </label>

      {helperText && (
        <HelpButton
          title={helperTextTitle ?? label}
          content={helperText}
          className="inline-flex pl-1 align-middle"
        />
      )}
    </div>
  ) : null;
};

export default Label;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/combobox.tsx

import { useState } from 'react';
import { twMerge } from 'tailwind-merge';

import Label from '@components/form-controls/label';
import { Combobox as HeadlessCombobox } from '@headlessui/react';
import { ChevronDown, Check } from '@untitled-ui/icons-react';

interface IComboboxProps {
  id?: string;
  name?: string;
  className?: string;
  options: string[];
  value: string;
  onChange: (option: string) => void;
  onBlur?: (e: React.FocusEvent<Element>) => void;
  label?: string;
  helperTextTitle?: string;
  helperText?: string;
  labelRenderer?: () => React.ReactNode;
  isInvalid?: boolean;
}

const Combobox: React.FC<IComboboxProps> = (p) => {
  const [query, setQuery] = useState('');

  const filteredOptions =
    query === ''
      ? p.options
      : p.options.filter((option) => {
          return option.toLowerCase().includes(query.toLowerCase());
        });

  const errorStyle = p.isInvalid
    ? 'ring-1 ring-error-300 focus:ring-error-300'
    : '';

  return (
    <div className="w-full">
      <Label
        htmlFor={p.id}
        label={p.label}
        helperTextTitle={p.helperTextTitle}
        helperText={p.helperText}
      />
      <HeadlessCombobox
        as="div"
        id={p.id}
        name={p.name}
        value={p.value}
        onChange={p.onChange}
        onBlur={p.onBlur}
      >
        <div className="relative mt-2">
          <HeadlessCombobox.Input
            className={twMerge(
              `w-full rounded-md border-0 h-12 focus:shadow-drop bg-white py-1.5 pl-3 pr-10 font-medium text-gray-900 shadow-sm ring-1 ring-gray-300 focus:ring-1 focus:ring-accent-300 sm:text-sm sm:leading-6`,
              errorStyle
            )}
            onChange={(event) => setQuery(event.target.value)}
            displayValue={(option: string) => option}
          />
          <HeadlessCombobox.Button className="absolute inset-y-0 right-0 flex items-center rounded-r-md px-2 focus:outline-none">
            <ChevronDown
              className="h-5 w-5 text-gray-500"
              aria-hidden="true"
              viewBox="0 0 24 24"
            />
          </HeadlessCombobox.Button>

          {filteredOptions.length > 0 && (
            <HeadlessCombobox.Options className="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm">
              {filteredOptions.map((option, i) => (
                <HeadlessCombobox.Option
                  key={`option-${i}`}
                  value={option}
                  className={({ active }) =>
                    twMerge([
                      'relative cursor-default select-none py-2 pl-3 pr-9 text-gray-700 font-medium',
                      active && 'bg-gray-50',
                    ])
                  }
                >
                  {({ selected }) => (
                    <>
                      <span className="block truncate font-medium">
                        {option}
                      </span>

                      {selected && (
                        <span className="absolute inset-y-0 right-0 flex items-center pr-4 text-accent-400">
                          <Check
                            className="h-5 w-5"
                            aria-hidden="true"
                            viewBox="0 0 24 24"
                          />
                        </span>
                      )}
                    </>
                  )}
                </HeadlessCombobox.Option>
              ))}
            </HeadlessCombobox.Options>
          )}
        </div>
      </HeadlessCombobox>
    </div>
  );
};

export default Combobox;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/address-autocomplete.tsx

import React from 'react';

import TextField from '@components/form-controls/text-field';
import { parseGoogleAddress } from '@form/utils';
import { Loader } from '@googlemaps/js-api-loader';

interface IAddressForm {
  id?: string;
  name: string;
  label: string;
  value?: string;
  helperTextTitle?: string;
  helperText?: string;
  disabled?: boolean;
  isInvalid?: boolean;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onBlur?: (e: React.FocusEvent<HTMLInputElement>) => void;
  triggerOnChange: (
    address: {
      address1: string;
      address2: string;
      city: string;
      state: string;
      postal: string;
      country: string;
    },
    place: google.maps.places.PlaceResult
  ) => void;
}

const fillInAddress = (
  autocomplete: google.maps.places.Autocomplete,
  props: IAddressForm
) => {
  const place = autocomplete.getPlace();
  const address = parseGoogleAddress(place);

  props.onChange(address.address1 as any);
  props.triggerOnChange(address, place);
};

const initAutocomplete = (
  addressLine1Ref: React.RefObject<HTMLInputElement>,
  props: IAddressForm
) => {
  if (addressLine1Ref?.current != null) {
    const autocomplete = new google.maps.places.Autocomplete(
      addressLine1Ref.current,
      {
        componentRestrictions: { country: ['us'] },
        fields: ['address_components', 'place_id'],
        types: ['address'],
      }
    );
    autocomplete.addListener('place_changed', () =>
      fillInAddress(autocomplete, props)
    );
  }
};

const AddressAutoCompleteInput: React.FC<IAddressForm> = (p) => {
  const addressLine1Ref = React.useRef<HTMLInputElement>(null);

  React.useEffect(() => {
    initAutocomplete(addressLine1Ref, p);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const inputId = `${p.id}-input`;

  return (
    <TextField
      id={inputId}
      type="text"
      name={p.name}
      ref={addressLine1Ref}
      label={p.label}
      helperTextTitle={p.helperTextTitle}
      helperText={p.helperText}
      value={p.value}
      onChange={p.onChange}
      onBlur={p.onBlur}
      disabled={p.disabled}
      isInvalid={p.isInvalid}
      autoComplete="on"
    />
  );
};

const loadPlacesApi = async (
  setIsLoaded: React.Dispatch<React.SetStateAction<boolean>>
) => {
  const loader = new Loader({
    apiKey: process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY ?? '',
    version: 'weekly',
    libraries: ['places'],
  });

  loader
    .importLibrary('places')
    .then(() => {
      setIsLoaded(true);
    })
    .catch((err) => {
      console.log(err);
    });
};

const AddressAutocomplete: React.FC<IAddressForm> = (p) => {
  const [isLoaded, setIsLoaded] = React.useState(false);

  React.useEffect(() => {
    if (!isLoaded) {
      loadPlacesApi(setIsLoaded);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return isLoaded ? <AddressAutoCompleteInput {...p} /> : null;
};

export default AddressAutocomplete;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/phone-input.tsx

import React from 'react';
import {
  defaultCountries,
  CountrySelector,
  usePhoneInput,
} from 'react-international-phone';
import 'react-international-phone/style.css';
import { twMerge } from 'tailwind-merge';

import HelpButton from '@components/buttons/help-button';
import Label from '@components/form-controls/label';
import { AlertCircle } from '@untitled-ui/icons-react';

interface ITextFieldProps extends React.InputHTMLAttributes<HTMLInputElement> {
  id?: string;
  name?: string;
  label?: string;
  type?: string;
  className?: string;
  placeholder?: string;
  value?: string;
  helperTextTitle?: string;
  helperText?: string;
  onChange?: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onBlur?: (e: React.FocusEvent<HTMLInputElement>) => void;
  onKeyDown?: (e: React.KeyboardEvent<HTMLInputElement>) => void;
  disabled?: boolean;
  isInvalid?: boolean;
}

const PhoneInput: React.FC<ITextFieldProps> = (p) => {
  const { label = '' } = p;
  const generatedId = React.useId();

  const { inputValue, handlePhoneValueChange, inputRef, country, setCountry } =
    usePhoneInput({
      defaultCountry: 'us',
      value: p.value,
      countries: defaultCountries,
      onChange: (data) => {
        p.onChange?.({
          target: { name: p.name, value: data.phone },
        } as React.ChangeEvent<HTMLInputElement>);
      },
    });

  const errorStyle = p.isInvalid
    ? 'ring-1 ring-error-300 focus:ring-error-300'
    : '';

  const inputId = p.id ?? generatedId;

  return (
    <>
      <Label id={inputId} htmlFor={inputId} label={label} />
      <div className="relative mt-2 rounded-md shadow-sm">
        <div className="absolute inset-y-1 left-1 flex items-center">
          <label htmlFor="country" className="sr-only">
            Country
          </label>
          <CountrySelector
            className="h-full"
            buttonStyle={{
              height: '100%',
              border: 0,
            }}
            selectedCountry={country.iso2}
            onSelect={({ iso2 }) => setCountry(iso2)}
          />
        </div>
        <input
          id={inputId}
          type="tel"
          ref={inputRef}
          placeholder={p.placeholder ?? ''}
          className={twMerge([
            `block w-full h-12 text-base font-dmsans rounded-md border-0 py-1.5 pl-14 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 
         placeholder:text-gray-500 focus:ring-2 focus:ring-accent-300 focus:shadow-drop disabled:cursor-not-allowed disabled:bg-gray-50 disabled:text-gray-500`,
            p.className,
            errorStyle,
          ])}
          value={inputValue}
          onChange={handlePhoneValueChange}
          onBlur={p.onBlur}
          onKeyDown={p.onKeyDown}
          disabled={p.disabled}
        />
        {p.helperText && !p.isInvalid && (
          <div className="absolute inset-y-0 right-0 flex pr-3">
            <HelpButton
              title={p.helperTextTitle ?? label}
              content={p.helperText}
            />
          </div>
        )}
        {p.isInvalid && (
          <div className="absolute inset-y-0 right-0 flex pr-3">
            <div className="flex items-center">
              <AlertCircle
                className="text-error-500"
                width={16}
                height={16}
                viewBox="0 0 24 24"
              />
            </div>
          </div>
        )}
      </div>
    </>
  );
};

export default PhoneInput;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/select.tsx

import React from 'react';
import { Fragment } from 'react';
import { twMerge } from 'tailwind-merge';

import Label from '@components/form-controls/label';
import { Listbox, Transition } from '@headlessui/react';
import { ChevronDown, Check } from '@untitled-ui/icons-react';
import { convertStringToKebabCase } from '@utils/utils';

interface ISelectProps {
  id?: string;
  name?: string;
  className?: string;
  options: string[];
  value: string;
  onChange: (option: string) => void;
  onBlur?: (e: React.FocusEvent<Element>) => void;
  placeholderOption?: string | null;
  label?: string;
  helperTextTitle?: string;
  helperText?: string;
  isInvalid?: boolean;
  disabled?: boolean;
}

const Select: React.FC<ISelectProps> = (p) => {
  const { placeholderOption = '' } = p;
  const handleBlur =
    (listBoxOpen: boolean) => (e: React.FocusEvent<Element>) => {
      if (!listBoxOpen) {
        p.onBlur?.(e);
      }
    };

  const errorStyle = p.isInvalid
    ? 'ring-1 ring-error-300 focus:ring-error-300'
    : '';

  return (
    <div className="w-full">
      <Label
        id={p.id}
        label={p.label}
        helperTextTitle={p.helperTextTitle}
        helperText={p.helperText}
      />
      <Listbox
        value={p.value}
        name={p.name}
        onChange={p.onChange}
        disabled={p.disabled}
      >
        {({ open }) => (
          <>
            <Listbox.Label className="sr-only">{p.label}</Listbox.Label>
            <div className="relative mt-2">
              <Listbox.Button
                className={twMerge([
                  `group relative h-12 w-full focus:shadow-drop cursor-default rounded-md bg-white py-1.5 pl-3 pr-10 text-left text-gray-900 ring-1 ring-gray-300 focus:outline-none focus:ring-1 focus:ring-accent-300 sm:text-sm sm:leading-6 disabled:cursor-not-allowed disabled:bg-gray-50`,
                  errorStyle,
                ])}
                onBlur={handleBlur(open)}
              >
                <span
                  className={twMerge([
                    `block truncate text-gray-900 font-medium group-disabled:text-gray-500`,
                    p.className,
                  ])}
                >
                  {p.value === '' ? placeholderOption : p.value}
                </span>
                <span className="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-2">
                  <ChevronDown
                    className="h-5 w-5 text-gray-500"
                    aria-hidden="true"
                    viewBox="0 0 24 24"
                  />
                </span>
              </Listbox.Button>

              <Transition
                show={open}
                as={Fragment}
                leave="transition ease-in duration-100"
                leaveFrom="opacity-100"
                leaveTo="opacity-0"
              >
                <Listbox.Options className="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 px-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm">
                  {p.options.map((option, i) => (
                    <Listbox.Option
                      key={`${convertStringToKebabCase(option)}-${i}`}
                      className={({ active }) =>
                        twMerge([
                          active && 'bg-gray-50',
                          'relative cursor-default select-none py-2 pl-3 pr-9 text-gray-700 rounded-md',
                        ])
                      }
                      value={option}
                    >
                      {({ selected }) => (
                        <>
                          <span className="block truncate font-medium">
                            {option}
                          </span>

                          {selected ? (
                            <span className="absolute inset-y-0 right-0 flex items-center pr-4 text-accent-400">
                              <Check
                                className="h-5 w-5"
                                aria-hidden="true"
                                viewBox="0 0 24 24"
                              />
                            </span>
                          ) : null}
                        </>
                      )}
                    </Listbox.Option>
                  ))}
                </Listbox.Options>
              </Transition>
            </div>
          </>
        )}
      </Listbox>
    </div>
  );
};

export default Select;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/datepicker/datepicker.tsx

import dayjs from 'dayjs';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import Calendar from '@components/form-controls/datepicker/calendar';
import Label from '@components/form-controls/label';
import TextField from '@components/form-controls/text-field';
import {
  useDismiss,
  useInteractions,
  useFloating,
  autoPlacement,
  autoUpdate,
  offset,
} from '@floating-ui/react';
import { Calendar as CalendarIcon } from '@untitled-ui/icons-react';

interface IDatePickerProps {
  id?: string;
  name?: string;
  className?: string;
  value?: string;
  onChange?: (date: string) => void;
  onBlur?: (e: React.FocusEvent<HTMLInputElement>) => void;
  dateFormat?: string;
  dayFormat?: string;
  monthHeaderFormat?: string;
  placeholder?: string;
  minDate?: dayjs.Dayjs;
  maxDate?: dayjs.Dayjs;
  isInvalid?: boolean;
  disabled?: boolean;
  helperTextTitle?: string;
  helperText?: string;
  label?: string;
}

const DatePicker: React.FC<IDatePickerProps> = (p) => {
  // Defaults
  const {
    dateFormat = 'MMM DD, YYYY',
    dayFormat = 'D',
    monthHeaderFormat = 'MMMM YYYY',
    placeholder = 'Select date',
    isInvalid,
  } = p;
  const [showCalendar, setShowCalendar] = React.useState(false);
  const [date, setDate] = React.useState(p.value ? dayjs(p.value) : undefined);

  const toggleCalendar = () => {
    setShowCalendar(!showCalendar);
  };

  const handleDateChange = (date: dayjs.Dayjs) => {
    setDate(date);
    p.onChange?.(date.format('YYYY-MM-DD'));
  };

  // Floating UI (dynamic positioning/auto-dismiss on click away)
  const { refs, x, y, strategy, context } = useFloating({
    open: showCalendar,
    onOpenChange: setShowCalendar,
    middleware: [
      offset(5),
      autoPlacement({
        allowedPlacements: [
          'top-start',
          'top',
          'top-end',
          'bottom-start',
          'bottom',
          'bottom-end',
        ],
      }),
    ],
    whileElementsMounted: autoUpdate,
  });
  const dismiss = useDismiss(context);

  const { getReferenceProps, getFloatingProps } = useInteractions([dismiss]);

  return (
    <>
      <div>
        <Label id={p.id} htmlFor={p.id} label={p.label} />
        <div className="relative mt-2 rounded-md shadow-sm max-w-[170px]">
          <div className="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3 z-10">
            <CalendarIcon
              className="text-gray-700"
              width={20}
              height={20}
              viewBox="0 0 24 24"
            />
          </div>
          <TextField
            id={p.id}
            type="text"
            className={twMerge([
              'py-1.5 pl-10 h-10 text-sm font-semibold text-gray-700',
              p.className,
            ])}
            ref={refs.setReference}
            onFocus={toggleCalendar}
            onBlur={p.onBlur}
            placeholder={placeholder}
            name={p.name}
            value={dayjs(p.value).format(dateFormat)}
            readOnly={true}
            isInvalid={isInvalid}
            helperTextTitle={p.helperTextTitle}
            helperText={p.helperText}
            {...getReferenceProps()}
          />
        </div>
      </div>
      {showCalendar && (
        <Calendar
          ref={refs.setFloating}
          initialDate={date ?? dayjs()}
          setDate={handleDateChange}
          callback={toggleCalendar}
          dateFormat={dateFormat}
          dayFormat={dayFormat}
          monthHeaderFormat={monthHeaderFormat}
          position={{
            x,
            y,
            strategy,
          }}
          getFloatingProps={getFloatingProps}
          minDate={p.minDate}
          maxDate={p.maxDate}
          initIsInvalid={isInvalid}
        />
      )}
    </>
  );
};

export default DatePicker;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/datepicker/day-button.tsx

import dayjs from 'dayjs';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import {
  type IDayProps,
  dateIsWithinRange,
} from '@components/form-controls/datepicker/utils';

interface IDayButtonProps extends IDayProps {
  selectedDate: dayjs.Dayjs;
  selectDate: () => void;
  dayFormat: string;
  minDate?: dayjs.Dayjs;
  maxDate?: dayjs.Dayjs;
}

const BaseDayButton: React.FC<{
  className?: string;
  onClick?: () => void;
  children: React.ReactNode;
}> = (p) => {
  return (
    <button
      type="button"
      className={twMerge([
        `rounded-full text-sm font-sans text-gray-700 justify-center text-center w-10 h-10 cursor-pointer`,
        p.className,
      ])}
      onClick={p.onClick}
    >
      {p.children}
    </button>
  );
};

const DayButton: React.FC<IDayButtonProps> = (p) => {
  const isSelected = p.date.isSame(p.selectedDate, 'day');
  const isInDateRange = dateIsWithinRange(p.date, p.minDate, p.maxDate);

  // Disabled days
  if (!p.isCurrentMonth || !isInDateRange) {
    return (
      <div className="rounded-full text-sm font-sans flex items-center justify-center w-10 h-10 text-gray-500 cursor-not-allowed focus-visible:outline-none">
        {p.date.format(p.dayFormat)}
      </div>
    );
  }

  // Selected day
  if (isSelected) {
    return (
      <BaseDayButton
        {...p}
        className="font-medium text-accent-700 bg-accent-200"
        onClick={p.selectDate}
      >
        {p.date.format(p.dayFormat)}
      </BaseDayButton>
    );
  }

  // Enabled, unselected days
  return (
    <BaseDayButton
      {...p}
      className="hover:bg-gray-50 focus-visible:outline focus-visible:outline-1 focus-visible:outline-accent-300"
      onClick={p.selectDate}
    >
      {p.date.format(p.dayFormat)}
    </BaseDayButton>
  );
};

export default DayButton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/datepicker/utils.ts

import dayjs from 'dayjs';

export interface IDayProps {
  date: dayjs.Dayjs;
  isCurrentMonth: boolean;
}

export const MONTH_NAMES = [
  'January',
  'February',
  'March',
  'April',
  'May',
  'June',
  'July',
  'August',
  'September',
  'October',
  'November',
  'December',
];

export const DAY_NAMES = ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sat', 'Su'];

const backFillFirstRow = (
  currentMonth: dayjs.Dayjs,
  monthRows: Array<IDayProps[]>
) => {
  const startOfMonth = dayjs(currentMonth).startOf('month');
  const calendarRows = monthRows;
  const firstRow = calendarRows[0];
  const dayOfFirst = startOfMonth.day(); // 0-6

  let daysToBackFill = 0;
  if (dayOfFirst > 1) {
    // Backfill to day of week (2-6)
    daysToBackFill = dayOfFirst - 1;
  } else if (dayOfFirst === 0) {
    // Backfill to Sunday (0)
    daysToBackFill = 6;
  }

  if (daysToBackFill > 0) {
    const previousMonth = startOfMonth.add(-1, 'month');
    const daysInPreviousMonth = previousMonth.daysInMonth();
    while (daysToBackFill > 0) {
      const date = previousMonth.date(daysInPreviousMonth - daysToBackFill + 1);
      firstRow.push({ date, isCurrentMonth: false });
      daysToBackFill -= 1;
    }
  }

  return calendarRows;
};

const fillRows = (
  currentMonth: dayjs.Dayjs,
  daysInMonth: number,
  monthRows: Array<IDayProps[]>
) => {
  const calendarRows = monthRows;
  [...Array(daysInMonth).keys()].forEach((day) => {
    const date = currentMonth.date(day + 1);
    if (
      calendarRows.length === 0 ||
      calendarRows[calendarRows.length - 1].length === 7
    ) {
      calendarRows.push([]);
    }

    calendarRows[calendarRows.length - 1].push({ date, isCurrentMonth: true });
  });
  return calendarRows;
};

const frontFillLastRow = (
  currentMonth: dayjs.Dayjs,
  monthRows: Array<IDayProps[]>
) => {
  const calendarRows = monthRows;
  const lastRow = calendarRows[calendarRows.length - 1];

  const daysToFrontFill = 7 - lastRow.length;

  if (daysToFrontFill > 0) {
    const nextMonth = currentMonth.add(1, 'month');
    for (let i = 1; i <= daysToFrontFill; i++) {
      const date = nextMonth.date(i);
      lastRow.push({ date, isCurrentMonth: false });
    }
  }

  return calendarRows;
};

export const getDaysInMonth = (currentMonth: dayjs.Dayjs) => {
  const daysInMonth = currentMonth.daysInMonth(); // 1 - 28-31

  const backFilledRows = backFillFirstRow(currentMonth, [[]]);
  const monthRows = fillRows(currentMonth, daysInMonth, backFilledRows);

  return frontFillLastRow(currentMonth, monthRows);
};

export const dateIsWithinRange = (
  date: dayjs.Dayjs,
  min?: dayjs.Dayjs,
  max?: dayjs.Dayjs
) => {
  if (min && max) {
    return dayjs(date).isBetween(min, max, 'd', '[]'); // include start and end
  } else if (min) {
    return dayjs(date).isAfter(min);
  } else if (max) {
    return dayjs(date).isBefore(max);
  } else {
    return true;
  }
};

export const isValidDate = (
  date: string,
  min?: dayjs.Dayjs,
  max?: dayjs.Dayjs
) => {
  if (date && dayjs(date).isValid()) {
    return dateIsWithinRange(dayjs(date), min, max);
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/datepicker/calendar.tsx

import dayjs from 'dayjs';
import isBetween from 'dayjs/plugin/isBetween';
import React from 'react';

import DayButton from '@/app/shared/components/form-controls/datepicker/day-button';
import TextField from '@/app/shared/components/form-controls/text-field';
import ButtonOutline from '@components/buttons/button-outline';
import ButtonSolid from '@components/buttons/button-solid';
import {
  DAY_NAMES,
  getDaysInMonth,
  isValidDate,
} from '@components/form-controls/datepicker/utils';
import OverlayBackground from '@components/overlays/overlay-background';
import { Strategy } from '@floating-ui/react';
import { ChevronLeft, ChevronRight } from '@untitled-ui/icons-react';

dayjs.extend(isBetween);

interface ICalendarProps {
  initialDate?: dayjs.Dayjs;
  setDate: (date: dayjs.Dayjs) => void;
  callback: () => void;
  dateFormat: string;
  dayFormat: string;
  monthHeaderFormat: string;
  position: {
    x: number;
    y: number;
    strategy: Strategy;
  };
  getFloatingProps: (
    userProps?: React.HTMLProps<HTMLElement> | undefined
  ) => Record<string, unknown>;
  minDate?: dayjs.Dayjs;
  maxDate?: dayjs.Dayjs;
  initIsInvalid?: boolean;
}

const Calendar = React.forwardRef(function (
  p: ICalendarProps,
  ref: React.ForwardedRef<HTMLDivElement | null>
) {
  //Defaults
  const { initialDate = dayjs() } = p;

  const [selectedDate, setSelectedDate] = React.useState(initialDate);
  const [currentMonth, setCurrentMonth] = React.useState(
    initialDate.startOf('month')
  );
  const [inputValue, setInputValue] = React.useState(
    initialDate.format(p.dateFormat)
  );
  const [invalidDate, setInvalidDate] = React.useState(
    p.initIsInvalid ?? false
  );

  // Apply date and close popover calendar
  const handleDateSelection = () => {
    p.setDate(selectedDate);
    p.callback();
  };

  // Month navigation
  const prev = () => {
    setCurrentMonth(currentMonth.add(-1, 'month'));
  };

  const next = () => {
    setCurrentMonth(currentMonth.add(1, 'month'));
  };

  const validateAndSetDate = (date: string) => {
    if (isValidDate(date, p.minDate, p.maxDate)) {
      setSelectedDate(dayjs(date));
      setCurrentMonth(dayjs(date));
    } else {
      setInvalidDate(true);
    }
  };

  // Handlers for Date Input field inside calendar
  const updateInputValue = (value: string) => {
    if (invalidDate) {
      setInvalidDate(false);
    }
    setInputValue(value);
  };

  const handleOnChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    updateInputValue(e.target.value);
  };

  const handleOnBlur = (e: React.FocusEvent<HTMLInputElement>) => {
    validateAndSetDate(e.currentTarget.value);
  };

  const handleKeypress = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      validateAndSetDate(e.currentTarget.value);
    }
  };

  // Day selection (also updates input field)
  const handleDateClick = (date: dayjs.Dayjs) => {
    setSelectedDate(date);
    updateInputValue(date.format(p.dateFormat));
  };

  // handle 'Today' button click
  const jumpToToday = () => {
    const today = dayjs();
    setSelectedDate(today);
    setCurrentMonth(today.startOf('month'));
    updateInputValue(today.format(p.dateFormat));
  };

  const style: React.CSSProperties = {
    position: p.position.strategy,
    top: p.position.y,
    left: p.position.x,
  };

  const isMobile = window.matchMedia('(max-width: 640px)').matches;

  if (isMobile) {
    style.position = 'fixed';
    style.top = '50%';
    style.left = '50%';
    style.transform = 'translate(-50%, -50%)';
  }

  return (
    <>
      <OverlayBackground hidden={!isMobile} />
      <div
        ref={ref}
        {...p.getFloatingProps}
        style={style}
        className="bg-white shadow-lg rounded-lg max-w-[328px] w-full z-50"
      >
        <div className="px-6 py-5">
          <div className="flex flex-row justify-between items-center mb-3">
            <button
              type="button"
              onClick={prev}
              className="w-9 h-9 mr-2 flex items-center justify-center rounded-full hover:bg-gray-50 focus-visible:outline focus-visible:outline-1 focus-visible:outline-accent-300"
            >
              <ChevronLeft
                className="text-gray-500"
                width={20}
                height={20}
                viewBox="0 0 24 24"
              />
            </button>
            <div className="text-base font-dmsans font-semibold text-gray-700">
              {currentMonth.format(p.monthHeaderFormat)}
            </div>
            <button
              type="button"
              onClick={next}
              className="w-9 h-9 ml-2 flex items-center justify-center rounded-full hover:bg-gray-50 focus-visible:outline focus-visible:outline-1 focus-visible:outline-accent-300"
            >
              <ChevronRight
                className="text-gray-500"
                width={20}
                height={20}
                viewBox="0 0 24 24"
              />
            </button>
          </div>
          <div className="flex flex-row items-center justify-center gap-3 mb-3">
            <TextField
              className="h-10"
              value={inputValue}
              onChange={handleOnChange}
              onBlur={handleOnBlur}
              onKeyDown={handleKeypress}
              isInvalid={invalidDate}
            />
            <ButtonOutline onClick={jumpToToday} variant="gray">
              Today
            </ButtonOutline>
          </div>
          <div className="grid grid-cols-7">
            {DAY_NAMES.map((weekDayName) => (
              <div
                key={weekDayName}
                className="text-sm font-dmsans font-semibold text-gray-700 w-10 h-10 flex items-center justify-center"
              >
                {weekDayName}
              </div>
            ))}
          </div>
          <div>
            {getDaysInMonth(currentMonth).map((row, i) => (
              <div key={`row-${i}`} className="grid grid-cols-7">
                {row.map((dayProps, j) => (
                  <DayButton
                    key={`day-${j}`}
                    selectedDate={selectedDate}
                    selectDate={() => handleDateClick(dayProps.date)}
                    dayFormat={p.dayFormat}
                    minDate={p.minDate}
                    maxDate={p.maxDate}
                    {...dayProps}
                  />
                ))}
              </div>
            ))}
          </div>
        </div>
        <div className="border-t border-gray-200 p-4 flex flex-row gap-3">
          <ButtonOutline className="w-full" onClick={p.callback} variant="gray">
            Cancel
          </ButtonOutline>
          <ButtonSolid
            className="w-full"
            onClick={handleDateSelection}
            variant="accent"
          >
            Apply
          </ButtonSolid>
        </div>
      </div>
    </>
  );
});

Calendar.displayName = 'Calendar';

export default Calendar;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/api-combobox/selected-options.tsx

import React from 'react';

import { getDisplayText } from './get-display-text';

interface ISelectedItemsProps {
  options: { [key: string]: any }[];
  displayKey?: string;
  onRemove: (option: any) => void;
}

const SelectedOptions: React.FC<ISelectedItemsProps> = ({
  options,
  displayKey,
  onRemove,
}) => {
  return (
    options.length > 0 && (
      <div className="mt-4 flex flex-row gap-3 flex-wrap">
        {options.map((selection: any, i) => (
          <span
            key={`${selection}-${i}`}
            className="inline-flex items-center gap-x-2 rounded-md bg-gray-200 px-2.5 py-1 text-xs font-medium text-gray-600"
          >
            {getDisplayText(selection, displayKey) ?? ''}
            <button
              type="button"
              className="group relative -mr-1 h-5 w-5 rounded-sm hover:bg-gray-500/20"
              onClick={() => onRemove(selection)}
            >
              <span className="sr-only">Remove</span>
              <svg
                viewBox="0 0 14 14"
                className="mx-auto h-3.5 w-3.5 stroke-gray-700/50 group-hover:stroke-gray-700/75"
              >
                <path d="M4 4l6 6m0-6l-6 6" />
              </svg>
              <span className="absolute -inset-1" />
            </button>
          </span>
        ))}
      </div>
    )
  );
};

export default SelectedOptions;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/api-combobox/api-combobox.tsx

import debounce from 'lodash.debounce';
import React, { useState } from 'react';
import { twMerge } from 'tailwind-merge';

import Label from '@components/form-controls/label';
import { Combobox as HeadlessCombobox } from '@headlessui/react';

import SearchResults from './search-results';
import SelectedOptions from './selected-options';

interface IApiComboboxProps {
  id?: string;
  name?: string;
  className?: string;
  searchApi: string;
  resultKey?: string;
  errorText?: string;
  noResultsText?: string;
  value: { [key: string]: any }[];
  placeholder?: string;
  onChange: (option: { [key: string]: any }[]) => void;
  onBlur?: (e: React.FocusEvent<Element>) => void;
  label?: string;
  helperTextTitle?: string;
  helperText?: string;
  labelRenderer?: () => React.ReactNode;
  isInvalid?: boolean;
  disabled?: boolean;
}

const getSearchResults = async (searchApi: string, query: string) => {
  const response = await fetch(`${searchApi}${query}`);

  if (!response.ok) {
    throw new Error('Error fetching search results.');
  }

  return await response.json();
};

const ApiCombobox: React.FC<IApiComboboxProps> = (p) => {
  const [query, setQuery] = useState('');
  const [hasSearched, setHasSearched] = useState(false);
  const [searching, setSearching] = useState(false);
  const [error, setError] = useState(false);
  const [searchResults, setSearchResults] = useState<
    Array<{ [key: string]: string }>
  >([]);

  const handleSearch = async (searchQuery: string) => {
    setSearchResults([]);
    setError(false);
    setHasSearched(false);
    setSearching(true);

    try {
      const results = await getSearchResults(p.searchApi, searchQuery);
      setSearchResults(results ?? []);
      setHasSearched(true);
    } catch (_e) {
      setError(true);
    } finally {
      setSearching(false);
    }
  };

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const debouncedSearch = React.useCallback(debounce(handleSearch, 1000), []);

  const handleReset = () => {
    debouncedSearch.cancel();
    setSearching(false);
    setSearchResults([]);
    setHasSearched(false);
    setError(false);
  };

  const handleQueryChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setQuery(e.target.value);

    if (e.target.value.length > 2) {
      debouncedSearch(e.target.value);
    } else {
      handleReset();
    }
  };

  const handleOptionSelect = (option: { [key: string]: any }[]) => {
    handleReset();
    setQuery('');
    p.onChange(option);
  };

  const removeItem = (item: any) => {
    const filtered = p.value.filter((i) => i !== item);
    p.onChange(filtered);
  };

  const errorStyle = p.isInvalid
    ? 'ring-1 ring-error-300 focus:ring-error-300'
    : '';

  const showOptions =
    searching || error || hasSearched || searchResults.length > 0;

  return (
    <div className={twMerge('w-full', p.className)}>
      <Label
        htmlFor={p.id}
        label={p.label}
        helperTextTitle={p.helperTextTitle}
        helperText={p.helperText}
      />
      <HeadlessCombobox
        as="div"
        id={p.id}
        name={p.name}
        value={p.value}
        onChange={handleOptionSelect}
        multiple
      >
        <div className="relative mt-2">
          <HeadlessCombobox.Input
            className={twMerge(
              `w-full rounded-md border-0 h-12 focus:shadow-drop bg-white py-1.5 pl-3 pr-10 font-medium text-gray-900 shadow-sm ring-1 ring-gray-300 focus:ring-1 focus:ring-accent-300 sm:text-sm sm:leading-6`,
              errorStyle
            )}
            value={query}
            placeholder={p.placeholder}
            onChange={handleQueryChange}
            onBlur={p.onBlur}
          />
          {showOptions && (
            <HeadlessCombobox.Options className="absolute z-10 mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm">
              <SearchResults
                selected={p.value}
                displayKey={p.resultKey}
                searching={searching}
                error={error}
                hasSearched={hasSearched}
                searchResults={searchResults}
                errorText={p.errorText}
                noResultsText={p.noResultsText}
              />
            </HeadlessCombobox.Options>
          )}
        </div>

        {/* Display the options selected by the user */}
        <SelectedOptions
          options={p.value}
          displayKey={p.resultKey}
          onRemove={removeItem}
        />
      </HeadlessCombobox>
    </div>
  );
};

export default ApiCombobox;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/api-combobox/get-display-text.ts

import get from 'lodash.get';

export const getDisplayText = (
  option: { [key: string]: any } | string,
  displayKey?: string
) => {
  if (typeof option === 'string') {
    return option ?? '';
  }
  return get(option, displayKey ?? '', '');
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/api-combobox/search-results.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import { Combobox } from '@headlessui/react';

import { getDisplayText } from './get-display-text';

interface ISearchResultsProps {
  selected: { [key: string]: any }[];
  displayKey?: string;
  searching: boolean;
  error: boolean;
  hasSearched: boolean;
  searchResults: { [key: string]: any }[];
  errorText?: string;
  noResultsText?: string;
}

const ResultOption: React.FC<{
  selected: { [key: string]: any }[];
  option: any;
  displayKey?: string;
}> = ({ option, displayKey, selected }) => {
  const optionText = getDisplayText(option, displayKey);
  const disabled = selected.some(
    (v) => getDisplayText(v, displayKey) === optionText
  );

  return (
    <Combobox.Option
      value={option}
      className={({ active, disabled }) =>
        twMerge([
          'relative cursor-default select-none py-2 pl-3 pr-9 text-gray-700 font-medium',
          active && 'bg-gray-50',
          disabled && 'bg-gray-50 text-gray-500 cursor-not-allowed',
        ])
      }
      disabled={disabled}
    >
      <span className="block truncate font-medium">{optionText}</span>
    </Combobox.Option>
  );
};

const SearchResults: React.FC<ISearchResultsProps> = ({
  selected,
  displayKey,
  searching,
  error,
  hasSearched,
  searchResults,
  errorText,
  noResultsText,
}) => {
  // Searching
  if (searching) {
    return (
      <div className="py-3 px-6 flex flex-col gap-2">
        {[...Array(3)].map((_e, i) => (
          <div
            key={`search-skeleton-${i}`}
            className="h-8 bg-gray-100 rounded-lg py-2 px-4 w-full animate-pulse"
          />
        ))}
      </div>
    );
  }

  // Error fetching results
  if (error) {
    return (
      <div className="py-1 px-6">
        <div className="font-dmsans text-gray-500 text-sm rounded-lg py-2 px-4 flex justify-between items-center w-full">
          {errorText ?? 'An error occurred.'}
        </div>
      </div>
    );
  }

  // Show Results
  if (searchResults.length > 0) {
    return searchResults.map((option, i) => (
      <ResultOption
        key={`search-result-${i}`}
        option={option}
        selected={selected}
        displayKey={displayKey}
      />
    ));
  }

  // No Results, no error
  if (hasSearched && searchResults.length === 0) {
    return (
      <div className="py-1 px-6">
        <div className="font-dmsans text-gray-500 text-sm rounded-lg py-2 px-4 flex justify-between items-center w-full">
          {noResultsText ?? 'No results found.'}
        </div>
      </div>
    );
  }
};

export default SearchResults;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/checkboxes/checkbox-button-input.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import { convertStringToKebabCase } from '@utils/utils';

interface ICheckboxButtonInputProps {
  id?: string;
  className?: string;
  option: string;

  groupName: string;
  groupValue: string[];
  groupOnChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  groupOnBlur?: (e: React.FocusEvent<HTMLInputElement>) => void;
  groupDisabled?: boolean;
  groupIsInvalid?: boolean;
}

const CheckboxButtonInput: React.FC<ICheckboxButtonInputProps> = (p) => {
  const errorStyle = p.groupIsInvalid ? 'border-error-300' : '';

  const optionId = React.useMemo(
    () => `${convertStringToKebabCase(p.groupName + p.option)}`,
    [p.groupName, p.option]
  );
  return (
    <div>
      <input
        id={optionId}
        className="opacity-0 w-0 absolute peer"
        name={p.groupName}
        type="checkbox"
        value={p.option}
        onChange={p.groupOnChange}
        onBlur={p.groupOnBlur}
        checked={p.groupValue.includes(p.option)}
        disabled={p.groupDisabled}
      />
      <label
        htmlFor={optionId}
        className={twMerge([
          `inline-flex items-center justify-center px-[18px] py-2.5 rounded-lg bg-white border border-gray-300 cursor-pointer 
          font-dmsans  text-base text-gray-700 
          peer-focus:ring-1 font-semibold peer-focus:ring-accent-200 
          peer-checked:border-accent-400 peer-checked:text-accent-700 peer-checked:bg-accent-50 
          peer-enabled:hover:text-accent-700 peer-enabled:hover:border-accent-300 peer-enabled:hover:bg-accent-100 
          peer-disabled:cursor-not-allowed peer-disabled:bg-gray-100`,
          p.className,
          errorStyle,
        ])}
      >
        {p.option}
      </label>
    </div>
  );
};

export default CheckboxButtonInput;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/checkboxes/checkbox-group-input.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import { convertStringToKebabCase } from '@utils/utils';

interface IRadioInputProps {
  id?: string;
  className?: string;
  option: string;

  groupName: string;
  groupValue: string[];
  groupOnChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  groupOnBlur?: (e: React.FocusEvent<HTMLInputElement>) => void;
  groupDisabled?: boolean;
  groupIsInvalid?: boolean;
}

const CheckboxGroupInput: React.FC<IRadioInputProps> = (p) => {
  const errorStyle = p.groupIsInvalid ? 'border-error-300' : '';

  const optionId = React.useMemo(
    () => `${convertStringToKebabCase(p.groupName + p.option)}`,
    [p.option, p.groupName]
  );
  return (
    <div className="flex items-center">
      <input
        id={optionId}
        className={twMerge([
          `checkbox-input h-4 w-4 border-gray-300 text-accent-100 rounded
                  hover:ring-1 hover:ring-accent-300 hover:ring-offset-0 hover:shadow-drop 
                  focus:ring-1 focus:ring-accent-700 focus:ring-offset-0 focus:shadow-drop 
                  checked:border-accent-700
                  disabled:pointer-events-none disabled:bg-gray-100 disabled:border-gray-300`,
          errorStyle,
        ])}
        name={p.groupName}
        type="checkbox"
        value={p.option}
        onChange={p.groupOnChange}
        onBlur={p.groupOnBlur}
        checked={p.groupValue.includes(p.option)}
        disabled={p.groupDisabled}
      />
      <label
        htmlFor={optionId}
        className="ml-3 block font-dmsans text-sm font-normal text-gray-600"
      >
        {p.option}
      </label>
    </div>
  );
};

export default CheckboxGroupInput;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/checkboxes/checkbox-group.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import CheckboxButtonInput from '@/app/shared/components/form-controls/checkboxes/checkbox-button-input';
import CheckboxGroupInput from '@/app/shared/components/form-controls/checkboxes/checkbox-group-input';

import Label from '../label';

interface ICheckboxGroupProps {
  id?: string;
  name: string;
  className?: string;
  options: string[];
  variant?: string | null;
  value: string[];
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onBlur?: (e: React.FocusEvent<HTMLInputElement>) => void;
  disabled?: boolean;
  isInvalid?: boolean;
  label?: string;
  helperTextTitle?: string;
  helperText?: string;
}

const CheckboxGroup: React.FC<ICheckboxGroupProps> = (p) => {
  const isButtonStyled = p.variant === 'buttonStyled';
  const CheckboxComponent = isButtonStyled
    ? CheckboxButtonInput
    : CheckboxGroupInput;

  return p.options && p.options.length > 0 ? (
    <div>
      <Label
        id={p.id}
        label={p.label}
        helperTextTitle={p.helperTextTitle}
        helperText={p.helperText}
      />
      <fieldset>
        <legend className="sr-only">{p.label}</legend>
        <div
          className={twMerge([
            isButtonStyled
              ? 'flex flex-row gap-2 items-center flex-wrap'
              : `space-y-3`,
          ])}
        >
          {p.options.map((option, i) => (
            <div key={`option-${i}`}>
              <CheckboxComponent
                groupName={p.name}
                groupValue={p.value}
                groupOnChange={p.onChange}
                groupOnBlur={p.onBlur}
                groupDisabled={p.disabled}
                groupIsInvalid={p.isInvalid}
                option={option}
              />
            </div>
          ))}
        </div>
      </fieldset>
    </div>
  ) : null;
};

export default CheckboxGroup;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/checkboxes/checkbox.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import Label from '../label';

interface IRadioInputProps {
  id?: string;
  className?: string;
  label: string;
  name: string;
  checked: boolean;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onBlur?: (e: React.FocusEvent<HTMLInputElement>) => void;
  disabled?: boolean;
  isInvalid?: boolean;
  helperTextTitle?: string;
  helperText?: string;
}

const CheckboxInput: React.FC<IRadioInputProps> = (p) => {
  const errorStyle = p.isInvalid ? 'border-error-300' : '';

  return (
    <div className="flex items-start">
      <input
        id={p.id}
        className={twMerge([
          `mt-1 checkbox-input h-4 w-4 border-gray-300 text-accent-100 rounded
                  hover:ring-1 hover:ring-accent-300 hover:ring-offset-0 hover:shadow-drop 
                  focus:ring-1 focus:ring-accent-700 focus:ring-offset-0 focus:shadow-drop 
                  checked:border-accent-700
                  disabled:pointer-events-none disabled:bg-gray-100 disabled:border-gray-300`,
          p.className,
          errorStyle,
        ])}
        name={p.name}
        type="checkbox"
        onChange={p.onChange}
        onBlur={p.onBlur}
        checked={p.checked}
        disabled={p.disabled}
      />
      <Label
        htmlFor={p.id}
        label={p.label}
        helperTextTitle={p.helperTextTitle}
        helperText={p.helperText}
        className="ml-3 mb-0"
        labelClassName="font-normal"
      />
    </div>
  );
};

export default CheckboxInput;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/radio-group/radio-input.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import { convertStringToKebabCase } from '@utils/utils';

interface IRadioInputProps {
  id?: string;
  className?: string;
  option: string;

  radioGroupName: string;
  radioGroupValue: string;
  radioGroupOnChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  radioGroupOnBlur?: (e: React.FocusEvent<HTMLInputElement>) => void;
  radioGroupDisabled?: boolean;
  radioGroupIsInvalid?: boolean;
}

const RadioInput: React.FC<IRadioInputProps> = (p) => {
  const errorStyle = p.radioGroupIsInvalid ? 'border-error-300' : '';

  const optionId = React.useMemo(
    () => `${convertStringToKebabCase(p.radioGroupName + p.option)}`,
    [p.option, p.radioGroupName]
  );
  return (
    <div className="flex items-center">
      <input
        id={optionId}
        className={twMerge([
          `radio-input h-4 w-4 border-gray-300 text-accent-100 
                  hover:ring-1 hover:ring-accent-300 hover:ring-offset-0 hover:shadow-drop 
                  focus:ring-1 focus:ring-accent-700 focus:ring-offset-0 focus:shadow-drop 
                  checked:border-accent-700 
                  disabled:pointer-events-none disabled:bg-gray-100 disabled:border-gray-300`,
          errorStyle,
        ])}
        name={p.radioGroupName}
        type="radio"
        value={p.option}
        onChange={p.radioGroupOnChange}
        onBlur={p.radioGroupOnBlur}
        checked={p.radioGroupValue === p.option}
        disabled={p.radioGroupDisabled}
      />
      <label htmlFor={optionId} className="ml-3 block text-sm text-gray-600">
        {p.option}
      </label>
    </div>
  );
};

export default RadioInput;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/radio-group/radio-group.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import RadioButtonInput from '@/app/shared/components/form-controls/radio-group/radio-button-input';
import RadioInput from '@/app/shared/components/form-controls/radio-group/radio-input';
import { ImageOption } from '@prisma/client';

import Label from '../label';
import RadioImageButtonInput from './radio-image-button-input';

interface IRadioButtonGroupProps {
  id?: string;
  name: string;
  className?: string;
  options: string[];
  imageOptions?: ImageOption[];
  variant?: string | null;
  value: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  onBlur?: (e: React.FocusEvent<HTMLInputElement>) => void;
  disabled?: boolean;
  isInvalid?: boolean;
  label?: string;
  helperTextTitle?: string;
  helperText?: string;
}

const RadioButtonGroup: React.FC<IRadioButtonGroupProps> = (p) => {
  if (p.variant === 'imageStyled') {
    return p.imageOptions && p.imageOptions.length > 0 ? (
      <div>
        <Label
          id={p.id}
          label={p.label}
          helperTextTitle={p.helperTextTitle}
          helperText={p.helperText}
        />
        <fieldset>
          <legend className="sr-only">{p.label}</legend>
          <div className="flex flex-row gap-2 items-center flex-wrap">
            {p.imageOptions.map((option, i) => (
              <div key={`option-${i}`}>
                <RadioImageButtonInput
                  radioGroupName={p.name}
                  radioGroupValue={p.value}
                  radioGroupOnChange={p.onChange}
                  radioGroupOnBlur={p.onBlur}
                  radioGroupDisabled={p.disabled}
                  radioGroupIsInvalid={p.isInvalid}
                  option={option}
                />
              </div>
            ))}
          </div>
        </fieldset>
      </div>
    ) : null;
  }

  const isButtonStyled = p.variant === 'buttonStyled';
  const RadioInputComponent = isButtonStyled ? RadioButtonInput : RadioInput;

  return p.options && p.options.length > 0 ? (
    <div>
      <Label
        id={p.id}
        label={p.label}
        helperTextTitle={p.helperTextTitle}
        helperText={p.helperText}
      />
      <fieldset>
        <legend className="sr-only">{p.label}</legend>
        <div
          className={twMerge([
            isButtonStyled
              ? 'flex flex-row gap-2 items-center flex-wrap'
              : `space-y-3`,
          ])}
        >
          {p.options.map((option, i) => (
            <div key={`option-${i}`}>
              <RadioInputComponent
                radioGroupName={p.name}
                radioGroupValue={p.value}
                radioGroupOnChange={p.onChange}
                radioGroupOnBlur={p.onBlur}
                radioGroupDisabled={p.disabled}
                radioGroupIsInvalid={p.isInvalid}
                option={option}
              />
            </div>
          ))}
        </div>
      </fieldset>
    </div>
  ) : null;
};

export default RadioButtonGroup;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/radio-group/radio-button-input.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

import { convertStringToKebabCase } from '@utils/utils';

interface IRadioInputProps {
  id?: string;
  className?: string;
  option: string;

  radioGroupName: string;
  radioGroupValue: string;
  radioGroupOnChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  radioGroupOnBlur?: (e: React.FocusEvent<HTMLInputElement>) => void;
  radioGroupDisabled?: boolean;
  radioGroupIsInvalid?: boolean;
}

const RadioInput: React.FC<IRadioInputProps> = (p) => {
  const errorStyle = p.radioGroupIsInvalid ? 'border-error-300' : '';

  const optionId = React.useMemo(
    () => `${convertStringToKebabCase(p.radioGroupName + p.option)}`,
    [p.radioGroupName, p.option]
  );
  return (
    <div>
      <input
        id={optionId}
        className="opacity-0 w-0 absolute peer"
        name={p.radioGroupName}
        type="radio"
        value={p.option}
        onChange={p.radioGroupOnChange}
        onBlur={p.radioGroupOnBlur}
        checked={p.radioGroupValue === p.option}
        disabled={p.radioGroupDisabled}
      />
      <label
        htmlFor={optionId}
        className={twMerge([
          `inline-flex items-center justify-center px-[18px] py-2.5 rounded-lg bg-white border border-gray-300 cursor-pointer 
          font-dmsans text-base text-gray-700 
          peer-focus:ring-1 font-semibold peer-focus:ring-accent-200 
          peer-checked:border-accent-400 peer-checked:text-accent-700 peer-checked:bg-accent-50 
          peer-enabled:hover:text-accent-700 peer-enabled:hover:border-accent-300 peer-enabled:hover:bg-accent-100 
          peer-disabled:cursor-not-allowed peer-disabled:bg-gray-100`,
          p.className,
          errorStyle,
        ])}
      >
        {p.option}
      </label>
    </div>
  );
};

export default RadioInput;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/form-controls/radio-group/radio-image-button-input.tsx

import Image from 'next/image';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import { ImageOption } from '@prisma/client';
import { convertStringToKebabCase } from '@utils/utils';

interface IRadioImageButtonInputProps {
  id?: string;
  className?: string;
  option: ImageOption;
  radioGroupName: string;
  radioGroupValue: string;
  radioGroupOnChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  radioGroupOnBlur?: (e: React.FocusEvent<HTMLInputElement>) => void;
  radioGroupDisabled?: boolean;
  radioGroupIsInvalid?: boolean;
}

const RadioImageButtonInput: React.FC<IRadioImageButtonInputProps> = (p) => {
  const errorStyle = p.radioGroupIsInvalid ? 'border-error-300' : '';

  const optionId = React.useMemo(
    () => `${convertStringToKebabCase(p.radioGroupName + p.option.text)}`,
    [p.radioGroupName, p.option]
  );
  return (
    <div>
      <input
        id={optionId}
        className="opacity-0 w-0 absolute peer"
        name={p.radioGroupName}
        type="radio"
        value={p.option.text}
        onChange={p.radioGroupOnChange}
        onBlur={p.radioGroupOnBlur}
        checked={p.radioGroupValue === p.option.text}
        disabled={p.radioGroupDisabled}
      />
      <label
        htmlFor={optionId}
        className={twMerge([
          `inline-flex gap-2 items-center justify-center px-3 py-2 rounded-lg bg-white border border-gray-300 cursor-pointer 
          font-dmsans text-base text-gray-700 
          peer-focus:ring-1 font-semibold peer-focus:ring-accent-200 
          peer-checked:border-accent-400 peer-checked:text-accent-700 peer-checked:bg-accent-50 
          peer-enabled:hover:text-accent-700 peer-enabled:hover:border-accent-300 peer-enabled:hover:bg-accent-100 
          peer-disabled:cursor-not-allowed peer-disabled:bg-gray-100`,
          p.className,
          errorStyle,
        ])}
      >
        <Image src={p.option.image} alt="" width={32} height={32} />
        <span>{p.option.text}</span>
      </label>
    </div>
  );
};

export default RadioImageButtonInput;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/checkout/checkout-data-wrapper.tsx

'use client';

import { ProductPageDocument } from 'prismicio-types';

import { queryClient } from '@/app/shared/components/context-wrapper';
import LoadingSpinner from '@/app/shared/components/loading-indicators/loading-spinner';
import { ExtendedUser } from '@/app/shared/models/extensions/identity/types/identityTypes';
import { CartInclude } from '@/app/shared/types';
import { cartPriceReturn } from '@/utils/ecommerce/cartUtils';
import { useQuery } from '@tanstack/react-query';

import CheckoutModule from './checkout-module';
import LoadError from './load-error';

const getCart = async () => {
  const res = await fetch('/api/ecommerce/cart/get-cart-with-content');
  const data = (await res.json()) as {
    cart: CartInclude;
    content: ProductPageDocument[];
  };

  return data;
};

const getCartPrice = async () => {
  const res = await fetch('/api/ecommerce/cart/price');
  return (await res.json()) as cartPriceReturn;
};

const refreshCart = () => {
  queryClient.invalidateQueries({ queryKey: ['cart'] });
  queryClient.invalidateQueries({ queryKey: ['cart-price'] });
};

const CheckoutDataWrapper: React.FC<{
  onSubmit?: () => Promise<void>;
  onSuccess: () => void;
  user: ExtendedUser;
  disableConsultationRemove: boolean;
}> = (p) => {
  const {
    isLoading: cartIsLoading,
    isError: cartError,
    data: cart,
  } = useQuery(['cart'], getCart, {
    refetchOnWindowFocus: false,
  });
  const {
    isLoading: priceIsLoading,
    isError: priceError,
    data: cartPrice,
  } = useQuery(['cart-price'], getCartPrice, {
    refetchOnWindowFocus: false,
  });

  if (cartIsLoading || priceIsLoading) {
    return (
      <div className="flex justify-center px-6 py-10">
        <LoadingSpinner fillClass="fill-accent-500" />
      </div>
    );
  }

  if (cartError || priceError) {
    return <LoadError />;
  }

  const hasItems =
    cart?.cart &&
    (cart?.cart?.cartProducts.length > 0 ||
      cart?.cart?.cartSubscriptionProducts.length > 0);

  return hasItems && cart.content ? (
    <div className="mx-auto w-full flex flex-col max-w-lg gap-y-6 lg:flex-row-reverse lg:overflow-hidden lg:max-w-6xl lg:gap-x-4">
      <CheckoutModule
        user={p.user}
        cart={cart.cart}
        cartPrice={cartPrice}
        productsContent={cart.content}
        startRefresh={refreshCart}
        isRefreshing={cartIsLoading || priceIsLoading}
        onSubmit={p.onSubmit}
        onSuccess={p.onSuccess}
        disableConsultationRemove={p.disableConsultationRemove}
      />
    </div>
  ) : (
    <LoadError />
  );
};

export default CheckoutDataWrapper;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/checkout/load-error.tsx

import { ExclamationTriangleIcon } from '@heroicons/react/20/solid';

const LoadError = () => {
  return (
    <div className="mx-auto rounded-lg bg-white px-4 pb-4 pt-5 text-left shadow-xl sm:my-8 sm:w-full sm:max-w-md sm:p-6">
      <div>
        <div className="mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-red-100">
          <ExclamationTriangleIcon
            aria-hidden="true"
            className="h-6 w-6 text-red-600"
          />
        </div>
        <div className="mt-3 text-center sm:mt-5">
          <p className="text-base font-semibold leading-6 text-gray-900">
            Something went wrong
          </p>
          <div className="mt-2">
            <p className="text-sm text-gray-500">
              We were unable to process your cart. We apologize for the
              inconvenience. Please try again later.
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default LoadError;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/checkout/stripe-checkout-wrapper.tsx

'use client';

import { ProductPageDocument } from 'prismicio-types';
import React from 'react';

import { ExtendedUser } from '@/app/shared/models/extensions/identity/types/identityTypes';
import { CartInclude } from '@/app/shared/types';
import { cartPriceReturn } from '@/utils/ecommerce/cartUtils';
import { Elements } from '@stripe/react-stripe-js';
import { loadStripe } from '@stripe/stripe-js';

import CheckoutForm from './stripe-checkout-form';

const stripePromise = loadStripe(
  `${process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY}`
);

interface IStripeCheckoutWrapperProps {
  user: ExtendedUser;
  isRefreshing: boolean;
  cart: CartInclude;
  cartPrice: cartPriceReturn;
  productsContent: ProductPageDocument[];
  onSubmit?: () => Promise<void>;
  onSuccess: () => void;
}

const StripeCheckoutWrapper: React.FC<IStripeCheckoutWrapperProps> = (p) => {
  const options = {
    mode: 'setup' as any,
    currency: 'usd',
    paymentMethodCreation: 'manual' as any,
    appearance: {
      theme: 'stripe' as any,
      variables: {
        colorPrimary: '#107569',
        colorBackground: '#ffffff',
        colorText: '#344054',
        colorDanger: '#F04438',
        fontFamily: 'DM Sans, system-ui, sans-serif',
        borderRadius: '4px',
        iconCheckmarkColor: '#107569',
        // See all possible variables below
      },
      rules: {
        '.Label': {
          color: '#344054',
          fontFamily: 'var(--font-dmsans)',
          fontSize: '14px',
          fontWeight: '500',
          lineHeight: '20px',
        },
        '.Input': {
          color: '#101828',
          fontFamily: 'var(--font-dmsans)',
          fontSize: '16px',
          fontWeight: '400',
          lineHeight: '24px',
          padding: '8px 12px',
          borderRadius: '8px',
          border: '1px solid #D0D5DD',
          boxShadow: '0px 1px 2px 0px rgba(16, 24, 40, 0.05)',
        },
        '.Input:focus': {
          border: '1px solid #5FE9D0',
          boxShadow: '0px 0px 0px 4px rgba(21, 183, 158, 0.10)',
        },
        '.Input--invalid': {
          border: '1px solid var(--Error-300, #FDA29B)',
          boxShadow: '0px 1px 2px 0px rgba(16, 24, 40, 0.05)',
        },
        '.Error': {
          color: '#F04438',
          fontFamily: 'var(--font-dmsans)',
          fontSize: '14px',
          fontWeight: '400',
          lineHeight: '20px',
        },
        '.CheckboxInput--checked': {
          borderRadius: '4px',
          border: '1px solid #107569',
          backgroundColor: '#F0FDF9',
          color: '#107569',
        },
      },
    },
  };

  return (
    <div className="w-full">
      <Elements stripe={stripePromise} options={options}>
        <CheckoutForm {...p} />
      </Elements>
    </div>
  );
};

export default StripeCheckoutWrapper;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/checkout/purchase-confirmation.tsx

import { CheckIcon } from '@heroicons/react/20/solid';

const PurchaseConfirmation = () => {
  return (
    <div className="mx-auto rounded-lg bg-white px-4 pb-4 pt-5 text-left shadow-xl sm:my-8 sm:w-full sm:max-w-md sm:p-6">
      <div>
        <div className="mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-green-100">
          <CheckIcon aria-hidden="true" className="h-6 w-6 text-green-600" />
        </div>
        <div className="mt-3 text-center sm:mt-5">
          <p className="text-base font-semibold leading-6 text-gray-900">
            Thank You for Your Purchase!
          </p>
          <div className="mt-2">
            <p className="text-sm text-gray-500">
              Your consultation purchase is confirmed. Please click the button
              below to continue.
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default PurchaseConfirmation;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/checkout/checkout-module.tsx

'use client';

import { ProductPageDocument } from 'prismicio-types';
import React from 'react';

import { ExtendedUser } from '@/app/shared/models/extensions/identity/types/identityTypes';
import { CartInclude } from '@/app/shared/types';
import { cartPriceReturn } from '@/utils/ecommerce/cartUtils';

import CartSummary from './cart-summary/cart-summary';
import StripeCheckoutWrapper from './stripe-checkout-wrapper';

export interface ICheckoutProps {
  user: ExtendedUser;
  cart: CartInclude;
  cartPrice: cartPriceReturn;
  productsContent: ProductPageDocument[];
  startRefresh: () => void;
  isRefreshing: boolean;
  onSuccess: () => void;
  disableConsultationRemove: boolean;
  onSubmit?: () => Promise<void>;
}

const CheckoutModule: React.FC<ICheckoutProps> = (p) => {
  React.useEffect(() => {
    const products = formatProducts(
      p.cart.cartProducts,
      p.cart.cartSubscriptionProducts
    );
    const dataLayer = window?.dataLayer || [];
    dataLayer.push({ ecommerce: null });
    dataLayer.push({
      event: 'begin_checkout',
      ecommerce: {
        currency: 'USD',
        value: (p.cartPrice.productPrice - p.cartPrice.promoCodeDiscount) / 100,
        coupon: p.cart.promoCodeCode,
        items: products,
      },
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <CartSummary
        cart={p.cart}
        cartPrice={p.cartPrice}
        productsContent={p.productsContent}
        isRefreshing={p.isRefreshing}
        startRefresh={p.startRefresh}
        disableConsultationRemove={p.disableConsultationRemove}
      />

      <section aria-labelledby="payment-heading" className="flex w-full">
        <h2 id="payment-heading" className="sr-only">
          Payment and shipping details
        </h2>

        <StripeCheckoutWrapper
          user={p.user}
          isRefreshing={p.isRefreshing}
          cart={p.cart}
          cartPrice={p.cartPrice}
          productsContent={p.productsContent}
          onSuccess={p.onSuccess}
          onSubmit={p.onSubmit}
        />
      </section>
    </>
  );
};

const formatProducts = (
  cartProducts: CartInclude['cartProducts'],
  cartSubscriptionProducts: CartInclude['cartSubscriptionProducts']
) => {
  const products = cartProducts.map((products, index) => {
    return {
      item_id: products.product.id,
      item_name: products.product.name,
      index: index,
      item_category: products.product.category,
      quantity: products.quantity,
      price: products.product.price / 100,
    };
  });

  products.push(
    ...cartSubscriptionProducts.map((subs, index) => {
      return {
        item_id: subs.subscriptionProduct.id,
        item_name: subs.subscriptionProduct.name,
        index: index + cartProducts.length,
        item_category: subs.subscriptionProduct.category,
        quantity: subs.quantity,
        price: subs.subscriptionProduct.price / 100,
      };
    })
  );

  return products;
};

export default CheckoutModule;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/checkout/line-items-skeleton.tsx

const LineItemSkeleton = () => {
  return (
    <div className="animate-pulse">
      <div className="mt-10 divide-y divide-gray-200">
        <div className="flex justify-between pb-3">
          <div className="w-24 h-5 bg-gray-200 rounded" />
          <div className="w-12 h-5 bg-gray-200 rounded" />
        </div>
        <div className="flex justify-between py-3">
          <div className="w-24 h-5 bg-gray-200 rounded" />
          <div className="w-12 h-5 bg-gray-200 rounded" />
        </div>
        <div className="flex justify-between py-3">
          <div className="w-24 h-5 bg-gray-200 rounded" />
          <div className="w-12 h-5 bg-gray-200 rounded" />
        </div>
        <div className="flex justify-between py-3">
          <div className="w-24 h-5 bg-gray-200 rounded" />
          <div className="w-12 h-5 bg-gray-200 rounded" />
        </div>
        <div className="flex justify-between py-3">
          <div className="w-24 h-5 bg-gray-200 rounded" />
          <div className="w-12 h-5 bg-gray-200 rounded" />
        </div>
      </div>
    </div>
  );
};

export default LineItemSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/checkout/stripe-checkout-form.tsx

'use client';

import { ProductPageDocument } from 'prismicio-types';
import React from 'react';

import ButtonSolid from '@/app/shared/components/buttons/button-solid';
import LoadingSpinner from '@/app/shared/components/loading-indicators/loading-spinner';
import { ExtendedUser } from '@/app/shared/models/extensions/identity/types/identityTypes';
import { CartInclude } from '@/app/shared/types';
import { cartPriceReturn } from '@/utils/ecommerce/cartUtils';
import { getFamilyMemberHeader, stateAbbreviationMap } from '@/utils/utils';
import {
  AddressElement,
  PaymentElement,
  useElements,
  useStripe,
} from '@stripe/react-stripe-js';

interface IStripeCheckoutFormProps {
  user: ExtendedUser;
  isRefreshing: boolean;
  cart: CartInclude;
  cartPrice: cartPriceReturn;
  productsContent: ProductPageDocument[];
  onSubmit?: () => Promise<void>;
  onSuccess: () => void;
}

const StripeCheckoutForm: React.FC<IStripeCheckoutFormProps> = (p) => {
  const stripe = useStripe();
  const elements = useElements();

  const [errorMessage, setErrorMessage] = React.useState('');
  const [loading, setLoading] = React.useState(false);

  if (!stripe || !elements) {
    // Stripe.js has not yet loaded.
    return null;
  }

  const handleErrorStates = (error: any) => {
    setLoading(false);
    setErrorMessage(error.message);
  };

  const handleCreatePaymentMethodError = (error: any) => {
    handleErrorStates(error);
  };

  const handleServerResponse = async (response: any) => {
    if (!response.ok) {
      handleErrorStates({ message: 'Unable to process payment' });
    } else {
      setLoading(false);
      p.onSuccess();
    }
  };

  const handleSubmit = async (event: any) => {
    event.preventDefault();

    if (!stripe) {
      // Stripe.js hasn't yet loaded.
      // Make sure to disable form submission until Stripe.js has loaded.
      return;
    }

    setLoading(true);

    // Trigger form validation and wallet collection
    const { error: submitError } = await elements.submit();
    if (submitError) {
      handleCreatePaymentMethodError(submitError);
      return;
    }

    // Create the PaymentMethod using the details collected by the Payment Element
    const { error, paymentMethod } = await stripe.createPaymentMethod({
      elements,
    });

    if (error) {
      // This point is only reached if there's an immediate error when
      // creating the PaymentMethod. (for example, payment details incomplete)
      handleCreatePaymentMethodError(error);
      return;
    }

    const addressElement = elements.getElement('address');

    if (!addressElement) {
      handleErrorStates({
        message: 'Please check address details.',
      });
      return;
    }

    const { value } = await addressElement.getValue();

    const payload = {
      paymentMethodId: paymentMethod.id,
      paymentProvider: 'STRIPE',
      address: {
        name: value.name,
        address1: value.address.line1,
        address2: value.address.line2,
        city: value.address.city,
        state: value.address.state,
        zip: value.address.postal_code,
      },
    };

    const familyMemberHeader = getFamilyMemberHeader();

    const headers = {
      'Content-Type': 'application/json',
      ...(familyMemberHeader ? familyMemberHeader : {}),
    };

    // Add payment method to user prior to purchase

    const paymentMethodAddResponse = await fetch(
      '/api/ecommerce/customer-info/payment-method',
      {
        method: 'POST',
        headers,
        body: JSON.stringify({
          paymentMethodId: payload.paymentMethodId,
          paymentProvider: payload.paymentProvider,
          customerData: payload.address,
        }),
      }
    );

    if (!paymentMethodAddResponse.ok) {
      const error = await paymentMethodAddResponse.json();
      handleErrorStates({ message: error.message });
      return;
    }

    if (p.onSubmit) {
      await p.onSubmit();
    }

    // TODO: move this logic to a generic ecom logging utility
    const products = p.cart.cartProducts.map((cartProduct, index) => {
      return {
        item_id: cartProduct.product.id,
        item_name: cartProduct.product.name,
        index: index,
        item_category: cartProduct.product.category,
        quantity: cartProduct.quantity,
        price: cartProduct.product.price / 100,
      };
    });

    products.push(
      ...p.cart.cartSubscriptionProducts.map((cartProduct, index) => {
        return {
          item_id: cartProduct.subscriptionProduct.id,
          item_name: cartProduct.subscriptionProduct.name,
          index: index + p.cart.cartProducts.length,
          item_category: cartProduct.subscriptionProduct.category,
          quantity: cartProduct.quantity,
          price: cartProduct.subscriptionProduct.price / 100,
        };
      })
    );

    const dataLayer = window?.dataLayer || [];

    dataLayer.push({ ecommerce: null });
    dataLayer.push({
      event: 'add_payment_info',
      ecommerce: {
        currency: 'USD',
        value: (p.cartPrice.productPrice - p.cartPrice.promoCodeDiscount) / 100,
        coupon: p.cart.promoCodeCode,
        items: products,
      },
    });

    // Invoke Stript Purchase
    const res = await fetch('/api/ecommerce/cart/purchase', {
      method: 'POST',
      headers,
      body: JSON.stringify(payload),
    });

    if (res.ok) {
      const responseBody = await res.json();

      dataLayer.push({ ecommerce: null });
      dataLayer.push({
        event: 'purchase',
        ecommerce: {
          currency: 'USD',
          value:
            (p.cartPrice.productPrice - p.cartPrice.promoCodeDiscount) / 100,
          transaction_id: responseBody.id,
          coupon: p.cart.promoCodeCode,
          items: products,
        },
      });
    }

    // Handle any next actions or errors.
    handleServerResponse(res);
  };

  const user = p.user;

  const addressDefault = user.addresses.find((address) => address.default);

  const defaultValues = {
    name: user?.firstName ? `${user.firstName} ${user.lastName}` : null,
    address: {
      line1: addressDefault?.address1,
      line2: addressDefault?.address2,
      city: addressDefault?.city,
      state: addressDefault?.state
        ? stateAbbreviationMap?.[addressDefault.state]
        : null,
      postal_code: addressDefault?.zip,
      country: 'US',
    },
  };

  return (
    <div>
      <AddressElement
        options={{
          mode: 'shipping',
          allowedCountries: ['US'],
          defaultValues,
        }}
      />
      <PaymentElement className="mt-4" />

      <div className="mt-6">
        <ButtonSolid
          type="button"
          variant="accent"
          className="py-2 px-8 w-full flex flex-row items-center justify-center"
          disabled={!stripe || loading || p.isRefreshing}
          onClick={handleSubmit}
        >
          {loading ? (
            <>
              <LoadingSpinner fillClass="fill-accent-300" size="sm" />
              <span className="ml-2">Submitting</span>
            </>
          ) : (
            <span>Checkout</span>
          )}
        </ButtonSolid>
      </div>
      {errorMessage && (
        <p className="text-sm text-error-500 font-dmsans">{errorMessage}</p>
      )}
    </div>
  );
};

export default StripeCheckoutForm;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/checkout/cart-summary/cost-details.tsx

'use client';

import React, { useEffect } from 'react';
import Cookies from 'universal-cookie';

import ButtonSolid from '@/app/shared/components/buttons/button-solid';
import TextField from '@/app/shared/components/form-controls/text-field';
import LoadingSpinner from '@/app/shared/components/loading-indicators/loading-spinner';
import { CartInclude } from '@/app/shared/types';
import { cartPriceReturn } from '@/utils/ecommerce/cartUtils';
import { formatCurrency, getFamilyMemberHeader } from '@/utils/utils';
import MarkdownElement from '@components/markdown-element';
import { XMarkIcon } from '@heroicons/react/20/solid';

import LineItemSkeleton from '../line-items-skeleton';

interface ICostDetailsProps {
  cartPrice: cartPriceReturn;
  cart: CartInclude;
  isRefreshing: boolean;
  startRefresh: () => void;
}

const addPromoCodeToCart = async (
  code: string,
  autoAddProductToCart = false
) => {
  try {
    const res = await fetch(`/api/ecommerce/cart/add-promo-code`, {
      method: 'POST',
      body: JSON.stringify({
        code: code.toUpperCase(),
        addProductToCart: autoAddProductToCart,
      }),
      headers: getFamilyMemberHeader(),
    });

    if (!res.ok) {
      throw new Error('Could not add promo code to cart');
    }

    return { success: true };
  } catch (error) {
    return { success: false };
  }
};

const removePromoCodeFromCart = async () => {
  try {
    const res = await fetch(`/api/ecommerce/cart/remove-promo-code`, {
      method: 'POST',
      body: JSON.stringify({}),
      headers: getFamilyMemberHeader(),
    });

    if (!res.ok) {
      throw new Error('Could not remove promo code from cart');
    }

    return { success: true };
  } catch (error) {
    return { success: false };
  }
};

const CostDetails: React.FC<ICostDetailsProps> = ({
  cart,
  cartPrice,
  isRefreshing,
  startRefresh,
}) => {
  const [promoCode, setPromoCode] = React.useState('');
  const [loading, setLoading] = React.useState(false);
  const [removing, setRemoving] = React.useState(false);
  const [addError, setAddError] = React.useState(false);
  const [removeError, setRemoveError] = React.useState(false);

  const subtotal = formatCurrency(cartPrice.subTotalPrice);
  const discount = formatCurrency(cartPrice.promoCodeDiscount);
  const taxes = formatCurrency(cartPrice.tax);
  const total = formatCurrency(cartPrice.totalPrice);
  const conciergeDiscount = formatCurrency(cartPrice.conciergeDiscount);
  const hasConciergeDiscount = cartPrice.conciergeDiscount < 0;

  const handleAddPromoCode = async (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault();

    await addPromoCode();
  };

  const addPromoCode = async (
    injectedPromoCode?: string,
    autoAddProductToCart = false
  ) => {
    setLoading(true);
    setAddError(false);

    try {
      const { success } = await addPromoCodeToCart(
        injectedPromoCode ?? promoCode,
        autoAddProductToCart
      );
      if (success) {
        setPromoCode('');
        startRefresh();
      } else {
        setAddError(true);
      }
    } catch (error) {
      console.error('Error adding promo code:', error);
      setAddError(true);
    } finally {
      setLoading(false);
    }
  };

  const handleRemovePromoCode = async () => {
    setRemoving(true);
    setRemoveError(false);

    try {
      const { success } = await removePromoCodeFromCart();
      if (success) {
        startRefresh();
      } else {
        setRemoveError(true);
      }
    } catch (error) {
      console.error('Error removing promo code:', error);
      setRemoveError(true);
    } finally {
      setRemoving(false);
    }
  };

  useEffect(() => {
    const cookies = new Cookies();
    const partnerPromoCode = cookies.get('partner-promo-code');

    if (partnerPromoCode && partnerPromoCode !== '') {
      const applyPromoCode = async () => {
        setPromoCode(partnerPromoCode);
        // we used the promo code, let's remove the cookie to prevent auto application in the future.
        cookies.remove('partner-promo-code', { path: '/' });

        await addPromoCode(partnerPromoCode, true);
      };

      applyPromoCode();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const disabled = loading || isRefreshing;
  return (
    <div className="font-dmsans flex-none border-t rounded-b-lg border-gray-200 bg-gray-50 p-6">
      <div>
        <label
          htmlFor="discount-code"
          className="block text-sm font-medium text-gray-700"
        >
          Promo Code
        </label>
        <div className="mt-1 flex space-x-4">
          <div className="w-full">
            <TextField
              type="text"
              placeholder="Enter Promo Code"
              id="discount-code"
              name="discount-code"
              className="block w-full h-10 shadow-sm sm:text-sm"
              value={promoCode}
              onChange={(e) => setPromoCode(e.target.value)}
              disabled={disabled}
            />
          </div>
          <ButtonSolid
            type="button"
            variant="gray"
            onClick={handleAddPromoCode}
            className="rounded-md min-w-[71px] border-0 flex justify-center items-center text-center bg-gray-200 px-4 text-sm font-medium text-gray-600 hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-accent-500 focus:ring-offset-2 focus:ring-offset-gray-50"
            disabled={disabled}
          >
            {loading ? (
              <LoadingSpinner fillClass="fill-gray-500" size="sm" />
            ) : (
              <span>Apply</span>
            )}
          </ButtonSolid>
        </div>
        {addError && (
          <p className="mt-2 text-sm text-error-500 font-dmsans">
            Unable to add promo code. Please check the code and try again.
          </p>
        )}
      </div>

      {isRefreshing ? (
        <LineItemSkeleton />
      ) : (
        <dl className="mt-10 divide-y divide-gray-200 text-sm font-medium text-gray-700">
          <div className="flex justify-between pb-3">
            <dt>Subtotal</dt>
            <dd>{subtotal}</dd>
          </div>
          {hasConciergeDiscount && (
            <div className="flex justify-between py-3">
              <dt>Concierge Discount</dt>
              <dd>{conciergeDiscount}</dd>
            </div>
          )}
          {cart?.promoCodeCode && cart.promoCodeCode.length > 0 && (
            <div className="py-3">
              <div className="flex justify-between">
                <dt className="flex">
                  Discount
                  <button
                    type="button"
                    className="flex ml-2 rounded-full bg-gray-200 px-2 py-0.5 text-xs tracking-wide text-gray-600"
                    aria-label="Remove Promo Code"
                    onClick={handleRemovePromoCode}
                  >
                    {cart.promoCodeCode}
                    {removing ? (
                      <LoadingSpinner
                        fillClass="ml-2 fill-gray-500"
                        size="sm"
                      />
                    ) : (
                      <XMarkIcon
                        className="ml-2 h-4 w-4 justify-self-end"
                        aria-hidden="true"
                      />
                    )}
                  </button>
                </dt>
                <dd>{discount}</dd>
              </div>
              {cart.promo && cart.promo.promoDisclaimer && (
                <MarkdownElement
                  className="mt-2 text-sm font-normal font-dmsans space-y-3"
                  overridePTag={false}
                >
                  {cart.promo.promoDisclaimer}
                </MarkdownElement>
              )}
              {removeError && (
                <p className="mt-2 text-sm font-normal text-error-500 font-dmsans">
                  Unable to remove promo code. Please try again later.
                </p>
              )}
            </div>
          )}
          <div className="flex justify-between py-3">
            <dt>Tax</dt>
            <dd>{taxes}</dd>
          </div>
          <div className="flex justify-between py-3">
            <dt>Shipping</dt>
            <dd>FREE</dd>
          </div>
          <div className="flex items-center justify-between text-gray-950 pt-3">
            <dt>Order Total</dt>
            <dd className="text-gray-700">{total}</dd>
          </div>
        </dl>
      )}
    </div>
  );
};

export default CostDetails;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/checkout/cart-summary/cart-summary.tsx

import { ProductPageDocument } from 'prismicio-types';
import React from 'react';

import { CartInclude } from '@/app/shared/types';
import { cartPriceReturn } from '@/utils/ecommerce/cartUtils';
import CartItems from '@components/cart//cart-items/cart-items';
import CartItemsSkeleton from '@components/cart/cart-items/cart-items-skeleton';

import CostDetails from './cost-details';

interface ICartSummaryProps {
  cart: CartInclude;
  cartPrice: cartPriceReturn;
  productsContent: ProductPageDocument[];
  startRefresh: () => void;
  isRefreshing: boolean;
  disableConsultationRemove?: boolean;
}

const CartSummary: React.FC<ICartSummaryProps> = ({
  cart,
  cartPrice,
  productsContent,
  isRefreshing,
  startRefresh,
  disableConsultationRemove,
}) => {
  return (
    <section
      aria-labelledby="summary-heading"
      className="mx-auto flex w-full max-w-xl rounded flex-col justify-between bg-gray-50 py-6"
    >
      <div className="px-4 pb-6">
        <h2 id="summary-heading" className="font-dmsans text-2xl text-gray-950">
          Order Summary
        </h2>
        {isRefreshing ? (
          <CartItemsSkeleton />
        ) : (
          <CartItems
            cart={cart}
            productsContent={productsContent}
            isRefreshing={isRefreshing}
            startRefresh={startRefresh}
            disableConsultationRemove={disableConsultationRemove}
          />
        )}
      </div>
      <CostDetails
        cart={cart}
        cartPrice={cartPrice}
        isRefreshing={isRefreshing}
        startRefresh={startRefresh}
      />
    </section>
  );
};

export default CartSummary;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/no-posts.tsx

import React from 'react';

import CustomPrismicLink from '@/app/shared/components/buttons/custom-prismic-link';
import { RichText } from '@/app/shared/components/text/rich-text';
import {
  ArrowLeftIcon,
  DocumentMagnifyingGlassIcon,
} from '@heroicons/react/24/outline';
import { KeyTextField, LinkField, RichTextField } from '@prismicio/client';

interface NoPostsProps {
  title: KeyTextField;
  description: RichTextField;
  link: LinkField;
  linkText: KeyTextField;
}

const NoPosts: React.FC<NoPostsProps> = ({
  title,
  description,
  link,
  linkText,
}) => {
  return (
    <div className="flex flex-col items-center text-center py-24 px-4">
      <DocumentMagnifyingGlassIcon className="mx-auto h-12 w-12 text-gray-400" />

      <p className="mt-3 font-dmsans font-medium text-lg sm:text-2xl text-gray-900">
        {title}
      </p>
      <RichText
        className="mt-1 font-dmsans text-sm sm:text-md text-gray-600 max-w-sm"
        field={description}
      />
      <div className="mt-6">
        <CustomPrismicLink
          field={link}
          variant="solid-accent"
          className="py-2.5 px-6 sm:px-10 text-sm bg-[#263A61] text-white rounded-full border-0 hover:bg-[#263A61] hover:opacity-80 transition-all duration-300 ease-in-out"
        >
          <ArrowLeftIcon className="h-5 w-5 inline mr-2" />
          {linkText}
        </CustomPrismicLink>
      </div>
    </div>
  );
};

export default NoPosts;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/blog-newsletter.tsx

import get from 'lodash.get';

import Signup from '@components/signup';
import { PrismicRichText } from '@prismicio/react';

import { BlogNewsletterRelatedData } from './types';

const BlogNewsletter = ({
  content,
}: {
  content: BlogNewsletterRelatedData;
}) => {
  return (
    <div
      className="relative flex flex-col items-center justify-center border border-gray-200 rounded-[20px] p-6"
      style={{
        backgroundImage: `linear-gradient(${get(
          content,
          'data.background_color_start',
          '#FFFFFF'
        )}, ${get(content, 'data.background_color_end', '#FFFFFF')})`,
      }}
    >
      <div className="relative w-full text-center font-dmsans">
        <h3
          className="text-[32px] leading-10 font-medium text-center mb-2.5"
          style={{
            color: get(content, 'data.title_color', '#000000'),
          }}
        >
          {content.data.title}
        </h3>
        <div
          style={{
            color: get(content, 'data.text_color', '#000000'),
          }}
        >
          <PrismicRichText
            field={content.data.text}
            components={{
              paragraph: ({ children }) => (
                <p className="text-center text-base leading-6 font-light tracking-[-0.01em]">
                  {children}
                </p>
              ),
            }}
          />
        </div>
        <Signup
          label_text={content.data.label}
          input_placeholder={content.data.placeholder}
          submit_text={content.data.subscribe_button_text}
          invalid_email_text={content.data.invalid_email_text}
          submitting_text={content.data.subscribing_text}
          submitted_text={content.data.subscribed_text}
          showLabel={true}
          className="sm:flex-col gap-1 mt-4"
          labelProps={{
            className:
              'text-center text-base leading-6 tracking-[-0.01em] font-extrabold',
            style: {
              color: get(content, 'data.label_color', '#000000'),
            },
          }}
          buttonProps={{
            className:
              'w-full mt-2.5 text-lg font-bold rounded-md border-0 py-2.5 sm:max-w-none hover:opacity-85',
            style: {
              backgroundColor: get(
                content,
                'data.subscribe_button_color',
                '#263a61'
              ),
              color: get(
                content,
                'data.subscribe_button_text_color',
                '#000000'
              ),
            },
          }}
        />
      </div>
    </div>
  );
};

export default BlogNewsletter;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/blog-header.tsx

import get from 'lodash.get';
import {
  BlogSearchDocument,
  BlogTagDocument,
  BloghomeDocument,
} from 'prismicio-types';

import { PrismicNextLink } from '@prismicio/next';

import BlogSearch from './blog-search';

const BlogHeader: React.FC<{
  page: BloghomeDocument | BlogSearchDocument | BlogTagDocument;
  initialQuery?: string;
}> = ({ page, initialQuery }) => {
  return (
    <header
      className="pt-24"
      style={{
        backgroundColor: get(page, 'data.header_background_color', '#FFFFFF'),
      }}
    >
      <nav className="mx-auto flex flex-col lg:flex-row max-w-7xl items-center justify-between gap-6 p-6 lg:px-8">
        <div className=" flex flex-col md:flex-row items-center justify-start gap-6 xl:gap-x-12">
          {page.data.links.map((item) => (
            <PrismicNextLink
              key={item.link_text}
              field={item.link}
              className="font-[georgia] text-3xl leading-8 font-normal"
              style={{
                color: get(page, 'data.link_color', '#000000'),
              }}
            >
              {item.link_text}
            </PrismicNextLink>
          ))}
        </div>
        <div className="flex lg:ml-auto max-w-[240px]">
          <BlogSearch
            placeholder={page.data?.search_placeholder ?? undefined}
            initialQuery={initialQuery}
          />
        </div>
      </nav>
    </header>
  );
};
export default BlogHeader;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/blog-search-list.tsx

import { BlogSearchDocument, BlogpostDocument } from 'prismicio-types';

import { createClient } from '@/prismicio';
import { getBaseUrl } from '@/utils/getBaseUrl';
import { PrismicPageType } from '@/utils/prismic/enums';
import { filter } from '@prismicio/client';
import { PrismicNextLink } from '@prismicio/next';

import NoPosts from './no-posts';

interface BlogSearchListProps {
  page: BlogSearchDocument;
  query?: string;
}

const getSearchResults = async (query: string) => {
  const client = createClient();
  try {
    return await client.getAllByType<BlogpostDocument>(
      PrismicPageType.BLOG_POST,
      {
        filters: [filter.fulltext(`document`, query)],
        pageSize: 5,
      }
    );
  } catch (error) {
    return [];
  }
};

const BlogSearchList: React.FC<BlogSearchListProps> = async ({
  page,
  query,
}) => {
  let blogPosts: BlogpostDocument[] = [];
  if (query) {
    blogPosts = await getSearchResults(query);
  }

  if (blogPosts && blogPosts.length > 0) {
    return (
      <>
        {blogPosts.map((post) => (
          <article
            key={post.id}
            className="flex flex-col items-start justify-between mb-8"
          >
            <div className="group relative rounded-[20px] border border-gray-200 w-full">
              <div className="p-4 rounded-t-[20px] bg-[#e7efe9] border-b border-gray-200">
                <h3 className="text-[28px] leading-7 text-[#263a61] font-[Georgia]">
                  <PrismicNextLink document={post}>
                    <span className="absolute inset-0" />
                    {post.data.title}
                  </PrismicNextLink>
                </h3>
              </div>
              <div className="px-4 pt-4 pb-6">
                <p className="font-dmsans text-[#a1a1a1] text-base leading-7 mb-2.5">{`${getBaseUrl()
                  ?.split('://')
                  .pop()}${post.url}`}</p>
                <p className="line-clamp-2 font-dmsans text-base leading-[22px] text-[#333333]">
                  {post.data.short_description}
                </p>
              </div>
            </div>
          </article>
        ))}
      </>
    );
  }

  return (
    <NoPosts
      title={page.data.no_posts_title}
      description={page.data.no_posts_description}
      link={page.data.no_posts_link}
      linkText={page.data.no_posts_link_text}
    />
  );
};

export default BlogSearchList;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/types.ts

import {
  BlogAdCardDocumentData,
  BlogNewsletterDocumentData,
  BlogcategoryDocumentData,
  BlogpostDocument,
  BlogpostDocumentData,
} from 'prismicio-types';

import { isFilledRelatedData } from '@/utils/prismic/prismic';
import {
  ContentRelationshipField,
  FilledContentRelationshipField,
  isFilled,
} from '@prismicio/client';
import { PrismicCustomType, PrismicPageType } from '@utils/prismic/enums';

export type BlogPostRelatedData = (
  | BlogpostDocument
  | FilledContentRelationshipField<PrismicPageType.BLOG_POST>
) & {
  data: {
    title: BlogpostDocumentData['title'];
    thumbnail?: BlogpostDocumentData['thumbnail'];
    short_description?: BlogpostDocumentData['short_description'];
    publication_date?: BlogpostDocumentData['publication_date'];
  };
};

export type BlogAdCardRelatedData =
  FilledContentRelationshipField<PrismicCustomType.BLOG_AD_CARD> & {
    data: {
      link: BlogAdCardDocumentData['link'];
      image?: BlogAdCardDocumentData['image'];
    };
  };

export type BlogNewsletterRelatedData =
  FilledContentRelationshipField<PrismicCustomType.BLOG_NEWSLETTER> & {
    data: {
      background_color_start: BlogNewsletterDocumentData['background_color_start'];
      background_color_end?: BlogNewsletterDocumentData['background_color_end'];
      title: BlogNewsletterDocumentData['title'];
      title_color?: BlogNewsletterDocumentData['title_color'];
      text?: BlogNewsletterDocumentData['text'];
      text_color?: BlogNewsletterDocumentData['text_color'];
      label?: BlogNewsletterDocumentData['label'];
      label_color?: BlogNewsletterDocumentData['label_color'];
      placeholder?: BlogNewsletterDocumentData['placeholder'];
      subscribe_button_text?: BlogNewsletterDocumentData['subscribe_button_text'];
      subscribe_button_text_color?: BlogNewsletterDocumentData['subscribe_button_text_color'];
      subscribe_button_color?: BlogNewsletterDocumentData['subscribe_button_color'];
      subscribing_text?: BlogNewsletterDocumentData['subscribing_text'];
      subscribed_text?: BlogNewsletterDocumentData['subscribed_text'];
      invalid_email_text?: BlogNewsletterDocumentData['invalid_email_text'];
    };
  };

export type BlogCategoryRelatedData =
  FilledContentRelationshipField<PrismicPageType.BLOG_CATEGORY> & {
    data: {
      category_name: BlogcategoryDocumentData['category_name'];
    };
  };

export const getTypedBlogPost = (linkField: ContentRelationshipField) => {
  if (isFilledRelatedData(linkField, PrismicPageType.BLOG_POST, 'title')) {
    return linkField as BlogPostRelatedData;
  }
  return null;
};

export const getTypedBlogAdCard = (linkField: ContentRelationshipField) => {
  if (isFilledRelatedData(linkField, PrismicCustomType.BLOG_AD_CARD, 'link')) {
    return linkField as BlogAdCardRelatedData;
  }
  return null;
};

export const getTypedBlogNewsletter = (linkField: ContentRelationshipField) => {
  if (
    isFilledRelatedData(linkField, PrismicCustomType.BLOG_NEWSLETTER, 'title')
  ) {
    return linkField as BlogNewsletterRelatedData;
  }
  return null;
};

export const getTypedRelatedCategory = (
  linkField: ContentRelationshipField
) => {
  if (
    isFilledRelatedData(
      linkField,
      PrismicPageType.BLOG_CATEGORY,
      'category_name'
    )
  ) {
    return linkField as BlogCategoryRelatedData;
  }
  return null;
};

export const getTypedRelatedBlogPost = (
  linkField: ContentRelationshipField
) => {
  if (isFilled.contentRelationship(linkField)) {
    switch (linkField.type) {
      case PrismicPageType.BLOG_POST:
        return getTypedBlogPost(linkField);
      case PrismicCustomType.BLOG_AD_CARD:
        return getTypedBlogAdCard(linkField);
      case PrismicCustomType.BLOG_NEWSLETTER:
        return getTypedBlogNewsletter(linkField);
      default:
        return null;
    }
  }
  return null;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/blog-search.tsx

'use client';

import { useRouter } from 'next/navigation';

import { MagnifyingGlassIcon } from '@heroicons/react/20/solid';

import ButtonBase from '../buttons/button-base';
import TextField from '../form-controls/text-field';

interface BlogSearchProps {
  placeholder?: string;
  initialQuery?: string;
}

const BlogSearch: React.FC<BlogSearchProps> = ({
  placeholder,
  initialQuery,
}) => {
  const router = useRouter();

  const handleSearch = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const searchParams = new URLSearchParams();
    searchParams.set('q', e.currentTarget.blogSearch.value);
    router.push('/blog/search?' + searchParams.toString());
  };

  return (
    <form onSubmit={handleSearch} className="relative w-full">
      <TextField
        name="blogSearch"
        defaultValue={initialQuery}
        placeholder={placeholder ?? 'Search...'}
        className="rounded-full pl-6 pr-12"
      />
      <ButtonBase
        type="submit"
        className="absolute top-1/2 -translate-y-1/2 right-1 bg-black rounded-full p-2.5"
      >
        <MagnifyingGlassIcon className="h-5 w-5 text-white" />
      </ButtonBase>
    </form>
  );
};

export default BlogSearch;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/blog-ad-card.tsx

import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';

import { BlogAdCardRelatedData } from './types';

const BlogAdCard = ({ card }: { card: BlogAdCardRelatedData }) => {
  return (
    <PrismicNextLink
      field={card.data.link}
      className="group relative rounded-[20px] hover:shadow-xl"
    >
      <div className="aspect-h-1 aspect-w-1 h-full w-full overflow-hidden rounded-[20px] sm:aspect-h-3 sm:aspect-w-2">
        {card?.data?.image && (
          <PrismicNextImage
            field={card?.data.image}
            className="h-full w-full object-cover object-center"
          />
        )}
        <svg
          width="32"
          height="32"
          viewBox="0 0 32 32"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
          className="absolute bottom-6 right-8 w-8 h-8 text-[#9b6222] group-hover:text-[#9b6222] group-hover:scale-110 transition-transform duration-300"
        >
          <g clipPath="url(#clip0_1_5278)">
            <path
              fillRule="evenodd"
              clipRule="evenodd"
              d="M1.9834 15.8672C1.9834 19.5494 3.44616 23.0808 6.04987 25.6845C8.65359 28.2883 12.185 29.751 15.8672 29.751C19.5494 29.751 23.0808 28.2883 25.6845 25.6845C28.2883 23.0808 29.751 19.5494 29.751 15.8672C29.751 12.185 28.2883 8.65359 25.6845 6.04987C23.0808 3.44616 19.5494 1.9834 15.8672 1.9834C12.185 1.9834 8.65359 3.44616 6.04987 6.04987C3.44616 8.65359 1.9834 12.185 1.9834 15.8672ZM31.7344 15.8672C31.7344 20.0755 30.0627 24.1113 27.087 27.087C24.1113 30.0627 20.0755 31.7344 15.8672 31.7344C11.659 31.7344 7.62308 30.0627 4.6474 27.087C1.67172 24.1113 0 20.0755 0 15.8672C0 11.659 1.67172 7.62308 4.6474 4.6474C7.62308 1.67172 11.659 0 15.8672 0C20.0755 0 24.1113 1.67172 27.087 4.6474C30.0627 7.62308 31.7344 11.659 31.7344 15.8672ZM8.92531 14.8755C8.66229 14.8755 8.41005 14.98 8.22407 15.166C8.03809 15.352 7.93361 15.6042 7.93361 15.8672C7.93361 16.1302 8.03809 16.3825 8.22407 16.5685C8.41005 16.7544 8.66229 16.8589 8.92531 16.8589H20.4152L16.1568 21.1153C16.0646 21.2075 15.9914 21.317 15.9415 21.4374C15.8916 21.5579 15.866 21.687 15.866 21.8174C15.866 21.9478 15.8916 22.0769 15.9415 22.1974C15.9914 22.3179 16.0646 22.4273 16.1568 22.5195C16.249 22.6117 16.3585 22.6849 16.4789 22.7348C16.5994 22.7847 16.7285 22.8104 16.8589 22.8104C16.9893 22.8104 17.1184 22.7847 17.2389 22.7348C17.3594 22.6849 17.4688 22.6117 17.561 22.5195L23.5112 16.5693C23.6036 16.4772 23.6769 16.3678 23.7269 16.2473C23.7769 16.1268 23.8026 15.9977 23.8026 15.8672C23.8026 15.7368 23.7769 15.6076 23.7269 15.4871C23.6769 15.3666 23.6036 15.2572 23.5112 15.1651L17.561 9.21488C17.4688 9.12268 17.3594 9.04954 17.2389 8.99964C17.1184 8.94974 16.9893 8.92405 16.8589 8.92405C16.7285 8.92405 16.5994 8.94974 16.4789 8.99964C16.3585 9.04954 16.249 9.12268 16.1568 9.21488C16.0646 9.30709 15.9914 9.41655 15.9415 9.53702C15.8916 9.65749 15.866 9.78661 15.866 9.91701C15.866 10.0474 15.8916 10.1765 15.9415 10.297C15.9914 10.4175 16.0646 10.5269 16.1568 10.6191L20.4152 14.8755H8.92531Z"
              fill="#9B6222"
            />
          </g>
          <defs>
            <clipPath id="clip0_1_5278">
              <rect width="31.7344" height="31.7344" fill="white" />
            </clipPath>
          </defs>
        </svg>
      </div>
    </PrismicNextLink>
  );
};

export default BlogAdCard;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/loading/featured-list-skeleton.tsx

const SmallPostSkeleton = () => {
  return (
    <div className="min-h-[150px] relative group aspect-h-1 aspect-w-2 overflow-hidden rounded-[20px] sm:aspect-none sm:relative sm:h-full flex">
      <div className="h-auto w-1/2 rounded-l-[20px] object-cover bg-gray-100" />
      <div className="w-1/2 bg-[#ddefe9] rounded-r-[20px] p-6 pb-3 flex flex-col justify-between">
        <div className="flex flex-1 flex-col">
          <div className="bg-gray-100 rounded-md h-5 w-full mb-2" />
          <div className="bg-gray-100 rounded-md h-5 w-3/4" />
        </div>
        <div className="bg-gray-100 rounded-md h-4 w-40" />
      </div>
    </div>
  );
};

const FeaturedListSkeleton = () => {
  return (
    <div className="mt-6 mx-auto max-w-7xl py-8 px-6 animate-pulse">
      <div className=" grid grid-cols-1 gap-y-6 lg:grid-cols-3 lg:gap-x-6 lg:gap-8">
        <div className="lg:col-span-2">
          <div className="relative w-full rounded-[20px] aspect-h-1 aspect-w-2 overflow-hidden sm:aspect-h-1 sm:aspect-w-1">
            <div className="absolute inset-0 -z-10 h-full w-full bg-gray-100" />
            <div className="m-8 bg-white rounded-[20px] max-w-[398px]">
              <div className="bg-[#ddefe9] rounded-t-[20px] p-6">
                <div className="bg-gray-100 rounded-md h-5 w-full mb-2" />
                <div className="bg-gray-100 rounded-md h-5 w-3/4 mb-2" />
              </div>
              <div className="rounded-b-[20px] p-6">
                <div className="bg-gray-100 rounded-md h-4 w-full mb-2" />
                <div className="bg-gray-100 rounded-md h-4 w-full mb-2" />
                <div className="bg-gray-100 rounded-md h-4 w-full mb-2" />
                <div className="bg-gray-100 rounded-md h-4 w-full mb-2" />
                <div className="bg-gray-100 rounded-md h-4 w-1/2 mb-2" />
                <div className="mt-8 bg-gray-100 rounded-md h-4 w-40" />
              </div>
            </div>
          </div>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-1 gap-6 lg:auto-rows-fr">
          <SmallPostSkeleton />
          <SmallPostSkeleton />
        </div>
      </div>
    </div>
  );
};

export default FeaturedListSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/loading/search-list-skeleton.tsx

const SearchListItemSkeleton = () => {
  return (
    <div className="flex flex-col items-start justify-between mb-8 animate-pulse">
      <div className="group relative rounded-[20px] border border-gray-200 w-full">
        <div className="p-4 rounded-t-[20px] bg-[#e7efe9] border-b border-gray-200">
          <div className="h-7" />
        </div>
        <div className="px-4 pt-4 pb-6">
          <div className="h-4 mb-6 mt-1.5 w-2/5 bg-gray-100 rounded-md" />
          <div className="h-4 mb-1.5 w-full bg-gray-100 rounded-md" />
          <div className="h-4 mb-1.5 w-full bg-gray-100 rounded-md" />
          <div className="h-4 mb-1.5 w-1/3 bg-gray-100 rounded-md" />
        </div>
      </div>
    </div>
  );
};

const SearchListSkeleton = () => {
  return (
    <div className="mt-6 mx-auto p-6 max-w-2xl lg:max-w-7xl">
      {[...Array(3)].map((_, index) => (
        <SearchListItemSkeleton key={`search-list-skeleton-item-${index}`} />
      ))}
    </div>
  );
};

export default SearchListSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/loading/header-skeleton.tsx

const HeaderSkeleton = () => {
  return (
    <div className="pt-24 bg-[#e7efe9] animate-pulse">
      <div className="mx-auto flex flex-col lg:flex-row max-w-7xl items-center justify-between gap-6 p-6 lg:px-8">
        <div className="w-full flex flex-col md:flex-row items-center justify-start gap-6 xl:gap-x-12">
          {[...Array(4)].map((_, i) => (
            <div
              key={`header-skeleton-link-${i}`}
              className="w-full max-w-[120px] bg-gray-100 rounded-md h-8"
            />
          ))}
        </div>
        <div className="flex lg:ml-auto w-full max-w-[240px]">
          <div className="w-full bg-gray-100 rounded-full h-10" />
        </div>
      </div>
    </div>
  );
};
export default HeaderSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/loading/post-list-skeleton.tsx

import PostSkeleton from './post-skeleton';

const PostListSkeleton = () => {
  return (
    <div className="mx-auto mt-6 p-6 max-w-2xl lg:max-w-7xl animate-pulse">
      <div className="mb-6 w-1/2 sm:w-80 bg-gray-100 rounded-md h-6" />
      <div className="mb-10 grid grid-cols-1 gap-x-4 gap-y-6 lg:grid-cols-3">
        {[...Array(3)].map((_, i) => (
          <PostSkeleton key={`post-list-skeleton-item-${i}`} />
        ))}
      </div>
    </div>
  );
};
export default PostListSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/loading/post-skeleton.tsx

const PostSkeleton = () => {
  return (
    <div className="relative flex flex-col items-start justify-between bg-white border border-gray-200 rounded-[20px] p-6 animate-pulse">
      <div className="relative w-full">
        <div className="h-[241px] w-full rounded-t-2xl bg-gray-100" />
        <div className="absolute inset-0 rounded-t-2xl ring-1 ring-inset ring-gray-900/10" />
      </div>
      <div className="w-full max-w-[95%] z-10 mr-[10%]">
        <div className="">
          <div className="bg-[#e7efe9] rounded-r-[15px] p-4 -mt-[25px] w-full min-h-[80px] content-center">
            <div className="w-full bg-gray-100 rounded-md h-4 mb-2" />
            <div className="w-3/4 bg-gray-100 rounded-md h-4" />
          </div>
          <div className="mt-5 w-full bg-gray-100 rounded-md h-3 mb-1" />
          <div className="w-full bg-gray-100 rounded-md h-3 mb-1" />
          <div className="w-3/4 bg-gray-100 rounded-md h-3" />
        </div>
        <div className="mt-4 w-1/4 min-w-[120px] bg-gray-100 rounded-md h-3" />
      </div>
    </div>
  );
};

export default PostSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/loading/article-header-skeleton.tsx

const ArticleHeaderSkeleton = () => {
  return (
    <div className="w-full mx-auto max-w-7xl pt-40 px-6 flex flex-col items-center animate-pulse">
      <div className="mb-2 w-full max-w-2xl bg-gray-100 rounded-md h-8" />
      <div className="mb-6 w-full max-w-md bg-gray-100 rounded-md h-8" />
      <div className="flex flex-row gap-2 justify-center items-center flex-wrap">
        {[...Array(3)].map((_, i) => (
          <div
            key={`article-tag-skeleton-${i}`}
            className="relative w-24 h-8 bg-[#efd9cd] rounded-full "
          />
        ))}
      </div>
      <div className="bg-gray-200 w-full mt-8 mb-6 h-px" />
    </div>
  );
};

export default ArticleHeaderSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/loading/article-skeleton.tsx

import InlineShareButtons from '../../buttons/share-buttons/inline-share-button';

const ArticleSkeleton = () => {
  return (
    <div className="w-full mx-auto max-w-6xl px-6 flex flex-col items-center animate-pulse pb-20">
      <div className="w-full mb-5">
        <div className="flex flex-row justify-between items-center pb-[60px]">
          <div className="flex items-center gap-x-6">
            <div className="h-16 w-16 rounded-full bg-gray-100" />
            <div className="font-dmsans">
              <div className="bg-gray-100 rounded-md h-4 mb-2 w-20" />
              <div className="bg-gray-100 rounded-md h-4 w-40" />
            </div>
          </div>
          <InlineShareButtons />
        </div>
        <div className="h-auto w-full overflow-hidden rounded-[20px] bg-gray-100">
          <div className="w-full h-[280px] sm:h-[350px] lg:h-[480px]" />
        </div>

        <div className="mx-auto max-w-[840px] mt-10">
          <div className="bg-gray-100 rounded-md h-6 w-1/3 mb-4" />
          <div className="bg-gray-100 rounded-md h-5 w-full mb-2" />
          <div className="bg-gray-100 rounded-md h-5 w-full mb-2" />
          <div className="bg-gray-100 rounded-md h-5 w-full mb-2" />
          <div className="bg-gray-100 rounded-md h-5 w-full mb-2" />
          <div className="bg-gray-100 rounded-md h-5 w-3/4 mb-1" />

          <div className="mt-16 flex flex-row justify-between items-center py-8 border-y border-[#eee] ">
            <div className="flex items-center gap-x-6">
              <div className="h-16 w-16 rounded-full bg-gray-100" />
              <div className="font-dmsans">
                <p className="text-lg font-light leading-8 tracking-[-0.02em] text-gray-500">
                  Article by
                </p>
                <div className="bg-gray-100 rounded-md h-4 mb-2 w-20" />
              </div>
            </div>
            <InlineShareButtons />
          </div>
        </div>
      </div>
    </div>
  );
};

export default ArticleSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/post-card/large-post-card.tsx

import dayjs from 'dayjs';

import { ArrowRightIcon } from '@heroicons/react/24/outline';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';

import { BlogPostRelatedData } from '../types';

const LargeBlogPostCard = ({ post }: { post: BlogPostRelatedData | null }) => {
  if (!post) return null;
  const link = 'link_type' in post ? { field: post } : { document: post };
  return (
    <article className="relative w-full rounded-[20px] group aspect-h-1 aspect-w-2 overflow-hidden sm:aspect-h-1 sm:aspect-w-1 hover:shadow-xl">
      <PrismicNextImage
        field={post.data.thumbnail}
        className="absolute inset-0 -z-10 h-full w-full object-cover object-center"
        alt=""
      />
      <div className="m-8 bg-white rounded-[20px] max-w-[398px] group-hover:shadow-lg">
        <div className="bg-[#ddefe9] rounded-t-[20px] p-6">
          <div className="text-[30px] font-[georgia] leading-9 text-black font-normal group-hover:text-[#9b6222]">
            <PrismicNextLink {...link}>
              <span className="absolute inset-0" />
              {post.data.title}
            </PrismicNextLink>
          </div>
        </div>
        <div className="rounded-b-[20px] p-6">
          <p className="font-dmsans text-base text-[#333] tracking-[-0.01em]">
            {post.data?.short_description}
          </p>
          {post.data.publication_date && (
            <div className="mt-4 flex items-center justify-between gap-x-4 text-base">
              <time
                dateTime={post.data.publication_date}
                className="text-[#979797] font-dmsans font-medium"
              >
                {dayjs(post.data.publication_date).format('MMMM D, YYYY')}
              </time>
              <ArrowRightIcon className="h-6 w-6 text-black group-hover:scale-110 transition-transform duration-300" />
            </div>
          )}
        </div>
      </div>
    </article>
  );
};

export default LargeBlogPostCard;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/post-card/post-card-alt.tsx

import dayjs from 'dayjs';
import { BlogpostDocument } from 'prismicio-types';

import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';

import { BlogPostRelatedData } from '../types';

const PostCardAlt = ({
  post,
}: {
  post: BlogPostRelatedData | BlogpostDocument;
}) => {
  if (!post) return null;
  const link = 'link_type' in post ? { field: post } : { document: post };
  return (
    <article className="relative flex flex-col items-start justify-start bg-white border border-gray-200 rounded-[20px] p-6 hover:shadow-xl">
      <div className="relative w-full">
        <PrismicNextImage
          field={post.data.thumbnail}
          alt=""
          className="aspect-[16/9] w-full rounded-t-2xl bg-gray-100 object-cover sm:aspect-[2/1] lg:aspect-[3/2]"
        />
        <div className="absolute inset-0 rounded-t-2xl ring-1 ring-inset ring-gray-900/10" />
      </div>
      <div className="max-w-xl z-10 mr-[10%]">
        <div className="mt-10 group">
          <div className="font-[georgia] text-lg line-clamp-2 font-light leading-6 text-[#263a61] group-hover:text-[#9b6222]">
            <PrismicNextLink {...link}>
              <span className="absolute inset-0" />
              {post.data.title}
            </PrismicNextLink>
          </div>
          <p className="font-dmsans mt-5 text-sm leading-6 text-gray-600">
            {post.data.short_description}
          </p>
        </div>
        {post.data.publication_date && (
          <div className="mt-4 flex items-center gap-x-4 text-base">
            <time
              dateTime={post.data.publication_date}
              className="text-[#979797] font-dmsans font-medium"
            >
              {dayjs(post.data.publication_date).format('MMMM D, YYYY')}
            </time>
          </div>
        )}
      </div>
    </article>
  );
};

export default PostCardAlt;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/post-card/post-card.tsx

import dayjs from 'dayjs';

import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';

import { BlogPostRelatedData } from '../types';

const PostCard = ({ post }: { post: BlogPostRelatedData | null }) => {
  if (!post) return null;
  const link = 'link_type' in post ? { field: post } : { document: post };
  return (
    <article className="relative flex flex-col items-start justify-between bg-white border border-gray-200 rounded-[20px] p-6 hover:shadow-xl">
      <div className="relative w-full">
        <PrismicNextImage
          field={post.data.thumbnail}
          alt=""
          className="aspect-[16/9] w-full rounded-t-2xl bg-gray-100 object-cover sm:aspect-[2/1] lg:aspect-[3/2]"
        />
        <div className="absolute inset-0 rounded-t-2xl ring-1 ring-inset ring-gray-900/10" />
      </div>
      <div className="max-w-xl z-10 mr-[10%]">
        <div className="group">
          <div className="bg-[#e7efe9] rounded-r-[15px] p-4 -mt-[25px] min-h-[80px] content-center">
            <div className="font-[georgia] text-lg line-clamp-2 font-light leading-6 text-[#263a61] group-hover:text-[#9b6222]">
              <PrismicNextLink {...link}>
                <span className="absolute inset-0" />
                {post.data.title}
              </PrismicNextLink>
            </div>
          </div>
          <p className="font-dmsans mt-5 line-clamp-3 text-sm leading-6 text-gray-600">
            {post.data.short_description}
          </p>
        </div>
        {post.data.publication_date && (
          <div className="mt-4 flex items-center gap-x-4 text-base">
            <time
              dateTime={post.data.publication_date}
              className="text-[#979797] font-dmsans font-medium"
            >
              {dayjs(post.data.publication_date).format('MMMM D, YYYY')}
            </time>
          </div>
        )}
      </div>
    </article>
  );
};

export default PostCard;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/blog/post-card/small-post-card.tsx

import dayjs from 'dayjs';

import { ArrowRightIcon } from '@heroicons/react/24/outline';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';

import { BlogPostRelatedData } from '../types';

const SmallBlogPostCard = ({ post }: { post: BlogPostRelatedData | null }) => {
  if (!post) return null;
  const link = 'link_type' in post ? { field: post } : { document: post };
  return (
    <article className="relative group aspect-h-1 aspect-w-2 overflow-hidden rounded-[20px] sm:aspect-none sm:relative sm:h-full flex hover:shadow-xl">
      <PrismicNextImage
        field={post.data.thumbnail}
        className="h-auto w-1/2 rounded-l-[20px] object-cover object-right"
        alt=""
      />
      <div className="w-1/2 bg-[#ddefe9] rounded-r-[20px] p-6 lg:p-3 xl:p-6 pb-3 flex flex-col justify-between">
        <div className="flex flex-1 items-center">
          <div className="text-2xl font-[georgia] leading-7 line-clamp-5 text-black font-normal group-hover:text-[#9b6222]">
            <PrismicNextLink {...link}>
              <span className="absolute inset-0" />
              {post.data.title}
            </PrismicNextLink>
          </div>
        </div>
        {post.data.publication_date && (
          <div className="mt-4 flex items-center justify-between gap-x-4 text-base">
            <time
              dateTime={post.data.publication_date}
              className="text-[#979797] font-dmsans font-medium"
            >
              {dayjs(post.data.publication_date).format('MMMM D, YYYY')}
            </time>
            <ArrowRightIcon className="h-5 w-5 text-black group-hover:scale-110 transition-transform duration-300" />
          </div>
        )}
      </div>
    </article>
  );
};

export default SmallBlogPostCard;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/user-avatar/user-avatar.tsx

import Image from 'next/image';
import React from 'react';
import { twMerge } from 'tailwind-merge';

import { User } from '@prisma/client';
import { getFullName } from '@utils/get-full-name';

interface IUserAvatarProps {
  user: User;
  userAvatarS3Url?: string;
  className?: string;
}

const UserAvatar: React.FC<IUserAvatarProps> = (p) => {
  const { user, userAvatarS3Url, className } = p;

  if (!userAvatarS3Url) {
    return (
      <div
        className={twMerge(
          'inline-flex h-8 w-8 rounded-full bg-accent-500 items-center justify-center text-white font-dmsans text-sm',
          className
        )}
      >
        {getFullName(user.firstName, user.lastName, user.email)
          ?.charAt(0)
          ?.toUpperCase() ?? 'A'}
      </div>
    );
  }

  return (
    <Image
      className={twMerge(
        'inline-block h-8 w-8 rounded-full bg-gray-50',
        className
      )}
      src={userAvatarS3Url}
      alt=""
      width="256"
      height="256"
    />
  );
};

export default UserAvatar;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/cookie-setter/cookie-setter.tsx

'use client';

import { useEffect, useState } from 'react';
import Cookies from 'universal-cookie';

import { getBaseUrl } from '@utils/getBaseUrl';

interface ICookieOption {
  path?: string;
  expires?: Date;
  maxAge?: number;
}

const CookieSetter = () => {
  const [responseHeaders, setResponseHeaders] = useState<Array<
    [string, string]
  > | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const responseWithCookies = await getSessionResponseWithCookies();
        setResponseHeaders(responseWithCookies?.headers);
      } catch (error) {
        console.error('Failed to fetch session response with cookies:', error);
      }
    };

    fetchData();
  }, []);

  useEffect(() => {
    if (!responseHeaders) return;

    const cookiesInstance = new Cookies();

    responseHeaders.forEach(([header, value]) => {
      if (header.toLowerCase() === 'set-cookie') {
        parseSetCookieString(value).forEach(({ name, value, options }) => {
          cookiesInstance.set(name, value, options);
        });
      }
    });
  }, [responseHeaders]);

  return null;
};

export default CookieSetter;

function parseSetCookieString(
  cookieString: string
): Array<{ name: string; value: string; options: ICookieOption }> {
  const parts = cookieString.split(/;(?=\s)/);
  return parts.map((part) => {
    const [firstPart, ...optionParts] = part.split(';');
    const [name, value] = firstPart.split('=');
    const options = optionParts.reduce<ICookieOption>((acc, part) => {
      const [key, val] = part.trim().split('=');
      switch (key.toLowerCase()) {
        case 'expires':
          acc.expires = new Date(val);
          break;
        case 'path':
          acc.path = val || '/';
          break;
        case 'max-age':
          acc.maxAge = parseInt(val, 10);
          break;
        default:
          // Optionally handle other options like domain, secure, sameSite, etc.
          break;
      }
      return acc;
    }, {});
    return { name, value, options };
  });
}

const getSessionResponseWithCookies = async () => {
  try {
    const res = await fetch(`${getBaseUrl()}/api/generate-client-session`, {
      method: 'GET',
      cache: 'no-store',
    });

    if (!res.ok) throw new Error('Network response was not ok');

    // Assuming your endpoint returns a JSON object with cookies information
    const data = await res.json(); // Adjust this based on your actual API response structure
    return data;
  } catch (error) {
    console.error('Error getting session response with cookies: ', error);
    return null;
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/file-upload/file-upload.tsx

import Image from 'next/image';
import React from 'react';
import { twMerge } from 'tailwind-merge';
import { v4 as uuidv4 } from 'uuid';

import { getSafeFileName } from '@/utils/file-upload/upload-helpers';
import { UploadStatus } from '@utils/enums';

import Label from '../form-controls/label';
import UploadItem from './file-items/file-item';

export interface ICustomFile {
  id: string;
  file: File;
  size: number;
  name: string;
  type: string;
  status?: UploadStatus;
  s3Url?: string;
}

interface IFileUploadContent {
  buttonText: string;
  afterButtonText: string;
  acceptedFileTypeText: string;
  invalidFileTypeText: string;
}

export interface IFileUploadProps {
  id?: string;
  label?: string;
  helperText?: string;
  helperTextTitle?: string;
  multiple?: boolean;
  isFileTypeValid?: (fileType: string) => boolean;
  handleFieldChange: (files: ICustomFile[]) => void;
  defaultValue?: ICustomFile[];
  meta?: { [key: string]: any };
  uploadFile: (
    file: ICustomFile,
    meta?: { [key: string]: any }
  ) => Promise<ICustomFile>;
  isInvalid?: boolean;
  ErrorComponent?: React.ReactNode;
  content: IFileUploadContent;
  disabled?: boolean;
}

const FileUpload: React.FC<IFileUploadProps> = (p) => {
  const [selectedFiles, setSelectedFiles] = React.useState<ICustomFile[]>(
    p.defaultValue ?? []
  );
  const [isInvalidFileType, setIsInvalidFileType] =
    React.useState<boolean>(false);

  React.useEffect(() => {
    if (selectedFiles) {
      p.handleFieldChange(selectedFiles);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedFiles]);

  const warnFileInvalid = () => {
    setIsInvalidFileType(true);
    autoRemoveError();
  };

  const autoRemoveError = () => {
    setTimeout(() => {
      setIsInvalidFileType(false);
    }, 10000);
  };

  const handleUploadResult = (uploadResult: ICustomFile) => {
    setSelectedFiles((prevState) => {
      const i = prevState.findIndex(
        (stateFile) => stateFile.id === uploadResult.id
      );
      if (i > -1) {
        prevState[i] = uploadResult;
      }
      return [...prevState];
    });
  };

  const handleSingleUpload = async (file: ICustomFile) => {
    const uploadResult = await p.uploadFile(file, p.meta);
    handleUploadResult(uploadResult);
    return uploadResult;
  };

  const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
    setIsInvalidFileType(false);
    const files = e.target.files;
    if (!files) return;

    const newFiles: ICustomFile[] = [];

    // Set initial state as uploading
    for (const file of files) {
      if (p.isFileTypeValid ? p.isFileTypeValid(file.type) : true) {
        newFiles.push({
          id: uuidv4(),
          file: file,
          size: file.size,
          name: getSafeFileName(file.name),
          type: file.type,
          status: UploadStatus.UPLOADING,
          s3Url: undefined,
        });
      } else {
        warnFileInvalid();
      }
    }
    setSelectedFiles(p.multiple ? [...selectedFiles, ...newFiles] : newFiles);

    // Create Promise array
    const uploadPromises = newFiles.map((file) => handleSingleUpload(file));

    await Promise.all(uploadPromises);
  };

  const retrySingleUpload = async (file: ICustomFile) => {
    setSelectedFiles((prevState) => {
      const i = prevState.findIndex((stateFile) => stateFile.id === file.id);
      if (i > -1) {
        prevState[i].status = UploadStatus.UPLOADING;
      }
      return [...prevState];
    });
    await handleSingleUpload(file);
  };

  const removeFile = (file: ICustomFile) => {
    const filteredFiles = selectedFiles?.filter((f) => f.name !== file.name);
    setSelectedFiles(filteredFiles);
  };

  const isInvalid = isInvalidFileType || p.isInvalid;

  return (
    <div>
      <div>
        <Label
          id={p.id}
          htmlFor={p.id}
          label={p.label}
          helperText={p.helperText}
          helperTextTitle={p.helperTextTitle}
        />
        <label
          className={twMerge(
            'mt-2 flex justify-center w-full h-32 px-4 border transition bg-white rounded-xl appearance-none cursor-pointer focus:outline-none',
            isInvalid
              ? 'border-error-500 hover:border-error-500'
              : 'border-gray-300 hover:border-accent-400 hover:border-2'
          )}
        >
          <span className="flex flex-col items-center justify-center space-y-2">
            <Image
              src="/assets/upload-cloud.svg"
              alt=""
              width={46}
              height={45}
            />
            <span className="font-dmsans text-sm text-gray-600">
              <span className="font-medium text-accent-700">
                {p.content.buttonText}
              </span>{' '}
              {p.content.afterButtonText}
            </span>
            <span className="font-dmsans text-xs text-gray-600">
              {p.content.acceptedFileTypeText}
            </span>
          </span>
          <input
            id={p.id}
            type="file"
            name="file_upload"
            className="hidden"
            onChange={handleFileSelect}
            multiple={p.multiple}
            disabled={p.disabled}
          />
        </label>
        {isInvalidFileType && (
          <p className="mt-2 text-sm text-error-500">
            {p.content.invalidFileTypeText}
          </p>
        )}
        {p.ErrorComponent}
      </div>
      <div className="mt-4">
        {selectedFiles && selectedFiles.length > 0 && (
          <div className="flex flex-col gap-4">
            {selectedFiles.map((selectedFile, i) => (
              <UploadItem
                key={`${selectedFile.name}-${i}`}
                {...selectedFile}
                handleRemove={removeFile}
                handleRetry={retrySingleUpload}
                disabled={p.disabled}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default FileUpload;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/file-upload/progress-bar.tsx

import React from 'react';

import { UploadStatus } from '@/utils/enums';
import { useInterval } from '@hooks/useInterval';

const ProgressBar = ({ uploadStatus }: { uploadStatus: UploadStatus }) => {
  const [startTime] = React.useState(Date.now());
  const [progress, setProgress] = React.useState(0);
  const [delay, setDelay] = React.useState<number | null>(100);

  useInterval(() => {
    const elapsedTime = Date.now() - startTime;
    const newProgress = Math.floor(
      (Math.atan(elapsedTime / 3e3) / (Math.PI / 2)) * 100
    );
    setProgress(newProgress);
  }, delay);

  React.useEffect(() => {
    if (uploadStatus === UploadStatus.SUCCESS) {
      setDelay(null);
      setProgress(100);
    }
  }, [uploadStatus]);

  return (
    <div className="mt-1 w-full flex flex-row items-center gap-2">
      <div className="w-full bg-gray-200 rounded-full h-2.5">
        <div
          className="bg-accent-300 h-2.5 rounded-full dark:bg-green-500"
          style={{ width: `${progress}%` }}
        />
      </div>
      <p className="font-dmsans w-10 text-sm font-medium text-gray-700">
        {progress}%
      </p>
    </div>
  );
};

export default ProgressBar;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/file-upload/file-items/uploading-item.tsx

import Image from 'next/image';
import React from 'react';

import ButtonBase from '@/app/shared/components/buttons/button-base';
import { UploadStatus } from '@/utils/enums';
import { convertBytes } from '@/utils/utils';
import FileExtensionBadge from '@components/file-upload/file-items/file-extension-badge';
import { type IUploadItemProps } from '@components/file-upload/file-items/file-item';
import ProgressBar from '@components/file-upload/progress-bar';
import { Trash01 } from '@untitled-ui/icons-react';

const UploadingItem: React.FC<IUploadItemProps> = ({
  handleRemove,
  disabled,
  ...file
}) => {
  return (
    <div className="relative p-4 border rounded-xl border-gray-200 bg-white sm:flex">
      <div className="mb-4 flex-shrink-0 sm:mb-0 sm:mr-4">
        <div className="relative ml-3">
          <Image
            src="/assets/file-outline.svg"
            alt=""
            width={32}
            height={40}
            aria-hidden="true"
          />
          <FileExtensionBadge filename={file.name} />
        </div>
      </div>
      <div className="w-full">
        <p className="font-dmsans text-sm font-medium text-gray-700 truncate max-w-[200px]">
          {file.name}
        </p>
        <p className="inline font-dmsans text-sm text-gray-600">
          {convertBytes(file.size ?? 0)}
        </p>
        <ProgressBar uploadStatus={file.status as UploadStatus} />
      </div>

      <div className="absolute top-0 right-0 p-2 flex flex-row items-center justify-end gap-1">
        <ButtonBase
          className="p-2"
          onClick={() => handleRemove(file)}
          disabled={disabled}
        >
          <Trash01 className="w-5 h-5 text-gray-500" viewBox="0 0 24 24" />
        </ButtonBase>
      </div>
    </div>
  );
};

export default UploadingItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/file-upload/file-items/file-item.tsx

import { UploadStatus } from '@/utils/enums';
import ErrorItem from '@components/file-upload/file-items/error-item';
import SuccessItem from '@components/file-upload/file-items/success-item';
import UploadingItem from '@components/file-upload/file-items/uploading-item';
import { ICustomFile } from '@components/file-upload/file-upload';

export interface IUploadItemProps extends ICustomFile {
  handleRemove: (file: ICustomFile) => void;
  handleRetry: (file: ICustomFile) => void;
  disabled?: boolean;
}

const UploadItem: React.FC<IUploadItemProps> = (p) => {
  const isSuccess = p.status === UploadStatus.SUCCESS;
  const isUploading = p.status === UploadStatus.UPLOADING;

  if (isSuccess) {
    return <SuccessItem {...p} />;
  }

  if (isUploading) {
    return <UploadingItem {...p} />;
  }

  return <ErrorItem {...p} />;
};

export default UploadItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/file-upload/file-items/file-extension-badge.tsx

import { twMerge } from 'tailwind-merge';

const extensionColorMap: { [key: string]: string } = {
  pdf: 'bg-red-600',
  doc: 'bg-blue-600',
  docx: 'bg-blue-600',
  xls: 'bg-green-700',
  xlsx: 'bg-green-700',
  csv: 'bg-green-600',
  ppt: 'bg-orange-600',
  pptx: 'bg-orange-600',
  jpg: 'bg-accent-500',
  jpeg: 'bg-accent-600',
  png: 'bg-accent-600',
  gif: 'bg-accent-600',
  svg: 'bg-accent-600',
  webp: 'bg-accent-600',
};

const FileExtensionBadge = ({ filename }: { filename: string }) => {
  const ext = filename.split('.').pop()?.substring(0, 4).toLowerCase();

  if (!ext) return null;

  const color = extensionColorMap?.[ext] ?? 'bg-gray-700';

  return (
    <div
      className={twMerge(
        'absolute bottom-1.5 -left-2 rounded-sm px-[3px] py-0.5 text-[10px] leading-3 font-bold text-white',
        color
      )}
    >
      {ext.toUpperCase()}
    </div>
  );
};

export default FileExtensionBadge;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/file-upload/file-items/success-item.tsx

import Image from 'next/image';
import React from 'react';

import ButtonBase from '@/app/shared/components/buttons/button-base';
import { convertBytes } from '@/utils/utils';
import FileExtensionBadge from '@components/file-upload/file-items/file-extension-badge';
import { type IUploadItemProps } from '@components/file-upload/file-items/file-item';
import { CheckCircleIcon } from '@heroicons/react/20/solid';
import { Trash01 } from '@untitled-ui/icons-react';

import FilePreviewTrigger from './file-preview/file-preview-trigger';

const SuccessItem: React.FC<IUploadItemProps> = ({
  handleRemove,
  disabled,
  ...file
}) => {
  return (
    <div className="relative p-4 border rounded-xl border-gray-200 bg-white sm:flex">
      <div className="mb-4 flex-shrink-0 sm:mb-0 sm:mr-4">
        <div className="relative ml-3">
          <Image
            src="/assets/file-outline.svg"
            alt=""
            width={32}
            height={40}
            aria-hidden="true"
          />
          <FileExtensionBadge filename={file.name} />
        </div>
      </div>
      <div className="w-full">
        <p className="font-dmsans text-sm font-medium text-gray-700 truncate max-w-[200px]">
          {file.name}
        </p>
        <div className="flex flex-row justify-start items-center gap-1.5 font-dmsans text-sm text-gray-600">
          {convertBytes(file.size ?? 0)} -{' '}
          {file.s3Url && (
            <FilePreviewTrigger
              s3ObjectKey={file.s3Url}
              fileType={file.type}
              disabled={disabled}
            />
          )}
        </div>
      </div>

      <div className="absolute top-0 right-0 p-2 flex flex-row items-center justify-end gap-1">
        <CheckCircleIcon
          className="h-5 w-5 text-accent-600"
          aria-hidden="true"
        />
        <ButtonBase
          className="p-2"
          onClick={() => handleRemove(file)}
          disabled={disabled}
        >
          <Trash01 className="w-5 h-5 text-gray-500" viewBox="0 0 24 24" />
        </ButtonBase>
      </div>
    </div>
  );
};

export default SuccessItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/file-upload/file-items/error-item.tsx

import Image from 'next/image';
import React from 'react';

import ButtonBase from '@/app/shared/components/buttons/button-base';
import FileExtensionBadge from '@components/file-upload/file-items/file-extension-badge';
import { type IUploadItemProps } from '@components/file-upload/file-items/file-item';
import { Trash01 } from '@untitled-ui/icons-react';

const ErrorItem: React.FC<IUploadItemProps> = ({
  handleRemove,
  handleRetry,
  disabled,
  ...file
}) => {
  return (
    <div className="relative p-4 border border-error-300 rounded-xl bg-error-25 sm:flex">
      <div className="mb-4 flex-shrink-0 sm:mb-0 sm:mr-4">
        <div className="relative ml-3">
          <Image
            src="/assets/error-file-upload.svg"
            alt=""
            width={32}
            height={40}
            aria-hidden="true"
          />
          <FileExtensionBadge filename={file.name} />
        </div>
      </div>
      <div className="w-full">
        <p className="font-dmsans text-sm font-medium text-error-700 truncate max-w-[200px]">
          {file.name}
        </p>
        <p className="font-dmsans text-sm text-error-600">
          Upload failed please try again
        </p>
        <ButtonBase
          className="px-0 py-1"
          variant="error"
          onClick={() => handleRetry(file)}
          disabled={disabled}
        >
          Try again
        </ButtonBase>
      </div>

      <div className="absolute top-0 right-0 p-2 flex flex-row items-center justify-end gap-1">
        <ButtonBase
          className="p-2"
          onClick={() => handleRemove(file)}
          disabled={disabled}
        >
          <Trash01 className="w-5 h-5 text-error-700" viewBox="0 0 24 24" />
        </ButtonBase>
      </div>
    </div>
  );
};

export default ErrorItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/file-upload/file-items/file-preview/file-preview.tsx

import React from 'react';

import { FileType } from '@/utils/enums';
import { determineFileType, getFamilyMemberHeader } from '@/utils/utils';
import ErrorToast from '@components/error-toast';
import LoadingSpinner from '@components/loading-indicators/loading-spinner';
import { useQuery } from '@tanstack/react-query';
import { FileDownload03 } from '@untitled-ui/icons-react';

import PreviewModal from './preview-modal';

interface IFilePreviewProps {
  open: boolean;
  setOpen: () => void;
  s3ObjectKey: string;
  fileType: string;
}

const getS3SignedUrl = async (s3ObjectUrl: string) => {
  const familyMemberHeader = getFamilyMemberHeader();

  const headers = {
    s3Url: s3ObjectUrl,
    ...(familyMemberHeader ? familyMemberHeader : {}),
  };

  const result = await fetch(`/api/forms/file-upload`, {
    method: 'GET',
    headers,
  });

  return (await result.json()) as { s3Url: string };
};

const FilePreview: React.FC<IFilePreviewProps> = (p) => {
  const { isLoading, data, isError } = useQuery(
    ['file-preview', p.s3ObjectKey],
    () => getS3SignedUrl(p.s3ObjectKey),
    {
      refetchOnWindowFocus: false,
      refetchInterval: 3600000, // 1hr same as expire time
      cacheTime: 3600000,
      staleTime: 3600000,
    }
  );

  const fileType = React.useMemo(
    () => determineFileType(p.fileType),
    [p.fileType]
  );

  if (isLoading) {
    return <LoadingSpinner fillClass="fill-accent-500" size="sm" />;
  }

  return (
    <>
      {data?.s3Url && (
        <>
          {fileType === FileType.DOCUMENT ? (
            <a href={data.s3Url} target="_blank" download title="Download">
              <span className="sr-only">Download</span>
              <FileDownload03
                className="h-5 w-5 text-gray-500"
                viewBox="0 0 24 24"
              />
            </a>
          ) : (
            <PreviewModal
              open={p.open}
              setOpen={p.setOpen}
              s3Url={data.s3Url}
              fileType={fileType}
            />
          )}
        </>
      )}
      <ErrorToast
        show={isError}
        text="Unable to generate preview. Please try again."
        onClose={p.setOpen}
        position="fixed"
      />
    </>
  );
};

export default FilePreview;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/file-upload/file-items/file-preview/preview-modal.tsx

import Image from 'next/image';
import React, { Fragment } from 'react';

import { FileType } from '@/utils/enums';
import { Dialog, Transition } from '@headlessui/react';
import { XMarkIcon } from '@heroicons/react/20/solid';

interface IPreviewModalProps {
  s3Url: string;
  setOpen: () => void;
  open: boolean;
  fileType: FileType.IMAGE | FileType.VIDEO;
}

const PreviewModal: React.FC<IPreviewModalProps> = (p) => {
  return (
    <Transition.Root show={p.open} as={Fragment}>
      <Dialog as="div" className="relative z-50" onClose={p.setOpen}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity" />
        </Transition.Child>

        <div className="fixed inset-0 z-10 w-screen overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4 text-center sm:items-center sm:p-0">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
              enterTo="opacity-100 translate-y-0 sm:scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 translate-y-0 sm:scale-100"
              leaveTo="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
            >
              <Dialog.Panel className="relative overflow-hidden text-left sm:my-8 sm:w-full sm:max-w-xl">
                <div className="absolute right-0 top-0 block pr-4 pt-4 z-10">
                  <button
                    type="button"
                    className="rounded-md bg-gray-50/30 text-gray-500 hover:text-gray-700 focus:outline-none"
                    onClick={p.setOpen}
                  >
                    <span className="sr-only">Close</span>
                    <XMarkIcon className="h-6 w-6" aria-hidden="true" />
                  </button>
                </div>
                <div className="aspect-h-1 aspect-w-1 overflow-hidden rounded-lg max-h-screen">
                  {p.fileType === FileType.VIDEO && (
                    <video
                      src={p.s3Url}
                      className="h-full w-full object-cover object-center"
                      width={1000}
                      height={1000}
                      controls={true}
                    />
                  )}

                  {p.fileType === FileType.IMAGE && (
                    <Image
                      className="h-full w-full object-cover object-center"
                      src={p.s3Url}
                      alt=""
                      width={1000}
                      height={1000}
                    />
                  )}
                </div>
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition.Root>
  );
};

export default PreviewModal;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/file-upload/file-items/file-preview/file-preview-trigger.tsx

import React from 'react';

import ButtonBase from '@components/buttons/button-base';

import FilePreview from './file-preview';

interface IFilePreviewTriggerProps {
  fileType: string;
  s3ObjectKey: string;
  disabled?: boolean;
}

const FilePreviewTrigger: React.FC<IFilePreviewTriggerProps> = (p) => {
  const [open, setOpen] = React.useState<boolean>(false);

  return p.s3ObjectKey ? (
    <>
      <ButtonBase
        variant="accent"
        size="sm"
        className="px-0"
        onClick={() => setOpen(true)}
        disabled={p.disabled}
      >
        View Preview
      </ButtonBase>
      {open && (
        <FilePreview
          open={open}
          setOpen={() => setOpen(false)}
          s3ObjectKey={p.s3ObjectKey}
          fileType={p.fileType}
        />
      )}
    </>
  ) : null;
};

export default FilePreviewTrigger;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/cart/cart-context-wrapper.tsx

'use client';

import CartSliderContextProvider from '../../contexts/cart-slider-context';

const CartContextWrapper = ({ children }: { children: React.ReactNode }) => {
  return <CartSliderContextProvider>{children}</CartSliderContextProvider>;
};

export default CartContextWrapper;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/cart/cart-button/index.tsx

import { cookies } from 'next/headers';
import { ProductPageDocument } from 'prismicio-types';

import { userCartReturn } from '@/utils/ecommerce/cartUtils';
import { getBaseUrl } from '@/utils/getBaseUrl';
import { CartProducts, Product } from '@prisma/client';

import ClientCartButton from './client-cart-button';

export interface IProductContent extends CartProducts {
  product: Product;
  content: ProductPageDocument;
}

const getCart = async () => {
  const res = await fetch(`${getBaseUrl()}/api/ecommerce/cart`, {
    method: 'GET',
    headers: { Cookie: cookies().toString() },
    cache: 'no-store',
  });
  return (await res.json()) as userCartReturn;
};

/**
 * Cart button that fetches items in cart server-side. Must be used in a server-side
 * rendered page wrapped in the CartSliderContextProvider.
 * @returns Promise<JSX.Element>
 */
const CartButton = async () => {
  const cart = await getCart();

  return <ClientCartButton cart={cart} />;
};

export default CartButton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/cart/cart-button/client-cart-button.tsx

'use client';

import React from 'react';

import { useCartSliderContext } from '@/app/shared/hooks/use-cart-slider-context';
import { userCartReturn } from '@/utils/ecommerce/cartUtils';
import { ProductCategories } from '@prisma/client';
import { ShoppingCart02 } from '@untitled-ui/icons-react';

import ButtonOutline from '../../buttons/button-outline';

interface ICartButtonProps {
  cart: userCartReturn;
}

const ClientCartButton: React.FC<ICartButtonProps> = (p) => {
  const { setShowCart } = useCartSliderContext();

  const otcProducts = (p?.cart?.cartProducts ?? []).filter(
    (item) => item.product.category === ProductCategories.OTC_MEDICATION
  );

  const concierge = (p?.cart?.cartSubscriptionProducts ?? []).filter(
    (item) => item.subscriptionProduct.category === ProductCategories.CONCIERGE
  );

  const itemsInCart = [...concierge, ...otcProducts].reduce((acc, item) => {
    return acc + item.quantity;
  }, 0);

  return (
    <ButtonOutline
      variant="gray"
      className="relative p-2"
      onClick={() => setShowCart(true)}
    >
      <span className="sr-only">Cart</span>
      <ShoppingCart02
        className="h-5 w-5 text-gray-400"
        aria-hidden="true"
        viewBox="0 0 24 24"
      />
      {itemsInCart > 0 && (
        <span className="absolute right-0 top-0 flex items-center justify-center h-[22px] w-6 -translate-y-1/2 translate-x-1/2 transform rounded-full bg-accent-50 ring-1 ring-accent-200 font-dmsans text-accent-700 text-xs font-medium text-center align-middle">
          {itemsInCart}
        </span>
      )}
    </ButtonOutline>
  );
};

export default ClientCartButton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/cart/cart-items/cart-items.tsx

import { ProductPageDocument } from 'prismicio-types';
import React from 'react';

import { CartInclude } from '@/app/shared/types';
import { ProductCategories } from '@prisma/client';

import CartItem from './cart-item';

interface ICartItemsProps {
  cart: CartInclude;
  productsContent: ProductPageDocument[];
  includedCategories?: ProductCategories[];
  includeSubscription?: boolean;
  isRefreshing: boolean;
  startRefresh: () => void;
  disableConsultationRemove?: boolean;
}

const CartItems: React.FC<ICartItemsProps> = ({
  cart,
  productsContent,
  includedCategories = [],
  includeSubscription = true,
  isRefreshing,
  startRefresh,
  disableConsultationRemove,
}) => {
  const filteredProducts = getFilteredProducts(cart, includedCategories);
  const filteredSubscriptions = getFilteredSubscriptions(
    cart,
    includedCategories
  );

  return (
    <div className="mt-8">
      <div className="flow-root">
        <ul role="list" className="-my-6 divide-y divide-gray-200">
          {filteredProducts.map((product) => (
            <CartItem
              key={product.id}
              item={{
                quantity: product.quantity,
                price: product.product.price,
                productId: product.product.id,
                name: product.product.name,
                imageURL: product.product.imageURL,
                category: product.product.category,
                isSubscription: false,
              }}
              productsContent={productsContent}
              isRefreshing={isRefreshing}
              startRefresh={startRefresh}
              disableConsultationRemove={disableConsultationRemove}
            />
          ))}
          {includeSubscription &&
            filteredSubscriptions.map((subscription) => (
              <CartItem
                key={subscription.id}
                item={{
                  quantity: subscription.quantity,
                  price: subscription.subscriptionProduct.price,
                  productId: subscription.subscriptionProduct.id,
                  name: subscription.subscriptionProduct.name,
                  category: subscription.subscriptionProduct.category,
                  isSubscription: true,
                  frequency: subscription.subscriptionProduct.frequency,
                  frequencyUnit: subscription.subscriptionProduct.frequencyUnit,
                }}
                productsContent={productsContent}
                isRefreshing={isRefreshing}
                startRefresh={startRefresh}
              />
            ))}
        </ul>
      </div>
    </div>
  );
};

const getFilteredProducts = (
  cart: CartInclude,
  includedCategories: ProductCategories[]
) => {
  return cart.cartProducts.filter((product) => {
    if (includedCategories && includedCategories.length > 0) {
      return includedCategories.includes(product.product.category);
    }
    return true;
  });
};

const getFilteredSubscriptions = (
  cart: CartInclude,
  includedCategories: ProductCategories[]
) => {
  return cart.cartSubscriptionProducts.filter((subscription) => {
    if (includedCategories && includedCategories.length > 0) {
      return includedCategories.includes(
        subscription.subscriptionProduct.category
      );
    }
    return true;
  });
};

export default CartItems;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/cart/cart-items/cart-item-actions.tsx

'use client';

import React from 'react';
import { twMerge } from 'tailwind-merge';

import ButtonOutline from '@/app/shared/components/buttons/button-outline';
import TextField from '@/app/shared/components/form-controls/text-field';
import { ProductCategories } from '@prisma/client';

import { ICartItemProps } from './cart-item';

const updateQuantity = async (
  productId: string,
  quantity: number,
  isSubscription: boolean
) => {
  const updateRoute = isSubscription
    ? '/api/ecommerce/subscription-product'
    : '/api/ecommerce/product';
  try {
    const res = await fetch(`${updateRoute}/${productId}/cart`, {
      method: 'POST',
      body: JSON.stringify({ setAbsoluteAmount: true, amount: quantity }),
    });

    if (!res.ok) {
      throw new Error('Could not update product quantity in cart');
    }

    return { success: true };
  } catch (error) {
    return { success: false };
  }
};

const CartItemActions: React.FC<ICartItemProps> = ({
  item,
  isRefreshing,
  startRefresh,
  disableConsultationRemove,
}) => {
  const [quantity, setQuantity] = React.useState(item.quantity.toString());
  const [updating, setUpdating] = React.useState(false);
  const [removing, setRemoving] = React.useState(false);
  const [error, setError] = React.useState(false);

  const handleQuantityChange = async (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    const value = e.target.value;
    const parsedValue = parseInt(value, 10);
    if (Number.isNaN(parsedValue) || parsedValue < 1) {
      setQuantity('');
    } else {
      setQuantity(parsedValue.toString());
    }
  };

  const handleQuantityUpdate = async () => {
    setUpdating(true);
    const parsedValue = parseInt(quantity, 10);

    if (Number.isNaN(parsedValue)) {
      setQuantity(item.quantity.toString());
    } else {
      const { success } = await updateQuantity(
        item.productId,
        parsedValue,
        item.isSubscription
      );

      if (success) {
        startRefresh();
      } else {
        setQuantity(item.quantity.toString());
        setError(true);
      }
    }
    setUpdating(false);
  };

  const handleRemoveFromCart = async () => {
    setRemoving(true);
    const { success } = await updateQuantity(
      item.productId,
      0,
      item.isSubscription
    );

    if (success) {
      startRefresh();
    } else {
      setError(true);
    }

    setRemoving(false);
  };

  const disabled = updating || removing || isRefreshing;

  const showRemoveButton = !(
    disableConsultationRemove &&
    item.category === ProductCategories.CONSULTATION
  );

  return (
    <>
      <div className="mt-1 flex flex-row gap-1 items-center">
        <span className="text-gray-500 text-sm">Quantity:</span>
        <div>
          {item.category === ProductCategories.OTC_MEDICATION ? (
            <TextField
              inputMode="numeric"
              pattern="[0-9]*"
              className="ml-1 px-1 rounded text-center text-sm h-6 w-10"
              value={quantity}
              onChange={handleQuantityChange}
              onBlur={handleQuantityUpdate}
              onKeyDown={(e) => {
                if (e.key === 'Enter') {
                  handleQuantityUpdate();
                }
              }}
              disabled={disabled}
            />
          ) : (
            <span className="text-gray-500 text-sm">{item.quantity}</span>
          )}
        </div>
      </div>
      {showRemoveButton && (
        <div className="mt-3 flex flex-1 text-sm">
          <ButtonOutline
            variant="gray"
            className={twMerge(
              'py-0.5 rounded',
              removing ? 'bg-black text-white' : ''
            )}
            onClick={handleRemoveFromCart}
            disabled={disabled}
          >
            Remove
          </ButtonOutline>
        </div>
      )}
      {error && (
        <p className="mt-2 text-red-500 text-xs">
          There was a problem. Please try again.
        </p>
      )}
    </>
  );
};

export default CartItemActions;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/cart/cart-items/cart-items-skeleton.tsx

const CartItemsSkeleton = () => {
  return (
    <div className="mt-8 animate-pulse">
      <div className="flow-root">
        <ul role="list" className="-my-6 divide-y divide-gray-200">
          {[...Array(2)].map((_item, i) => (
            <li key={`cart-item-line-${i}`} className="flex py-6 items-center">
              <div className="h-20 w-20 sm:h-24 sm:w-24 flex-shrink-0 overflow-hidden rounded-md bg-gray-200" />

              <div className="ml-4 flex flex-1 flex-col">
                <div>
                  <div className="flex justify-between text-base">
                    <div className="h-6 bg-gray-200 w-3/4 rounded" />
                    <div className="h-6 bg-gray-200 w-10 rounded ml-4" />
                  </div>
                </div>

                <div className="mt-1 flex flex-row gap-1 items-center">
                  <div className="bg-gray-200 h-5 w-20 rounded" />
                  <div className="bg-gray-200 h-5 w-10 ml-1 rounded" />
                </div>
                <div className="mt-3 flex flex-1 text-sm">
                  <div className="bg-gray-200 h-6 w-20 rounded" />
                </div>
              </div>
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
};

export default CartItemsSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/cart/cart-items/cart-item.tsx

import Image from 'next/image';
import { ProductPageDocument } from 'prismicio-types';

import { getPrismicProductId } from '@/utils/get-prismic-product-id';
import { formatCurrency } from '@/utils/utils';
import { ProductCategories, SubscriptionFrequencyUnits } from '@prisma/client';
import { isFilled } from '@prismicio/client';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';

import CartItemActions from './cart-item-actions';

interface ICartItem {
  quantity: number;
  price: number;
  productId: string;
  name: string;
  imageURL?: string | null;
  category: ProductCategories;
  isSubscription: boolean;
  frequency?: number;
  frequencyUnit?: SubscriptionFrequencyUnits;
}

export interface ICartItemProps {
  item: ICartItem;
  productsContent: ProductPageDocument[];
  isRefreshing: boolean;
  startRefresh: () => void;
  disableConsultationRemove?: boolean;
}

const ProductImage = ({
  item,
  prismicContent,
}: {
  item: ICartItem;
  prismicContent?: ProductPageDocument | null;
}) => {
  if (prismicContent && isFilled.image(prismicContent.data.thumbnail)) {
    return (
      <div className="h-24 w-24 flex-shrink-0 overflow-hidden rounded-md">
        <PrismicNextImage
          field={prismicContent.data.thumbnail}
          alt=""
          className="h-full w-full object-cover object-center"
        />
      </div>
    );
  }

  if (item.imageURL) {
    return (
      <div className="h-24 w-24 flex-shrink-0 overflow-hidden rounded-md">
        <Image
          src={item.imageURL}
          alt=""
          className="h-full w-full object-cover object-center"
        />
      </div>
    );
  }

  return null;
};

const CartItem: React.FC<ICartItemProps> = (p) => {
  const { item, productsContent } = p;
  const prismicContent = productsContent.find(
    (document) => getPrismicProductId(document.data) === item.productId
  );

  return (
    <li className="flex py-6 items-center">
      <ProductImage item={item} prismicContent={prismicContent} />

      <div className="ml-4 flex flex-1 flex-col">
        <div>
          <div className="flex justify-between text-base font-medium text-gray-900">
            <h3>
              {prismicContent ? (
                <>
                  {prismicContent.data.is_shop_product ? (
                    <PrismicNextLink document={prismicContent}>
                      {prismicContent.data.name}
                    </PrismicNextLink>
                  ) : (
                    prismicContent.data.name
                  )}
                </>
              ) : (
                item.name
              )}
            </h3>
            <p className="ml-4">{formatCurrency(item.quantity * item.price)}</p>
          </div>
        </div>

        <CartItemActions {...p} />
      </div>
    </li>
  );
};

export default CartItem;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/cart/cart-slider/index.tsx

import { cookies } from 'next/headers';
import { ProductPageDocument, ShopCartDocument } from 'prismicio-types';

import { CartInclude } from '@/app/shared/types';
import { createClient } from '@/prismicio';
import { getIsProd } from '@/utils/get-is-prod';
import { getPrismicProductId } from '@/utils/get-prismic-product-id';
import { getBaseUrl } from '@/utils/getBaseUrl';
import { PrismicCustomType, PrismicPageType } from '@/utils/prismic/enums';
import { CartProducts, Product, ProductCategories } from '@prisma/client';
import { filter } from '@prismicio/client';

import ClientCartSlider from './client-cart-slider';

export interface IProductContent extends CartProducts {
  product: Product;
  content?: ProductPageDocument;
}

const isProd = getIsProd();

const getCart = async () => {
  const res = await fetch(`${getBaseUrl()}/api/ecommerce/cart`, {
    method: 'GET',
    headers: { Cookie: cookies().toString() },
    cache: 'no-store',
  });
  return (await res.json()) as CartInclude;
};

const getProductContent = async (cart: CartInclude) => {
  const client = createClient();

  const filterString = !isProd
    ? `my.${PrismicPageType.PRODUCT_PAGE}.dev_product_id`
    : `my.${PrismicPageType.PRODUCT_PAGE}.product_id`;

  const ids = (cart.cartProducts ?? []).map((item) => item.productId);
  try {
    const products = await client.getAllByType<ProductPageDocument>(
      PrismicPageType.PRODUCT_PAGE,
      {
        filters: [filter.any(filterString, ids)],
      }
    );

    return products;
  } catch (error) {
    return [];
  }
};

const getCartContent = async () => {
  const client = createClient();
  return client.getSingle<ShopCartDocument>(PrismicCustomType.SHOPCART);
};

/**
 * Cart slider that fetches items in cart server-side. Must be used in a server-side
 * rendered page wrapped in the CartSliderContextProvider.
 * @returns Promise<JSX.Element>
 */
const CartSlider = async () => {
  const [cartItems, cartContent] = await Promise.all([
    getCart(),
    getCartContent(),
  ]);

  const productContent = await getProductContent(cartItems);

  const otcProducts = (cartItems?.cartProducts ?? []).filter(
    (product) => product.product.category === ProductCategories.OTC_MEDICATION
  );

  const products = otcProducts.map((product) => {
    const content = productContent.find(
      (item) => getPrismicProductId(item.data) === product.productId
    );

    return {
      ...product,
      content,
    } as IProductContent;
  });

  return (
    <ClientCartSlider
      cart={cartItems}
      products={products}
      productsContent={productContent}
      content={cartContent}
    />
  );
};

export default CartSlider;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/cart/cart-slider/client-cart-slider.tsx

'use client';

import { useRouter } from 'next/navigation';
import { ProductPageDocument, ShopCartDocument } from 'prismicio-types';
import React, { Fragment } from 'react';

import CartSummaryItems from '@/app/shared/components/cart/cart-items/cart-items';
import { useCartSliderContext } from '@/app/shared/hooks/use-cart-slider-context';
import { CartInclude } from '@/app/shared/types';
import { Dialog, Transition } from '@headlessui/react';
import { XMarkIcon } from '@heroicons/react/24/outline';
import { ProductCategories } from '@prisma/client';

import CustomPrismicLink from '../../buttons/custom-prismic-link';
import CartItemsSkeleton from '../cart-items/cart-items-skeleton';
import { IProductContent } from './index';

interface ICartSliderProps {
  cart: CartInclude;
  products: IProductContent[];
  productsContent: ProductPageDocument[];
  content: ShopCartDocument;
}

const ClientCartSlider: React.FC<ICartSliderProps> = (p) => {
  const { content } = p;
  const router = useRouter();
  const { showCart, setShowCart, isPending, startTransition } =
    useCartSliderContext();
  return (
    <Transition.Root show={showCart} as={Fragment}>
      <Dialog as="div" className="relative z-[60]" onClose={setShowCart}>
        <Transition.Child
          as={Fragment}
          enter="ease-in-out duration-500"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in-out duration-500"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity" />
        </Transition.Child>

        <div className="fixed inset-0 overflow-hidden">
          <div className="absolute inset-0 overflow-hidden">
            <div className="pointer-events-none fixed inset-y-0 right-0 flex max-w-full pl-0 sm:pl-10">
              <Transition.Child
                as={Fragment}
                enter="transform transition ease-in-out duration-500 sm:duration-700"
                enterFrom="translate-x-full"
                enterTo="translate-x-0"
                leave="transform transition ease-in-out duration-500 sm:duration-700"
                leaveFrom="translate-x-0"
                leaveTo="translate-x-full"
              >
                <Dialog.Panel className="pointer-events-auto w-screen max-w-md">
                  <div className="flex h-full flex-col overflow-y-scroll bg-white shadow-xl">
                    <div className="flex-1 overflow-y-auto px-4 py-6 sm:px-6">
                      <div className="flex items-start justify-between">
                        <Dialog.Title className="text-lg font-medium text-gray-900">
                          {content.data.title}
                        </Dialog.Title>
                        <div className="ml-3 flex h-7 items-center">
                          <button
                            type="button"
                            className="relative -m-2 p-2 text-gray-400 hover:text-gray-500"
                            onClick={() => setShowCart(false)}
                          >
                            <span className="absolute -inset-0.5" />
                            <span className="sr-only">Close panel</span>
                            <XMarkIcon className="h-6 w-6" aria-hidden="true" />
                          </button>
                        </div>
                      </div>

                      {isPending ? (
                        <CartItemsSkeleton />
                      ) : (
                        <CartSummaryItems
                          cart={p.cart}
                          productsContent={p.productsContent}
                          includedCategories={[
                            ProductCategories.OTC_MEDICATION,
                            ProductCategories.CONCIERGE,
                          ]}
                          includeSubscription={true}
                          isRefreshing={isPending}
                          startRefresh={() =>
                            startTransition(() => router.refresh())
                          }
                        />
                      )}
                    </div>

                    <div className="border-t border-gray-200 px-4 py-6 sm:px-6">
                      <div className="">
                        <CustomPrismicLink
                          variant="solid-accent"
                          field={content.data.checkout_link}
                          onClick={() => setShowCart(false)}
                          className="flex items-center justify-center rounded-md border border-transparent px-6 py-3 text-base shadow-sm"
                        >
                          {content.data.checkout_link_text}
                        </CustomPrismicLink>
                      </div>
                    </div>
                  </div>
                </Dialog.Panel>
              </Transition.Child>
            </div>
          </div>
        </div>
      </Dialog>
    </Transition.Root>
  );
};

export default ClientCartSlider;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/text/paragraph.tsx

import React from 'react';
import { twMerge } from 'tailwind-merge';

interface IParagraphProps {
  variant?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'p';
  size?: 'sm' | 'md' | 'lg' | 'xl'; // Only applies to p variant
  className?: string;
  children: React.ReactNode;
}

const sizeMap = {
  sm: 'text-sm',
  md: 'text-base',
  lg: 'text-lg',
  xl: 'text-xl',
};

const variantMap = {
  p: '',
  h1: 'text-5xl font-semibold text-primary-950 my-6',
  h2: 'text-4xl font-semibold text-primary-950 my-5',
  h3: 'text-3xl font-semibold text-primary-950 my-5',
  h4: 'text-2xl font-semibold text-primary-950 my-5',
  h5: 'font-financier text-4xl font-semibold text-[#202939] mb-0',
};

const Paragraph: React.FC<IParagraphProps> = ({
  variant = 'p',
  size = 'md',
  className,
  children,
}) => {
  // Dynamically choose the component based on the variant prop
  const Tag = variant || 'p'; // Default to 'p' if variant is not provided
  const sizeStyle = sizeMap[size];
  const variantStyle = variantMap[variant];

  return React.createElement(
    Tag,
    {
      className: twMerge([
        'font-dmsans text-gray-600 mb-5 text-md',
        sizeStyle,
        variantStyle,
        className,
      ]),
    },
    children
  );
};

export default Paragraph;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/text/rich-text.tsx

import { twMerge } from 'tailwind-merge';

import { RichTextField } from '@prismicio/client';
import {
  JSXMapSerializer,
  PrismicRichText,
  PrismicLink,
} from '@prismicio/react';

export const richTextComponents: JSXMapSerializer = {
  label: ({ node, children }) => {
    if (node.data.label === 'codespan') {
      return <code>{children}</code>;
    }
  },
  heading1: ({ children }) => (
    <div className="text-4xl font-bold tracking-tight text-gray-900">
      {children}
    </div>
  ),
  heading2: ({ children }) => (
    <div className="text-3xl font-semibold text-gray-900">{children}</div>
  ),
  heading3: ({ children }) => (
    <div className="text-2xl font-semibold text-gray-900">{children}</div>
  ),
  heading4: ({ children }) => (
    <div className="text-xl font-medium text-gray-900">{children}</div>
  ),
  heading5: ({ children }) => (
    <div className="text-lg text-gray-900">{children}</div>
  ),
  paragraph: ({ children }) => <p>{children}</p>,
  list: ({ children }) => (
    <ul className="list-disc ml-6 space-y-1.5">{children}</ul>
  ),
  hyperlink: ({ children, node }) => (
    <PrismicLink field={node.data} className="underline text-accent-700">
      {children}
    </PrismicLink>
  ),
  em: ({ children }) => <em>{children}</em>,
};

interface RichTextProps {
  field: RichTextField;
  components?: JSXMapSerializer;
}

export const RichText = ({
  field,
  className,
  components,
}: RichTextProps & { className?: string }) => {
  return (
    <div
      className={twMerge(
        'font-dmsans text-base text-gray-600 space-y-6',
        className
      )}
    >
      <PrismicRichText
        field={field}
        components={components ? components : richTextComponents}
      />
    </div>
  );
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/errors/error-boundary.tsx

'use client';

import { Component, ErrorInfo, ReactNode } from 'react';

import { datadogRum } from '@datadog/browser-rum';

interface ErrorBoundaryProps {
  fallback: ReactNode;
  children: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
}

class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(_: Error): ErrorBoundaryState {
    return { hasError: true };
  }

  componentDidCatch(error: Error, info: ErrorInfo): void {
    datadogRum.addError(error, {
      componentStack: info.componentStack,
    });
  }

  render(): ReactNode {
    if (this.state.hasError) {
      return this.props.fallback;
    }

    return this.props.children;
  }
}

export default ErrorBoundary;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/dropdowns/dependent-dropdown.tsx

'use client';

import React, { Fragment } from 'react';
import { twMerge } from 'tailwind-merge';

import { Menu, Transition } from '@headlessui/react';
import { ChevronDownIcon, PlusIcon } from '@heroicons/react/20/solid';
import {
  FilledContentRelationshipField,
  FilledLinkToWebField,
  KeyTextField,
  LinkField,
  LinkResolverFunction,
  isFilled,
} from '@prismicio/client';
import { PrismicNextLink } from '@prismicio/next';

import { ExtendedUser } from '../../types';

interface IDependentDropdownProps {
  user?: ExtendedUser;
  link: FilledContentRelationshipField | FilledLinkToWebField | LinkField;
  dropdownText?: KeyTextField;
  linkResolver?: LinkResolverFunction;
}

const DependentDropdown: React.FC<IDependentDropdownProps> = ({
  user,
  link,
  dropdownText,
  linkResolver,
}) => {
  const isContentRelationship = isFilled.contentRelationship(link);

  if (!isContentRelationship) {
    return null;
  }

  const getDependentLink = (dependentId: string): string => {
    let pathAndQuery = linkResolver ? linkResolver(link) : null;

    if (!pathAndQuery && link.url) pathAndQuery = link.url;
    else if (!pathAndQuery) return '';

    const finalUrl = new URL(pathAndQuery, process.env.NEXT_PUBLIC_BASE_URL);

    finalUrl.searchParams.append('mid', dependentId);

    return `${finalUrl.pathname}${finalUrl.search}`;
  };

  return (
    <Menu as="div" className="relative inline-block text-left w-full">
      <div>
        <Menu.Button className="font-dmsans inline-flex w-full items-center justify-center gap-x-1.5 rounded-md bg-white px-3 py-2 text-base font-semibold text-gray-700 shadow-sm ring-1 ring-gray-300 hover:bg-gray-50">
          {dropdownText}
          <ChevronDownIcon
            className="-mr-1 h-5 w-5 text-gray-400"
            aria-hidden="true"
          />
        </Menu.Button>
      </div>

      <Transition
        as={Fragment}
        enter="transition ease-out duration-100"
        enterFrom="transform opacity-0 scale-95"
        enterTo="transform opacity-100 scale-100"
        leave="transition ease-in duration-75"
        leaveFrom="transform opacity-100 scale-100"
        leaveTo="transform opacity-0 scale-95"
      >
        <Menu.Items className="absolute right-0 bottom-[48px] sm:bottom-auto z-50 mt-2 w-56 origin-top-right rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none">
          <div className="py-1">
            {(user?.dependents ?? []).map((dependent) => (
              <Menu.Item key={dependent.id}>
                {({ active }) => (
                  <PrismicNextLink
                    href={getDependentLink(dependent.id)}
                    className={twMerge(
                      active && 'bg-gray-100',
                      'block px-4 py-2 font-dmsans text-base text-gray-900 font-medium'
                    )}
                    linkResolver={linkResolver}
                  >
                    {dependent.firstName}
                  </PrismicNextLink>
                )}
              </Menu.Item>
            ))}
            <Menu.Item>
              {({ active }) => (
                <PrismicNextLink
                  field={link}
                  className={twMerge(
                    active && 'bg-gray-100',
                    'flex items-center gap-1 px-4 py-2 font-dmsans text-base text-gray-900 font-medium'
                  )}
                  linkResolver={linkResolver}
                >
                  <PlusIcon className="h-3 w-3 text-gray-900" />
                  <span>Add New</span>
                </PrismicNextLink>
              )}
            </Menu.Item>
          </div>
        </Menu.Items>
      </Transition>
    </Menu>
  );
};
export default DependentDropdown;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/header/profileMenu.tsx

import { Session } from 'next-auth';
import { signIn, signOut, useSession } from 'next-auth/react';
import Image from 'next/image';
import React, { Fragment } from 'react';
import { twMerge } from 'tailwind-merge';

import { getSignoutUrl } from '@/app/(features)/(authentication)/signout/getSignoutUrl';
import { Menu, Transition } from '@headlessui/react';

export const ProfileMenu = () => {
  const { data: session, status } = useSession();
  if (status === 'authenticated') return AuthenticatedProfileMenu(session);
  else return UnauthenticatedProfileMenu();
};

const UnauthenticatedProfileMenu = () => {
  return (
    <Menu as="div" className="relative ml-3">
      <div>
        <Menu.Button className="relative flex rounded-full bg-white text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
          <span className="absolute -inset-1.5" />
          <span className="sr-only">Open user menu</span>
          <Image
            className="w-8 rounded-full"
            src="/assets/neutral-placeholder-profile.jpg"
            alt=""
            width="100"
            height="100"
          />
        </Menu.Button>
      </div>
      <Transition
        as={Fragment}
        enter="transition ease-out duration-200"
        enterFrom="transform opacity-0 scale-95"
        enterTo="transform opacity-100 scale-100"
        leave="transition ease-in duration-75"
        leaveFrom="transform opacity-100 scale-100"
        leaveTo="transform opacity-0 scale-95"
      >
        <Menu.Items className="absolute right-0 z-10 mt-2 w-48 origin-top-right rounded-md bg-white py-1 shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none">
          <Menu.Item>
            {({ active }) => (
              <button
                className={twMerge(
                  active ? 'bg-gray-100' : '',
                  'block px-4 py-2 text-sm text-gray-700'
                )}
                onClick={() => signIn()}
              >
                Sign In
              </button>
            )}
          </Menu.Item>
        </Menu.Items>
      </Transition>
    </Menu>
  );
};

const AuthenticatedProfileMenu = (session: Session) => {
  return (
    <Menu as="div" className="relative ml-3">
      <div>
        <Menu.Button className="relative flex rounded-full bg-white text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
          <span className="absolute -inset-1.5" />
          <span className="sr-only">Open user menu</span>
          <Image
            className="h-8 w-8 rounded-full"
            src={
              session?.user?.image ?? '/assets/neutral-placeholder-profile.jpg'
            }
            alt=""
            width="50"
            height="50"
          />
        </Menu.Button>
      </div>
      <Transition
        as={Fragment}
        enter="transition ease-out duration-200"
        enterFrom="transform opacity-0 scale-95"
        enterTo="transform opacity-100 scale-100"
        leave="transition ease-in duration-75"
        leaveFrom="transform opacity-100 scale-100"
        leaveTo="transform opacity-0 scale-95"
      >
        <Menu.Items className="absolute right-0 z-10 mt-2 w-48 origin-top-right rounded-md bg-white py-1 shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none">
          <Menu.Item>
            {({ active }) => (
              <a
                href="#"
                className={twMerge(
                  active ? 'bg-gray-100' : '',
                  'block px-4 py-2 text-sm text-gray-700'
                )}
              >
                Your Profile
              </a>
            )}
          </Menu.Item>
          <Menu.Item>
            {({ active }) => (
              <a
                href="#"
                className={twMerge(
                  active ? 'bg-gray-100' : '',
                  'block px-4 py-2 text-sm text-gray-700'
                )}
              >
                Settings
              </a>
            )}
          </Menu.Item>
          <Menu.Item>
            {({ active }) => (
              <button
                className={twMerge(
                  active ? 'bg-gray-100' : '',
                  'block px-4 py-2 text-sm text-gray-700'
                )}
                onClick={async () => {
                  const callbackUrl = await getSignoutUrl();
                  signOut({ redirect: true, callbackUrl });
                }}
              >
                Sign Out
              </button>
            )}
          </Menu.Item>
        </Menu.Items>
      </Transition>
    </Menu>
  );
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/header/header.tsx

'use client';

import { SessionProvider } from 'next-auth/react';
import Image from 'next/image';
import { Fragment } from 'react';

import { Disclosure } from '@headlessui/react';
import { Bars3Icon, BellIcon, XMarkIcon } from '@heroicons/react/24/outline';

import { ProfileMenu } from './profileMenu';

export default function Header() {
  return (
    <Disclosure as="nav" className="bg-white shadow">
      {({ open }) => (
        <>
          <div className="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
            <div className="flex h-16 justify-between">
              <div className="flex">
                <div className="-ml-2 mr-2 flex items-center md:hidden">
                  {/* Mobile menu button */}
                  <Disclosure.Button className="relative inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-100 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500">
                    <span className="absolute -inset-0.5" />
                    <span className="sr-only">Open main menu</span>
                    {open ? (
                      <XMarkIcon className="block h-6 w-6" aria-hidden="true" />
                    ) : (
                      <Bars3Icon className="block h-6 w-6" aria-hidden="true" />
                    )}
                  </Disclosure.Button>
                </div>
                <div className="flex flex-shrink-0 items-center">
                  <Image
                    className="h-8 w-auto"
                    src="https://tailwindui.com/img/logos/mark.svg?color=indigo&shade=600"
                    alt="Your Company"
                    width="50"
                    height="50"
                  />
                </div>
                <div className="hidden md:ml-6 md:flex md:space-x-8">
                  {/* Current: "border-indigo-500 text-gray-900", Default: "border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700" */}
                  <a
                    href="/"
                    className="inline-flex items-center border-b-2 border-indigo-500 px-1 pt-1 text-sm font-medium text-gray-900"
                  >
                    Home
                  </a>
                  <a
                    href="/form"
                    className="inline-flex items-center border-b-2 border-transparent px-1 pt-1 text-sm font-medium text-gray-500 hover:border-gray-300 hover:text-gray-700"
                  >
                    Forms
                  </a>
                  <a
                    href="/blog"
                    className="inline-flex items-center border-b-2 border-transparent px-1 pt-1 text-sm font-medium text-gray-500 hover:border-gray-300 hover:text-gray-700"
                  >
                    Blog
                  </a>
                  <a
                    href="/account"
                    className="inline-flex items-center border-b-2 border-transparent px-1 pt-1 text-sm font-medium text-gray-500 hover:border-gray-300 hover:text-gray-700"
                  >
                    Account
                  </a>
                </div>
              </div>
              <div className="flex items-center">
                <div className="flex-shrink-0">
                  <button
                    type="button"
                    className="relative inline-flex items-center gap-x-1.5 rounded-md bg-primary-950 px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-primary-900 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600"
                  >
                    Get Started
                  </button>
                </div>
                <div className="hidden md:ml-4 md:flex md:flex-shrink-0 md:items-center">
                  <button
                    type="button"
                    className="relative rounded-full bg-white p-1 text-gray-400 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-primary-900 focus:ring-offset-2"
                  >
                    <span className="absolute -inset-1.5" />
                    <span className="sr-only">View notifications</span>
                    <BellIcon className="h-6 w-6" aria-hidden="true" />
                  </button>

                  {/* Profile dropdown */}
                  <SessionProvider>
                    <ProfileMenu />
                  </SessionProvider>
                </div>
              </div>
            </div>
          </div>

          <Disclosure.Panel className="md:hidden">
            <div className="space-y-1 pb-3 pt-2">
              {/* Current: "bg-indigo-50 border-indigo-500 text-indigo-700", Default: "border-transparent text-gray-500 hover:bg-gray-50 hover:border-gray-300 hover:text-gray-700" */}
              <Disclosure.Button
                as="a"
                href="/"
                className="block border-l-4 border-indigo-500 bg-indigo-50 py-2 pl-3 pr-4 text-base font-medium text-indigo-700 sm:pl-5 sm:pr-6"
              >
                Home
              </Disclosure.Button>
              <Disclosure.Button
                as="a"
                href="/form"
                className="block border-l-4 border-transparent py-2 pl-3 pr-4 text-base font-medium text-gray-500 hover:border-gray-300 hover:bg-gray-50 hover:text-gray-700 sm:pl-5 sm:pr-6"
              >
                Forms
              </Disclosure.Button>
              <Disclosure.Button
                as="a"
                href="/blog"
                className="block border-l-4 border-transparent py-2 pl-3 pr-4 text-base font-medium text-gray-500 hover:border-gray-300 hover:bg-gray-50 hover:text-gray-700 sm:pl-5 sm:pr-6"
              >
                Blog
              </Disclosure.Button>
              <Disclosure.Button
                as="a"
                href="/account"
                className="block border-l-4 border-transparent py-2 pl-3 pr-4 text-base font-medium text-gray-500 hover:border-gray-300 hover:bg-gray-50 hover:text-gray-700 sm:pl-5 sm:pr-6"
              >
                Account
              </Disclosure.Button>
            </div>
            <div className="border-t border-gray-200 pb-3 pt-4">
              <div className="flex items-center px-4 sm:px-6">
                <div className="flex-shrink-0">
                  <Image
                    className="h-10 w-10 rounded-full"
                    src="https://media.licdn.com/dms/image/C4E03AQG0dxZ7NOTKeQ/profile-displayphoto-shrink_800_800/0/1627002802459?e=1697068800&v=beta&t=C32m8TWr4K5-mGhP5A075E77vXR8tKJVAvsjgrxmMU8"
                    alt=""
                    width="50"
                    height="50"
                  />
                </div>
                <div className="ml-3">
                  <div className="text-base font-medium text-gray-800">
                    Tim Ritzema
                  </div>
                  <div className="text-sm font-medium text-gray-500">
                    tim@dermi.io
                  </div>
                </div>
                <button
                  type="button"
                  className="relative ml-auto flex-shrink-0 rounded-full bg-white p-1 text-gray-400 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
                >
                  <span className="absolute -inset-1.5" />
                  <span className="sr-only">View notifications</span>
                  <BellIcon className="h-6 w-6" aria-hidden="true" />
                </button>
              </div>
              <div className="mt-3 space-y-1">
                <Disclosure.Button
                  as="a"
                  href="#"
                  className="block px-4 py-2 text-base font-medium text-gray-500 hover:bg-gray-100 hover:text-gray-800 sm:px-6"
                >
                  Your Profile
                </Disclosure.Button>
                <Disclosure.Button
                  as="a"
                  href="#"
                  className="block px-4 py-2 text-base font-medium text-gray-500 hover:bg-gray-100 hover:text-gray-800 sm:px-6"
                >
                  Settings
                </Disclosure.Button>
                <Disclosure.Button
                  as="a"
                  href="#"
                  className="block px-4 py-2 text-base font-medium text-gray-500 hover:bg-gray-100 hover:text-gray-800 sm:px-6"
                >
                  Sign out
                </Disclosure.Button>
              </div>
            </div>
          </Disclosure.Panel>
        </>
      )}
    </Disclosure>
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/number-spinner/number-spinner.tsx

import React from 'react';
import { useSpring, animated } from 'react-spring';

import { useInterval } from '@hooks/useInterval';

interface NumberSpinnerProps {
  from: number;
  to: number;
  delay?: number;
  precision?: number;
}

function randomDecimal(min: number, max: number, precision: number) {
  const factor = Math.pow(10, precision);
  return Math.min(
    Math.max(
      Math.floor(Math.random() * (max * factor - min * factor) + min * factor) /
        factor,
      min
    ),
    max
  );
}

const NumberSpinner = (p: NumberSpinnerProps) => {
  const [to, setTo] = React.useState(
    randomDecimal(p.from, p.to, p.precision ?? 0)
  );
  const [from, setFrom] = React.useState(
    randomDecimal(p.from, p.to, p.precision ?? 0)
  );

  useInterval(() => {
    setTo(randomDecimal(p.from, p.to, p.precision ?? 0));
    setFrom(randomDecimal(p.from, p.to, p.precision ?? 0));
  }, 2500);

  const { number } = useSpring({
    from: { number: 0 },
    number: to,
    delay: p.delay ?? 100,
    config: { mass: 1, tension: 20, friction: 10 },
  });

  return (
    <animated.span className="font-bold">
      {number.to((n) => n.toFixed(p.precision ?? 0))}
    </animated.span>
  );
};

export default NumberSpinner;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/banner/banner.tsx

'use client';

import React, { useState, useEffect } from 'react';

import { XMarkIcon } from '@heroicons/react/20/solid';

export interface IBannerProps {
  title: string | null;
  subtext: string | null;
  url?: string | null;
  className?: string;
  sessionStorageKey?: string;
}

const Banner: React.FC<IBannerProps> = ({
  title,
  subtext,
  url,
  className,
  sessionStorageKey,
}) => {
  const [isVisible, setIsVisible] = useState(true);

  const sessionItemKey = sessionStorageKey ?? 'bannerDismissed';

  useEffect(() => {
    // Check sessionStorage to see if the banner was previously dismissed
    const isDismissed = sessionStorage.getItem(sessionItemKey) === 'true';
    setIsVisible(!isDismissed);
  }, [sessionItemKey]);

  const dismissBanner = () => {
    // Hide the banner and set a flag in sessionStorage
    setIsVisible(false);
    sessionStorage.setItem(sessionItemKey, 'true');
  };

  // If the banner is not visible, don't render it
  if (!isVisible) return null;

  return (
    <div
      className={`flex items-center gap-x-6 bg-white px-6 py-2.5 sm:px-3.5 ${
        className ? className : ''
      }`}
    >
      <p className="text-sm leading-6 text-gray-900 text-center w-full">
        {url ? (
          <a href={url} rel="noopener noreferrer">
            <strong className="font-semibold">{title || 'Click Here'}</strong>
            {subtext && (
              <>
                <svg
                  viewBox="0 0 2 2"
                  className="mx-2 inline h-0.5 w-0.5 fill-current"
                  aria-hidden="true"
                >
                  <circle cx={1} cy={1} r={1} />
                </svg>
                {subtext}&nbsp;<span aria-hidden="true">&rarr;</span>
              </>
            )}
          </a>
        ) : (
          <>
            <strong className="font-semibold">{title || 'Banner Title'}</strong>
            {subtext && ` - ${subtext}`}
          </>
        )}
      </p>
      <div className="flex flex-1 justify-end">
        <button
          type="button"
          className="-m-3 p-3 focus-visible:outline-offset-[-4px]"
          onClick={dismissBanner}
        >
          <span className="sr-only">Dismiss</span>
          <XMarkIcon className="h-5 w-5 text-gray-900" aria-hidden="true" />
        </button>
      </div>
    </div>
  );
};

export default Banner;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/banner/global-banner.tsx

'use client';

import get from 'lodash.get';
import { GlobalBannerDocument } from 'prismicio-types';
import React, { Fragment } from 'react';

import { createClient } from '@/prismicio';
import { PrismicCustomType } from '@/utils/prismic/enums';
import { Transition } from '@headlessui/react';
import { XMarkIcon } from '@heroicons/react/20/solid';
import { isFilled } from '@prismicio/client';
import { PrismicNextImage, PrismicNextLink } from '@prismicio/next';
import { PrismicRichText } from '@prismicio/react';
import { useQuery } from '@tanstack/react-query';

const fetchGlobalBanner = async () => {
  const client = createClient();
  const banner = await client
    .getSingle<GlobalBannerDocument>(PrismicCustomType.GLOBAL_BANNER)
    .catch(() => undefined);

  return {
    ...banner,
    isActiveBanner: banner !== undefined,
  };
};

const GlobalBanner = () => {
  const { isLoading, data, isError } = useQuery({
    queryKey: ['global-banner'],
    queryFn: fetchGlobalBanner,
  });

  const [isVisible, setIsVisible] = React.useState(true);

  const sessionItemKey = 'globalBannerDismissed';

  React.useEffect(() => {
    // Check sessionStorage to see if the banner was previously dismissed
    const isDismissed = sessionStorage.getItem(sessionItemKey) === 'true';
    setIsVisible(!isDismissed);
  }, [sessionItemKey]);

  const dismissBanner = () => {
    // Hide the banner and set a flag in sessionStorage
    setIsVisible(false);
    sessionStorage.setItem(sessionItemKey, 'true');
  };

  const shouldShow =
    isVisible && !isLoading && !isError && data.isActiveBanner && !!data?.data;

  // If the banner is not visible, don't render it
  if (!shouldShow) return <></>;

  return data?.data ? (
    <Transition
      as={Fragment}
      show={shouldShow}
      appear={true}
      enter="transition ease-out duration-300"
      enterFrom="-translate-y-full"
      enterTo="translate-y-0"
      leave="transition ease-out duration-300"
      leaveFrom="translate-y-0"
      leaveTo="-translate-y-full"
    >
      <div
        className="global-banner min-h-[70px] w-full bg-accent-25 px-6 py-5 sm:py-2.5 pr-8 lg:pl-8 border-b"
        style={{
          backgroundColor: get(data, 'data.background_color', '#F6FEFC'),
          borderColor: get(data, 'data.bottom_border_color', '#5FE9D0'),
        }}
        role="alert"
      >
        <div className="max-w-7xl mx-auto w-full flex items-center justify-between gap-4">
          <div className="flex flex-row gap-2 items-center">
            {isFilled.image(data.data.icon) && (
              <PrismicNextImage
                field={data.data.icon}
                className="w-10 h-10"
                alt=""
              />
            )}
            <div
              className="font-dmsans text-base leading-5"
              style={{
                color: get(data, 'data.text_color', '#107569'),
              }}
            >
              <PrismicRichText
                field={data.data.text}
                components={{
                  paragraph: ({ children }) => <p>{children}</p>,
                  hyperlink: ({ children, node }) => (
                    <PrismicNextLink field={node.data} className="underline">
                      {children}
                    </PrismicNextLink>
                  ),
                }}
              />
            </div>
          </div>
          {data.data.dismissible && (
            <button
              type="button"
              className="flex-none p-3 focus-visible:outline-offset-[-4px]"
              onClick={dismissBanner}
            >
              <span className="sr-only">Dismiss</span>
              <XMarkIcon
                className="h-6 w-6"
                style={{
                  color: get(data, 'data.close_x_color', '#107569'),
                }}
                aria-hidden="true"
              />
            </button>
          )}
        </div>
      </div>
    </Transition>
  ) : null;
};

export default GlobalBanner;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/banner/location-warning.tsx

'use client';

import React, { useEffect, useState } from 'react';

import { getUserCountry } from '@/utils/location/countryChecker';

import Banner from './banner';

const bannerSessionKey = 'lw-dismissed';

const LocationWarning: React.FC = () => {
  const [lwDismissed, setLwDismissed] = useState<boolean>(true);

  useEffect(() => {
    const checkBannerState = async () => {
      const dismissed = sessionStorage.getItem(bannerSessionKey);
      if (dismissed) {
        setLwDismissed(true);
      } else {
        const userCountry = await getUserCountry();
        const userNotInUS = userCountry && userCountry !== 'US';

        setLwDismissed(!userNotInUS);

        if (!userNotInUS) sessionStorage.setItem(bannerSessionKey, 'true');
      }
    };

    checkBannerState();
  }, []);

  if (lwDismissed) return null;

  return (
    <Banner
      title="🇺🇸 Cortina services available in the US"
      subtext="It appears you might be browsing from a another country. Currently, Cortina's online dermatology services are only available to users in the United States."
      key="badcountry"
      className="fixed top-0 left-0 w-full z-[99999] bg-white"
      sessionStorageKey={bannerSessionKey}
    />
  );
};

export default LocationWarning;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/analytics/windowDOM/window-dom.tsx

'use client';

import { useEffect } from 'react';

import { User } from '@prisma/client';

interface Cortina {
  email?: string;
  userId?: string;
}

declare global {
  interface Window {
    dataLayer?: Record<string, unknown>[];
    cortina: Cortina;
  }
}

export interface IWindowDOMProps {
  user?: User | null;
}

const initGTM = (user: User) => {
  try {
    window.cortina = window.cortina || {};
    window.cortina.email = user.email ? user.email : '';
    window.cortina.userId = user.id ? user.id : '';
  } catch (e) {
    /* do nothing */
  }
};

const WindowDOM: React.FC<IWindowDOMProps> = ({ user }) => {
  useEffect(() => {
    if (user) {
      initGTM(user);
    }
  }, [user]);

  return null;
};

export default WindowDOM;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/data-table/table-loading-skeleton.tsx

import React from 'react';

const TableLoadingSkeleton: React.FC = () => {
  return (
    <div className="flow-root animate-pulse">
      <div className="-my-2 overflow-x-hidden -mx-2 lg:-mx-2">
        <div className="inline-block min-w-full py-2 align-middle px-2 lg:px-2">
          <div className="overflow-hidden shadow ring-1 ring-gray-200 rounded-lg mt-6 -mx-0">
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th className="py-5" />
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-200 bg-white">
                {[...Array(4)].map((_e, i) => (
                  <tr key={`table-row-${i}`}>
                    <td className="p-4">
                      <div className="h-3 w-1/4 rounded bg-gray-200" />
                    </td>
                  </tr>
                ))}
              </tbody>
              <tfoot>
                <tr>
                  <td colSpan={5}>
                    <div className="flex items-center justify-between bg-white py-3 px-4">
                      <div className="hidden sm:block">
                        <div className="h-3 w-28 rounded bg-gray-200" />
                      </div>
                      <div className="flex flex-1 justify-between sm:justify-end">
                        <div className="h-8 w-20 rounded-lg bg-gray-200" />
                        <div className="ml-3 h-8 w-20 rounded-lg bg-gray-200" />
                      </div>
                    </div>
                  </td>
                </tr>
              </tfoot>
            </table>
          </div>
        </div>
      </div>
    </div>
  );
};

export default TableLoadingSkeleton;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/components/data-table/data-table.tsx

'use client';

import React from 'react';

import {
  ColumnDef,
  PaginationState,
  flexRender,
  getCoreRowModel,
  getPaginationRowModel,
  useReactTable,
} from '@tanstack/react-table';

import ButtonOutline from '../buttons/button-outline';

interface IDataTableProps<T> {
  data: T[];
  columns: ColumnDef<T, any>[];
  itemsPerPage?: number;
}

function DataTable<T>(p: IDataTableProps<T>) {
  const { itemsPerPage = 5 } = p;
  const [data] = React.useState(() => [...p.data]);

  const [{ pageIndex, pageSize }, setPagination] =
    React.useState<PaginationState>({
      pageIndex: 0,
      pageSize: itemsPerPage,
    });

  const pagination = React.useMemo(
    () => ({
      pageIndex,
      pageSize,
    }),
    [pageIndex, pageSize]
  );

  const table = useReactTable({
    data,
    columns: p.columns,
    state: {
      pagination,
    },
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    onPaginationChange: setPagination,
  });

  const resultText = `Showing page ${
    table.getState().pagination.pageIndex + 1
  } of ${table.getPageCount()}`;

  return p.data.length > 0 ? (
    <div>
      <div className="flow-root">
        <div className="-my-2 overflow-x-auto -mx-2 lg:-mx-2">
          <div className="inline-block min-w-full py-2 align-middle px-2 lg:px-2">
            <div className="overflow-hidden shadow ring-1 ring-gray-200 rounded-lg mt-6 -mx-0">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  {table.getHeaderGroups().map((headerGroup) => (
                    <tr key={headerGroup.id}>
                      {headerGroup.headers.map((header) => (
                        <th
                          key={header.id}
                          scope="col"
                          className="py-4 px-3 text-left font-dmsans text-xs font-medium text-gray-600"
                        >
                          {header.isPlaceholder
                            ? null
                            : flexRender(
                                header.column.columnDef.header,
                                header.getContext()
                              )}
                        </th>
                      ))}
                    </tr>
                  ))}
                </thead>
                <tbody className="divide-y divide-gray-200 bg-white">
                  {table.getRowModel().rows.map((row) => (
                    <tr key={row.id}>
                      {row.getVisibleCells().map((cell) => (
                        <td
                          key={cell.id}
                          className="px-3 py-4 text-sm text-gray-600 lg:table-cell"
                        >
                          {flexRender(
                            cell.column.columnDef.cell,
                            cell.getContext()
                          )}
                        </td>
                      ))}
                    </tr>
                  ))}
                </tbody>
                <tfoot className="bg-white">
                  <tr>
                    <td colSpan={5}>
                      <nav
                        className="flex items-center justify-betweenbg-white px-4 py-3 sm:px-6"
                        aria-label="Pagination"
                      >
                        <div className="hidden sm:block">
                          <p className="text-sm text-gray-700">{resultText}</p>
                        </div>
                        <div className="flex flex-1 justify-between sm:justify-end">
                          <ButtonOutline
                            variant="gray"
                            className="px-3 py-2 "
                            onClick={() => table.previousPage()}
                            disabled={!table.getCanPreviousPage()}
                          >
                            Previous
                          </ButtonOutline>
                          <ButtonOutline
                            variant="gray"
                            className="ml-3 px-3 py-2"
                            onClick={() => table.nextPage()}
                            disabled={!table.getCanNextPage()}
                          >
                            Next
                          </ButtonOutline>
                        </div>
                      </nav>
                    </td>
                  </tr>
                </tfoot>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  ) : null;
}

export default DataTable;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/hooks/use-autosize-textarea.ts

import React from 'react';

const useAutosizeTextArea = (
  textAreaRef: HTMLTextAreaElement | null,
  value: string,
  maxHeight?: number
) => {
  React.useEffect(() => {
    if (textAreaRef) {
      textAreaRef.style.height = 'auto';
      const scrollHeight = textAreaRef.scrollHeight;

      if (maxHeight && maxHeight < scrollHeight) {
        textAreaRef.style.height = maxHeight + 'px';
      } else {
        textAreaRef.style.height = scrollHeight + 'px';
      }
    }
  }, [textAreaRef, value, maxHeight]);
};

export { useAutosizeTextArea };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/hooks/use-handlebars.ts

import Handlebars from 'handlebars';
import React from 'react';

import { registerHelpers } from '@/utils/handlebars-helpers';

const useHandlebars = (
  content?: string,
  dataContext?: { [key: string]: unknown }
) => {
  const [compiledText, setCompiledText] = React.useState('');

  const compile = (content = '') => {
    try {
      const template = Handlebars.compile(content ?? '');
      setCompiledText(template({ ...dataContext }));
    } catch (_e) {
      console.log('Error compiling handlebars template');
      return '';
    }
  };

  React.useEffect(() => {
    registerHelpers();
    compile(content);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [content, dataContext]);

  return compiledText;
};

export { useHandlebars };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/hooks/useInterval.ts

import React from 'react';

export function useInterval(callback: () => void, delay: number | null) {
  const savedCallback = React.useRef<() => void>();

  // Remember the latest callback.
  React.useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  // Set up the interval.
  React.useEffect(() => {
    function tick() {
      if (savedCallback.current) {
        savedCallback.current();
      }
    }
    if (delay !== null) {
      const id = setInterval(tick, delay);
      return () => clearInterval(id);
    }
  }, [delay]);
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/hooks/useMediaQuery.ts

import { useEffect, useState } from 'react';

export function useMediaQuery(query: string) {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    const mediaQuery = window.matchMedia(query);
    setMatches(mediaQuery.matches);
    const handler = (event: MediaQueryListEvent) => setMatches(event.matches);

    mediaQuery.addEventListener('change', handler);

    return () => mediaQuery.removeEventListener('change', handler);
  }, [query]);

  return matches;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/hooks/useHasScrolled.ts

import { useEffect, useState } from 'react';

// Added distance parameter to determine how much
// from the top tell return value is updated.
// The name of the hook better reflects intended use.
export const useHasScrolled = (distance = 10, divClassName?: string) => {
  // setting initial value to false
  const [scroll, setScroll] = useState(false);

  // running on mount
  useEffect(() => {
    const onWindowScroll = () => {
      // Logic is false tell user reaches threshold, then true after.
      const scrollCheck: boolean = window.scrollY >= distance;
      if (scrollCheck !== scroll) {
        setScroll(scrollCheck);
      }
    };

    const onElementScroll = (e: Event) => {
      const scrollCheck: boolean =
        (e.target as HTMLDivElement).scrollTop >= distance;
      if (scrollCheck !== scroll) {
        setScroll(scrollCheck);
      }
    };

    if (divClassName) {
      const el = document.getElementsByClassName(divClassName)?.[0];
      if (el) {
        el.addEventListener('scroll', onElementScroll);

        return () => {
          el.removeEventListener('scroll', onElementScroll);
        };
      }
    } else {
      // setting the event handler from web API
      document.addEventListener('scroll', onWindowScroll);

      // cleaning up from the web API
      return () => {
        document.removeEventListener('scroll', onWindowScroll);
      };
    }
  }, [distance, divClassName, scroll, setScroll]);

  return scroll;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/hooks/use-cart-slider-context.ts

import { useContext } from 'react';

import { CartSliderContext } from '../contexts/cart-slider-context';

export function useCartSliderContext() {
  const context = useContext(CartSliderContext);
  if (!context) {
    throw new Error(
      'useCartSliderContext must be used within the CartSliderContextProvider'
    );
  }
  return context;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/shared/hooks/useBreakpoints.ts

import { useMediaQuery } from './useMediaQuery';

// Hook to determine media breakpoints using Javascript (matches Tailwind CSS breakpoints)
export function useBreakpoints() {
  const breakpoints = {
    isSm: useMediaQuery('(min-width: 640px)'),
    isMd: useMediaQuery('(min-width: 768px)'),
    isLg: useMediaQuery('(min-width: 1024px)'),
    isXl: useMediaQuery('(min-width: 1280px)'),
    is2Xl: useMediaQuery('(min-width: 1536px)'),
  };

  return breakpoints;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/organization/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { OrganizationCreateInputSchema } from 'prisma/generated/zod';

import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { organizationClient } from '@models/extensions/b2b';
import { UserRole } from '@prisma/client';

/**
 * @swagger
 * /api/organizations:
 *   get:
 *     summary: Retrieve all organizations
 *     description: Returns a list of organizations accessible to authorized users.
 *     tags:
 *       - Organizations
 *     responses:
 *       '200':
 *         description: A list of organizations.
 *       '401':
 *         description: Unauthorized - User does not have the necessary permissions.
 *       '404':
 *         description: No organizations found.
 */
const GET = async (request: NextRequest) => {
  try {
    const authResult = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!authResult.success) return authResult.unAuthorizedResponse;

    const { user } = authResult;

    let result;

    if (user.isElevated)
      result = await organizationClient.organization.findMany();
    else {
      if (!user.organizationId)
        return ApiErrorHandler.handle404Error({
          message: 'No organization found for user.',
          reqUrl: request.url,
        });

      result = await organizationClient.organization.findUnique({
        where: {
          status: 'ACTIVE',
          id: user.organizationId,
        },
      });
    }

    if (!result)
      return ApiErrorHandler.handle404Error({
        message: 'No organization found.',
        reqUrl: request.url,
      });

    return NextResponse.json(result, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to retrieve the organizations.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

/**
 * @swagger
 * /api/organizations:
 *   post:
 *     summary: Create a new organization
 *     description: Creates a new organization if the user has admin privileges.
 *     tags:
 *       - Organizations
 *     requestBody:
 *       description: Data for creating a new organization
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               logo:
 *                 type: string
 *               tiers:
 *                 type: string[]
 *                 description: This property is optional.
 *               departments:
 *                 type: string[]
 *                 description: This property is optional.
 *               roles:
 *                 type: string[]
 *                 description: This property is optional.
 *               locations:
 *                 type: object[]
 *                 description: This property is optional.
 *               contacts:
 *                 type: object[]
 *                 description: This property is optional.
 *               status:
 *                 type: StatusEnum
 *                 description: This property is optional.
 *     responses:
 *       '201':
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *         description: New organization created successfully.
 *       '400':
 *         description: Invalid request data.
 *       '401':
 *         description: Unauthorized - User does not have necessary permissions.
 *       '500':
 *         description: Internal server error while creating the organization.
 */
const POST = async (request: NextRequest) => {
  const authResult = await getUserAndCheckAuthorized({
    request: request,
    roleAccess: [UserRole.ADMIN],
    customErrorMessage: "You don't have permission to create an organization.",
  });

  if (!authResult.success) return authResult.unAuthorizedResponse;

  const txtBody = await request.text();

  try {
    const body = JSON.parse(txtBody);

    const validatedBody = OrganizationCreateInputSchema.parse(body);

    const newOranization = await organizationClient.organization.create({
      data: validatedBody,
    });

    if (!newOranization) {
      throw new Error('Failed to create new organization.');
    }

    return NextResponse.json(newOranization, {
      status: HttpStatusCode.CREATED,
    });
  } catch (error) {
    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      reqBody: txtBody,
      reqHeaders: request.headers,
      error,
    });
  }
};

export { POST, GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/organization/[organizationId]/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { OrganizationUpdateInputSchema } from 'prisma/generated/zod';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { organizationClient } from '@models/extensions/b2b';
import { PublicOrganization } from '@models/extensions/b2b/types/organizationTypes';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const GET = async (
  request: NextRequest,
  { params }: { params: { organizationId: string } }
) => {
  try {
    const { organizationId } = params;

    const authResult = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!authResult.success) return authResult.unAuthorizedResponse;

    const { user } = authResult;

    if (!user.isElevated && user.organizationId != organizationId)
      return ApiErrorHandler.handleUnauthorizedError({
        message: 'You are not authorized to access this organization.',
        reqUrl: request.url,
      });

    const organization = await organizationClient.organization.findUnique({
      where: {
        id: organizationId,
      },
    });

    if (!organization)
      return ApiErrorHandler.handle404Error({
        message: 'Organization not found with the provided id.',
        reqUrl: request.url,
      });

    // return the basic version of an organization if they are just a patient
    if (!user.isElevated && !user.isExternalHr)
      return NextResponse.json(organization as PublicOrganization, {
        status: 200,
      });

    return NextResponse.json(organization, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to retrieve the organizations.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

const PATCH = async (
  request: NextRequest,
  { params }: { params: { organizationId: string } }
) => {
  const requestBody = await getSafeRequestBody(request);

  if (!requestBody.isValidJson) return requestBody.badRequestResponse;

  try {
    const { organizationId } = params;

    const authResult = await getUserAndCheckAuthorized({
      request: request,
      authMethod: organizationClient.organization.canModifyOrgData,
      beforeUserParams: [organizationId],
    });

    if (!authResult.success) return authResult.unAuthorizedResponse;

    const validatedBody = OrganizationUpdateInputSchema.parse(
      requestBody.jsonBody
    );

    const updatedOrg = await organizationClient.organization.update({
      where: {
        id: organizationId,
      },
      data: validatedBody,
    });

    return NextResponse.json(updatedOrg, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to patch the organizations.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { organizationId: string } }
) => {
  try {
    const { organizationId } = params;

    const authResult = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
      customErrorMessage: 'You do not have permission to delete organizations.',
    });

    if (!authResult.success) return authResult.unAuthorizedResponse;

    const deletedOrg = await organizationClient.organization.delete({
      where: {
        id: organizationId,
      },
    });

    if (!deletedOrg)
      return ApiErrorHandler.handle404Error({
        message: 'Organization not found with the provided id.',
        reqUrl: request.url,
      });

    return NextResponse.json(
      { message: `Organization ${organizationId} was successfully deleted.` },
      { status: HttpStatusCode.OK }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to delete the organizations.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { GET, PATCH, DELETE };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/organization/[organizationId]/upload-logo/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { organizationClient } from '@/app/shared/models/extensions/b2b';
import { ApiErrorHandler } from '@/utils/errors';
import { uploadFileToS3 } from '@/utils/file-upload/file-upload';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { S3Client } from '@aws-sdk/client-s3';

const Bucket =
  process.env.ORGANIZATION_LOGO_BUCKET ?? 'dev-dermi-organization-logos';
const s3 = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.MESSAGE_MEDIA_AWS_ACCESS_KEY as string,
    secretAccessKey: process.env.MESSAGE_MEDIA_SECRET_ACCESS_KEY as string,
  },
});

const POST = async (
  request: NextRequest,
  { params: { organizationId } }: { params: { organizationId: string } }
) => {
  try {
    if (!organizationId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'You must include a valid organizationId',
        reqUrl: request.url,
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: organizationClient.organization.canModifyOrgData,
      beforeUserParams: [organizationId],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const formData = await request.formData();

    if (!formData || !formData.has('file'))
      return ApiErrorHandler.handleBadRequest({
        message: 'You must include a file',
        reqUrl: request.url,
      });

    const files = formData.getAll('file') as File[];

    if (files.length > 1)
      return ApiErrorHandler.handleBadRequest({
        message: 'You can only upload one file as the logo',
        reqUrl: request.url,
      });

    const file = files[0];

    const s3Key = `${organizationId}/${file.name}`;

    const response = await uploadFileToS3(Bucket, s3Key, file, s3);

    if (response.s3Url) {
      const updatedOrg = await organizationClient.organization.update({
        where: {
          id: organizationId,
        },
        data: {
          logo: response.s3Url,
        },
      });

      return NextResponse.json(updatedOrg, { status: HttpStatusCode.OK });
    }

    return ApiErrorHandler.handleServerError({
      message: 'There was a problem uploading the file',
      reqUrl: request.url,
      error: response,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem uploading the file',
      reqUrl: request.url,
      reqBody: '',
      error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/organization/[organizationId]/contact/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { OrganizationContactCreateInputSchema } from 'prisma/generated/zod';

import { organizationClient } from '@/app/shared/models/extensions/b2b';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';

const POST = async (
  request: NextRequest,
  { params }: { params: { organizationId: string } }
) => {
  const requestBody = await getSafeRequestBody(request);

  try {
    const { organizationId } = params;

    if (!requestBody.isValidJson) return requestBody.badRequestResponse;

    const authResult = await getUserAndCheckAuthorized({
      request: request,
      authMethod: organizationClient.organization.canModifyOrgData,
      beforeUserParams: [organizationId],
    });

    if (!authResult.success) return authResult.unAuthorizedResponse;

    const contactData = OrganizationContactCreateInputSchema.parse(
      requestBody.jsonBody
    );

    const organization = await organizationClient.organization.update({
      where: {
        id: organizationId,
      },
      data: {
        contacts: {
          push: contactData,
        },
      },
    });

    if (!organization)
      return ApiErrorHandler.handle404Error({
        message: 'Organization not found with the provided id.',
        reqUrl: request.url,
      });

    return NextResponse.json(organization, { status: HttpStatusCode.CREATED });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to retrieve the organizations.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/organization/[organizationId]/contact/[contactIdentifier]/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { OrganizationContactUpdateInputSchema } from 'prisma/generated/zod';

import { organizationClient } from '@models/extensions/b2b';
import { OrganizationContact } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getSafeRequestBody } from '@utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { organizationId: string; contactIdentifier: string } }
) => {
  const requestBody = await getSafeRequestBody(request);

  try {
    const { organizationId, contactIdentifier } = params;

    if (!requestBody.isValidJson) return requestBody.badRequestResponse;

    const authResult = await getUserAndCheckAuthorized({
      request: request,
      authMethod: organizationClient.organization.canModifyOrgData,
      beforeUserParams: [organizationId],
    });

    if (!authResult.success) return authResult.unAuthorizedResponse;

    const contactData = OrganizationContactUpdateInputSchema.parse(
      requestBody.jsonBody
    );

    const organization = await organizationClient.organization.findUnique({
      where: {
        id: organizationId,
      },
    });

    if (!organization)
      return ApiErrorHandler.handle404Error({
        message: 'Organization not found with the provided id.',
        reqUrl: request.url,
      });

    let contactFound = false;

    const contacts = organization.contacts.map((contact) => {
      if (contact.contactIdentifier === contactIdentifier) {
        const contactUpdates = contactData as Partial<OrganizationContact>;

        contactFound = true;

        contact = {
          ...contact,
          ...contactUpdates,
        };
      }

      return contact;
    });

    if (!contactFound)
      return ApiErrorHandler.handle404Error({
        message: 'Contact not found with the provided identifier.',
        reqUrl: request.url,
      });

    const updatedOrganization = await organizationClient.organization.update({
      where: {
        id: organizationId,
      },
      data: {
        contacts: contacts,
      },
    });

    return NextResponse.json(updatedOrganization, {
      status: HttpStatusCode.OK,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to retrieve the organizations.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { organizationId: string; contactIdentifier: string } }
) => {
  try {
    const { organizationId, contactIdentifier } = params;

    const authResult = await getUserAndCheckAuthorized({
      request: request,
      authMethod: organizationClient.organization.canModifyOrgData,
      beforeUserParams: [organizationId],
    });

    if (!authResult.success) return authResult.unAuthorizedResponse;

    const organization = await organizationClient.organization.findUnique({
      where: {
        id: organizationId,
      },
    });

    if (!organization)
      return ApiErrorHandler.handle404Error({
        message: 'Organization not found with the provided id.',
        reqUrl: request.url,
      });

    let contactFound = false;

    const contacts = organization.contacts.filter((contact) => {
      if (contact.contactIdentifier === contactIdentifier) {
        contactFound = true;
        return false;
      }

      return true;
    });

    if (!contactFound)
      return ApiErrorHandler.handle404Error({
        message: 'Contact not found with the provided identifier.',
        reqUrl: request.url,
      });

    const updatedOrganization = await organizationClient.organization.update({
      where: {
        id: organizationId,
      },
      data: {
        contacts: contacts,
      },
    });

    return NextResponse.json(updatedOrganization, {
      status: HttpStatusCode.OK,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to retrieve the organizations.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH, DELETE };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/organization/[organizationId]/location/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { OrganizationLocationCreateInputSchema } from 'prisma/generated/zod';

import { organizationClient } from '@models/extensions/b2b';
import { ApiErrorHandler } from '@utils/errors';
import { getSafeRequestBody } from '@utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const POST = async (
  request: NextRequest,
  { params }: { params: { organizationId: string } }
) => {
  const requestBody = await getSafeRequestBody(request);

  try {
    const { organizationId } = params;

    if (!requestBody.isValidJson) return requestBody.badRequestResponse;

    const authResult = await getUserAndCheckAuthorized({
      request: request,
      authMethod: organizationClient.organization.canModifyOrgData,
      beforeUserParams: [organizationId],
    });

    if (!authResult.success) return authResult.unAuthorizedResponse;

    const locationData = OrganizationLocationCreateInputSchema.parse(
      requestBody.jsonBody
    );

    const organization = await organizationClient.organization.findUnique({
      where: {
        id: organizationId,
      },
    });

    if (!organization)
      return ApiErrorHandler.handle404Error({
        message: 'Organization not found with the provided id.',
        reqUrl: request.url,
      });

    const locationExists = organization.locations.some((location) => {
      return location.locationIdentifier === locationData.locationIdentifier;
    });

    if (locationExists)
      return ApiErrorHandler.handleBadRequest({
        message: 'A location with that identifier has already been created.',
        reqUrl: request.url,
      });

    const updatedOrganization = await organizationClient.organization.update({
      where: {
        id: organizationId,
      },
      data: {
        locations: {
          push: locationData,
        },
      },
    });

    return NextResponse.json(updatedOrganization, {
      status: HttpStatusCode.OK,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to retrieve the organizations.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/organization/[organizationId]/location/[locationIdentifier]/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { OrganizationLocationUpdateInputSchema } from 'prisma/generated/zod';

import { organizationClient } from '@models/extensions/b2b';
import { OrganizationLocation } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getSafeRequestBody } from '@utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { organizationId: string; locationIdentifier: string } }
) => {
  const requestBody = await getSafeRequestBody(request);

  try {
    const { organizationId, locationIdentifier } = params;

    if (!requestBody.isValidJson) return requestBody.badRequestResponse;

    const authResult = await getUserAndCheckAuthorized({
      request: request,
      authMethod: organizationClient.organization.canModifyOrgData,
      beforeUserParams: [organizationId],
    });

    if (!authResult.success) return authResult.unAuthorizedResponse;

    const locationData = OrganizationLocationUpdateInputSchema.parse(
      requestBody.jsonBody
    );

    const organization = await organizationClient.organization.findUnique({
      where: {
        id: organizationId,
      },
    });

    if (!organization)
      return ApiErrorHandler.handle404Error({
        message: 'Organization not found with the provided id.',
        reqUrl: request.url,
      });

    let locationFound = false;

    const locations = organization.locations.map((location) => {
      if (location.locationIdentifier === locationIdentifier) {
        const locationUpdates = locationData as Partial<OrganizationLocation>;

        locationFound = true;

        location = {
          ...location,
          ...locationUpdates,
        };
      }

      return location;
    });

    if (!locationFound)
      return ApiErrorHandler.handle404Error({
        message: 'Location not found with the provided identifier.',
        reqUrl: request.url,
      });

    const updatedOrganization = await organizationClient.organization.update({
      where: {
        id: organizationId,
      },
      data: {
        locations: locations,
      },
    });

    return NextResponse.json(updatedOrganization, {
      status: HttpStatusCode.OK,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to retrieve the organizations.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { organizationId: string; locationIdentifier: string } }
) => {
  try {
    const { organizationId, locationIdentifier } = params;

    const authResult = await getUserAndCheckAuthorized({
      request: request,
      authMethod: organizationClient.organization.canModifyOrgData,
      beforeUserParams: [organizationId],
    });

    if (!authResult.success) return authResult.unAuthorizedResponse;

    const organization = await organizationClient.organization.findUnique({
      where: {
        id: organizationId,
      },
    });

    if (!organization)
      return ApiErrorHandler.handle404Error({
        message: 'Organization not found with the provided id.',
        reqUrl: request.url,
      });

    let locationFound = false;

    const locations = organization.locations.filter((location) => {
      if (location.locationIdentifier === locationIdentifier) {
        locationFound = true;
        return false;
      }

      return true;
    });

    if (!locationFound)
      return ApiErrorHandler.handle404Error({
        message: 'Location not found with the provided identifier.',
        reqUrl: request.url,
      });

    const updatedOrganization = await organizationClient.organization.update({
      where: {
        id: organizationId,
      },
      data: {
        locations: locations,
      },
    });

    return NextResponse.json(updatedOrganization, {
      status: HttpStatusCode.OK,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to retrieve the organizations.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PATCH, DELETE };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/organization/[organizationId]/employee/route.ts

import { ObjectId } from 'mongodb';
import { NextRequest, NextResponse } from 'next/server';
import { EmployeeCreateWithoutOrganizationInputSchema } from 'prisma/generated/zod';

import { organizationClient } from '@/app/shared/models/extensions/b2b';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';

const GET = async (
  request: NextRequest,
  { params }: { params: { organizationId: string } }
) => {
  if (!ObjectId.isValid(params.organizationId))
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid organizationId.',
      reqUrl: request.url,
    });

  const authResult = await getUserAndCheckAuthorized({
    request,
    authMethod: organizationClient.organization.canModifyOrgData,
    beforeUserParams: [params.organizationId],
  });

  const { organizationId } = params;

  if (!authResult.success) return authResult.unAuthorizedResponse;

  if (
    !authResult.user.isElevated &&
    authResult.user.organizationId !== organizationId
  )
    return ApiErrorHandler.handleUnauthorizedError({
      message: 'You are not authorized to access this resource.',
      reqUrl: request.url,
      reqHeaders: request.headers,
    });

  const employees = await organizationClient.employee.findMany({
    where: {
      organizationId,
    },
  });

  if (!employees)
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to get the employees.',
      reqUrl: request.url,
    });

  return NextResponse.json(employees, { status: HttpStatusCode.OK });
};

const POST = async (
  request: NextRequest,
  { params }: { params: { organizationId: string } }
) => {
  const safeBody = await getSafeRequestBody(request);

  if (!safeBody.isValidJson)
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid json body.',
      reqUrl: request.url,
      reqBody: safeBody.txtBody,
    });

  try {
    const { organizationId } = params;

    const validatedBody = EmployeeCreateWithoutOrganizationInputSchema.parse(
      safeBody.jsonBody
    );

    if (!validatedBody) {
      return ApiErrorHandler.handleBadRequest({
        message: 'Invalid request body.',
        reqUrl: request.url,
        reqBody: safeBody.txtBody,
      });
    }

    const employee = await organizationClient.employee.create({
      data: {
        ...validatedBody,
        organization: {
          connect: {
            id: organizationId,
          },
        },
      },
    });

    return NextResponse.json(employee, { status: 201 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to create the employee.',
      reqUrl: request.url,
      reqBody: safeBody.txtBody,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { POST, GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/organization/[organizationId]/employee/count/route.ts

import { ObjectId } from 'mongodb';
import { NextRequest, NextResponse } from 'next/server';

import { organizationClient } from '@/app/shared/models/extensions/b2b';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';

const GET = async (
  request: NextRequest,
  { params }: { params: { organizationId: string } }
) => {
  if (!ObjectId.isValid(params.organizationId))
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid organizationId.',
      reqUrl: request.url,
    });

  const authResult = await getUserAndCheckAuthorized({
    request,
    authMethod: organizationClient.organization.canModifyOrgData,
    beforeUserParams: [params.organizationId],
  });

  const { organizationId } = params;

  if (!authResult.success) return authResult.unAuthorizedResponse;

  if (
    !authResult.user.isElevated &&
    authResult.user.organizationId !== organizationId
  )
    return ApiErrorHandler.handleUnauthorizedError({
      message: 'You are not authorized to access this resource.',
      reqUrl: request.url,
      reqHeaders: request.headers,
    });

  const employeeCount = await organizationClient.employee.count({
    where: {
      organizationId,
    },
  });

  return NextResponse.json(
    { employeeCount: employeeCount },
    { status: HttpStatusCode.OK }
  );
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/organization/[organizationId]/employee/batch/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { EmployeeCreateNestedManyWithoutOrganizationInputSchema } from 'prisma/generated/zod';

import { organizationClient } from '@/app/shared/models/extensions/b2b';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import type { Prisma } from '@prisma/client';

const POST = async (
  request: NextRequest,
  { params }: { params: { organizationId: string } }
) => {
  const safeBody = await getSafeRequestBody(request);

  if (!safeBody.isValidJson)
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid json body.',
      reqUrl: request.url,
      reqBody: safeBody.txtBody,
    });

  try {
    const { organizationId } = params;

    const validatedBody =
      EmployeeCreateNestedManyWithoutOrganizationInputSchema.parse(
        safeBody.jsonBody
      );

    let employeeData: Prisma.EmployeeCreateManyInput[] = [];

    if (validatedBody.createMany?.data === undefined)
      return ApiErrorHandler.handleBadRequest({
        message: 'Invalid request body.',
        reqUrl: request.url,
        reqBody: safeBody.txtBody,
      });

    if (Array.isArray(validatedBody.createMany?.data)) {
      employeeData = validatedBody.createMany.data.map((employee) => {
        const employeeWithOrg = employee as Prisma.EmployeeCreateManyInput;
        employeeWithOrg.organizationId = organizationId;
        return employeeWithOrg;
      });
    } else {
      employeeData.push({ ...validatedBody.createMany.data, organizationId });
    }

    const result = await organizationClient.employee.createMany({
      data: employeeData,
    });

    if (!result)
      return ApiErrorHandler.handleServerError({
        message: 'An error ocurred trying to create the employee.',
        reqUrl: request.url,
        reqBody: safeBody.txtBody,
      });

    return NextResponse.json(result, { status: 201 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to create the employee.',
      reqUrl: request.url,
      reqBody: safeBody.txtBody,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/experimental/route.ts

import { NextRequest, NextResponse } from 'next/server';

import {
  CookieJar,
  createCookieResponse,
} from '@/utils/responses/responseHelpers';
import { getUserInfo, isUserAuthorized } from '@auth/auth';

// Next wants to format this statically because it lacks necessary imports to determine that it is dynamic.
// Because we access headers / cookies in the userinfo lookup we need this to be dynamic.
export const dynamic = 'force-dynamic';
// import { prisma } from '@clients/mongo/prismaClient';
/**
 * experimental route used for testing.
 */
const GET = async (request: NextRequest) => {
  try {
    // const { searchParams } = new URL(request.url);
    // const id = searchParams.get('id');

    // if (!id)
    //   return NextResponse.json({ error: 'No ID requested' }, { status: 400 });

    // const foundUser = await prisma.user.findUnique({
    //   where: {
    //     id: id,
    //   },
    // });

    // if (!foundUser)
    //   return NextResponse.json(
    //     { error: 'Failed to find user' },
    //     { status: 404 }
    //   );

    // await throwIfCurrentUserUnauthorized();

    // const userResponse = await getSessionUserInfo(request);

    // if (isSessionUserInfoSuccessResponse(userResponse)) {
    //   return NextResponse.json('Hello, ' + userResponse.user.name, {
    //     status: 200,
    //   });
    // } else {
    //   return NextResponse.json(
    //     'BAD USER! ' + (await userResponse.unauthorizedApiResponse.text()),
    //     { status: 200 }
    //   );
    // }
    const cookieJar: CookieJar = { cookies: [] };
    const userVal = await getUserInfo(request, cookieJar);
    console.log(userVal);

    console.log(
      'User Authorized: ',
      isUserAuthorized(userVal, ['ANONYMOUS_PATIENT', 'ADMIN', 'PATIENT'])
    );

    // transferCookie(new NextResponse(), response);

    // const dynamicData = await fetch(
    //   `http://localhost:3000/api/auth/signin/cognito`,
    //   { cache: 'no-store' }
    // );

    return createCookieResponse('Howdy!', cookieJar); // NextResponse.json({ message: 'howdy' });
  } catch (error) {
    console.log(error);
    return NextResponse.json({ error: 'Failed to get user' }, { status: 500 });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/route.ts

import { NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { sortForm } from '@form/utils/api-utils';
import { FORM_INCLUDE } from '@form/utils/types';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (request: Request) => {
  try {
    const results = await prismaFormClient.form.findMany({
      include: FORM_INCLUDE,
    });

    const sortedForm = results.map((form) => sortForm(form));

    return NextResponse.json(sortedForm);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Error getting forms',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/sections/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const results = await prismaFormClient.formSection.findMany({
      include: {
        steps: {
          include: { formElements: { include: { text: true, field: true } } },
        },
      },
    });

    return NextResponse.json(results);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the sections',
      reqUrl: request.url,
      error: error,
    });
  }
};

const POST = async (request: NextRequest) => {
  const txtBody = await request.text();
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = JSON.parse(txtBody);

    if (!body) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A section body is required',
        reqUrl: request.url,
        reqBody: txtBody,
      });
    }

    const results = await prismaFormClient.formSection.create({
      data: body,
    });
    return NextResponse.json(results);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem adding the section',
      reqUrl: request.url,
      reqBody: txtBody,
      error: error,
    });
  }
};

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/sections/[sectionId]/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (
  request: NextRequest,
  { params }: { params: { sectionId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (!params.sectionId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A sectionId parameter is required',
        reqUrl: request.url,
      });
    }

    const results = await prismaFormClient.formSection.findUnique({
      where: { id: params.sectionId },
      include: {
        steps: {
          include: { formElements: { include: { text: true, field: true } } },
        },
      },
    });
    return NextResponse.json(results);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the section by id',
      reqUrl: request.url,
      error: error,
    });
  }
};

const PATCH = async (
  request: NextRequest,
  { params }: { params: { sectionId: string } }
) => {
  const txtBody = await request.text();
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = JSON.parse(txtBody);
    if (!params.sectionId || !body) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A sectionId parameter and section body is required',
        reqUrl: request.url,
        reqBody: txtBody,
      });
    }

    const results = await prismaFormClient.formSection.update({
      where: { id: params.sectionId },
      data: body,
    });

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem updating the section',
      reqUrl: request.url,
      reqBody: txtBody,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { sectionId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (!params.sectionId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A sectionId parameter is required',
        reqUrl: request.url,
      });
    }

    const results = await prismaFormClient.formSection.delete({
      where: { id: params.sectionId },
    });
    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem deleting the section',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET, PATCH, DELETE };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/sections/[sectionId]/add-new-step/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const POST = async (
  request: NextRequest,
  { params }: { params: { sectionId: string } }
) => {
  const txtBody = await request.text();
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = JSON.parse(txtBody);
    if (!params.sectionId || !body) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A sectionId parameter and step body is required.',
        reqUrl: request.url,
        reqBody: txtBody,
      });
    }

    const results = await prismaFormClient.formSection.update({
      where: { id: params.sectionId },
      data: { steps: { create: body } },
    });
    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem adding the step to the section',
      reqUrl: request.url,
      reqBody: txtBody,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/sections/[sectionId]/add-existing-step/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { sectionId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const headersList = headers();
    const stepId = headersList.get('stepId');

    if (!params.sectionId || !stepId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A sectionId parameter and a stepId header is required',
        reqUrl: request.url,
      });
    }

    const results = await prismaFormClient.formSection.update({
      where: { id: params.sectionId },
      data: { steps: { connect: { id: stepId } } },
    });

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem adding the step reference to the section',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/sections/[sectionId]/remove-step/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { sectionId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const headersList = headers();
    const stepId = headersList.get('stepId');

    if (!params.sectionId || !stepId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A sectionId parameter and a stepId header is required',
        reqUrl: request.url,
      });
    }

    const results = await prismaFormClient.formSection.update({
      where: { id: params.sectionId },
      data: { steps: { disconnect: { id: stepId } } },
    });

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message:
        'There was a problem removing the step reference from the section',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/forms/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const POST = async (request: NextRequest) => {
  const txtBody = await request.text();
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = JSON.parse(txtBody);

    if (!body) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A form body is required.',
        reqUrl: request.url,
        reqBody: txtBody,
      });
    }
    const results = await prismaFormClient.form.create({
      data: body,
    });
    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Error creating form',
      reqUrl: request.url,
      reqBody: txtBody,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/forms/[formId]/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { formId: string } }
) => {
  const txtBody = await request.text();
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = JSON.parse(txtBody);
    if (!params.formId || !body) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A formId param and an update body is required.',
        reqUrl: request.url,
        reqBody: txtBody,
      });
    }

    const results = await prismaFormClient.form.update({
      where: { id: params.formId },
      data: body,
    });

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem updating the form',
      reqUrl: request.url,
      reqBody: txtBody,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { formId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (!params.formId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A formId param is required.',
        reqUrl: request.url,
      });
    }

    await prismaFormClient.form.delete({
      where: { id: params.formId },
    });

    return NextResponse.json(
      {
        message: `successully deleted form`,
      },
      { status: 200 }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem deleting the form',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { PATCH, DELETE };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/forms/[formId]/remove-section/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { formId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const headersList = headers();
    const sectionId = headersList.get('sectionId');

    if (!params.formId || !sectionId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A formId param and a sectionId header is required.',
        reqUrl: request.url,
      });
    }

    const results = await prismaFormClient.form.update({
      where: { id: params.formId },
      data: { sections: { disconnect: { id: sectionId } } },
    });

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem removing the section from the form',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/forms/[formId]/add-existing-section/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const PATCH = async (
  request: NextRequest,
  { params: { formId } }: { params: { formId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const headersList = headers();
    const sectionId = headersList.get('sectionId');

    if (!formId || !sectionId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A formId param and a sectionId header is required.',
        reqUrl: request.url,
      });
    }

    const results = await prismaFormClient.form.update({
      where: { id: formId },
      data: { sections: { connect: { id: sectionId } } },
    });

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem adding the section to the form',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/forms/[formId]/export/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { ErrorNextResponse } from '@/utils/errors/apiErrorHandler';
import { ExportedFormType } from '@/utils/forms/export-import-types';
import { exportForm } from '@/utils/forms/export-utils';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (
  request: NextRequest,
  { params }: { params: { formId: string } }
): Promise<NextResponse<ExportedFormType | ErrorNextResponse>> => {
  try {
    if (!params.formId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A formId param is required.',
        reqUrl: request.url,
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const form = await exportForm(params.formId);

    if (!form || !form.id) {
      return ApiErrorHandler.handle404Error({
        message: 'Could not find a form with that id',
        reqUrl: request.url,
      });
    }

    return NextResponse.json(form);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem retrieving the form',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/forms/[formId]/save/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (
  request: NextRequest,
  { params }: { params: { formId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (!params.formId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A formId param is required.',
        reqUrl: request.url,
      });
    }

    const results = await prismaFormClient.formData.findMany({
      where: {
        formId: params.formId,
        archived: false,
      },
    });

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting form data',
      reqUrl: request.url,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { formId: string } }
) => {
  const headersList = headers();

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const userId = headersList.get('userId');

    if (!params.formId || !userId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'Please provide a formId and userId.',
        reqUrl: request.url,
        reqHeaders: headersList,
      });
    }

    await prismaFormClient.formData.delete({
      where: { formId_userId: { formId: params.formId, userId } },
    });
    return NextResponse.json(
      { message: 'Form data deleted.' },
      { status: 200 }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem removing the form',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET, DELETE };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/forms/[formId]/add-new-section/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const POST = async (
  request: NextRequest,
  { params }: { params: { formId: string } }
) => {
  const txtBody = await request.text();
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = JSON.parse(txtBody);

    if (!params.formId || !body) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A formId param and a section body is required.',
        reqUrl: request.url,
        reqBody: txtBody,
      });
    }

    const results = await prismaFormClient.form.update({
      where: { id: params.formId },
      data: { sections: { create: body } },
    });

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem adding the section to the form',
      reqUrl: request.url,
      reqBody: txtBody,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/forms/import/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { ErrorNextResponse } from '@/utils/errors/apiErrorHandler';
import {
  FormImportPayloadSchema,
  FormImportType,
} from '@/utils/forms/export-import-types';
import { importForm } from '@/utils/forms/import-utils';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const POST = async (
  request: NextRequest
): Promise<NextResponse<{ formId: string } | ErrorNextResponse>> => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const formData = await request.formData();
    const file = formData.get('file') as File | null;

    const createNewElements = formData.get('createNewElements') === 'true';
    const updateForm = formData.get('updateForm') === 'true';

    if (!file) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A file is required.',
        reqUrl: request.url,
      });
    }

    const fileContent = await file.text();
    const jsonData = JSON.parse(fileContent);

    const payload = {
      exportedForm: jsonData,
      options: {
        createNewElements,
        updateForm,
      },
    };

    const validatedData = FormImportPayloadSchema.parse(payload);

    const { exportedForm, options } = validatedData;

    const formId = await importForm(exportedForm as FormImportType, options);
    return NextResponse.json({ formId }, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem importing the form',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/forms/revalidate/route.ts

import { revalidateTag } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';

import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    revalidateTag('form');

    return NextResponse.json('Successfully invalidated form cache', {
      status: 200,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem invalidating the form cache',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/pdf/save-data/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const GET = async (request: NextRequest) => {
  const headersList = headers();
  const id = headersList.get('id');

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (id) {
      // GET ONE
      const results = await prismaFormClient.formPDFData.findUnique({
        where: { id },
      });
      return NextResponse.json(results, { status: 200 });
    }

    // GET ALL
    const results = await prismaFormClient.formPDFData.findMany();
    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the form pdf data',
      reqUrl: request.url,
      error: error,
    });
  }
};

const DELETE = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const headersList = headers();
    const id = headersList.get('id');

    if (!id) {
      return ApiErrorHandler.handleBadRequest({
        message: 'Please provide a id.',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    await prismaFormClient.formData.delete({
      where: { id },
    });
    return NextResponse.json({ message: 'Form pdf data deleted.' });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem removing the form pdf data',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { GET, DELETE };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/modals/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const results = await prismaFormClient.modal.findMany();
    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Error getting modals',
      reqUrl: request.url,
      error: error,
    });
  }
};

const POST = async (request: NextRequest) => {
  const txtBody = await request.text();
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = JSON.parse(txtBody);

    if (!body) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A modal body is required.',
        reqUrl: request.url,
        reqBody: txtBody,
      });
    }
    const results = await prismaFormClient.modal.create({
      data: body,
    });
    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Error creating modal',
      reqUrl: request.url,
      reqBody: txtBody,
      error: error,
    });
  }
};

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/modals/[id]/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { id: string } }
) => {
  const txtBody = await request.text();
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = JSON.parse(txtBody);
    if (!params.id || !body) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A modal id param and body is required.',
        reqUrl: request.url,
        reqBody: txtBody,
      });
    }

    const results = await prismaFormClient.modal.update({
      where: { id: params.id },
      data: body,
    });

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem updating the modal',
      reqUrl: request.url,
      reqBody: txtBody,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { id: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (!params.id) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A modal id param is required.',
        reqUrl: request.url,
      });
    }

    await prismaFormClient.modal.delete({
      where: { id: params.id },
    });
    return NextResponse.json(
      {
        message: 'successully deleted modal',
      },
      { status: 200 }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem deleting the modal',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { PATCH, DELETE };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/elements/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const results = await prismaFormClient.formElement.findMany({
      include: { text: true, field: true },
    });

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the elements',
      reqUrl: request.url,
      error: error,
    });
  }
};

const POST = async (request: NextRequest) => {
  const txtBody = await request.text();

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = JSON.parse(txtBody);

    if (!body) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A form element body is required.',
        reqUrl: request.url,
        reqBody: body,
      });
    }

    const results = await prismaFormClient.formElement.createElement(body);
    return NextResponse.json(results);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem adding the element',
      reqUrl: request.url,
      reqBody: txtBody,
      error: error,
    });
  }
};

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/elements/[elementId]/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole, elementType } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (
  request: NextRequest,
  { params }: { params: { elementId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (!params.elementId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'An elementId parameter is required.',
        reqUrl: request.url,
      });
    }

    const results = await prismaFormClient.formElement.findUnique({
      where: { id: params.elementId },
      include: { text: true, field: true },
    });
    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the element by id',
      reqUrl: request.url,
      error: error,
    });
  }
};

const PATCH = async (
  request: NextRequest,
  { params }: { params: { elementId: string } }
) => {
  const txtBody = await request.text();
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = JSON.parse(txtBody);

    if (!params.elementId || !body) {
      return ApiErrorHandler.handleBadRequest({
        message: 'An elementId parameter and update body is required.',
        reqUrl: request.url,
      });
    }

    const elementData: { [key: string]: any } = {};
    const { name, ...otherData } = body;
    if (name) elementData.name = name;

    const element = await prismaFormClient.formElement.findUnique({
      where: { id: params.elementId },
    });

    if (!element) throw new Error('Element not found');

    if (element.elementType === elementType.FormText) {
      elementData.text = { update: otherData };
    } else {
      elementData.field = { update: otherData };
    }

    const results = await prismaFormClient.formElement.update({
      where: { id: params.elementId },
      data: elementData,
    });

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem updating the element',
      reqUrl: request.url,
      reqBody: txtBody,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { elementId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (!params.elementId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'An elementId parameter is required.',
        reqUrl: request.url,
      });
    }

    const element = await prismaFormClient.formElement.findUnique({
      where: { id: params.elementId },
      include: { text: true, field: true },
    });

    if (!element) throw new Error('Element not found');

    const results = await prismaFormClient.$transaction(async (prisma) => {
      if (element.text) {
        await prisma.formText.delete({ where: { id: element.text?.id } });
      } else {
        await prisma.formField.delete({ where: { id: element.field?.id } });
      }
      return await prisma.formElement.delete({
        where: { id: params.elementId },
      });
    });
    return NextResponse.json(results);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem removing the element',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET, PATCH, DELETE };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/steps/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const results = await prismaFormClient.formStep.findMany();

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the steps',
      reqUrl: request.url,
      error: error,
    });
  }
};

const POST = async (request: NextRequest) => {
  const txtBody = await request.text();
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = JSON.parse(txtBody);

    if (!body) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A step body is required.',
        reqUrl: request.url,
        reqBody: txtBody,
      });
    }

    const results = await prismaFormClient.formStep.create({
      data: body,
    });

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem adding the step',
      reqUrl: request.url,
      reqBody: txtBody,
      error: error,
    });
  }
};

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/steps/[stepId]/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (
  request: NextRequest,
  { params }: { params: { stepId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (!params.stepId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A stepId param is required.',
        reqUrl: request.url,
      });
    }

    const results = await prismaFormClient.formStep.findUnique({
      where: { id: params.stepId },
      include: { formElements: { include: { text: true, field: true } } },
    });
    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the step',
      reqUrl: request.url,
      error: error,
    });
  }
};

const PATCH = async (
  request: NextRequest,
  { params }: { params: { stepId: string } }
) => {
  const txtBody = await request.text();
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = JSON.parse(txtBody);

    if (!params.stepId || !body) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A stepId param and update body is required.',
        reqUrl: request.url,
        reqBody: txtBody,
      });
    }

    const results = await prismaFormClient.formStep.update({
      where: { id: params.stepId },
      data: body,
    });
    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem updating the step',
      reqUrl: request.url,
      reqBody: txtBody,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { stepId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (!params.stepId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A stepId param is required.',
        reqUrl: request.url,
      });
    }

    const results = await prismaFormClient.formStep.delete({
      where: { id: params.stepId },
    });
    return NextResponse.json(results);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem deleting the step',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET, PATCH, DELETE };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/steps/[stepId]/remove-element/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { stepId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const headersList = headers();
    const elementId = headersList.get('elementId');

    if (!params.stepId || !elementId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A stepId parameter and an elementId header is required',
        reqUrl: request.url,
      });
    }

    const results = await prismaFormClient.formStep.update({
      where: { id: params.stepId },
      data: { formElements: { disconnect: { id: elementId } } },
    });
    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message:
        'There was a problem removing the element reference from the step',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/steps/[stepId]/add-new-element/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

export async function POST(
  request: NextRequest,
  { params }: { params: { stepId: string } }
) {
  const txtBody = await request.text();
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = JSON.parse(txtBody);
    if (!params.stepId || !body) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A stepId parameter and an form element body is required',
        reqUrl: request.url,
        reqBody: txtBody,
      });
    }

    const results = await prismaFormClient.$transaction(async (prisma) => {
      const element = await prisma.formElement.createElement(body);
      return await prisma.formStep.update({
        where: { id: params.stepId },
        data: { formElements: { connect: { id: element.id } } },
      });
    });
    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem adding the element to the step',
      reqUrl: request.url,
      reqBody: txtBody,
      error: error,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/admin/steps/[stepId]/add-existing-element/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { stepId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const headersList = headers();
    const elementId = headersList.get('elementId');

    if (!params.stepId || !elementId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A stepId parameter and an elementId header is required',
        reqUrl: request.url,
      });
    }

    const results = await prismaFormClient.formStep.update({
      where: { id: params.stepId },
      data: { formElements: { connect: { id: elementId } } },
    });
    return NextResponse.json(results);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem adding the element reference to the step',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/pdf/save-data/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { getUserInfo } from '@/utils/auth/auth';
import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { CookieJar } from '@/utils/responses/responseHelpers';
import { SFNClient, StartExecutionCommand } from '@aws-sdk/client-sfn';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const POST = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PATIENT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = await request.json();
    const { formId, formTitle, submissionDateTime, responses } = body;

    const cookieJar: CookieJar = { cookies: [] };
    const user = await getUserInfo(request, cookieJar);

    if (!user.id)
      return ApiErrorHandler.handleUnauthorizedError({
        message: 'User is not logged in',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });

    const createResponse = await prismaFormClient.formPDFData.create({
      data: {
        formId,
        formTitle,
        submissionDateTime,
        userId: user.id,
        responses,
      },
    });

    // Trigger Step function
    const client = new SFNClient({
      credentials: {
        accessKeyId: process.env.FORM_S3_AWS_ACCESS_KEY ?? '',
        secretAccessKey: process.env.FORM_S3_SECRET_ACCESS_KEY ?? '',
      },
      region: process.env.AWS_REGION ?? 'us-east-1',
    });

    const command = new StartExecutionCommand({
      stateMachineArn: process.env.FORM_PDF_SFN_ARN ?? '',
      input: JSON.stringify({ id: createResponse.id }),
    });

    const test = await client.send(command);

    if (test.$metadata.httpStatusCode !== 200) {
      throw new Error('SFN Execution Failed to Send');
    }

    return NextResponse.json({ message: 'Form pdf data saved.' });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem saving the form pdf data',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/pdf/generate-pdf/route.tsx

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { S3Client } from '@aws-sdk/client-s3';
import { Upload } from '@aws-sdk/lib-storage';
import ReactPDF from '@joshuajaco/react-pdf-renderer-bundled';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

import Template from './template';

const POST = async (request: NextRequest) => {
  const txtBody = await request.text();
  try {
    const body = JSON.parse(txtBody);

    if (!body.id) {
      return ApiErrorHandler.handleBadRequest({
        message: 'An id is required',
        reqUrl: request.url,
        reqBody: txtBody,
      });
    }

    const id = body.id;
    const formPDFData = await prismaFormClient.formPDFData.findUnique({
      where: { id },
    });

    if (!formPDFData) {
      return ApiErrorHandler.handle404Error({
        message: 'Unable to find form data with that id',
        reqUrl: request.url,
        reqBody: txtBody,
      });
    }

    // Create PDF
    const pdfBuffer = await ReactPDF.renderToStream(
      <Template data={formPDFData} />
    );

    // Upload to S3
    const uploadStream = new Upload({
      client: new S3Client({
        credentials: {
          accessKeyId: process.env.FORM_PDF_AWS_ACCESS_KEY ?? '',
          secretAccessKey: process.env.FORM_PDF_AWS_SECRET_ACCESS_KEY ?? '',
        },
        region: process.env.AWS_REGION ?? 'us-east-1',
      }),
      queueSize: 4,
      leavePartsOnError: false,
      params: {
        Bucket: process.env.FORM_PDF_S3_BUCKET,
        Key: `${formPDFData.userId}/${
          formPDFData.formId
        }/${Date.now().toString()}.pdf`,
        Body: pdfBuffer as any,
        ContentType: 'application/pdf',
      },
    });
    const result = await uploadStream.done();

    // Cleanup
    if (result.$metadata.httpStatusCode !== 200) {
      throw new Error('Upload failed');
    }

    await prismaFormClient.formPDFData.delete({
      where: { id },
    });

    return NextResponse.json({ message: 'Form pdf generated.' });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem generating the pdf',
      reqUrl: request.url,
      reqBody: txtBody,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/pdf/generate-pdf/template.tsx

import dayjs from 'dayjs';

import {
  Document,
  Page,
  Text,
  View,
  StyleSheet,
  Font,
} from '@joshuajaco/react-pdf-renderer-bundled';
import { FormPDFData } from '@prisma/client';

// Create styles
const styles = StyleSheet.create({
  page: {
    padding: 50,
  },
  header: {
    fontSize: 9,
    marginBottom: 10,
    display: 'flex',
    flexDirection: 'column',
    gap: 10,
  },
  headerText: {
    fontFamily: 'Helvetica-Bold',
  },
  section: {
    border: '1px solid black',
    padding: 15,
    marginBottom: 10,
  },
  sectionTitle: {
    fontSize: 9,
    fontFamily: 'Helvetica-Bold',
    marginBottom: 15,
  },
  responseView: {
    padding: 5,
    marginBottom: 10,
  },
  question: {
    fontSize: 9,
    fontFamily: 'Helvetica-Bold',
    marginBottom: 5,
  },
  answer: {
    fontSize: 9,
    margin: '0 0 10px 0',
    padding: '0 0 10px 0',
    borderBottom: '1px solid black',
    width: '100%',
  },
  answerLast: {
    fontSize: 9,
    margin: '0 0 10px 0',
    padding: '0 0 10px 0',
    width: '100%',
  },
});

Font.register({ family: 'Verdana', src: '/fonts/verdana.ttf' });

const Template = ({ data }: { data: FormPDFData }) => (
  <Document>
    <Page size="LETTER" style={styles.page}>
      <View style={styles.header}>
        <Text style={styles.headerText}>Form ID: {data.formId}</Text>
        <Text style={styles.headerText}>User ID: {data.userId}</Text>
        <Text style={styles.headerText}>Form Title: {data.formTitle}</Text>
        <Text style={styles.headerText}>
          Submission Date:{' '}
          {dayjs(data.submissionDateTime).format('MM/DD/YYYY hh:mm A')}
        </Text>
      </View>
      {data.responses.map((section, i) => (
        <View key={i} style={styles.section}>
          <Text style={styles.sectionTitle}>{section.sectionTitle}</Text>
          {section.responses.map((response, j) => {
            if (j === section.responses.length - 1) {
              return (
                <View key={j}>
                  <Text style={styles.question}>{response.question}</Text>
                  <Text style={styles.answerLast}>{response.answer}</Text>
                </View>
              );
            }
            return (
              <View key={j}>
                <Text style={styles.question}>{response.question}</Text>
                <Text style={styles.answer}>{response.answer}</Text>
              </View>
            );
          })}
        </View>
      ))}
    </Page>
  </Document>
);

export default Template;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/[formId]/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { mergeFormTranslations } from '@/utils/mergeTranslations';
import { sortForm } from '@form/utils/api-utils';
import { FORM_INCLUDE } from '@form/utils/types';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (
  request: NextRequest,
  { params }: { params: { formId: string } }
) => {
  try {
    if (!params.formId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A formId param is required.',
        reqUrl: request.url,
      });
    }

    const headersList = headers();
    const locale = headersList.get('locale');

    const results = await prismaFormClient.form.findUnique({
      where: { id: params.formId },
      include: FORM_INCLUDE,
    });
    if (!results || !results.id) {
      return ApiErrorHandler.handle404Error({
        message: 'Could not find form with that id',
        reqUrl: request.url,
      });
    }

    if (locale) {
      return NextResponse.json(
        sortForm(mergeFormTranslations(results, locale)),
        { status: 200 }
      );
    }
    return NextResponse.json(results);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem retrieving the form',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/[formId]/save/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (
  request: NextRequest,
  { params }: { params: { formId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (!params.formId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A formId param is required.',
        reqUrl: request.url,
      });
    }

    const results = await prismaFormClient.formData.findUnique({
      where: {
        formId_userId: { formId: params.formId, userId: userInfo.user.id },
        archived: false,
      },
    });

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting form data',
      reqUrl: request.url,
      error: error,
    });
  }
};

const POST = async (
  request: NextRequest,
  { params }: { params: { formId: string } }
) => {
  const body = await request.text();

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const jsonBody = JSON.parse(body);
    const { formValues } = jsonBody;

    if (!params.formId || !formValues) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A formId param and formValues body is required.',
        reqUrl: request.url,
      });
    }

    await prismaFormClient.formData.upsert({
      where: {
        formId_userId: { formId: params.formId, userId: userInfo.user.id },
      },
      update: {
        data: formValues,
      },
      create: {
        formId: params.formId,
        userId: userInfo.user.id,
        data: formValues,
      },
    });

    return NextResponse.json({ message: 'Form data saved.' }, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem saving the form',
      reqUrl: request.url,
      reqBody: body,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { formId: string } }
) => {
  const userInfo = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.ADMIN],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  if (!params.formId)
    return ApiErrorHandler.handleBadRequest({
      message: 'Missing the formId url path parameter.',
      reqUrl: request.url,
      reqHeaders: request.headers,
    });

  try {
    await prismaFormClient.formData.delete({
      where: {
        formId_userId: { formId: params.formId, userId: userInfo.user.id },
      },
    });

    return NextResponse.json(
      { message: 'Form data for the user on the selected form was deleted.' },
      { status: HttpStatusCode.OK }
    );
  } catch (error) {
    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      error: error,
      additionalContext: { userId: userInfo.user.id, formId: params.formId },
    });
  }
};

export { DELETE, GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/modals/[id]/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { mergeContent } from '@/utils/mergeTranslations';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (
  request: NextRequest,
  { params }: { params: { id: string } }
) => {
  if (!params.id) {
    return ApiErrorHandler.handleBadRequest({
      message: 'A modal id param is required.',
      reqUrl: request.url,
    });
  }

  const headersList = headers();
  const locale = headersList.get('locale');

  try {
    const results = await prismaFormClient.modal.findUnique({
      where: { id: params.id },
    });
    if (!results || !results.id) {
      return ApiErrorHandler.handle404Error({
        message: 'Could not find modal with that id',
        reqUrl: request.url,
      });
    }

    if (locale) {
      return NextResponse.json(mergeContent(results, locale));
    } else {
      return NextResponse.json(results);
    }
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem retrieving the modal',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/file-upload/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { getS3Url, uploadFileToS3 } from '@/utils/file-upload/file-upload';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { S3Client } from '@aws-sdk/client-s3';
import { User, UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const s3 = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.FORM_S3_AWS_ACCESS_KEY as string,
    secretAccessKey: process.env.FORM_S3_SECRET_ACCESS_KEY as string,
  },
});

const POST = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PATIENT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const headersList = headers();
    const s3Bucket = headersList.get('s3bucket');

    if (!s3Bucket) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A s3 bucket is required',
        reqUrl: request.url,
        reqBody: '',
        error: 'No s3 bucket provided',
      });
    }

    const formData = await request.formData();
    const files = formData.getAll('file') as File[];

    const response = await Promise.all(
      files.map(async (file) => {
        const s3Key = `${userInfo.user.id}/${file.name}`;
        return uploadFileToS3(s3Bucket, s3Key, file, s3);
      })
    );

    return NextResponse.json(response, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem uploading the file',
      reqUrl: request.url,
      reqBody: '',
      error,
    });
  }
};

const mediaIsRelatedToUser = async (user: User, mediaUrl: string) => {
  const pathParts = mediaUrl.split('/');
  const includesUserId = pathParts.includes(user.id);

  return includesUserId;
};

async function GET(request: NextRequest) {
  try {
    const headerList = headers();
    const s3Url = headerList.get('s3Url');

    if (!s3Url) {
      return ApiErrorHandler.handleBadRequest({
        message: 'You must include an s3 url',
        reqUrl: request.url,
        reqBody: '',
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: mediaIsRelatedToUser,
      afterUserParams: [s3Url],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const response = await getS3Url({
      mediaUrl: s3Url,
      expiresIn: 3600,
      s3Client: s3,
      source: 'get_uploaded_file',
    });

    if (response.error) {
      return ApiErrorHandler.handleServerError({
        message: response.errorMessage ?? 'Error getting file',
        reqUrl: request.url,
        reqBody: '',
      });
    }

    return NextResponse.json({ s3Url: response.s3Url }, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Failed to get signed url',
      reqUrl: request.url,
      error: error,
    });
  }
}

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/file-upload/info/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getS3FileInfo } from '@/utils/file-upload/file-upload';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { S3Client } from '@aws-sdk/client-s3';
import { User, UserRole } from '@prisma/client';

const s3 = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.FORM_S3_AWS_ACCESS_KEY as string,
    secretAccessKey: process.env.FORM_S3_SECRET_ACCESS_KEY as string,
  },
});

const mediaIsRelatedToUser = async (user: User, mediaUrl: string) => {
  const pathParts = mediaUrl.split('/');
  const includesUserId = pathParts.includes(user.id);

  return includesUserId;
};

async function GET(request: NextRequest) {
  try {
    const headerList = headers();
    const s3Url = headerList.get('s3Url');

    if (!s3Url) {
      return ApiErrorHandler.handleBadRequest({
        message: 'You must include an s3 url',
        reqUrl: request.url,
        reqBody: '',
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      authMethod: mediaIsRelatedToUser,
      roleAccess: [UserRole.PATIENT],
      afterUserParams: [s3Url],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (!userInfo.user.id) {
      return ApiErrorHandler.handleUnauthorizedError({
        message: 'User is not logged in',
        reqUrl: request.url,
        reqHeaders: headerList,
      });
    }

    const response = await getS3FileInfo(s3Url, s3);

    if (response.error) {
      return ApiErrorHandler.handleServerError({
        message: response.errorMessage ?? 'Error getting file',
        reqUrl: request.url,
        reqBody: '',
      });
    }

    return NextResponse.json(response, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Failed to get file info',
      reqUrl: request.url,
      error: error,
    });
  }
}

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/forms/data/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { logger } from '@/utils/clients/logging/winstonClient';
import { prismaFormClient } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const DELETE = async (request: NextRequest) => {
  const userInfo = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.PATIENT],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  try {
    await prismaFormClient.formData.deleteMany({
      where: {
        userId: userInfo.user.id,
      },
    });

    return NextResponse.json(
      { message: 'All saved form data has been deleted for user.' },
      { status: HttpStatusCode.OK }
    );
  } catch (error) {
    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      error: error,
      additionalContext: { userId: userInfo.user.id },
    });
  }
};

export { DELETE };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/order/route.ts

// GET - Get Orders
import { NextRequest, NextResponse } from 'next/server';

import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });
    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const returnedOrders = await prisma.order.findMany({
      where: { userId: userInfo.user.id },
      include: {
        cartProducts: {
          select: {
            quantity: true,
            product: true,
            externalPaymentId: true,
          },
        },
        cartSubscriptionProducts: {
          select: {
            quantity: true,
            subscriptionProduct: true,
            externalPaymentId: true,
          },
        },
      },
    });

    return NextResponse.json(returnedOrders, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the orders',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/subscription-product/route.ts

// POST - Create Subscription Products
// GET - Get Subscription Products
import { NextRequest, NextResponse } from 'next/server';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import {
  ProductCategories,
  ShippingPartner,
  SubscriptionFrequencyUnits,
  UserRole,
} from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

interface createSubscriptionProductInput {
  name: string;
  description: string;
  price: number;
  imageURL?: string;
  active?: boolean;
  category: ProductCategories;
  frequency: number;
  frequencyUnit: SubscriptionFrequencyUnits;
  trialPeriodLength: number;
  trialPeriodUnit: SubscriptionFrequencyUnits;
  shippingPartner?: ShippingPartner;
  shippingPartnerSKU?: string;
  shippingOrderData?: any;
}

const POST = async (request: NextRequest) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const createSubscriptionProductInput: createSubscriptionProductInput =
      safeBody.jsonBody as createSubscriptionProductInput;

    const newSubscriptionProduct = await prisma.subscriptionProduct.create({
      data: {
        name: createSubscriptionProductInput.name,
        description: createSubscriptionProductInput.description,
        price: createSubscriptionProductInput.price,
        category: createSubscriptionProductInput.category,
        imageURL: createSubscriptionProductInput.imageURL
          ? createSubscriptionProductInput.imageURL
          : undefined,
        active: createSubscriptionProductInput.active
          ? createSubscriptionProductInput.active
          : true,
        frequency: createSubscriptionProductInput.frequency,
        frequencyUnit: createSubscriptionProductInput.frequencyUnit,
        trialPeriodLength: createSubscriptionProductInput.trialPeriodLength,
        trialPeriodUnit: createSubscriptionProductInput.trialPeriodUnit,
        shippingPartner: createSubscriptionProductInput.shippingPartner
          ? createSubscriptionProductInput.shippingPartner
          : undefined,
        shippingOrderData: createSubscriptionProductInput.shippingOrderData
          ? createSubscriptionProductInput.shippingOrderData
          : undefined,
        shippingPartnerSKU: createSubscriptionProductInput.shippingPartnerSKU,
      },
    });

    return NextResponse.json(newSubscriptionProduct, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem posting the subscription product',
      reqUrl: request.url,
      error: error,
    });
  }
};

const GET = async (request: NextRequest) => {
  try {
    const { searchParams } = new URL(request.url);
    const productCategory = searchParams.get('category') as ProductCategories;

    const returnedProducts = await prisma.subscriptionProduct.findMany({
      where: {
        category: productCategory ? productCategory : undefined,
      },
    });

    return NextResponse.json(returnedProducts, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the products',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/subscription-product/[subscriptionProductId]/route.ts

// POST - Update Subscription Products
// DELETE - Delete Subscription Products
// GET - Get Subscription Product
import { NextRequest, NextResponse } from 'next/server';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import {
  ProductCategories,
  ShippingPartner,
  SubscriptionFrequencyUnits,
  UserRole,
} from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

interface updateSubscriptionProductInput {
  name?: string;
  description?: string;
  price?: number;
  imageURL?: string;
  active?: boolean;
  category?: ProductCategories;
  frequency?: number;
  frequencyUnit?: SubscriptionFrequencyUnits;
  trialPeriodLength?: number;
  trialPeriodUnit?: SubscriptionFrequencyUnits;
  shippingPartner?: ShippingPartner;
  shippingOrderData?: any;
}

const POST = async (
  request: NextRequest,
  { params }: { params: { subscriptionProductId: string } }
) => {
  try {
    const productId = params.subscriptionProductId;

    if (!productId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No product Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const safeBody = await getSafeRequestBody(request);
    if (!safeBody.isValidJson) return safeBody.badRequestResponse;

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const updateProductInput: updateSubscriptionProductInput =
      safeBody.jsonBody as updateSubscriptionProductInput;

    const updatedSubscriptionProduct = await prisma.subscriptionProduct.update({
      where: {
        id: productId,
      },
      data: updateProductInput,
    });

    return NextResponse.json(updatedSubscriptionProduct, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem updating the subscription product',
      reqUrl: request.url,
      error: error,
    });
  }
};

const GET = async (
  request: NextRequest,
  { params }: { params: { subscriptionProductId: string } }
) => {
  try {
    const productId = params.subscriptionProductId;

    if (!productId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No subscription product Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const returnedSubscriptionProduct =
      await prisma.subscriptionProduct.findUnique({
        where: {
          id: productId,
        },
      });

    return NextResponse.json(returnedSubscriptionProduct, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the subscription product',
      reqUrl: request.url,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { subscriptionProductId: string } }
) => {
  try {
    const productId = params.subscriptionProductId;

    if (!productId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No product Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const deletedProduct = await prisma.subscriptionProduct.delete({
      where: {
        id: productId,
      },
    });

    return NextResponse.json(deletedProduct, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the product',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { DELETE, GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/subscription-product/[subscriptionProductId]/cart/route.ts

// POST - Add Subscription Product to Cart
// DELETE - Remove Subscription product from cart
import { NextRequest, NextResponse } from 'next/server';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import {
  addSubscriptionProductToCart,
  removeSubscriptionProductFromCart,
} from '@utils/ecommerce/cartUtils';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

interface AddSubscriptionProductToCartInput {
  setAbsoluteAmount: boolean;
  amount: number;
}

const POST = async (
  request: NextRequest,
  { params }: { params: { subscriptionProductId: string } }
) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const addSubscriptionProductToCartInput: AddSubscriptionProductToCartInput =
      safeBody.jsonBody as AddSubscriptionProductToCartInput;

    const subscriptionProductId = params.subscriptionProductId;

    if (!subscriptionProductId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No product Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const cartObject = await addSubscriptionProductToCart(
      userInfo.user,
      subscriptionProductId,
      addSubscriptionProductToCartInput.setAbsoluteAmount,
      addSubscriptionProductToCartInput.amount
    );

    return NextResponse.json(cartObject.cart, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem updating the product',
      reqUrl: request.url,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { subscriptionProductId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const subscriptionProductId = params.subscriptionProductId;

    if (!subscriptionProductId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No product Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const cartObject = await removeSubscriptionProductFromCart(
      userInfo.user,
      subscriptionProductId
    );

    return NextResponse.json(cartObject.cart, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem removing the product',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { DELETE, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/payment-routing/route.ts

// POST - Create Promo Code
// GET - Get Promo Code
import { NextRequest, NextResponse } from 'next/server';
import { PaymentRoutingInfoCreateInputSchema } from 'prisma/generated/zod';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const POST = async (request: NextRequest) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const validatedBody = PaymentRoutingInfoCreateInputSchema.parse(
      safeBody.jsonBody
    );

    if (validatedBody.id) {
      const updatedPaymentRoute = await prisma.paymentRoutingInfo.update({
        where: {
          id: validatedBody.id,
        },
        data: validatedBody,
      });

      return NextResponse.json(updatedPaymentRoute, { status: 200 });
    } else {
      const newPaymentRoute = await prisma.paymentRoutingInfo.create({
        data: validatedBody,
      });

      return NextResponse.json(newPaymentRoute, { status: 200 });
    }
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message:
        'There was a problem updating or inserting the connected account',
      reqUrl: request.url,
      error: error,
    });
  }
};

const GET = async (request: NextRequest) => {
  try {
    // Only an admin can return the full list of promo codes
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const returnedPaymentRoutes = await prisma.paymentRoutingInfo.findMany({
      where: {},
    });

    return NextResponse.json(returnedPaymentRoutes, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the payment routes',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/product/route.ts

// POST - Create Products
// GET - Get Products
import { NextRequest, NextResponse } from 'next/server';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import { ProductCategories, ShippingPartner, UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

interface createProductInput {
  name: string;
  description: string;
  price: number;
  imageURL?: string;
  active?: boolean;
  category: ProductCategories;
  shippingPartner?: ShippingPartner;
  shippingOrderData?: any;
  shippingPartnerSKU?: string;
}

const POST = async (request: NextRequest) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const createProductInput: createProductInput =
      safeBody.jsonBody as createProductInput;

    const newProduct = await prisma.product.create({
      data: {
        name: createProductInput.name,
        description: createProductInput.description,
        price: createProductInput.price,
        category: createProductInput.category,
        imageURL: createProductInput.imageURL
          ? createProductInput.imageURL
          : undefined,
        active: createProductInput.active ? createProductInput.active : true,
        shippingPartner: createProductInput.shippingPartner
          ? createProductInput.shippingPartner
          : undefined,
        shippingOrderData: createProductInput.shippingOrderData
          ? createProductInput.shippingOrderData
          : undefined,
        shippingPartnerSKU: createProductInput.shippingPartnerSKU,
      },
    });

    return NextResponse.json(newProduct, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem posting the product',
      reqUrl: request.url,
      error: error,
    });
  }
};

const GET = async (request: NextRequest) => {
  try {
    const { searchParams } = new URL(request.url);
    const productCategory = searchParams.get('category') as ProductCategories;

    const returnedProducts = await prisma.product.findMany({
      where: {
        category: productCategory ? productCategory : undefined,
      },
    });

    return NextResponse.json(returnedProducts, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the products',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/product/[productId]/route.ts

// POST - Update Products
// DELETE - Delete Products
// GET - Get Product
import { NextRequest, NextResponse } from 'next/server';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import { ProductCategories, ShippingPartner, UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

interface updateProductInput {
  name?: string;
  description?: string;
  price?: number;
  imageURL?: string;
  active?: boolean;
  category?: ProductCategories;
  shippingPartner?: ShippingPartner;
  shippingOrderData?: any;
  shippingPartnerSKU?: string;
}

const POST = async (
  request: NextRequest,
  { params }: { params: { productId: string } }
) => {
  try {
    const productId = params.productId;

    if (!productId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No product Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const safeBody = await getSafeRequestBody(request);
    if (!safeBody.isValidJson) return safeBody.badRequestResponse;

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const updateProductInput: updateProductInput =
      safeBody.jsonBody as updateProductInput;

    const updatedProduct = await prisma.product.update({
      where: {
        id: productId,
      },
      data: updateProductInput,
    });

    return NextResponse.json(updatedProduct, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem updating the product',
      reqUrl: request.url,
      error: error,
    });
  }
};

const GET = async (
  request: NextRequest,
  { params }: { params: { productId: string } }
) => {
  try {
    const productId = params.productId;

    if (!productId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No product Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const returnedProduct = await prisma.product.findUnique({
      where: {
        id: productId,
      },
    });

    return NextResponse.json(returnedProduct, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the product',
      reqUrl: request.url,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { productId: string } }
) => {
  try {
    const productId = params.productId;

    if (!productId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No product Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const deletedProduct = await prisma.product.delete({
      where: {
        id: productId,
      },
    });

    return NextResponse.json(deletedProduct, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the product',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { DELETE, GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/product/[productId]/cart/route.ts

// POST - Add Product to Cart
// DELETE - Remove product from cart
import { NextRequest, NextResponse } from 'next/server';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import {
  addProductToCart,
  removeProductFromCart,
} from '@utils/ecommerce/cartUtils';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

interface addProductToCartInput {
  setAbsoluteAmount: boolean;
  amount: number;
}

const POST = async (
  request: NextRequest,
  { params }: { params: { productId: string } }
) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const addProductToCartInput: addProductToCartInput =
      safeBody.jsonBody as addProductToCartInput;

    const productId = params.productId;

    if (!productId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No product Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const cartObject = await addProductToCart(
      userInfo.user,
      productId,
      addProductToCartInput.setAbsoluteAmount,
      addProductToCartInput.amount
    );

    return NextResponse.json(cartObject.cart, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem updating the product',
      reqUrl: request.url,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { productId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const productId = params.productId;

    if (!productId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No product Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const cartObject = await removeProductFromCart(userInfo.user, productId);

    return NextResponse.json(cartObject.cart, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem removing the product',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { DELETE, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/subscriptions/route.ts

// GET - Get Subscriptions
import { NextRequest, NextResponse } from 'next/server';

import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });
    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const returnedSubscriptions = await prisma.userSubscription.findMany({
      where: { userId: userInfo.user.id, ended: false },
      include: {
        subscriptionProduct: true,
      },
    });

    return NextResponse.json(returnedSubscriptions, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the subscriptions',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/cart/route.ts

// GET - Get your own cart
// DELETE - Remove item from your cart
import { NextRequest } from 'next/server';

import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { getUserCart } from '@utils/ecommerce/cartUtils';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });
    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    return createCookieResponse(
      (await getUserCart(userInfo.user)).cart,
      userInfo.cookieJar
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the cart',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/cart/remove-promo-code/route.ts

// POST - Add Promo Code to Cart
import { NextRequest, NextResponse } from 'next/server';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import { getUserCart } from '@utils/ecommerce/cartUtils';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const POST = async (request: NextRequest) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const currentUserCart = await getUserCart(userInfo.user);

    const updatedCart = await prisma.cart.update({
      where: {
        id: currentUserCart.cart.id,
      },
      data: {
        promoCodeCode: null,
      },
      include: {
        cartProducts: true,
        cartSubscriptionProducts: true,
      },
    });

    return NextResponse.json(updatedCart, {
      status: 200,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem removing the promo code from the cart',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/cart/get-cart-with-content/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { getProductContentForCart } from '@/utils/helpers/helpers';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { getUserCart } from '@utils/ecommerce/cartUtils';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });
    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const cart = await getUserCart(userInfo.user);
    const content = await getProductContentForCart(cart.cart);

    return NextResponse.json({
      cart: cart.cart,
      content,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the cart',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/cart/add-promo-code/route.ts

// POST - Add Promo Code to Cart
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { prismaEcomClient } from '@/app/shared/models/extensions/ecommerce';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import {
  addProductToCart,
  addSubscriptionProductToCart,
  getUserCart,
} from '@utils/ecommerce/cartUtils';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const addPromoCodeSchema = z.object({
  code: z.string(),
  addProductToCart: z.boolean().optional().default(false),
});

const POST = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const promoCodeBodyResult = await getSafeTypedBody(
      request,
      addPromoCodeSchema
    );

    if (!promoCodeBodyResult.success) return promoCodeBodyResult.errorResponse;

    const { value: addPromoCodeInput } = promoCodeBodyResult;

    const retrievedPromoCode = await prismaEcomClient.promoCodes.findFirst({
      where: { code: addPromoCodeInput.code },
    });

    const promoCanBeUsed =
      retrievedPromoCode &&
      (await retrievedPromoCode.isActive(userInfo.user.id));

    if (!promoCanBeUsed) {
      return ApiErrorHandler.handle404Error({
        message: 'Promo code is not active',
        reqUrl: request.url,
        logError: false,
      });
    }

    if (addPromoCodeInput.addProductToCart) {
      const addProduct = retrievedPromoCode.associatedProductIds.length > 0;
      const addSubscription =
        !addProduct && retrievedPromoCode.associatedSubscriptionIds.length > 0;

      if (addProduct || addSubscription) {
        const productToAdd = addProduct
          ? retrievedPromoCode.associatedProductIds[0]
          : retrievedPromoCode.associatedSubscriptionIds[0];

        if (addProduct && productToAdd)
          await addProductToCart(userInfo.user, productToAdd, true, 1);
        else if (addSubscription && productToAdd)
          await addSubscriptionProductToCart(
            userInfo.user,
            productToAdd,
            true,
            1
          );
      }
    }

    const currentUserCart = await getUserCart(userInfo.user);

    const updatedCart = await prismaEcomClient.cart.update({
      where: {
        id: currentUserCart.cart.id,
      },
      data: {
        promoCodeCode: addPromoCodeInput.code,
      },
      include: {
        cartProducts: true,
        cartSubscriptionProducts: true,
      },
    });

    return NextResponse.json(updatedCart, {
      status: 200,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem adding the promo code to the cart',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/cart/price/route.ts

// POST - Add Promo Code to Cart
import { NextRequest, NextResponse } from 'next/server';

import { prismaEcomClient } from '@/app/shared/models/extensions/ecommerce';
import { applyConciergeDiscount } from '@/utils/ecommerce/conciergeUtils';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { cartPriceReturn, getUserCart } from '@utils/ecommerce/cartUtils';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';
import {
  GetSumProductPrices,
  GetSumSubscriptionPrices,
} from '@utils/payments/purchaseSystem';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const currentUserCart = await getUserCart(userInfo.user);

    let promoCode = null;
    if (currentUserCart.cart.promoCodeCode) {
      const promoCodeResult = await prismaEcomClient.promoCodes.findFirst({
        where: { code: currentUserCart.cart.promoCodeCode },
      });

      const promoCanBeUsed = await promoCodeResult?.isActive(userInfo.user.id);

      if (promoCanBeUsed) promoCode = promoCodeResult;
    }

    const sumProductPricesNoPromo = await GetSumProductPrices(
      currentUserCart.cartProducts,
      null
    );
    const sumProductPrices = await GetSumProductPrices(
      currentUserCart.cartProducts,
      promoCode
    );

    const sumSubscriptionProductPricesNoPromo = await GetSumSubscriptionPrices(
      currentUserCart.cartSubscriptionProducts,
      null
    );
    const sumSubscriptionPrices = await GetSumSubscriptionPrices(
      currentUserCart.cartSubscriptionProducts,
      promoCode
    );

    // Promo Code is applied then concierge
    const subTotal =
      sumSubscriptionProductPricesNoPromo + sumProductPricesNoPromo;
    const promoCodeAppliedSubTotal = sumProductPrices + sumSubscriptionPrices;

    const conciergeDiscountedPrice = await applyConciergeDiscount(
      promoCodeAppliedSubTotal,
      userInfo.user,
      currentUserCart.conciergeInCartPrice
    );

    const cartPriceInfo: cartPriceReturn = {
      subTotalPrice: subTotal,
      conciergeDiscount: conciergeDiscountedPrice - promoCodeAppliedSubTotal,
      productPrice: sumProductPrices,
      subscriptionPrice: sumSubscriptionPrices,
      promoCodeDiscount:
        promoCodeAppliedSubTotal -
        (sumProductPricesNoPromo + sumSubscriptionProductPricesNoPromo),
      tax: 0, // TODO: Integrate tax system to calculate user taxes
      shipping: 0, // TODO: Calculate shipping
      totalPrice: conciergeDiscountedPrice + 0 - 0, // TODO: Subtotal + Tax - PromoCodeDiscount should go here
    };

    // TODO: Determine what exactly we want to return
    return NextResponse.json(await cartPriceInfo, {
      status: 200,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem calculating the cart price',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/cart/purchase/route.ts

// POST - Add Promo Code to Cart
import { NextRequest, NextResponse } from 'next/server';

import { prismaEcomClient } from '@/app/shared/models/extensions/ecommerce';
import LoggerUtil from '@/utils/clients/logging/apiUtilLogger';
import { isUserConciergeMember } from '@/utils/ecommerce/conciergeUtils';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserEventNames } from '@/utils/user-events/enums';
import UserEventsClient from '@/utils/user-events/user-events-client';
import { prisma } from '@clients/mongo/prismaClient';
import {
  Address,
  CartProducts,
  CartSubscriptionProducts,
  OrderType,
  PaymentProviders,
  ProductCategories,
  User,
} from '@prisma/client';
import { getUserCart } from '@utils/ecommerce/cartUtils';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';
import { GetPurchaseSystem } from '@utils/payments/purchaseSystem';
import { shipOrder } from '@utils/shipping/shippingUtils';

interface purchaseCartInput {
  paymentMethodId: string;
  paymentProvider: PaymentProviders;
  address: Address;
}

interface separatedCartItems {
  OTCItems: CartProducts[];
  medicalItems: CartProducts[];
}

interface separatedSubscriptionCartItems {
  OTCItems: CartSubscriptionProducts[];
  medicalItems: CartSubscriptionProducts[];
}

async function separateCartItems(
  currentUserCartProducts: CartProducts[]
): Promise<separatedCartItems> {
  const OTCItems: CartProducts[] = [];
  const medicalItems: CartProducts[] = [];

  for (let i = 0; i < currentUserCartProducts.length; i++) {
    if (currentUserCartProducts[i]) {
      const productToBuy = await prisma.product.findUnique({
        where: {
          id: currentUserCartProducts[i].productId,
        },
      });

      if (productToBuy?.category === ProductCategories.CONSULTATION) {
        medicalItems.push(currentUserCartProducts[i]);
      } else if (productToBuy?.category === ProductCategories.CONCIERGE) {
        medicalItems.push(currentUserCartProducts[i]);
      } else {
        OTCItems.push(currentUserCartProducts[i]);
      }
    }
  }

  return {
    OTCItems,
    medicalItems,
  };
}

async function separateSubscriptionCartItems(
  currentUserCartSubscriptionProducts: CartSubscriptionProducts[]
): Promise<separatedSubscriptionCartItems> {
  const OTCItems: CartSubscriptionProducts[] = [];
  const medicalItems: CartSubscriptionProducts[] = [];

  for (let i = 0; i < currentUserCartSubscriptionProducts.length; i++) {
    if (currentUserCartSubscriptionProducts[i]) {
      const productToBuy = await prisma.subscriptionProduct.findUnique({
        where: {
          id: currentUserCartSubscriptionProducts[i].subscriptionProductId,
        },
      });

      if (productToBuy?.category === ProductCategories.CONSULTATION) {
        medicalItems.push(currentUserCartSubscriptionProducts[i]);
      } else if (productToBuy?.category === ProductCategories.CONCIERGE) {
        medicalItems.push(currentUserCartSubscriptionProducts[i]);
      } else {
        OTCItems.push(currentUserCartSubscriptionProducts[i]);
      }
    }
  }

  return {
    OTCItems,
    medicalItems,
  };
}

async function checkConciergePurchaseEligibility(
  user: User,
  otcSubscriptions: CartSubscriptionProducts[]
) {
  const conciergeSubscriptionsInCart = otcSubscriptions.filter(
    (item) =>
      item.subscriptionProductId ===
        process.env.PRODUCT_ID_CONCIERGE_SUBSCRIPTION_MONTHLY ||
      item.subscriptionProductId ==
        process.env.PRODUCT_ID_CONCIERGE_SUBSCRIPTION_YEARLY
  );

  if (
    (await isUserConciergeMember(user)) &&
    conciergeSubscriptionsInCart.length > 0
  ) {
    throw new Error(
      'Concierge may not be purchased while user maintains an active subscription'
    );
  }

  if (conciergeSubscriptionsInCart.length > 1) {
    throw new Error(
      'Only one concierge subscription may be purchased at a time'
    );
  }

  for (const conciergeSubscription of conciergeSubscriptionsInCart) {
    if (conciergeSubscription.quantity > 1) {
      throw new Error(
        'Only one concierge subscription may be purchased at a time'
      );
    }
  }
}

const POST = async (request: NextRequest) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const purchaseCartInput: purchaseCartInput =
      safeBody.jsonBody as purchaseCartInput;

    const currentUserCart = await getUserCart(userInfo.user);

    // Separate OTC, Medical, Subscriptions
    const OTCAndMedicalItems = await separateCartItems(
      currentUserCart.cartProducts
    );

    const OTCAndMedicalSubscriptions = await separateSubscriptionCartItems(
      currentUserCart.cartSubscriptionProducts
    );

    await LoggerUtil.logInfo(
      'cart_purchase_request',
      'api/ecommerce/cart/purchase',
      {
        userId: currentUserCart.cart.userId,
        currentUserCart,
        OTCAndMedicalItems,
        OTCAndMedicalSubscriptions,
      }
    );

    // Determine if user is attempting purchase concierge when they shouldn't be able to
    await checkConciergePurchaseEligibility(
      userInfo.user,
      OTCAndMedicalSubscriptions.OTCItems
    );

    await LoggerUtil.logInfo(
      'check_concierge_eligibility_success',
      'api/ecommerce/cart/purchase',
      {
        userId: currentUserCart.cart.userId,
        currentUserCart,
        OTCAndMedicalSubscriptions,
      }
    );

    let promoCode = null;
    if (currentUserCart.cart.promoCodeCode) {
      const promoCodeResult = await prismaEcomClient.promoCodes.findFirst({
        where: {
          code: currentUserCart.cart.promoCodeCode,
        },
      });

      const promoCanBeUsed = await promoCodeResult?.isActive(userInfo.user.id);

      if (promoCanBeUsed) promoCode = promoCodeResult;
    }

    if (!promoCode)
      await LoggerUtil.logError(
        'promo_code_not_found',
        'api/ecommerce/cart/purchase',
        new Error('The promo code in the cart is no longer active.'),
        {
          userId: currentUserCart.cart.userId,
          promoCode: currentUserCart.cart.promoCodeCode,
        }
      );
    else
      await LoggerUtil.logInfo(
        'promo_code_found',
        'api/ecommerce/cart/purchase',
        {
          userId: currentUserCart.cart.userId,
          promoCode: currentUserCart.cart.promoCodeCode,
        }
      );

    // Create the Order
    let newOrder = await prisma.order.create({
      data: {
        userId: userInfo.user.id,
        paymentMethodId: purchaseCartInput.paymentMethodId,
        paymentProvider: purchaseCartInput.paymentProvider,
        orderType: OrderType.NEW_ORDER,
        shippingAddress: purchaseCartInput.address,
        promoCodeCode: promoCode?.code,
      },
    });

    if (!newOrder)
      await LoggerUtil.logError(
        'order_creation_failed',
        'api/ecommerce/cart/purchase',
        new Error('Order creation failed.'),
        {
          userId: currentUserCart.cart.userId,
          currentUserCart,
          OTCAndMedicalSubscriptions,
        }
      );
    else
      await LoggerUtil.logInfo(
        'order_creation_success',
        'api/ecommerce/cart/purchase',
        {
          userId: currentUserCart.cart.userId,
          currentUserCart,
          newOrder,
        }
      );

    // Buy the items
    const purchaseSystem = await GetPurchaseSystem();

    const [
      otcProductsPurchased,
      medicalProductsPurchased,
      otcSubscriptionsPurchased,
      medicalSubscriptionsPurchased,
    ] = await Promise.all([
      await purchaseSystem.BuyOTC(
        purchaseCartInput.paymentMethodId,
        purchaseCartInput.paymentProvider,
        userInfo.user,
        purchaseCartInput.address,
        OTCAndMedicalItems.OTCItems,

        newOrder,
        currentUserCart.cart,
        promoCode,
        !!currentUserCart.conciergeInCartPrice
      ),
      await purchaseSystem.BuyMedical(
        purchaseCartInput.paymentMethodId,
        purchaseCartInput.paymentProvider,
        userInfo.user,
        purchaseCartInput.address,
        OTCAndMedicalItems.medicalItems,
        newOrder,
        currentUserCart.cart,
        promoCode,
        !!currentUserCart.conciergeInCartPrice
      ),
      await purchaseSystem.BuyOTCSubscription(
        purchaseCartInput.paymentMethodId,
        purchaseCartInput.paymentProvider,
        userInfo.user,
        purchaseCartInput.address,
        OTCAndMedicalSubscriptions.OTCItems,

        newOrder,
        currentUserCart.cart,
        promoCode,
        currentUserCart.conciergeInCartPrice
      ),
      await purchaseSystem.BuyMedicalSubscription(
        purchaseCartInput.paymentMethodId,
        purchaseCartInput.paymentProvider,
        userInfo.user,
        purchaseCartInput.address,
        OTCAndMedicalSubscriptions.medicalItems,

        newOrder,
        currentUserCart.cart,
        promoCode,
        !!currentUserCart.conciergeInCartPrice
      ),
    ]);

    await LoggerUtil.logInfo(
      'product_purchasing_complete',
      'api/ecommerce/cart/purchase',
      {
        userId: currentUserCart.cart.userId,
        OTCProductPurchases: otcProductsPurchased.numberProductsPurchased,
        MedicalProductPurchases:
          medicalProductsPurchased.numberProductsPurchased,
        OTCSubPurchases: otcSubscriptionsPurchased.numberProductsPurchased,
        MedicalSubPurchases:
          medicalSubscriptionsPurchased.numberProductsPurchased,
      }
    );

    // delete the order if the order is empty
    if (
      medicalProductsPurchased.numberProductsPurchased <= 0 &&
      medicalSubscriptionsPurchased.numberProductsPurchased <= 0 &&
      otcSubscriptionsPurchased.numberProductsPurchased <= 0 &&
      otcProductsPurchased.numberProductsPurchased <= 0
    ) {
      await prisma.order.delete({
        where: {
          id: newOrder.id,
        },
      });

      await LoggerUtil.logInfo(
        'no_purchases_delete_order',
        'api/ecommerce/cart/purchase',
        {
          userId: currentUserCart.cart.userId,
          orderId: newOrder.id,
        }
      );

      return NextResponse.json('Nothing Purchased', {
        status: 200,
      });
    }

    newOrder = await prisma.order.update({
      where: {
        id: newOrder.id,
      },
      data: {
        medicalPaymentId: medicalProductsPurchased.paymentId,
        medicalSubscriptionPaymentId: medicalSubscriptionsPurchased.paymentId,
        otcPaymentId: otcProductsPurchased.paymentId,
        otcSubscriptionPaymentId: otcSubscriptionsPurchased.paymentId,
      },
    });

    await LoggerUtil.logInfo(
      'updated_order_with_payment_details',
      'api/ecommerce/cart/purchase',
      {
        userId: currentUserCart.cart.userId,
        order: newOrder,
      }
    );

    await UserEventsClient.addEvent(
      userInfo.user,
      UserEventNames.DERMI_CHECKOUT_COMPLETED_AND_PURCHASE,
      {
        orderId: newOrder.id,
        otcPurchased: otcProductsPurchased.numberProductsPurchased,
        medicalPurchased: medicalProductsPurchased.numberProductsPurchased,
        otcSubsPurchased: otcSubscriptionsPurchased.numberProductsPurchased,
        medicalSubsPurchased:
          medicalSubscriptionsPurchased.numberProductsPurchased,
      }
    );

    // Create Shipments
    const shipments = await shipOrder(
      userInfo.user,
      newOrder,
      purchaseCartInput.address,
      currentUserCart.cartProducts,
      currentUserCart.cartSubscriptionProducts
    );

    if (shipments && shipments.length > 0)
      await LoggerUtil.logInfo(
        'order_shipment_created',
        'api/ecommerce/cart/purchase',
        {
          userId: currentUserCart.cart.userId,
          orderId: newOrder?.id,
          shipments,
        }
      );
    else
      await LoggerUtil.logInfo(
        'no_shipments_created',
        'api/ecommerce/cart/purchase',
        {
          userId: currentUserCart.cart.userId,
          orderId: newOrder?.id,
          order: newOrder,
        }
      );

    // TODO: Determine what exactly we want to return
    return NextResponse.json(
      await prisma.order.findUnique({
        where: {
          id: newOrder.id,
        },
        include: {
          cartProducts: {
            select: {
              product: true,
            },
          },
          cartSubscriptionProducts: {
            select: {
              subscriptionProduct: true,
            },
          },
        },
      }),
      {
        status: 200,
      }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem purchasing the cart',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/promo-code/route.ts

// POST - Create Promo Code
// GET - Get Promo Code
import moment from 'moment';
import { NextRequest, NextResponse } from 'next/server';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import { SubscriptionFrequencyUnits, UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

interface createPromoCodeInput {
  code: string;
  description: string;
  amountOff: number;
  percentOff: number;
  worksForAllProducts?: boolean;
  active?: boolean;
  associatedProductIds: string[];
  associatedSubscriptionIds: string[];
  duration?: number;
  durationUnit?: SubscriptionFrequencyUnits;
  startDateTime?: string;
  endDateTime?: string;
}

const POST = async (request: NextRequest) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const createPromoCodeInput: createPromoCodeInput =
      safeBody.jsonBody as createPromoCodeInput;

    const startDateTime = createPromoCodeInput.startDateTime
      ? moment(createPromoCodeInput.startDateTime).utc().toDate()
      : undefined;

    const endDateTime = createPromoCodeInput.endDateTime
      ? moment(createPromoCodeInput.endDateTime).utc().toDate()
      : undefined;

    const newPromoCode = await prisma.promoCodes.create({
      data: {
        code: createPromoCodeInput.code,
        description: createPromoCodeInput.description,
        active: createPromoCodeInput.active
          ? createPromoCodeInput.active
          : true,
        amountOff: createPromoCodeInput.amountOff
          ? createPromoCodeInput.amountOff
          : 0,
        percentOff: createPromoCodeInput.percentOff
          ? createPromoCodeInput.percentOff
          : 0,
        worksForAllProducts: createPromoCodeInput.worksForAllProducts
          ? createPromoCodeInput.worksForAllProducts
          : false,
        associatedProductIds: createPromoCodeInput.associatedProductIds,
        associatedSubscriptionIds:
          createPromoCodeInput.associatedSubscriptionIds,
        duration: createPromoCodeInput.duration
          ? createPromoCodeInput.duration
          : undefined,
        durationUnit: createPromoCodeInput.durationUnit
          ? createPromoCodeInput.durationUnit
          : undefined,
        startDateTime,
        endDateTime,
      },
    });

    return NextResponse.json(newPromoCode, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem posting the promo code',
      reqUrl: request.url,
      error: error,
    });
  }
};

const GET = async (request: NextRequest) => {
  try {
    // Only an admin can return the full list of promo codes
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const returnedPromoCodes = await prisma.promoCodes.findMany({
      where: {},
    });

    return NextResponse.json(returnedPromoCodes, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the promo codes',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/promo-code/redeem/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { prismaEcomClient } from '@/app/shared/models/extensions/ecommerce';
import LoggerUtil from '@/utils/clients/logging/apiUtilLogger';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';

const RedeemPromoCodeSchema = z.object({
  promoCode: z.string(),
});

const POST = async (request: NextRequest) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
  });

  if (!userResult.success)
    return ApiErrorHandler.handleBadRequest({
      message: 'No user found',
      reqUrl: request.url,
      reqHeaders: request.headers,
    });

  const bodyResult = await getSafeTypedBody(request, RedeemPromoCodeSchema);

  if (!bodyResult.success)
    return ApiErrorHandler.handleBadRequest({
      message: 'No promo code was provided to redeem',
      reqUrl: request.url,
      reqHeaders: request.headers,
    });

  const { promoCode } = bodyResult.value;

  try {
    const foundPromoCode = await prismaEcomClient.promoCodes.findUnique({
      where: {
        code: promoCode,
      },
    });

    if (!foundPromoCode) throw new Error('Promo code not found');

    const promoIsActive = await foundPromoCode.isActive(userResult.user.id);

    if (!promoIsActive) throw new Error('Promo code has already been used');

    await LoggerUtil.logInfo(
      'promo_code_redeemed',
      'api/ecommerce/promo-code/redeem',
      {
        userId: userResult.success ? userResult.user.id : 'unknown',
        promoCode,
        campaign: foundPromoCode.campaign,
      }
    );

    const userCookies = userResult.cookieJar.cookies;
    const headers = new Headers(accessHeaders);

    userCookies.forEach((cookie) => {
      let cookieString = `${cookie.name}=${cookie.value}`;

      if (cookie.path) {
        cookieString += `; Path=${cookie.path}`;
      }
      if (cookie.domain) {
        cookieString += `; Domain=${cookie.domain}`;
      }
      if (cookie.httpOnly) {
        cookieString += `; HttpOnly`;
      }
      if (cookie.secure) {
        cookieString += `; Secure`;
      }
      if (cookie.expires) {
        cookieString += `; Expires=${new Date(cookie.expires).toUTCString()}`;
      }

      headers.append('Set-Cookie', cookieString);
    });

    return NextResponse.json(
      { success: true },
      {
        status: HttpStatusCode.OK,
        headers,
      }
    );
  } catch (error) {
    const typedError = error as Error;
    const errorResponse = ApiErrorHandler.handleServerError({
      message: typedError.message ?? 'Error redeeming promo code',
      reqUrl: request.url,
      reqHeaders: request.headers,
      additionalContext: {
        source: 'redemption',
        redemptionSource: request.referrer,
        promoCode,
        userId: userResult.user.id,
      },
    });

    Object.entries(accessHeaders).forEach(([key, value]) => {
      errorResponse.headers.set(key, value);
    });

    return errorResponse;
  }
};

const OPTIONS = () => {
  return NextResponse.json(
    {},
    {
      status: HttpStatusCode.OK,
      headers: {
        Allow: 'POST, OPTIONS',
        ...accessHeaders,
      },
    }
  );
};

export { POST, OPTIONS };

const accessHeaders = {
  'Access-Control-Allow-Origin': 'https://explore.cortinahealth.com',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/promo-code/[promoCodeId]/route.ts

// POST - Update Promo Codes
// DELETE - Delete Promo Codes
// GET - Get Promo Codes
import moment from 'moment';
import { NextRequest, NextResponse } from 'next/server';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import { SubscriptionFrequencyUnits, UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

interface updatePromoCodeInput {
  code?: string;
  description?: string;
  amountOff?: number;
  percentOff?: number;
  worksForAllProducts?: boolean;
  active?: boolean;
  associatedProductIds?: string[];
  associatedSubscriptionIds?: string[];
  duration?: number;
  durationUnit?: SubscriptionFrequencyUnits;
  startDateTime?: string | Date;
  endDateTime?: string | Date;
}

const POST = async (
  request: NextRequest,
  { params }: { params: { promoCodeId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    const promoCodeId = params.promoCodeId;

    if (!promoCodeId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No promo code Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const safeBody = await getSafeRequestBody(request);
    if (!safeBody.isValidJson) return safeBody.badRequestResponse;

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const updatePromoCodeInput: updatePromoCodeInput =
      safeBody.jsonBody as updatePromoCodeInput;

    const { startDateTime, endDateTime } = updatePromoCodeInput;

    if (startDateTime && typeof startDateTime === 'string')
      updatePromoCodeInput.startDateTime = moment(startDateTime).utc().toDate();

    if (endDateTime && typeof endDateTime === 'string')
      updatePromoCodeInput.endDateTime = moment(endDateTime).utc().toDate();

    const updatedPromoCode = await prisma.promoCodes.update({
      where: {
        id: promoCodeId,
      },
      data: updatePromoCodeInput,
    });

    return NextResponse.json(updatedPromoCode, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem updating the promo code',
      reqUrl: request.url,
      error: error,
    });
  }
};

const GET = async (
  request: NextRequest,
  { params }: { params: { promoCodeId: string } }
) => {
  try {
    // Only admin can retrieve the details of a promo code
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    const promoCodeId = params.promoCodeId;

    if (!promoCodeId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No promo code Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const returnedPromoCode = await prisma.promoCodes.findUnique({
      where: {
        id: promoCodeId,
      },
    });

    return NextResponse.json(returnedPromoCode, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the promo code',
      reqUrl: request.url,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { promoCodeId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    const promoCodeId = params.promoCodeId;

    if (!promoCodeId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No product Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const deletedPromoCode = await prisma.promoCodes.delete({
      where: {
        id: promoCodeId,
      },
    });

    return NextResponse.json(deletedPromoCode, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the promo code',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { DELETE, GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/customer-info/route.ts

// POST - Create or Update Customer
import { NextRequest, NextResponse } from 'next/server';

import { createOrUpdateStripeCustomer } from '@/utils/payments/stripe-utils';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const POST = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN, UserRole.PATIENT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    // Create Stripe Customer
    const customer = await createOrUpdateStripeCustomer(userInfo.user);

    // Add stripe ID to the main user
    const updatedUser = await prisma.user.update({
      where: { id: userInfo.user.id },
      data: { stripeId: customer.id },
    });

    // Update the Dependents
    await prisma.user.updateMany({
      where: {
        guardianId: userInfo.user.id,
      },
      data: {
        stripeId: customer.id,
      },
    });

    return NextResponse.json(
      `customer ${updatedUser.stripeId} successfully created`,
      { status: 200 }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem creating the customer provider',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/customer-info/payment-method/route.ts

// POST - Save Payment Method
// GET - Get Payment Methods
import { NextRequest, NextResponse } from 'next/server';

import LoggerUtil from '@/utils/clients/logging/apiUtilLogger';
import {
  addNameToUserIfNull,
  splitFullNameIntoFirstAndLast,
} from '@/utils/helpers/helpers';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { PaymentProviders } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';
import {
  attachPaymentMethod,
  getPaymentMethods,
} from '@utils/payments/stripe-utils';
import { IPaymentMethod } from '@utils/payments/types';

interface PaymentMethodsWithProvider extends IPaymentMethod {
  paymentProvider: PaymentProviders;
}

interface savePaymentMethodInput {
  paymentMethodId: string;
  paymentProvider: PaymentProviders;
  customerData?: any;
}

const POST = async (request: NextRequest) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const savePaymentMethodInput: savePaymentMethodInput =
      safeBody.jsonBody as savePaymentMethodInput;

    if (savePaymentMethodInput.paymentProvider === PaymentProviders.STRIPE) {
      await attachPaymentMethod(
        savePaymentMethodInput.paymentMethodId,
        userInfo.user
      );
    } else if (
      savePaymentMethodInput.paymentProvider === PaymentProviders.DEMO
    ) {
      await LoggerUtil.logInfo(
        'save_payment_info',
        'post api/ecommerce/customer-info/payment-method',
        {
          userId: userInfo.user.id,
          paymentMethod: savePaymentMethodInput.paymentMethodId,
        }
      );
    } else {
      throw new Error('Payment provider is not supported');
    }

    const { firstName, lastName } = splitFullNameIntoFirstAndLast(
      savePaymentMethodInput.customerData?.name
    );
    await addNameToUserIfNull(userInfo.user, firstName, lastName);

    return NextResponse.json(
      { message: 'Payment method saved' },
      {
        status: 200,
      }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem adding the payment method to the user',
      reqUrl: request.url,
      error: error,
    });
  }
};

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const paymentMethodsWithProvider: PaymentMethodsWithProvider[] = [];

    const paymentMethods = await getPaymentMethods(userInfo.user);

    paymentMethods.forEach((element) => {
      paymentMethodsWithProvider.push({
        paymentProvider: PaymentProviders.STRIPE,
        ...element,
      });
    });

    return NextResponse.json(paymentMethodsWithProvider, {
      status: 200,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem retrieving payment methods for this user',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/customer-info/payment-method/[paymentProvider]/[paymentMethodId]/route.ts

// POST - Save Payment Method
// GET - Get Payment Methods
import { NextRequest, NextResponse } from 'next/server';

import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { PaymentProviders } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';
import { getPaymentMethodById } from '@utils/payments/stripe-utils';
import { IPaymentMethod } from '@utils/payments/types';

const GET = async (
  request: NextRequest,
  { params }: { params: { paymentMethodId: string; paymentProvider: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (params.paymentProvider === PaymentProviders.STRIPE) {
      return NextResponse.json(
        await getPaymentMethodById(params.paymentMethodId),
        {
          status: 200,
        }
      );
    } else if (params.paymentProvider === PaymentProviders.DEMO) {
      const demoCardToReturn: IPaymentMethod = {
        id: 'Test',
        brand: 'Cortina',
        expMonth: '5',
        expYear: '2028',
        last4: '5555',
        default: false,
      };
      return NextResponse.json(demoCardToReturn, {
        status: 200,
      });
    } else {
      throw new Error('Payment provider is not supported');
    }
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem retrieving payment methods for this user',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/shipment/route.ts

// GET - Get Shipments
import { NextRequest, NextResponse } from 'next/server';

import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });
    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const returnedShipments = await prisma.shipment.findMany({
      where: { userId: userInfo.user.id },
      include: {
        products: true,
        subscriptionProducts: true,
      },
    });

    return NextResponse.json(returnedShipments, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the shipments',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/ecommerce/shipment/[shipmentId]/route.ts

// GET - Get Shipments
import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { shipOrder } from '@/utils/shipping/shippingUtils';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

// Update shipment (Basically attempts to reship an order if the order is in error)
const POST = async (
  request: NextRequest,
  { params }: { params: { shipmentId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });
    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const shipmentId = params.shipmentId;

    // Attempt to reorder the shipment
    const shipment = await prisma.shipment.findFirst({
      where: {
        id: shipmentId,
        userId: userInfo.user.id,
      },
      include: {
        user: true,
      },
    });

    if (shipment) {
      const orderWithProducts = await prisma.order.findUnique({
        where: {
          id: shipment?.orderId,
        },
        include: {
          cartProducts: true,
          cartSubscriptionProducts: true,
        },
      });

      if (orderWithProducts && orderWithProducts.shippingAddress) {
        const returnedShipments = await shipOrder(
          shipment.user,
          orderWithProducts,
          orderWithProducts.shippingAddress,
          orderWithProducts.cartProducts,
          orderWithProducts.cartSubscriptionProducts
        );

        return NextResponse.json(returnedShipments, { status: 200 });
      } else {
        return NextResponse.json('No Shipping Address Found', { status: 200 });
      }
    }

    return NextResponse.json('Shipment not found', { status: 404 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem ordering the shipments',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/submit/collect-consultation-funds/route.ts

import { NextRequest, NextResponse } from 'next/server';

import {
  addProductToCart,
  addSubscriptionProductToCart,
} from '@/utils/ecommerce/cartUtils';
import { ConsultationType } from '@/utils/enums';
import { needsConsultation } from '@/utils/get-user-state';
import { getBaseUrl } from '@/utils/getBaseUrl';
import { getUserAttributes } from '@/utils/helpers/helpers';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';

export async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, GET' } });
}

export async function GET(request: NextRequest) {
  try {
    const userInfo = await getUserAndCheckAuthorized({ request: request });
    if (!userInfo.success) return userInfo.unAuthorizedResponse;
    const extendedUser = await getUserAttributes(userInfo.user);

    // Parsing the URL to get and manipulate query parameters
    const url = new URL(request.url);
    const consultType =
      url.searchParams.get('consult-type') || ConsultationType.SELF;
    url.searchParams.delete('consult-type');

    // Set up the redirect based on the consultation type of SELF or FAMILY
    const baseUrl = getBaseUrl();
    let basePath =
      consultType == ConsultationType.FAMILY ||
      consultType == ConsultationType.SELF
        ? `/account/select-consultation-type-${consultType}`
        : '/api/submit/update-payment-status';
    if (url.searchParams.toString()) {
      basePath += `?${url.searchParams.toString()}`;
    }

    // Result of this API will always redirect somewhere
    let redirectUrl = '/account/error';

    const needToPurchasecConsultation = await needsConsultation();
    if (needToPurchasecConsultation) {
      await addProductToCart(
        userInfo.user,
        process.env.PRODUCT_ID_ONE_TIME_MEDICAL_CONSULTATION + '',
        true,
        1
      );

      if (!extendedUser.hasConcierge) {
        await addSubscriptionProductToCart(
          userInfo.user,
          process.env.PRODUCT_ID_CONCIERGE_SUBSCRIPTION_MONTHLY + '',
          true,
          1
        );
      }

      // Construct the redirect URL with the encoded basePath as part of redirect_url
      const encodedRedirectUrl = encodeURIComponent(basePath);
      redirectUrl = `${baseUrl}/shop/checkout?redirect_url=${encodedRedirectUrl}`;
    } else {
      redirectUrl = `${baseUrl}${basePath}`;
    }

    return NextResponse.redirect(redirectUrl);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message:
        'There was a problem adding the consultation product to the cart',
      reqUrl: request.url,
      error: error,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/submit/submit-self-intake/route.ts

import { revalidateTag } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';

import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { submitSelfIntake } from '@/utils/submission-helpers/submit-self-intake';
import {
  SubmitSelfIntakeType,
  submitSelfIntakeSchema,
} from '@/utils/submission-helpers/zod-schemas';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

export async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, POST' } });
}

export async function POST(request: NextRequest) {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    // Type check the incoming body
    const typeCheckResult = await getSafeTypedBody(
      request,
      submitSelfIntakeSchema
    );

    if (!typeCheckResult.success) return typeCheckResult.errorResponse;

    // Update the user and create a new case
    const submissionResult = await submitSelfIntake(
      userInfo.user,
      typeCheckResult.value as SubmitSelfIntakeType
    );

    revalidateTag('user');

    return NextResponse.json(submissionResult, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem submitting the intake',
      reqUrl: request.url,
      error: error,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/submit/consultation-form/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { UpdateMeSchema } from 'prisma/custom-schemas/updateMe';

import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import {
  addProductToCart,
  addSubscriptionProductToCart,
} from '@/utils/ecommerce/cartUtils';
import {
  convertStringDateToISOString,
  getUserAttributes,
} from '@/utils/helpers/helpers';
import { UserEventNames } from '@/utils/user-events/enums';
import UserEventsClient from '@/utils/user-events/user-events-client';
import { prisma } from '@utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@utils/errors';
import { registerUserWithPaymentVendor } from '@utils/helpers/helpers';
import { getSafeRequestBody } from '@utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

export async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, POST' } });
}

export async function POST(request: NextRequest) {
  const bodyResult = await getSafeRequestBody(request);

  if (!bodyResult.isValidJson)
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid JSON body.',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
    });

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const incomingData = bodyResult.jsonBody;
    if (incomingData.dob) {
      incomingData.dob = convertStringDateToISOString(incomingData.dob);
    }

    const updateData = UpdateMeSchema.parse(incomingData);

    const {
      firstName,
      phoneNumber,
      lastName,
      addresses,
      sexAtBirth,
      dob,
      skinType,
      skinProfile,
    } = updateData; // fields a user is allowed to update

    const dsResult = await DosespotClient.pushUserDataToDoseSpot(
      { ...updateData, medicalProfile: { dob, sexAtBirth } },
      userInfo.user
    );

    if (!dsResult.success && !dsResult.error.shouldContinue)
      return ApiErrorHandler.handleServerError({
        message: 'There was an issue updating the user data',
        reqUrl: request.url,
        reqBody: bodyResult.txtBody,
        error: dsResult.error.errorDetail,
      });

    const updatedUser = await prisma.user.update({
      where: { id: userInfo.user.id },
      data: {
        firstName,
        lastName,
        phoneNumber,
        addresses,
        dosespotId:
          userInfo.user.dosespotId ??
          (dsResult.success ? dsResult.patientDoseSpotId : undefined),
        medicalProfile: {
          upsert: {
            update: {
              dob,
              sexAtBirth,
              skinType,
              skinProfile,
            },
            create: {
              dob,
              sexAtBirth,
              skinType,
              skinProfile,
            },
          },
        },
      },
    });

    if ((await registerUserWithPaymentVendor()) === null) {
      return NextResponse.json({
        status: HttpStatusCode.FAILED_DEPENDENCY,
        message:
          'There was a problem registering the user with the payment processor.',
      });
    }

    await addProductToCart(
      userInfo.user,
      process.env.PRODUCT_ID_ONE_TIME_MEDICAL_CONSULTATION + '',
      true,
      1
    );

    const extendedUser = await getUserAttributes(userInfo.user);

    if (!extendedUser.hasConcierge) {
      await addSubscriptionProductToCart(
        userInfo.user,
        process.env.PRODUCT_ID_CONCIERGE_SUBSCRIPTION_MONTHLY + '',
        true,
        1
      );
    }

    await UserEventsClient.addEvent(
      userInfo.user,
      UserEventNames.DERMI_CONSULTATION_SUBMITTED,
      {}
    );
    await UserEventsClient.addEvent(
      userInfo.user,
      UserEventNames.DERMI_CASE_STARTED,
      {}
    );

    return NextResponse.json(updatedUser, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem updating the user',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
      error: error,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/submit/cancel-concierge/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserEventNames } from '@/utils/user-events/enums';
import UserEventsClient from '@/utils/user-events/user-events-client';
import { ProductCategories, UserRole } from '@prisma/client';

export async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, POST' } });
}

// TODO: Save feedback somewhere

// interface UserFeedback {
//   userId: string;
//   feedback: string;
// }

export async function POST(request: NextRequest) {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PATIENT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    // const feedbackObj: UserFeedback = await request.json();

    const userId = userInfo.user.id;

    // Get all active subscriptions
    //TODO: get rid of the nested where clause
    const subscriptions = await prisma.userSubscription.findMany({
      where: {
        userId: userId,
        ended: false, // Assuming you want to update only active subscriptions
        subscriptionProduct: {
          category: ProductCategories.CONCIERGE,
        },
      },
      select: {
        id: true, // Required to update each subscription
        nextRenewalDate: true, // The value to set as endDate
      },
    });

    // Update each subscription
    const updatePromises = subscriptions.map((subscription) => {
      if (subscription.nextRenewalDate) {
        return prisma.userSubscription.update({
          where: {
            id: subscription.id,
          },
          data: {
            endDate: subscription.nextRenewalDate,
          },
        });
      }
    });

    await Promise.all(updatePromises);

    await UserEventsClient.addEventByUserId(
      userId,
      UserEventNames.DERMI_CONCIERGE_CANCELLED,
      {}
    );

    return NextResponse.json({}, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message:
        'Error canceling concierge subscription. Please try again or contact customer support.',
      reqUrl: request.url,
      error: error,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/submit/tret-family/route.ts

import { revalidateTag } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';

import { COOKIE_KEYS } from '@/utils/enums';
import { postFamilyCaseToCase } from '@/utils/helpers/helpers';
import {
  upsertGuardianUserData,
  upsertMemberData,
} from '@/utils/submit/submitFormUtils';
import { deepLog } from '@/utils/utils';
import { ApiErrorHandler } from '@utils/errors';
import { getSafeRequestBody } from '@utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

export async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, POST' } });
}

export async function POST(request: NextRequest) {
  const bodyResult = await getSafeRequestBody(request);

  if (!bodyResult.isValidJson)
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid JSON body.',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
    });

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const data = bodyResult.jsonBody;
    // deepLog('data', data);

    const user = await upsertGuardianUserData(userInfo.user, data);
    if (!user) {
      return ApiErrorHandler.handleServerError({
        message: 'There was an issue upserting the user data',
        reqUrl: request.url,
        reqBody: bodyResult.txtBody,
      });
    }

    const member = await upsertMemberData(data.existingMember, data);
    if (!member) {
      return ApiErrorHandler.handleServerError({
        message: 'There was an issue upserting the member data',
        reqUrl: request.url,
        reqBody: bodyResult.txtBody,
      });
    }

    const memberId = member.id;
    const caseSubmissionResponse = await postFamilyCaseToCase(
      memberId,
      bodyResult.txtBody
    );

    if (caseSubmissionResponse && caseSubmissionResponse?.id) {
      revalidateTag('user');
      const response = NextResponse.json(caseSubmissionResponse, {
        status: HttpStatusCode.OK,
      });
      response.cookies.set(COOKIE_KEYS.FAMILY_MEMBER, memberId, {
        path: '/',
      });
      return response;
    } else {
      return ApiErrorHandler.handleBadRequest({
        message: 'There was a problem posting the case. Please try again.',
        reqUrl: request.url,
        reqBody: bodyResult.txtBody,
      });
    }
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem submitting the tret-family form.',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
      error: error,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/submit/family-consultation-form/route.ts

import { revalidateTag } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';

import {
  upsertMemberData,
  upsertGuardianUserData,
} from '@/utils/submit/submitFormUtils';
import { ApiErrorHandler } from '@utils/errors';
import { getSafeRequestBody } from '@utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

export async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, POST' } });
}

export async function POST(request: NextRequest) {
  const bodyResult = await getSafeRequestBody(request);

  if (!bodyResult.isValidJson)
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid JSON body.',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
    });

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const data = bodyResult.jsonBody;

    const user = await upsertGuardianUserData(userInfo.user, data);
    if (!user) {
      return ApiErrorHandler.handleServerError({
        message: 'There was an issue upserting the user data',
        reqUrl: request.url,
        reqBody: bodyResult.txtBody,
      });
    }

    const member = await upsertMemberData(data.existingMember, data);
    if (!member) {
      return ApiErrorHandler.handleServerError({
        message: 'There was an issue upserting the member data',
        reqUrl: request.url,
        reqBody: bodyResult.txtBody,
      });
    }

    revalidateTag('user');

    return NextResponse.json({ mid: member.id }, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem updating the user',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
      error: error,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/submit/case-form/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { FormUserDataCreateInputSchema } from 'prisma/generated/zod';
import { z } from 'zod';

import { casePrismaClient } from '@/app/shared/models/extensions/cases';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import {
  CaseStatus,
  MessageStatus,
  ThreadAction,
  ThreadStatus,
  ThreadType,
  UserRole,
} from '@prisma/client';

const caseFormSchema = z.object({
  complaint: z.string(),
  complaintMessage: z.string(),
  intakeForm: FormUserDataCreateInputSchema,
});

type CaseFormSubmission = z.infer<typeof caseFormSchema>;

const POST = async (request: NextRequest) => {
  const userInfo = await getUserAndCheckAuthorized({
    request: request,
    roleAccess: [UserRole.PATIENT],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  const { user } = userInfo;

  const formData = await getSafeTypedBody<CaseFormSubmission>(
    request,
    caseFormSchema
  );

  if (!formData.success) return formData.errorResponse;
  try {
    const { value: caseSubmissionData } = formData;

    const newCaseWithThread = await casePrismaClient.case.create({
      data: {
        user: {
          connect: {
            id: user.id,
          },
        },
        status: CaseStatus.OPEN,
        intakeForm: caseSubmissionData.intakeForm,
        thread: {
          create: {
            user: { connect: { id: user.id } },
            type: ThreadType.MEDICAL,
            messages: {
              create: {
                fromUserId: user.id,
                status: MessageStatus.SENT,
                content: caseSubmissionData.complaintMessage,
                sentWhen: new Date(Date.now()),
                readByIds: { set: [user.id] },
              },
            },
            lastMessageDate: new Date(Date.now()),
            status: ThreadStatus.ACTIVE,
            history: {
              create: {
                triggeredById: user.id,
                statusTo: ThreadStatus.ACTIVE,
                action: ThreadAction.CREATED,
              },
            },
          },
        },
      },
    });

    if (!newCaseWithThread) {
      return ApiErrorHandler.handleCatchAllError({
        error: 'There was an error creating the case',
        reqUrl: request.url,
        reqHeaders: request.headers,
        code: HttpStatusCode.INTERNAL_SERVER_ERROR,
      });
    }

    return NextResponse.json(newCaseWithThread, {
      status: HttpStatusCode.CREATED,
    });
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/submit/tret-self/route.ts

import { revalidateTag } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';

import { upsertUserData } from '@/utils/submit/submitFormUtils';
import { ApiErrorHandler } from '@utils/errors';
import { postCase } from '@utils/helpers/helpers';
import { getSafeRequestBody } from '@utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

export async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, POST' } });
}

export async function POST(request: NextRequest) {
  const bodyResult = await getSafeRequestBody(request);

  if (!bodyResult.isValidJson)
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid JSON body.',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
    });

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const data = bodyResult.jsonBody;

    const user = await upsertUserData(userInfo.user, data);
    if (!user) {
      return ApiErrorHandler.handleServerError({
        message: 'There was an issue upserting the user data',
        reqUrl: request.url,
        reqBody: bodyResult.txtBody,
      });
    }

    const caseSubmissionResponse = await postCase(bodyResult.txtBody);

    revalidateTag('user');
    return NextResponse.json(caseSubmissionResponse, {
      status: HttpStatusCode.OK,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem submitting the tret-self form.',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
      error: error,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/submit/update-payment-status/route.ts

import { revalidateTag } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';

import LoggerUtil from '@/utils/clients/logging/apiUtilLogger';
import { logger } from '@/utils/clients/logging/winstonClient';
import { getBaseUrl } from '@/utils/getBaseUrl';
import { redeemConsultation } from '@/utils/helpers/helpers';
import { UserEventNames } from '@/utils/user-events/enums';
import UserEventsClient from '@/utils/user-events/user-events-client';
import { prisma } from '@clients/mongo/prismaClient';
import { CaseStatus } from '@prisma/client';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';

export async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, GET' } });
}

export async function GET(request: NextRequest) {
  const userInfo = await getUserAndCheckAuthorized({ request: request });
  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  const baseUrl = getBaseUrl();
  const searchParams = request.nextUrl.searchParams;
  const caseId = searchParams.get('caseId');

  if (!caseId) {
    return NextResponse.redirect(`${baseUrl}/account/cases`);
  }

  try {
    // First, retrieve the case to check its status
    const caseData = await prisma.case.findUnique({
      where: {
        id: caseId,
      },
    });

    if (!caseData || caseData.status !== CaseStatus.PREPAYMENT) {
      logger.info('Case not eligible for update.', {
        user: userInfo.user,
        caseId: caseId,
      });
      return NextResponse.redirect(
        `${baseUrl}/account/cases?caseId=${caseId}&status-update=ineligible`
      );
    }

    const availableConsultationId = await redeemConsultation(userInfo.user);
    if (availableConsultationId) {
      const updatedCase = await prisma.case.update({
        where: {
          id: caseId,
        },
        data: {
          status: CaseStatus.OPEN,
          redeemedProductId: availableConsultationId,
        },
      });

      revalidateTag('cases');

      await UserEventsClient.addEvent(
        userInfo.user,
        UserEventNames.DERMI_CASE_SUBMITTED,
        {}
      );
    }

    return NextResponse.redirect(
      `${baseUrl}/account/cases?caseId=${caseId}&status-update=success`
    );
  } catch (error) {
    await LoggerUtil.logError(
      'consultation_redemption_failure',
      'get api/submit/update-payment-status',
      error,
      { user: userInfo.user.id, caseId }
    );
    return NextResponse.redirect(`${baseUrl}/account/cases`);
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/submit/submit-family-intake/route.ts

import { revalidateTag } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';

import { COOKIE_KEYS } from '@/utils/enums';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { submitFamilyIntake } from '@/utils/submission-helpers/submit-family-intake';
import {
  SubmitFamilyIntakeType,
  submitFamilyIntakeSchema,
} from '@/utils/submission-helpers/zod-schemas';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

export async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, POST' } });
}

export async function POST(request: NextRequest) {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    // Type check the incoming body
    const typeCheckResult = await getSafeTypedBody(
      request,
      submitFamilyIntakeSchema
    );

    if (!typeCheckResult.success) return typeCheckResult.errorResponse;

    // Update the guardian, upsert the family member, and create a new case
    const submissionResult = await submitFamilyIntake(
      userInfo.user,
      typeCheckResult.value as SubmitFamilyIntakeType
    );

    // Switch context to the family member
    const response = NextResponse.json(submissionResult, {
      status: HttpStatusCode.OK,
    });

    revalidateTag('user');

    response.cookies.set(
      COOKIE_KEYS.FAMILY_MEMBER,
      submissionResult.member.id,
      {
        path: '/',
      }
    );

    return response;
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem submitting the intake',
      reqUrl: request.url,
      error: error,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/submit/family-case/route.ts

import { revalidateTag } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';

import { COOKIE_KEYS } from '@/utils/enums';
import { ApiErrorHandler } from '@utils/errors';
import {
  postFamilyCaseToCase,
  reassignConciergeFromParentToMember,
} from '@utils/helpers/helpers';
import { getSafeRequestBody } from '@utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

export async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, POST' } });
}

export async function POST(request: NextRequest) {
  const bodyResult = await getSafeRequestBody(request);

  if (!bodyResult.isValidJson)
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid JSON body.',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
    });

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const formData = bodyResult.jsonBody;

    if (!formData || !formData.memberId) {
      return ApiErrorHandler.handleBadRequest({
        message:
          'Invalid JSON body in family case submission: Invalid MemberID.',
        reqUrl: request.url,
        reqBody: bodyResult.txtBody,
      });
    }

    const memberId = formData.memberId;
    const caseSubmissionResponse = await postFamilyCaseToCase(
      memberId,
      bodyResult.txtBody
    );

    if (caseSubmissionResponse && caseSubmissionResponse?.id) {
      const benefitReassign = await reassignConciergeFromParentToMember(
        userInfo.user.id,
        memberId
      );

      revalidateTag('user');
      const response = NextResponse.json(caseSubmissionResponse, {
        status: HttpStatusCode.OK,
      });
      response.cookies.set(
        COOKIE_KEYS.FAMILY_MEMBER,
        formData.memberId.toString(),
        {
          path: '/',
        }
      );
      return response;
    } else {
      return ApiErrorHandler.handleBadRequest({
        message: 'There was a problem posting the case. Please try again.',
        reqUrl: request.url,
        reqBody: bodyResult.txtBody,
      });
    }
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem posting the case',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
      error: error,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/auth/[...nextauth]/route.ts

import NextAuth from 'next-auth';

import { authOptions } from '@auth/auth';

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/health/api/route.ts

import { NextResponse } from 'next/server';

import HttpStatusCode from '@/utils/statusCodes';

// check if the api is up
const GET = () => {
  return NextResponse.json({}, { status: HttpStatusCode.OK });
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/health/mongo/route.ts

import { MongoClient } from 'mongodb';
import { NextResponse } from 'next/server';

import LoggerUtil from '@/utils/clients/logging/apiUtilLogger';
import { logger } from '@/utils/clients/logging/winstonClient';
import HttpStatusCode from '@/utils/statusCodes';

export const dynamic = 'force-dynamic';

// checks apis ability to connect to mongo
const GET = async () => {
  const mongoSuccess = await checkMongoConnection();

  if (mongoSuccess) return NextResponse.json({}, { status: HttpStatusCode.OK });

  return NextResponse.json(
    'Unable to connect to mongo. Check datadog for details.',
    {
      status: HttpStatusCode.INTERNAL_SERVER_ERROR,
    }
  );
};

const connectionString = process.env.DATABASE_URL;

const checkMongoConnection = async (): Promise<boolean> => {
  if (!connectionString) {
    const error: Error = {
      message: 'Missing connection string environment variable.',
      name: 'mongo_missing_connectionstring',
    };
    logger.log('error', 'mongo_missing_connectionstring', {
      metadata: { error },
    });
    return false;
  }

  const client = new MongoClient(connectionString);

  try {
    // Connect to the MongoDB server
    await client.connect();

    // Ping the server to check the connection
    await client.db().command({ ping: 1 });

    return true;
  } catch (error) {
    await LoggerUtil.logError(
      'mongo_connection_failure',
      'checkMongoConnection',
      error,
      {}
    );
    return false;
  } finally {
    // Close the connection
    await client.close();
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/internal/google-analytics-report/route.ts

import moment from 'moment';
import { NextRequest, NextResponse } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getFullGAReport } from '@/utils/reporting/user-trends';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';

const GET = async (request: NextRequest) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  const startTime = request.nextUrl.searchParams.get('startTime');
  const endTime = request.nextUrl.searchParams.get('endTime');

  if (startTime && !endTime) {
    return ApiErrorHandler.handleBadRequest({
      message: 'Both start and end time must be provided',
      reqUrl: request.url,
    });
  }

  const start = moment(startTime).toDate();
  const end = moment(endTime).toDate();

  if (end && start && end < start) {
    return ApiErrorHandler.handleBadRequest({
      message: 'End date cannot be before start date',
      reqUrl: request.url,
    });
  }

  try {
    const gaReport = await getFullGAReport(start, end);

    return NextResponse.json(gaReport, { status: 200 });
  } catch (error) {
    const typedError = error as Error;

    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      error: typedError,
      additionalContext: {
        startTime,
        endTime,
      },
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/internal/products/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prismaEcomClient } from '@/app/shared/models/extensions/ecommerce';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';
import { usePrismicClient } from '@prismicio/react';

const GET = async (request: NextRequest) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  const products = (await prismaEcomClient.product.findMany()) ?? [];
  const subscriptionProducts =
    (await prismaEcomClient.subscriptionProduct.findMany()) ?? [];

  return NextResponse.json({ products, subscriptionProducts }, { status: 200 });
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/internal/user-trends/route.ts

import moment from 'moment';
import { NextRequest, NextResponse } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getDemographicReport } from '@/utils/reporting/user-trends';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';

const GET = async (request: NextRequest) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  const startTime = request.nextUrl.searchParams.get('startTime');
  const endTime = request.nextUrl.searchParams.get('endTime');

  if (!startTime || !endTime) {
    return ApiErrorHandler.handleBadRequest({
      message: 'Start and End dates must be provided',
      reqUrl: request.url,
    });
  }

  try {
    const start = moment(startTime).toDate();
    const end = moment(endTime).toDate();

    if (end && start && end < start) {
      return ApiErrorHandler.handleBadRequest({
        message: 'End date cannot be before start date',
        reqUrl: request.url,
      });
    }

    const demographics = await getDemographicReport(start, end);

    return NextResponse.json(demographics, { status: 200 });
  } catch (error) {
    const typedError = error as Error;

    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      error: typedError,
      additionalContext: {
        startTime,
        endTime,
      },
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/internal/promo-codes/route.ts

import moment from 'moment';
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { prismaEcomClient } from '@/app/shared/models/extensions/ecommerce';
import { ApiErrorHandler } from '@/utils/errors';
import { iso8601Regex } from '@/utils/helpers/helpers';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import {
  PromoCodeUsage,
  SubscriptionFrequencyUnits,
  UserRole,
} from '@prisma/client';

const GET = async (request: NextRequest) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  try {
    const promoCodes = await prismaEcomClient.promoCodes.findMany({});

    if (!promoCodes)
      return ApiErrorHandler.handleServerError({
        message: 'No promo codes were returned.',
        reqUrl: request.url,
      });

    const promoCodesWithActiveStatus = promoCodes.map((promoCode) => {
      return {
        ...promoCode,
        isWithinActiveDateRange: promoCode.isActiveWithinDateRange(),
      };
    });

    return NextResponse.json(promoCodesWithActiveStatus, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to retrieve the promo codes.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

const CreatePromoCodeSchema = z
  .object({
    code: z.string(),
    description: z.string(),
    campaign: z.string(),
    discount: z.number(),
    discountType: z.enum(['PERCENT', 'AMOUNT']),
    startDate: z
      .string()
      .regex(iso8601Regex, {
        message: 'Invalid ISO 8601 date string for startDate',
      })
      .optional(),
    endDate: z
      .string()
      .regex(iso8601Regex, {
        message: 'Invalid ISO 8601 date string for startDate',
      })
      .optional(),
    includeAllProducts: z.boolean().optional(),
    productIds: z.array(z.string()).optional(),
    subscriptionProductIds: z.array(z.string()).optional(),
    maxUses: z.number().optional(),
    maxUsesPer: z.nativeEnum(PromoCodeUsage).optional(),
    disableSubscriptionAutoRenew: z.boolean().default(false),
    promoDisclaimer: z.string().optional(),
    subscriptionTrialTime: z
      .number()
      .int('subscriptionTrialTime must be an interger')
      .gte(0, 'subscriptionTrialTime must be greater than or equal to 0')
      .optional(),
    subscriptionTrialTimeUnit: z
      .nativeEnum(SubscriptionFrequencyUnits)
      .optional(),
  })
  .refine((promo) => {
    // make sure the percent is between 1 and 100
    if (promo.discountType === 'PERCENT') {
      return (
        Number.isInteger(promo.discount) &&
        promo.discount >= 0 &&
        promo.discount <= 100
      );
    }
    return true;
  }, 'Percent discounts must have a whole number between 1 and 100')
  .refine((promo) => {
    // make sure the amount is positive
    if (promo.discountType === 'AMOUNT') {
      return Number.isInteger(promo.discount) && promo.discount >= 0;
    }
    return true;
  }, 'Amount discounts must be positive numbers')
  .refine((promo) => {
    return promo.endDate && promo.startDate
      ? moment(promo.endDate).toDate() > moment(promo.startDate).toDate()
      : true;
  }, 'Start date must be before end date.')
  .refine((promo) => {
    return promo.endDate
      ? moment(promo.endDate).toDate() > moment().toDate()
      : true;
  }, 'End date must be in the future.');

const POST = async (request: NextRequest) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  const safeBody = await getSafeTypedBody(request, CreatePromoCodeSchema);

  if (!safeBody.success) return safeBody.errorResponse;

  try {
    const { value: promoData } = safeBody;

    const amountOff =
      promoData.discountType === 'AMOUNT' ? promoData.discount * 100 : 0; // amount off to stripe price

    const percentOff =
      promoData.discountType === 'PERCENT' ? promoData.discount / 100 : 0; // percent off to decimal

    const promoCode = await prismaEcomClient.promoCodes.create({
      data: {
        code: promoData.code,
        description: promoData.description,
        campaign: promoData.campaign,
        amountOff,
        percentOff,
        startDateTime: promoData.startDate,
        endDateTime: promoData.endDate,
        worksForAllProducts: promoData.includeAllProducts,
        associatedProductIds: promoData.productIds,
        associatedSubscriptionIds: promoData.subscriptionProductIds,
        numberUses: promoData.maxUses,
        numberUsesPer: promoData.maxUsesPer,
        promoDisclaimer: promoData.promoDisclaimer,
        disableSubscriptionAutoRenew: promoData.disableSubscriptionAutoRenew,
        subscriptionTrialTime: promoData.subscriptionTrialTime,
        subscriptionTrialTimeUnit: promoData.subscriptionTrialTimeUnit,
      },
    });

    return NextResponse.json(promoCode, { status: 201 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Error creating promo code.',
      reqUrl: request.url,
      reqBody: JSON.stringify(safeBody.value),
      error,
    });
  }
};

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/internal/promo-codes/[promoCode]/route.ts

import moment from 'moment';
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { prismaEcomClient } from '@/app/shared/models/extensions/ecommerce';
import { ApiErrorHandler } from '@/utils/errors';
import { iso8601Regex } from '@/utils/helpers/helpers';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import {
  PromoCodeUsage,
  SubscriptionFrequencyUnits,
  UserRole,
} from '@prisma/client';

const UpdatePromoCodeSchema = z
  .object({
    code: z.string().optional(),
    description: z.string().optional(),
    campaign: z.string().optional(),
    discount: z.number().optional(),
    discountType: z.enum(['PERCENT', 'AMOUNT']).optional(),
    startDate: z
      .string()
      .regex(iso8601Regex, {
        message: 'Invalid ISO 8601 date string for startDate',
      })
      .optional(),
    endDate: z
      .string()
      .regex(iso8601Regex, {
        message: 'Invalid ISO 8601 date string for startDate',
      })
      .optional(),
    includeAllProducts: z.boolean().optional(),
    productIds: z.array(z.string()).optional(),
    subscriptionProductIds: z.array(z.string()).optional(),
    maxUses: z.number().optional(),
    maxUsesPer: z.nativeEnum(PromoCodeUsage).optional(),
    disableSubscriptionAutoRenew: z.boolean().optional(),
    promoDisclaimer: z.string().optional(),
    subscriptionTrialTime: z
      .number()
      .int('subscriptionTrialTime must be an interger')
      .gte(0, 'subscriptionTrialTime must be greater than or equal to 0')
      .optional(),
    subscriptionTrialTimeUnit: z
      .nativeEnum(SubscriptionFrequencyUnits)
      .optional(),
  })
  .refine((promo) => {
    return !promo.discount || (promo.discount && promo.discountType);
  }, 'You must provide a discountType when updating the discounts value')
  .refine((promo) => {
    // make sure the percent is between 1 and 100
    if (
      promo.discount &&
      promo.discountType &&
      promo.discountType === 'PERCENT'
    ) {
      return (
        promo.discount &&
        Number.isInteger(promo.discount) &&
        promo.discount >= 1 &&
        promo.discount <= 100
      );
    } else {
      return true;
    }
  }, 'Percent discounts must have a whole number between 1 and 100')
  .refine((promo) => {
    return promo.endDate && promo.startDate
      ? moment(promo.endDate).toDate() > moment(promo.startDate).toDate()
      : true;
  }, 'Start date must be before end date.')
  .refine((promo) => {
    return promo.endDate
      ? moment(promo.endDate).toDate() > moment().toDate()
      : true;
  }, 'End date must be in the future.');

const PATCH = async (
  request: NextRequest,
  { params }: { params: { promoCode: string } }
) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  const safeBody = await getSafeTypedBody(request, UpdatePromoCodeSchema);

  if (!safeBody.success) return safeBody.errorResponse;

  try {
    const { value: promoData } = safeBody;

    const foundPromoCode = await prismaEcomClient.promoCodes.findUnique({
      where: {
        code: params.promoCode,
      },
    });

    if (!foundPromoCode)
      return ApiErrorHandler.handle404Error({
        message: 'Promo code not found',
        reqUrl: request.url,
      });

    const amountOff =
      promoData.discount &&
      promoData.discountType &&
      promoData.discountType === 'AMOUNT'
        ? promoData.discount * 100
        : 0; // amount off to stripe price

    const percentOff =
      promoData.discount &&
      promoData.discountType &&
      promoData.discountType === 'PERCENT'
        ? promoData.discount / 100
        : 0; // percent off to decimal

    const promoCode = await prismaEcomClient.promoCodes.update({
      where: {
        code: params.promoCode,
      },
      data: {
        code: promoData.code,
        description: promoData.description,
        campaign: promoData.campaign,
        amountOff,
        percentOff,
        startDateTime: promoData.startDate,
        endDateTime: promoData.endDate,
        worksForAllProducts: promoData.includeAllProducts,
        associatedProductIds: promoData.productIds,
        associatedSubscriptionIds: promoData.subscriptionProductIds,
        numberUses: promoData.maxUses,
        numberUsesPer: promoData.maxUsesPer,
        promoDisclaimer: promoData.promoDisclaimer,
        disableSubscriptionAutoRenew: promoData.disableSubscriptionAutoRenew,
        subscriptionTrialTime: promoData.subscriptionTrialTime,
        subscriptionTrialTimeUnit: promoData.subscriptionTrialTimeUnit,
      },
    });

    return NextResponse.json(promoCode, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Error updating promo code.',
      reqUrl: request.url,
      reqBody: JSON.stringify(safeBody.value),
      error,
    });
  }
};

const GET = async (
  request: NextRequest,
  { params }: { params: { promoCode: string } }
) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  try {
    const foundPromoCode = await prismaEcomClient.promoCodes.findUnique({
      where: {
        code: params.promoCode,
      },
    });

    if (!foundPromoCode)
      return ApiErrorHandler.handle404Error({
        message: 'Promo code not found',
        reqUrl: request.url,
      });

    return NextResponse.json(foundPromoCode, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to retrieve the promo code.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { promoCode: string } }
) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  try {
    const deletedPromoCode = await prismaEcomClient.promoCodes.delete({
      where: {
        code: params.promoCode,
      },
    });

    if (!deletedPromoCode)
      return ApiErrorHandler.handle404Error({
        message: 'Promo code not found',
        reqUrl: request.url,
      });

    return NextResponse.json(deletedPromoCode, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to delete the promo code.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { DELETE, GET, PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/internal/promo-codes/batch/route.ts

import moment from 'moment';
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { prismaEcomClient } from '@/app/shared/models/extensions/ecommerce';
import { ApiErrorHandler } from '@/utils/errors';
import { iso8601Regex } from '@/utils/helpers/helpers';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import {
  Prisma,
  PromoCodeUsage,
  SubscriptionFrequencyUnits,
  UserRole,
} from '@prisma/client';

const BatchCreatePromoCodeSchema = z
  .object({
    codes: z.array(z.string()),
    description: z.string(),
    campaign: z.string(),
    discount: z.number(),
    discountType: z.enum(['PERCENT', 'AMOUNT']),
    startDate: z
      .string()
      .regex(iso8601Regex, {
        message: 'Invalid ISO 8601 date string for startDate',
      })
      .optional(),
    endDate: z
      .string()
      .regex(iso8601Regex, {
        message: 'Invalid ISO 8601 date string for startDate',
      })
      .optional(),
    includeAllProducts: z.boolean().optional(),
    productIds: z.array(z.string()).optional(),
    subscriptionProductIds: z.array(z.string()).optional(),
    maxUses: z.number().optional(),
    maxUsesPer: z.nativeEnum(PromoCodeUsage).optional(),
    disableSubscriptionAutoRenew: z.boolean().default(false),
    promoDisclaimer: z.string().optional(),
    subscriptionTrialTime: z
      .number()
      .int('subscriptionTrialTime must be an interger')
      .gte(0, 'subscriptionTrialTime must be greater than or equal to 0')
      .optional(),
    subscriptionTrialTimeUnit: z
      .nativeEnum(SubscriptionFrequencyUnits)
      .optional(),
  })
  .refine((promo) => {
    // make sure the percent is between 1 and 100
    if (promo.discountType === 'PERCENT') {
      return (
        Number.isInteger(promo.discount) &&
        promo.discount >= 0 &&
        promo.discount <= 100
      );
    }
  }, 'Percent discounts must have a whole number between 1 and 100')
  .refine((promo) => {
    return promo.endDate && promo.startDate
      ? moment(promo.endDate).toDate() > moment(promo.startDate).toDate()
      : true;
  }, 'Start date must be before end date.')
  .refine((promo) => {
    return promo.endDate
      ? moment(promo.endDate).toDate() > moment().toDate()
      : true;
  }, 'End date must be in the future.');

const POST = async (request: NextRequest) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  const safeBody = await getSafeTypedBody(request, BatchCreatePromoCodeSchema);

  if (!safeBody.success) return safeBody.errorResponse;

  try {
    const { value: promoData } = safeBody;

    const amountOff =
      promoData.discountType === 'AMOUNT'
        ? promoData.discount * 100
        : undefined; // amount off to stripe price

    const percentOff =
      promoData.discountType === 'PERCENT'
        ? promoData.discount / 100
        : undefined; // percent off to decimal

    const promoCodesToCreate: Prisma.PromoCodesCreateInput[] =
      safeBody.value.codes.map((code) => {
        return {
          code,
          description: promoData.description,
          campaign: promoData.campaign,
          amountOff,
          percentOff,
          startDateTime: promoData.startDate,
          endDateTime: promoData.endDate,
          worksForAllProducts: promoData.includeAllProducts,
          associatedProductIds: promoData.productIds,
          associatedSubscriptionIds: promoData.subscriptionProductIds,
          numberUses: promoData.maxUses,
          numberUsesPer: promoData.maxUsesPer,
          promoDisclaimer: promoData.promoDisclaimer,
          disableSubscriptionAutoRenew: promoData.disableSubscriptionAutoRenew,
          subscriptionTrialTime: promoData.subscriptionTrialTime,
          subscriptionTrialTimeUnit: promoData.subscriptionTrialTimeUnit,
        };
      });

    const promoCode = await prismaEcomClient.promoCodes.createMany({
      data: promoCodesToCreate,
    });

    return NextResponse.json(promoCode, { status: 201 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Error creating promo code.',
      reqUrl: request.url,
      reqBody: JSON.stringify(safeBody.value),
      error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/internal/promo-codes/batch/[campaign]/route.ts

import moment from 'moment';
import { NextRequest, NextResponse } from 'next/server';
import { randexp } from 'randexp';
import { z } from 'zod';

import { prismaEcomClient } from '@/app/shared/models/extensions/ecommerce';
import { ApiErrorHandler } from '@/utils/errors';
import { iso8601Regex } from '@/utils/helpers/helpers';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import {
  PromoCodeUsage,
  SubscriptionFrequencyUnits,
  UserRole,
} from '@prisma/client';

const UpdatePromoCodeSchema = z
  .object({
    codePattern: z
      .string()
      .optional()
      .refine((pattern) => {
        if (!pattern) return true;

        return (
          pattern.startsWith('/') && pattern.endsWith('/'),
          'Ensure your regex pattern is surrounded in /'
        );
      })
      .refine((pattern) => {
        if (!pattern) return true;
        try {
          const innerRegex = pattern.slice(1, -1);
          new RegExp(innerRegex);
          return true;
        } catch (error) {
          return false;
        }
      }, 'The pattern provided is not valid regex'),
    description: z.string().optional(),
    campaign: z.string().optional(),
    discount: z.number().optional(),
    discountType: z.enum(['PERCENT', 'AMOUNT']).optional(),
    startDate: z
      .string()
      .regex(iso8601Regex, {
        message: 'Invalid ISO 8601 date string for startDate',
      })
      .optional(),
    endDate: z
      .string()
      .regex(iso8601Regex, {
        message: 'Invalid ISO 8601 date string for startDate',
      })
      .optional(),
    includeAllProducts: z.boolean().optional(),
    productIds: z.array(z.string()).optional(),
    subscriptionProductIds: z.array(z.string()).optional(),
    maxUses: z.number().optional(),
    maxUsesPer: z.nativeEnum(PromoCodeUsage).optional(),
    disableSubscriptionAutoRenew: z.boolean().optional(),
    promoDisclaimer: z.string().optional(),
    subscriptionTrialTime: z
      .number()
      .int('subscriptionTrialTime must be an interger')
      .gte(0, 'subscriptionTrialTime must be greater than or equal to 0')
      .optional(),
    subscriptionTrialTimeUnit: z
      .nativeEnum(SubscriptionFrequencyUnits)
      .optional(),
  })
  .refine((promo) => {
    return !promo.discount || (promo.discount && promo.discountType);
  }, 'You must provide a discountType when updating the discounts value')
  .refine((promo) => {
    // make sure the percent is between 1 and 100
    if (
      promo.discount &&
      promo.discountType &&
      promo.discountType === 'PERCENT'
    ) {
      return (
        promo.discount &&
        Number.isInteger(promo.discount) &&
        promo.discount >= 1 &&
        promo.discount <= 100
      );
    } else {
      return true;
    }
  }, 'Percent discounts must have a whole number between 1 and 100')
  .refine((promo) => {
    return promo.endDate && promo.startDate
      ? moment(promo.endDate).toDate() > moment(promo.startDate).toDate()
      : true;
  }, 'Start date must be before end date.')
  .refine((promo) => {
    return promo.endDate
      ? moment(promo.endDate).toDate() > moment().toDate()
      : true;
  }, 'End date must be in the future.');

const PATCH = async (
  request: NextRequest,
  { params }: { params: { campaign: string } }
) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  const safeBody = await getSafeTypedBody(request, UpdatePromoCodeSchema);

  if (!safeBody.success) return safeBody.errorResponse;

  try {
    const { value: promoData } = safeBody;

    const amountOff =
      promoData.discount &&
      promoData.discountType &&
      promoData.discountType === 'AMOUNT'
        ? promoData.discount * 100
        : 0; // amount off to stripe price

    const percentOff =
      promoData.discount &&
      promoData.discountType &&
      promoData.discountType === 'PERCENT'
        ? promoData.discount / 100
        : 0; // percent off to decimal

    let code: string | undefined = undefined;

    if (promoData.codePattern) {
      const innerRegex = promoData.codePattern.slice(1, -1);

      const codeRegex = new RegExp(innerRegex);

      code = randexp(codeRegex);
    }

    const updatedPromoCodes = await prismaEcomClient.promoCodes.updateMany({
      where: {
        campaign: params.campaign,
      },
      data: {
        code: code,
        description: promoData.description,
        campaign: promoData.campaign,
        amountOff,
        percentOff,
        startDateTime: promoData.startDate,
        endDateTime: promoData.endDate,
        worksForAllProducts: promoData.includeAllProducts,
        associatedProductIds: promoData.productIds,
        associatedSubscriptionIds: promoData.subscriptionProductIds,
        numberUses: promoData.maxUses,
        numberUsesPer: promoData.maxUsesPer,
        promoDisclaimer: promoData.promoDisclaimer,
        disableSubscriptionAutoRenew: promoData.disableSubscriptionAutoRenew,
        subscriptionTrialTime: promoData.subscriptionTrialTime,
        subscriptionTrialTimeUnit: promoData.subscriptionTrialTimeUnit,
      },
    });

    return NextResponse.json(
      { updatedPromoCodes, count: updatedPromoCodes.count },
      { status: 200 }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Error updating promo code.',
      reqUrl: request.url,
      reqBody: JSON.stringify(safeBody.value),
      error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { campaign: string } }
) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  try {
    const deletedPromoCodes = await prismaEcomClient.promoCodes.deleteMany({
      where: {
        campaign: params.campaign,
      },
    });

    if (!deletedPromoCodes)
      return ApiErrorHandler.handle404Error({
        message: 'Promo code not found',
        reqUrl: request.url,
      });

    return NextResponse.json(deletedPromoCodes, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Error deleting promo code.',
      reqUrl: request.url,
      error,
    });
  }
};

export { DELETE, PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/internal/promo-codes/batch/pattern/route.ts

import moment from 'moment';
import { NextRequest, NextResponse } from 'next/server';
import { randexp } from 'randexp';
import { z } from 'zod';

import { prismaEcomClient } from '@/app/shared/models/extensions/ecommerce';
import { ApiErrorHandler } from '@/utils/errors';
import { iso8601Regex } from '@/utils/helpers/helpers';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import {
  Prisma,
  PromoCodeUsage,
  SubscriptionFrequencyUnits,
  UserRole,
} from '@prisma/client';

const BatchGeneratePromoCodeSchema = z
  .object({
    codePattern: z
      .string()
      .refine(
        (pattern) => pattern.startsWith('/') && pattern.endsWith('/'),
        'Ensure your regex pattern is surrounded in /'
      )
      .refine((pattern) => {
        try {
          const innerRegex = pattern.slice(1, -1);
          new RegExp(innerRegex);
          return true;
        } catch (error) {
          return false;
        }
      }, 'The pattern provided is not valid regex'),
    generateQty: z.number().int('generateQty should be an integer value'),
    description: z.string(),
    campaign: z.string(),
    discount: z.number(),
    discountType: z.enum(['PERCENT', 'AMOUNT']),
    startDate: z
      .string()
      .regex(iso8601Regex, {
        message: 'Invalid ISO 8601 date string for startDate',
      })
      .optional(),
    endDate: z
      .string()
      .regex(iso8601Regex, {
        message: 'Invalid ISO 8601 date string for startDate',
      })
      .optional(),
    includeAllProducts: z.boolean().optional(),
    productIds: z.array(z.string()).optional(),
    subscriptionProductIds: z.array(z.string()).optional(),
    maxUses: z.number().optional(),
    maxUsesPer: z.nativeEnum(PromoCodeUsage).optional(),
    disableSubscriptionAutoRenew: z.boolean().default(false),
    promoDisclaimer: z.string().optional(),
    subscriptionTrialTime: z
      .number()
      .int('subscriptionTrialTime must be an interger')
      .gte(0, 'subscriptionTrialTime must be greater than or equal to 0')
      .optional(),
    subscriptionTrialTimeUnit: z
      .nativeEnum(SubscriptionFrequencyUnits)
      .optional(),
  })
  .refine((promo) => {
    // make sure the percent is between 1 and 100
    if (promo.discountType === 'PERCENT') {
      return (
        Number.isInteger(promo.discount) &&
        promo.discount >= 0 &&
        promo.discount <= 100
      );
    }
  }, 'Percent discounts must have a whole number between 1 and 100')
  .refine((promo) => {
    return promo.endDate && promo.startDate
      ? moment(promo.endDate).toDate() > moment(promo.startDate).toDate()
      : true;
  }, 'Start date must be before end date.')
  .refine((promo) => {
    return promo.endDate
      ? moment(promo.endDate).toDate() > moment().toDate()
      : true;
  }, 'End date must be in the future.');

const POST = async (request: NextRequest) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  const safeBody = await getSafeTypedBody(
    request,
    BatchGeneratePromoCodeSchema
  );

  if (!safeBody.success) return safeBody.errorResponse;

  try {
    const { value: promoData } = safeBody;

    const amountOff =
      promoData.discountType === 'AMOUNT'
        ? promoData.discount * 100
        : undefined; // amount off to stripe price

    const percentOff =
      promoData.discountType === 'PERCENT'
        ? promoData.discount / 100
        : undefined; // percent off to decimal

    const promoCodesToCreate: Prisma.PromoCodesCreateInput[] = [];

    const innerRegex = promoData.codePattern.slice(1, -1);

    const codeRegex = new RegExp(innerRegex);

    for (let i = 0; i < safeBody.value.generateQty; i++) {
      promoCodesToCreate.push({
        code: randexp(codeRegex),
        description: promoData.description,
        campaign: promoData.campaign,
        amountOff,
        percentOff,
        startDateTime: promoData.startDate,
        endDateTime: promoData.endDate,
        worksForAllProducts: promoData.includeAllProducts,
        associatedProductIds: promoData.productIds,
        associatedSubscriptionIds: promoData.subscriptionProductIds,
        numberUses: promoData.maxUses,
        numberUsesPer: promoData.maxUsesPer,
        promoDisclaimer: promoData.promoDisclaimer,
        disableSubscriptionAutoRenew: promoData.disableSubscriptionAutoRenew,
        subscriptionTrialTime: promoData.subscriptionTrialTime,
        subscriptionTrialTimeUnit: promoData.subscriptionTrialTimeUnit,
      });
    }

    const promoCodes = await prismaEcomClient.promoCodes.createMany({
      data: promoCodesToCreate,
    });

    return NextResponse.json(
      {
        promoCodesCreated: promoCodesToCreate.map(
          (promoCode) => promoCode.code
        ),
        numCreated: promoCodes,
      },
      { status: 201 }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Error creating promo codes.',
      reqUrl: request.url,
      reqBody: JSON.stringify(safeBody.value),
      error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/internal/consultations/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getConsultationReport } from '@/utils/reporting/consultations-helpers';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';

const GET = async (request: NextRequest) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  const startTime = request.nextUrl.searchParams.get('startTime');
  const endTime = request.nextUrl.searchParams.get('endTime');

  try {
    const reportToSend = await getConsultationReport(startTime, endTime);

    return NextResponse.json({ reportToSend }, { status: 200 });
  } catch (error) {
    const typedError = error as Error;

    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      error: typedError,
      additionalContext: {
        startTime,
        endTime,
      },
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/internal/migrated-user-statistics/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getMigratedUserStatistics } from '@/utils/reporting/user-trends';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';

const GET = async (request: NextRequest) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  try {
    const migratedUserStatistics = await getMigratedUserStatistics();

    return NextResponse.json(migratedUserStatistics, { status: 200 });
  } catch (error) {
    const typedError = error as Error;

    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      error: typedError,
      additionalContext: {},
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/internal/orders/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getOrderSummary } from '@/utils/reporting/orders-helpers';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';

const GET = async (request: NextRequest) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.INTERNAL_STAFF, UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  const startTime = request.nextUrl.searchParams.get('startTime');
  const endTime = request.nextUrl.searchParams.get('endTime');

  try {
    const productResult = await getOrderSummary(startTime, endTime);
    return NextResponse.json({ productResult }, { status: 200 });
  } catch (error) {
    const typedError = error as Error;

    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      error: typedError,
      additionalContext: {
        startTime,
        endTime,
      },
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/cases/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { CaseInclude } from '@/app/shared/types';
import { getCasePhysicianAccess } from '@/utils/get-case-physician-access';
import { prisma } from '@clients/mongo/prismaClient';
import { CaseStatus } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';
import { getUserAttributes } from '@utils/helpers/helpers';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const userAttributes = await getUserAttributes(userInfo.user);

    // Retrieve all cases for the user
    const userCases = await prisma.case.findMany({
      where: {
        userId: userInfo.user.id, // Assuming userInfo.user.id contains the ID of the user
        status: { not: { in: [CaseStatus.DELETED, CaseStatus.ARCHIVED] } },
      },
      include: {
        user: true, // Include user details
        physician: true, // Include physician details
        prescriptions: true, // Include related prescriptions
        // You can include other relations based on your needs
      },
    });

    const casesWithAccessInfo = userCases.map((caseItem) =>
      getCasePhysicianAccess<CaseInclude>(caseItem, userAttributes)
    );

    return NextResponse.json(
      {
        userCases: casesWithAccessInfo,
      },
      { status: 200 }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem retrieving the cases for the user',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/dermi/users/by-phone/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { testUSPhoneNumber } from 'prisma/custom-validators/phoneNumberValidation';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const GET = async (request: NextRequest) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.ADMIN, UserRole.SYSTEM],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  const phoneNumber = '+' + request.nextUrl.searchParams.get('phoneNumber');

  if (!phoneNumber || !testUSPhoneNumber(phoneNumber))
    return ApiErrorHandler.handleBadRequest({
      message: 'Please provide a valid phoneNumber ex. 15551234567',
      reqUrl: request.url,
    });

  try {
    const user = await prisma.user.findFirst({
      where: { phoneNumber },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        addresses: true,
      },
    });

    if (!user)
      return ApiErrorHandler.handle404Error({
        message: 'User not found',
        reqUrl: request.url,
      });

    const caseCount = await prisma.case.count({ where: { userId: user.id } });

    const dermiUser = {
      userId: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      defaultAddress: user.addresses.find((x) => x.default) ?? null,
      numberOfCases: caseCount,
    };

    return NextResponse.json(dermiUser, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred attempting to get the user from the database',
      reqUrl: request.url,
      error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user/route.ts

import { NextRequest } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getUserAttributes } from '@/utils/helpers/helpers';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { prisma } from '@clients/mongo/prismaClient';
import { UserRole } from '@prisma/client';

/**
 * get a user by id
 * todo: secure this route?
 */
const GET = async (request: NextRequest) => {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });
    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (!id) {
      const returnedUser = await prisma.user.findUnique({
        where: {
          id: userInfo.user.id,
        },
      });

      return createCookieResponse(returnedUser, userInfo.cookieJar);
    }

    // Return error if user role is not allowed to access other patients
    if (
      !(
        userInfo.user.roles.includes(UserRole.ADMIN) ||
        userInfo.user.roles.includes(UserRole.PHYSICIAN) ||
        userInfo.user.roles.includes(UserRole.CORTINA_NURSE) ||
        userInfo.user.roles.includes(UserRole.CORTINA_SUPPORT) ||
        userInfo.user.roles.includes(UserRole.PHYSICIAN_SUPPORT)
      )
    ) {
      return ApiErrorHandler.handle404Error({
        message: 'Failed to find user',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const foundUser = await prisma.user.findUnique({
      where: {
        id: id,
      },
    });

    if (!foundUser)
      return ApiErrorHandler.handle404Error({
        message: 'Failed to find user',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });

    const extendedUser = await getUserAttributes(foundUser);

    return createCookieResponse(extendedUser, userInfo.cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Failed to get the user',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user/add-role/route.ts

import { NextRequest } from 'next/server';

import { userPrismaClient } from '@/app/shared/models/extensions/identity';
import { getUserInfo, isUserAuthorized } from '@/utils/auth/auth';
import {
  CookieJar,
  createCookieResponse,
} from '@/utils/responses/responseHelpers';
import { prisma } from '@clients/mongo/prismaClient';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

interface addRoleInput {
  userId?: string;
  role?: UserRole;
}

/**
 * @swagger
 * /api/user/add-role:
 *   post:
 *     tags: [User]
 *     summary: Add a role to a user
 *     description: Admin Only Endpoint that can add a new role to a user
 *     requestBody:
 *        required: true
 *        description: Requires a user ID and role type to be sent. Role types are ADMIN, PATIENT, PHYSICIAN, PHYSICIAN_SUPPORT, CORTINA_NURSE, CORTINA_SUPPORT
 *        content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               userId:
 *                 type: string
 *               role:
 *                 type: string
 *             example:
 *               userId: "123456789abcdefg"
 *               role: "PHYSICIAN"
 *     responses:
 *       200:
 *         description: User successfully created or already was created.
 *         content:
 *           application/json:
 *             example:
 *               message: User Created
 *               status: 200
 *       400:
 *         description: Client did not provide some data needed to complete the request
 *         content:
 *           application/json:
 *             example:
 *               status: 400
 *               message: User ID Must be Provided
 *       500:
 *         description: An error occurred
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: Unexpected Error
 */
const POST = async (request: NextRequest) => {
  try {
    const cookieJar: CookieJar = { cookies: [] };
    const user = await getUserInfo(request, cookieJar);

    const roleAccess: UserRole[] = [UserRole.ADMIN];

    const canUpdateRoles = isUserAuthorized(user, roleAccess);

    if (!canUpdateRoles)
      return ApiErrorHandler.handleUnauthorizedError({
        message: 'User does not have the proper access to add a role to a user',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });

    const updateData: addRoleInput = (await request.json()) as addRoleInput;

    if (!updateData.userId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'User id is required',
        reqUrl: request.url,
      });
    } else if (!updateData.role) {
      return ApiErrorHandler.handleBadRequest({
        message: 'Role to Update must be provided',
        reqUrl: request.url,
      });
    }

    if (
      await userPrismaClient.user.userHasRole(
        updateData.userId,
        updateData.role
      )
    ) {
      return ApiErrorHandler.handleBadRequest({
        message: `User already has ${updateData.role} role`,
        reqUrl: request.url,
      });
    }

    const updatedUser = await prisma.user.update({
      where: {
        id: updateData.userId,
      },
      data: {
        roles: {
          push: updateData.role,
        },
      },
    });

    return createCookieResponse(updatedUser, cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem adding the role',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user/medical-profile/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { UpdateMedicalProfileSchema } from 'prisma/custom-schemas/updateMedicalProfile';
import { FormUserDataCreateInputSchema } from 'prisma/generated/zod';

import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import {
  convertStringDateToISOString,
  transformAllergenPayloadToDSInput,
  transformMedicationPayloadToDSInput,
} from '@/utils/helpers/helpers';
import { prisma } from '@utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@utils/errors';
import { getSafeRequestBody } from '@utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const POST = async (request: NextRequest) => {
  const bodyResult = await getSafeRequestBody(request);

  if (!bodyResult.isValidJson)
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid JSON body.',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
    });

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const incomingData = bodyResult.jsonBody;
    if (incomingData.dob) {
      incomingData.dob = convertStringDateToISOString(incomingData.dob);
    }

    const { sexAtBirth, history, allergies, medications, ...updateFields } =
      incomingData;

    const historyToUpdate = history
      ? FormUserDataCreateInputSchema.parse(history)
      : undefined;

    // Map the allergies and medications to the correct format for Dosespot
    const allergensInput = transformAllergenPayloadToDSInput(allergies);
    const medicationsInput = transformMedicationPayloadToDSInput(medications);

    const dosespotDataToUpdate = UpdateMedicalProfileSchema.parse({
      ...updateFields,
      sexAtBirth,
      medications: medicationsInput,
      allergies: allergensInput,
    });

    const dsResult = await DosespotClient.pushUserDataToDoseSpot(
      {
        medicalProfile: dosespotDataToUpdate,
      },
      userInfo.user
    );

    if (!dsResult.success && !dsResult.error.shouldContinue)
      return ApiErrorHandler.handleServerError({
        message: dsResult.error.errorMessage,
        reqUrl: request.url,
        reqBody: bodyResult.txtBody,
        error: dsResult.error.errorDetail,
      });

    const medicalProfile = dosespotDataToUpdate;

    // Remove the medications and allergies from the medical profile
    delete medicalProfile.medications;
    delete medicalProfile.allergies;

    const updatedUser = await prisma.user.update({
      where: { id: userInfo.user.id },
      data: {
        dosespotId:
          userInfo.user.dosespotId ??
          (dsResult.success ? dsResult.patientDoseSpotId : undefined),
        medicalProfile: {
          upsert: {
            update: {
              ...medicalProfile,
              history: { push: historyToUpdate },
              medicalProfileCompletedDate: new Date(Date.now()),
            },
            create: {
              ...medicalProfile,
              history: historyToUpdate,
              medicalProfileCompletedDate: new Date(Date.now()),
            },
          },
        },
      },
      include: { medicalProfile: true },
    });

    return NextResponse.json(updatedUser, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem updating the medical profile',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
      error: error,
    });
  }
};

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const { medications, allergies } =
      await DosespotClient.getAllergiesAndMedicationsForUser(userInfo.user);

    const { medicalProfile } = userInfo.user;
    if (medicalProfile && medicalProfile.history) {
      delete medicalProfile['history' as keyof typeof medicalProfile];
    }

    const userMedicalProfile = {
      ...medicalProfile,
      allergies,
      medications,
    };

    return NextResponse.json(userMedicalProfile, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while getting the user medical profile.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error,
    });
  }
};

async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, POST, GET' } });
}

export { GET, OPTIONS, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user/create-dependent/route.ts

import { revalidateTag } from 'next/cache';
import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getSafeRequestBody } from '@utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

interface createDependentInput {
  firstName: string;
  lastName: string;
}

const POST = async (request: NextRequest) => {
  const bodyResult = await getSafeRequestBody(request);

  if (!bodyResult.isValidJson)
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid JSON body.',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
    });

  try {
    // Only patients can have a dependent. Not anonymous patients
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PATIENT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const incomingData: createDependentInput =
      bodyResult.jsonBody as createDependentInput;

    const newDependentUser = await prisma.user.create({
      data: {
        guardianId: userInfo.user.id,
        firstName: incomingData.firstName,
        lastName: incomingData.lastName,
        roles: [UserRole.PATIENT],
        email: userInfo.user.email,
        stripeId: userInfo.user.stripeId,
        phoneNumber: userInfo.user.phoneNumber,
      },
    });

    revalidateTag('user');

    return NextResponse.json(newDependentUser, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem creating the dependent user',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user/get-cortina-id/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { userPrismaClient } from '@/app/shared/models/extensions/identity';
import { ApiErrorHandler } from '@/utils/errors';
import HttpStatusCode from '@/utils/statusCodes';

const GET = async (request: NextRequest) => {
  try {
    // todo: more security checks here to ensure the request comes from self-hosted retool intance.
    if (!request.headers.get('user-agent')?.startsWith('Retool'))
      return ApiErrorHandler.handleBadRequest({
        message: 'Invalid request.',
        reqUrl: request.url,
      });

    const retoolSid = request.headers.get('x-retool-sid');

    if (!retoolSid)
      return ApiErrorHandler.handleBadRequest({
        message: 'Missing retool sid header.',
        reqUrl: request.url,
      });

    const user = await userPrismaClient.user.findFirst({
      where: {
        retoolSid: retoolSid,
      },
      select: {
        id: true,
      },
    });

    if (!user)
      throw ApiErrorHandler.handle404Error({
        message: 'User with that sid not found.',
        reqUrl: request.url,
      });

    return NextResponse.json(
      { cortinaId: user.id },
      { status: HttpStatusCode.OK }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occured while getting cortina id for that retool sid.',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user/medical-info/route.ts

import { NextRequest, NextResponse } from 'next/server';

import {
  CookieJar,
  createCookieResponse,
} from '@/utils/responses/responseHelpers';
import { getUserInfo, isUserAuthorized } from '@auth/auth';

const GET = async (request: NextRequest) => {
  try {
    const allergyMedTest = {
      allergies: [
        {
          name: 'Amoxicillin',
          id: 1232,
        },
        {
          name: 'Advil',
          id: 1522,
        },
      ],
      medications: [
        {
          name: 'Penicillin',
          id: 1523,
        },
        {
          name: 'Advair Diskus',
          id: 1622,
        },
      ],
    };

    return NextResponse.json(allergyMedTest);
  } catch (error) {
    console.log(error);
    return NextResponse.json({ error: 'Failed to get user' }, { status: 500 });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user/search/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { getUserInfo, isUserAuthorized } from '@/utils/auth/auth';
import { ApiErrorHandler } from '@/utils/errors';
import { CookieJar } from '@/utils/responses/responseHelpers';
import { prisma } from '@clients/mongo/prismaClient';
import { UserRole } from '@prisma/client';

const buildFilterArray = (searchParams: URLSearchParams) => {
  const filterArray = [];
  const id = searchParams.get('id');
  const firstName = searchParams.get('firstName');
  const lastName = searchParams.get('lastName');
  const email = searchParams.get('email');
  const phone = searchParams.get('phone');

  if (id && id.length > 12) {
    filterArray.push({
      id: id as string,
    });
  }

  if (firstName && firstName.length > 1) {
    filterArray.push({
      firstName: {
        startsWith: firstName as string,
        mode: 'insensitive',
      },
    });
  }

  if (lastName && lastName.length > 1) {
    filterArray.push({
      lastName: {
        startsWith: lastName as string,
        mode: 'insensitive',
      },
    });
  }

  if (email && email.length > 1) {
    filterArray.push({
      email: {
        equals: email as string,
      },
    });
  }

  if (phone && phone.length > 9) {
    filterArray.push({
      phoneNumber: phone as string,
    });
  }

  return filterArray;
};

/**
 * @swagger
 * /api/user/search:
 *   get:
 *     summary: Search users
 *     description: Returns a list of users that most closely match the search parameters.
 *     tags:
 *       - User
 *     parameters:
 *       - in: query
 *         name: id
 *         description: The id of the user. Must be exact match.
 *         required: false
 *         schema:
 *           type: string
 *       - in: query
 *         name: name
 *         description: The user's name. Case insensitive and can be partial start.
 *         required: false
 *         schema:
 *           type: string
 *       - in: query
 *         name: email
 *         description: The user's email address. Case insensitive and can be partial start.
 *         required: false
 *         schema:
 *           type: string
 *       - in: query
 *         name: phone
 *         description: The user's phone number. Must be exact match.
 *         required: false
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: The array of user's matching the search.
 *         content:
 *           application/json:
 *             schema:
 *              items:
 *                $ref: '#/components/schemas/User'
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: Failed to search users.
 */
const GET = async (request: NextRequest) => {
  try {
    const cookieJar: CookieJar = { cookies: [] };
    const { searchParams } = new URL(request.url);

    const user = await getUserInfo(request, cookieJar);

    const roleAccess: UserRole[] = [UserRole.ADMIN, UserRole.CORTINA_SUPPORT];

    const isAuthorized = isUserAuthorized(user, roleAccess);

    if (!isAuthorized) {
      return ApiErrorHandler.handleUnauthorizedError({
        message: 'User does not have the proper access to search users',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const filterArray = buildFilterArray(searchParams);

    const users = await prisma.user.findMany({
      where: {
        OR: filterArray as any,
      },
    });

    return NextResponse.json(users);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Failed to search users',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user/me/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { UpdateMeSchema } from 'prisma/custom-schemas/updateMe';

import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import {
  convertStringDateToISOString,
  getUserAttributes,
} from '@/utils/helpers/helpers';
import { prisma } from '@utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@utils/errors';
import { getSafeRequestBody } from '@utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

/**
 * @swagger
 * /api/user/me:
 *   get:
 *     summary: Gets the current user.
 *     description: Retrieves the current user object.
 *     tags:
 *       - User
 *     responses:
 *       '200':
 *         description: The current user.
 *         content:
 *           application/json:
 *             schema:
 *              items:
 *                $ref: '#/components/schemas/User'
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: Failed to get user.
 */
const GET = async (request: NextRequest) => {
  try {
    const authResult = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!authResult.success)
      return ApiErrorHandler.handle404Error({
        message: 'User not found',
        reqUrl: request.url,
      });

    const { user } = authResult;
    const extendedUser = await getUserAttributes(user);

    return NextResponse.json(extendedUser);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Failed to get user',
      reqUrl: request.url,
      error,
    });
  }
};

/**
 * @swagger
 * /api/user/me:
 *   patch:
 *     summary: Updates the current user.
 *     description: Updates the current user's name and/or avatarUrl.
 *     tags:
 *       - User
 *     requestBody:
 *       description: JSON payload containing details of the draft message to create.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 description: The name of the user.
 *                 required: false
 *                 type: string
 *               avatarUrl:
 *                 description: The s3 object url for the user's avatar.
 *                 required: false
 *                 type: string
 *           example:
 *             name: "Eren Jaeger"
 *             avatarUrl: "https://<bucket>.s3.amazonaws.com/<s3Key>"
 *     responses:
 *       '200':
 *         description: The updated user.
 *         content:
 *           application/json:
 *             schema:
 *              items:
 *                $ref: '#/components/schemas/User'
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while updating the user.
 */
const PATCH = async (request: NextRequest) => {
  const bodyResult = await getSafeRequestBody(request);

  if (!bodyResult.isValidJson)
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid JSON body.',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
    });

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const incomingData = bodyResult.jsonBody;
    if (incomingData.dob) {
      incomingData.dob = convertStringDateToISOString(incomingData.dob);
    }

    const updateData = UpdateMeSchema.parse(incomingData);

    const {
      firstName,
      phoneNumber,
      lastName,
      avatarUrl,
      addresses,
      sexAtBirth,
      dob,
    } = updateData; // fields a user is allowed to update

    const dsResult = await DosespotClient.pushUserDataToDoseSpot(
      updateData,
      userInfo.user
    );

    if (!dsResult.success && !dsResult.error.shouldContinue)
      return ApiErrorHandler.handleServerError({
        message: 'There was an issue updating the user data',
        reqUrl: request.url,
        reqBody: bodyResult.txtBody,
        error: dsResult.error.errorDetail,
      });

    const updatedUser = await prisma.user.update({
      where: { id: userInfo.user.id },
      data: {
        firstName,
        lastName,
        phoneNumber,
        avatarUrl,
        addresses,
        dosespotId:
          userInfo.user.dosespotId ??
          (dsResult.success ? dsResult.patientDoseSpotId : undefined),
        medicalProfile: {
          upsert: {
            update: {
              dob,
              sexAtBirth,
            },
            create: {
              dob,
              sexAtBirth,
            },
          },
        },
      },
    });

    return NextResponse.json(updatedUser, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem updating the user',
      reqUrl: request.url,
      reqBody: bodyResult.txtBody,
      error: error,
    });
  }
};

/**
 * @swagger
 * /api/user/me:
 *   options:
 *     summary: Gets allowed methods for this route.
 *     description: Gets allowed methods for this route.
 *     tags:
 *       - User
 *     responses:
 *       '200':
 *         description: Ok.
 *         headers:
 *           Allow:
 *             schema:
 *               type: string
 *             description: The allowed methods.
 */
async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, PATCH' } });
}

export { GET, PATCH, OPTIONS };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user/avatar/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { getUserInfo } from '@/utils/auth/auth';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { getS3Url, uploadFileToS3 } from '@/utils/file-upload/file-upload';
import {
  CookieJar,
  createCookieResponse,
} from '@/utils/responses/responseHelpers';
import HttpStatusCode from '@/utils/statusCodes';
import { S3Client } from '@aws-sdk/client-s3';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const Bucket =
  process.env.PROFILE_AVATAR_BUCKET ?? 'dev-user-profile-avatar-images';
const s3 = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.PROFILE_AVATAR_AWS_ACCESS_KEY as string,
    secretAccessKey: process.env.PROFILE_AVATAR_SECRET_ACCESS_KEY as string,
  },
});

/**
 * @swagger
 * /api/user/avatar:
 *   get:
 *     summary: Get a signed url from s3 for a given user's avatar image.
 *     description: Generates an s3Url for a user's avatar image to securely display in a user's session.
 *     tags:
 *       - User
 *     parameters:
 *       - in: query
 *         name: id
 *         description: The id of the user.
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       '200':
 *         description: The s3Url for the avatar. Expires in 3600 seconds or 1 hour.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 s3Url: string
 *       '404':
 *         description: User not found
 *         content:
 *           application/json:
 *             example:
 *               status: "404"
 *               message: Failed to find user.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while generating the s3Url.
 */
async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    const cookieJar: CookieJar = { cookies: [] };
    let avatarUrl: string | null;

    if (id) {
      const foundUser = await prisma.user.findUnique({
        where: {
          id: id,
        },
      });

      if (!foundUser) {
        return ApiErrorHandler.handle404Error({
          message: 'Failed to find user',
          reqUrl: request.url,
          reqHeaders: request.headers,
        });
      } else {
        avatarUrl = foundUser.avatarUrl;
      }
    } else {
      const userInfo = await getUserInfo(request, cookieJar);
      avatarUrl = userInfo.avatarUrl;
    }

    if (!avatarUrl) {
      return NextResponse.json(
        { s3Url: null, userId: id },
        { status: HttpStatusCode.OK }
      );
    }

    const response = await getS3Url({
      mediaUrl: avatarUrl,
      expiresIn: 3600,
      s3Client: s3,
      source: 'get_avatar',
    });

    if (response.error) {
      return ApiErrorHandler.handleServerError({
        message: response.errorMessage ?? 'Error getting avatar',
        reqUrl: request.url,
        reqBody: '',
      });
    }

    return NextResponse.json(
      { s3Url: response.s3Url, userId: id },
      { status: HttpStatusCode.OK }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the avatar',
      reqUrl: request.url,
      reqBody: '',
      error,
    });
  }
}

/**
 * @swagger
 * /api/user/avatar:
 *   post:
 *     summary: Upload an avatar image for the current user.
 *     description: Uploads an avatar image to s3 and then references the s3 key on the user.
 *     tags:
 *       - User
 *     parameters:
 *       - in: formData
 *         name: upfile
 *         type: file
 *         description: The file to upload.
 *     responses:
 *       '200':
 *         description: The avatar upload status object.
 *         content:
 *           application/json:
 *             schema:
 *              items:
 *                $ref: '#/components/schemas/FileUploadResult'
 *       '404':
 *         description: User not found
 *         content:
 *           application/json:
 *             example:
 *               status: "404"
 *               message: Failed to find user.
 *       '500':
 *         description: Server Error
 *         content:
 *           application/json:
 *             example:
 *               status: "error"
 *               message: An error occurred while generating the s3Url.
 */
const POST = async (request: NextRequest) => {
  try {
    const cookieJar: CookieJar = { cookies: [] };
    const userInfo = await getUserInfo(request, cookieJar);

    const formData = await request.formData();
    const avatarImage = formData.get('file') as File;

    const s3Key = `${userInfo.id}/${avatarImage.name}`;
    const response = await uploadFileToS3(Bucket, s3Key, avatarImage, s3);

    return createCookieResponse(response, cookieJar);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem uploading the avatar',
      reqUrl: request.url,
      reqBody: '',
      error,
    });
  }
};

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user/get-family/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { IFamilyMember } from '@/app/shared/types';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const GET = async (request: NextRequest) => {
  try {
    // Only patients can have a dependent. Not anonymous patients
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PATIENT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const primaryId = userInfo.user.guardianId ?? userInfo.user.id;

    const family = await prisma.user.findMany({
      where: {
        OR: [
          {
            guardianId: primaryId,
          },
          {
            id: primaryId,
          },
        ],
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        guardianId: true,
        avatarUrl: true,
      },
    });

    const familyMembers = family.map((member) => {
      return {
        ...member,
        isPrimary: member.id === primaryId,
      } as IFamilyMember;
    });

    return NextResponse.json(familyMembers, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem retrieving the family members',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user/family-stats/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { IFamilyStatsResponse } from '@/app/shared/types';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { getFamilyIDs } from '@/utils/dependents/dependentUsersUtilities';
import { ErrorNextResponse } from '@/utils/errors/apiErrorHandler';
import { getCasePhysicianAccess } from '@/utils/get-case-physician-access';
import { getUserAttributes } from '@/utils/helpers/helpers';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const GET = async (
  request: NextRequest
): Promise<NextResponse<IFamilyStatsResponse | ErrorNextResponse>> => {
  try {
    // We don't need a specific role to execute this
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const userFamilyIDs = await getFamilyIDs(userInfo.user);

    const today = new Date();
    const sevenDaysAgo = new Date(new Date().setDate(new Date().getDate() - 7));
    const sevenDaysInTheFuture = new Date(
      new Date().setDate(new Date().getDate() + 7)
    );

    // Get Cases Diagnosed in last 7 days
    const casesDiagnosedInLast7Days = await prisma.case.findMany({
      where: {
        diagnosedAt: {
          gte: sevenDaysAgo,
        },
        userId: {
          in: userFamilyIDs,
        },
      },
      include: {
        user: true,
        physician: true,
      },
    });

    // Get changes to shipment in last 7 days
    const shippingChangesInLast7Days = await prisma.shipment.findMany({
      where: {
        updatedAt: {
          gte: sevenDaysAgo,
        },
        userId: {
          in: userFamilyIDs,
        },
      },
      include: {
        user: true,
        order: true,
        products: true,
        subscriptionProducts: true,
      },
    });

    // Get Unread Messages for User
    // Get All User Threads
    const allFamilyThreads = await prisma.thread.findMany({
      where: {
        userId: {
          in: userFamilyIDs,
        },
      },
      include: {
        user: true,
      },
    });

    let totalUnreadMessages = 0;
    const unreadThreads = [];
    for (const thread of allFamilyThreads) {
      const unreadMessagesForThread =
        await messagingClient.message.getUnreadMessagesForThread(
          thread.id,
          thread.user
        );

      unreadThreads.push({
        ...thread,
        unreadMessagesForThread: unreadMessagesForThread.length,
      });
      totalUnreadMessages += unreadMessagesForThread.length;
    }

    // Get Cases Expiring Soon
    const allFamilyCases = await prisma.case.findMany({
      where: {
        userId: {
          in: userFamilyIDs,
        },
      },
      include: {
        user: true,
      },
    });

    const casesWithConsultationExpiringWithin7Days = [];
    for (const currentCase of allFamilyCases) {
      const userAttributes = await getUserAttributes(currentCase.user);

      if (!userAttributes.hasConcierge) {
        const physicianAccessInfo = getCasePhysicianAccess(
          currentCase,
          userAttributes
        );

        const expirationDate = new Date(
          physicianAccessInfo.nonConciergeAccessExpiresOn
        );

        // Only show cases that aren't alraedy expired, but will expire within 7 days
        if (expirationDate > today && expirationDate < sevenDaysInTheFuture) {
          casesWithConsultationExpiringWithin7Days.push(currentCase);
        }
      }
    }

    return NextResponse.json(
      {
        casesDiagnosedInLast7Days,
        shippingChangesInLast7Days,
        unreadThreads,
        casesWithConsultationExpiringWithin7Days,
        totalNotifications:
          casesDiagnosedInLast7Days.length +
          shippingChangesInLast7Days.length +
          totalUnreadMessages +
          casesWithConsultationExpiringWithin7Days.length,
      } as IFamilyStatsResponse,
      { status: HttpStatusCode.OK }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem retrieving the family statistics',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user/[userId]/link-retool-sid/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { userPrismaClient } from '@/app/shared/models/extensions/identity';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const retoolSidSchema = z.object({
  retoolSid: z.string(),
});

const PATCH = async (
  request: NextRequest,
  { params }: { params: { userId: string } }
): Promise<NextResponse> => {
  const safeBody = await getSafeRequestBody(request);

  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const { retoolSid } = retoolSidSchema.parse(safeBody.jsonBody);
    const { userId } = params;

    const forceLink = request.nextUrl.searchParams.get('forceLink');

    const sidAlreadyLinked = await userPrismaClient.user.findFirst({
      where: {
        retoolSid: retoolSid,
      },
      select: {
        id: true,
      },
    });

    if (sidAlreadyLinked && !forceLink) {
      return ApiErrorHandler.handleBadRequest({
        reqUrl: request.url,
        reqHeaders: request.headers,
        message: `Sid ${retoolSid} is already linked to user with id ${sidAlreadyLinked.id}`,
      });
    } else if (sidAlreadyLinked) {
      await userPrismaClient.user.update({
        where: { id: sidAlreadyLinked.id },
        data: { retoolSid: null },
      });
    }

    const updatedUser = await userPrismaClient.user.update({
      where: { id: userId },
      data: { retoolSid },
    });

    if (!updatedUser) {
      return ApiErrorHandler.handle404Error({
        reqUrl: request.url,
        reqHeaders: request.headers,
        message: `No user found with id ${userId}`,
      });
    }

    return NextResponse.json(updatedUser, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      error,
      reqUrl: request.url,
      reqHeaders: request.headers,
      message: 'An error occurred while updating the user',
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user/on-signin/route.ts

import { NextRequest, NextResponse } from 'next/server';

import {
  getSessionUserInfo,
  isSessionUserInfoSuccessResponse,
} from '@auth/auth';
import CognitoClient from '@clients/cognito/cognitoClient';
import { prisma } from '@clients/mongo/prismaClient';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

/**
 * @swagger
 * /api/user/on-signin:
 *   post:
 *     tags: [User]
 *     summary: Create user on signin
 *     description: Endpoint to to create a new Cortina user the first time someone logs in. Will not cause a problem to call after user has initial Cortina Login
 *     responses:
 *       200:
 *         description: User successfully created or already was created.
 *         content:
 *           application/json:
 *             example:
 *               message: User Created
 *               status: 200
 *       500:
 *         description: An error occurred while creating / checking for the user
 *         content:
 *           application/json:
 *             example:
 *               status: 500
 *               message: User not logged in
 */
const POST = async (request: NextRequest) => {
  try {
    const session = await getSessionUserInfo(request);

    if (!isSessionUserInfoSuccessResponse(session)) {
      return session.unauthorizedApiResponse;
    }

    const userInfo = session.user;

    if (!userInfo.cortinaId) {
      const userData = await prisma.user.create({
        data: {
          email: userInfo.email,
          cognitoId: userInfo.sub,
          roles: [UserRole.PATIENT],
        },
      });

      await CognitoClient.updateCortinaIdByUsername(
        userInfo.userName,
        userData.id
      );

      return NextResponse.json({ message: 'User created' }, { status: 201 });
    }

    return NextResponse.json(
      { message: 'User already created' },
      { status: 200 }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while creating the user',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user/get-dependents/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const GET = async (request: NextRequest) => {
  try {
    // Only patients can have a dependent. Not anonymous patients
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PATIENT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const dependentusers = await prisma.user.findMany({
      where: {
        guardianId: userInfo.user.id,
      },
    });

    return NextResponse.json(dependentusers, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem retrieving the dependent users',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/shipping/curexa/route.ts

// Curexa Shipping Webhook Order Status Update
import { NextRequest, NextResponse } from 'next/server';

import LoggerUtil from '@/utils/clients/logging/apiUtilLogger';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import SlackClient from '@/utils/clients/slack/slackClient';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { UserEventNames } from '@/utils/user-events/enums';
import UserEventsClient from '@/utils/user-events/user-events-client';
import { Shipment, ShipmentStatus, ShippingPartner } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

async function getShipment(orderId: string): Promise<Shipment | null> {
  const foundShipment = await prisma.shipment.findFirst({
    where: {
      shippingPartnerId: orderId,
      shippingPartner: ShippingPartner.CUREXA,
    },
  });

  return foundShipment;
}

async function processCurexaOutForDelivery(
  shipment: Shipment,
  trackingNumber: string
) {
  await prisma.shipment.update({
    where: {
      id: shipment.id,
    },
    data: {
      shipmentStatus: ShipmentStatus.SHIPPED,
      trackingNumber: trackingNumber,
    },
  });

  await UserEventsClient.addEventByUserId(
    shipment.userId,
    UserEventNames.DERMI_RX_ORDER_SHIPPED,
    {
      orderNumber: shipment.id,
      tracking_number: trackingNumber,
    }
  );
}

async function processCurexaError(shipment: Shipment, errorDetails: string) {
  const updatedShipment = await prisma.shipment.update({
    where: {
      id: shipment.id,
    },
    data: {
      shipmentStatus: ShipmentStatus.FAILED,
      errorDetails: errorDetails,
    },
  });

  await SlackClient.logOrderIssue(
    updatedShipment.orderId,
    updatedShipment.userId,
    updatedShipment.shippingPartner,
    errorDetails,
    {
      shippingPartnerId: updatedShipment.shippingPartnerId,
    }
  );
}

async function processCurexaComplete(shipment: Shipment) {
  await prisma.shipment.update({
    where: {
      id: shipment.id,
    },
    data: {
      shipmentStatus: ShipmentStatus.DELIVERED,
    },
  });

  await UserEventsClient.addEventByUserId(
    shipment.userId,
    UserEventNames.DERMI_RX_ORDER_DELIVERED,
    {
      orderNumber: shipment.id,
    }
  );
}

async function processCurexaInProgress(shipment: Shipment) {
  await prisma.shipment.update({
    where: {
      id: shipment.id,
    },
    data: {
      shipmentStatus: ShipmentStatus.PENDING,
    },
  });
}

async function processCurexaCancelled(shipment: Shipment) {
  const updatedShipment = await prisma.shipment.update({
    where: {
      id: shipment.id,
    },
    data: {
      shipmentStatus: ShipmentStatus.CANCELLED,
    },
  });

  await SlackClient.logOrderIssue(
    updatedShipment.orderId,
    updatedShipment.userId,
    updatedShipment.shippingPartner,
    'Order was cancelled by curexa',
    {
      shippingPartnerId: updatedShipment.shippingPartnerId,
    }
  );
}

//// CUREXA STATUSES
// new (Denotes a new order that has not been processed yet)
// in_progress (An order that is being reviewed or fulfilled)
// out_for_delivery (An order that has been fulfilled and shipped)
// canceled (An order that has been canceled)
// completed (An order that has been delievered)
// error (An order with an error, the status_details will contain the reason)

const POST = async (request: NextRequest) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const APIKey = request.headers.get('x-bearer-token');

    if (!APIKey || APIKey !== process.env.CUREXA_WEBHOOK_API_KEY) {
      return NextResponse.json({ status: 'unauthroized' }, { status: 401 });
    }

    const orderId = safeBody.jsonBody.order_id;
    const status = safeBody.jsonBody.status;

    await LoggerUtil.logInfo('curexa_shipment_update', '/api/shipping/curexa', {
      orderId,
      status,
    });

    const shipment = await getShipment(orderId);

    if (!shipment) {
      await LoggerUtil.logError(
        'curexa_shipment_not_found',
        '/api/shipping/curexa',
        new Error(
          `Shipment not found for Order: ${orderId}. Status: ${status}`
        ),
        { payload: safeBody.jsonBody }
      );

      return NextResponse.json(
        { status: 'success' },
        {
          status: 200,
        }
      );
    }

    switch (status) {
      case 'out_for_delivery': {
        // SET OUT FOR DELIVERY STATUS MEANING THAT THE ORDER HAS SHIPPED
        const trackingNumber = safeBody.jsonBody.tracking_number;
        const carrier = safeBody.jsonBody.carrier;

        await processCurexaOutForDelivery(shipment, trackingNumber);
        break;
      }
      case 'error': {
        // INDICATE ERROR
        const statusDetails = safeBody.jsonBody.status_details;

        await processCurexaError(shipment, statusDetails);
        break;
      }
      case 'completed':
        await processCurexaComplete(shipment);
        break;
      case 'canceled':
        await processCurexaCancelled(shipment);
        break;
      case 'in_progress':
        await processCurexaInProgress(shipment);
        break;
      case 'new':
        // known to not do anything
        break;
      default:
        // log unknown status' but return OK so they don't keep hitting us
        await LoggerUtil.logError(
          'curexa_unknown_status',
          '/api/shipping/curexa',
          new Error(
            `Unrecognized Curexa Status for Order: ${orderId}. Status: ${status}`
          ),
          { payload: safeBody.jsonBody }
        );
    }

    return NextResponse.json(
      { status: 'success' },
      {
        status: 200,
      }
    );
  } catch (error) {
    if (error instanceof Error) {
      await SlackClient.logOrderIssue(
        'unknown',
        'unknown',
        ShippingPartner.CUREXA,
        'order failure',
        {
          errorMessage: error.message,
          payload: safeBody.jsonBody,
        }
      );
    } else {
      await SlackClient.logOrderIssue(
        'unknown',
        'unknown',
        ShippingPartner.CUREXA,
        'order failure',
        {
          errorMessage: 'An unknown error has occured',
          stringifiedError: JSON.stringify(error),
          payload: safeBody.jsonBody,
        }
      );
    }

    return ApiErrorHandler.handleServerError({
      message: 'Error occurred processing the curexa update.',
      reqUrl: request.url,
      error: error,
      reqBody: safeBody.txtBody,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/shipping/shiphero/route.ts

// Ship Hero Shipping Webhook Order Status Update
import { NextRequest, NextResponse } from 'next/server';

import LoggerUtil from '@/utils/clients/logging/apiUtilLogger';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { UserEventNames } from '@/utils/user-events/enums';
import UserEventsClient from '@/utils/user-events/user-events-client';
import { ShipmentStatus } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

async function processShippingUpdateWebhook(shipmentWebhookData: any) {
  const orderNumber = shipmentWebhookData.fulfillment.order_number;

  const internalShipment = await prisma.shipment.findFirst({
    where: {
      shippingPartnerId: orderNumber,
    },
  });

  if (!internalShipment) {
    throw new Error(
      `Ship Hero shipment with order number ${orderNumber} was not found`
    );
  }

  const trackingNumber = shipmentWebhookData.fulfillment.tracking_number;

  await prisma.shipment.update({
    where: {
      id: internalShipment.id,
    },
    data: {
      trackingNumber: trackingNumber,
      shipmentStatus: ShipmentStatus.SHIPPED,
    },
  });

  await UserEventsClient.addEventByUserId(
    internalShipment.userId,
    UserEventNames.DERMI_OTC_ORDER_SHIPPED,
    {
      orderNumber: internalShipment.id,
      otcPurchased: internalShipment.trackingNumber,
    }
  );
}

// Process Shipping Update Webhook
const POST = async (request: NextRequest) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const webhookType = safeBody.jsonBody.webhook_type;

    await LoggerUtil.logInfo(
      'shiphero_shipment_webhook_hit',
      '/api/shipping/shiphero',
      {
        webhookType,
        orderId: safeBody.jsonBody.fulfillment?.order_number,
        webhookData: safeBody.jsonBody,
      }
    );

    if (webhookType === 'Shipment Update') {
      await processShippingUpdateWebhook(safeBody.jsonBody);
    } else {
      throw new Error(
        `Unrecognized webhook of type ${webhookType} received at ShipHero Endpoint`
      );
    }

    return NextResponse.json(
      { status: 'success' },
      {
        status: 200,
      }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem processing the ship hero webhook',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/checkout/start-checkout/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { ExtendedUser } from '@/app/shared/models/extensions/identity/types/identityTypes';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import {
  addProductToCart,
  addSubscriptionProductToCart,
} from '@/utils/ecommerce/cartUtils';
import { ApiErrorHandler } from '@/utils/errors';
import { ErrorNextResponse } from '@/utils/errors/apiErrorHandler';
import { getAvailableConsult } from '@/utils/get-available-consult';
import { getUserAttributes } from '@/utils/helpers/helpers';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';

export interface IStartCheckoutResponse {
  user: ExtendedUser;
  paymentRequired: boolean;
  paymentConfirmed: boolean;
}

const getShouldAddConcierge = async (
  user: ExtendedUser,
  selectedUserId?: string | null
) => {
  if (selectedUserId) {
    const dependentUser = await prisma.user.findUnique({
      where: {
        id: selectedUserId,
        guardianId: user.id,
      },
    });

    if (dependentUser) {
      const extendedDependent = await getUserAttributes(dependentUser);
      return !extendedDependent.hasConcierge;
    }
  }

  const extendedUser = await getUserAttributes(user);
  return !extendedUser.hasConcierge;
};

const addConsultationAndConcierge = async (
  user: ExtendedUser,
  selectedUserId?: string | null
) => {
  await addProductToCart(
    user,
    process.env.PRODUCT_ID_ONE_TIME_MEDICAL_CONSULTATION + '',
    true,
    1
  );

  const shouldAddConcierge = await getShouldAddConcierge(user, selectedUserId);

  if (shouldAddConcierge) {
    await addSubscriptionProductToCart(
      user,
      process.env.PRODUCT_ID_CONCIERGE_SUBSCRIPTION_MONTHLY + '',
      true,
      1
    );
  }
};

export async function GET(
  request: NextRequest
): Promise<NextResponse<IStartCheckoutResponse | ErrorNextResponse>> {
  const headersList = headers();
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    // TODO: Check if employer requires payment
    const paymentRequired = true;

    if (!paymentRequired) {
      return NextResponse.json(
        {
          user: userInfo.user,
          paymentRequired: false,
          paymentConfirmed: false,
        },
        { status: 200 }
      );
    }

    const availableConsultations = await getAvailableConsult(userInfo.user);

    if (availableConsultations > 0) {
      return NextResponse.json(
        {
          user: userInfo.user,
          paymentRequired: true,
          paymentConfirmed: true,
        },
        { status: 200 }
      );
    }

    const selectedUserId = headersList.get('selected-user-id');
    await addConsultationAndConcierge(userInfo.user, selectedUserId);

    return NextResponse.json(
      {
        user: userInfo.user,
        paymentRequired: true,
        paymentConfirmed: false,
      },
      { status: 200 }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem starting the checkout process',
      reqUrl: request.url,
      error: error,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/checkout/create-ds-user/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { ExtendedUser } from '@/app/shared/models/extensions/identity/types/identityTypes';
import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { ErrorNextResponse } from '@/utils/errors/apiErrorHandler';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { SexAtBirthEnum } from '@prisma/client';
import { AddressCreateInputSchema } from '@prisma/generated/zod';

const addDoseSpotUserSchema = z.object({
  firstName: z.string(),
  lastName: z.string(),
  addresses: AddressCreateInputSchema.array().optional(),
  phoneNumber: z.string(),
  dob: z.coerce.date(),
  sexAtBirth: z.nativeEnum(SexAtBirthEnum),
});

const createDosespotUser = async (
  dsData: Zod.infer<typeof addDoseSpotUserSchema>,
  user: ExtendedUser
): Promise<boolean> => {
  const dsResult = await DosespotClient.pushUserDataToDoseSpot(
    {
      ...dsData,
      medicalProfile: {
        dob: dsData.dob,
        sexAtBirth: dsData.sexAtBirth,
      },
    },
    user
  );

  if (dsResult.success) {
    await prisma.user.update({
      where: {
        id: user.id,
      },
      data: {
        dosespotId: dsResult.patientDoseSpotId,
      },
    });
    return true;
  } else {
    return false;
  }
};

export async function POST(
  request: NextRequest
): Promise<NextResponse<{ success: boolean } | ErrorNextResponse>> {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    if (!userInfo.user.dosespotId) {
      const safeBody = await getSafeTypedBody(request, addDoseSpotUserSchema);

      if (!safeBody.success) return safeBody.errorResponse;

      const result = await createDosespotUser(safeBody.value, userInfo.user);

      if (!result) {
        throw new Error('Could not create DoseSpot user');
      }
    }

    return NextResponse.json(
      {
        success: true,
      },
      { status: 200 }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem starting the checkout process',
      reqUrl: request.url,
      error: error,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/partner/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { userPrismaClient } from '@/app/shared/models/extensions/identity';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const partnerCreateSchema = z.object({
  name: z.string(),
  cognitoId: z.string(),
});

const POST = async (request: NextRequest) => {
  const userInfo = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.ADMIN],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  const body = await getSafeTypedBody(request, partnerCreateSchema);

  if (!body.success) return body.errorResponse;

  const { name, cognitoId } = body.value;

  try {
    const partner = await userPrismaClient.partner.create({
      data: {
        name,
        cognitoId,
      },
    });

    if (!partner)
      return ApiErrorHandler.handleServerError({
        message:
          'An error occured trying to create the partner. Please try again.',
        reqUrl: request.url,
        reqBody: JSON.stringify(body.value),
      });

    return NextResponse.json(partner, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      reqBody: JSON.stringify(body.value),
      error: error,
    });
  }
};

const GET = async (request: NextRequest) => {
  const userInfo = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.ADMIN],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  const partners = await userPrismaClient.partner.findMany();

  return NextResponse.json(partners, { status: HttpStatusCode.OK });
};

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/partner/[partnerId]/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { userPrismaClient } from '@/app/shared/models/extensions/identity';
import { PartnerInclude } from '@/app/shared/types';
import { ApiErrorHandler } from '@/utils/errors';
import { ErrorNextResponse } from '@/utils/errors/apiErrorHandler';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const partnerPatchSchema = z
  .object({
    name: z.string().optional(),
    cognitoId: z.string().optional(),
  })
  .refine(
    (body) => body.cognitoId || body.name,
    'Must provide at least one body parameter to update.'
  );

const GET = async (
  request: NextRequest,
  { params }: { params: { partnerId: string } }
): Promise<
  NextResponse<PartnerInclude | { message: string } | ErrorNextResponse> // Partner | Not Found | Error
> => {
  const { partnerId } = params;

  const userInfo = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.ADMIN],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  try {
    const partner = await userPrismaClient.partner.findUnique({
      where: {
        id: partnerId,
      },
      include: {
        preferences: true,
      },
    });

    if (!partner)
      return NextResponse.json(
        { message: 'Partner not found' },
        { status: HttpStatusCode.NOT_FOUND }
      );

    return NextResponse.json(partner, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      error: error,
    });
  }
};

const PATCH = async (
  request: NextRequest,
  { params }: { params: { partnerId: string } }
) => {
  const { partnerId } = params;

  const userInfo = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.ADMIN],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  const body = await getSafeTypedBody(request, partnerPatchSchema);

  if (!body.success) return body.errorResponse;

  const { name, cognitoId } = body.value;

  try {
    const partner = await userPrismaClient.partner.update({
      where: {
        id: partnerId,
      },
      data: {
        name: name ?? undefined,
        cognitoId: cognitoId ?? undefined,
      },
    });

    if (!partner)
      return ApiErrorHandler.handleServerError({
        message:
          'An error occured trying to create the partner. Please try again.',
        reqUrl: request.url,
        reqBody: JSON.stringify(body.value),
      });

    return NextResponse.json(partner, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      reqBody: JSON.stringify(body.value),
      error: error,
    });
  }
};

const DELETE = async (
  request: NextRequest,
  { params }: { params: { partnerId: string } }
) => {
  const { partnerId } = params;

  const userInfo = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.ADMIN],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  try {
    const partner = await userPrismaClient.partner.delete({
      where: {
        id: partnerId,
      },
    });

    if (!partner)
      return ApiErrorHandler.handleServerError({
        message:
          'An error occured trying to create the partner. Please try again.',
        reqUrl: request.url,
      });

    return NextResponse.json(
      { message: `Partner ${partnerId} successfully deleted.` },
      { status: HttpStatusCode.OK }
    );
  } catch (error) {
    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      error: error,
    });
  }
};

export { DELETE, GET, PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/partner/[partnerId]/preferences/update/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import {
  ApiErrorHandler,
  ErrorNextResponse,
} from '@/utils/errors/apiErrorHandler';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { PartnerPreferences, UserRole } from '@prisma/client';

const partnerPreferencesUpdateSchema = z.object({
  logo: z.string().optional(),
  allowIntakeByTreatment: z.boolean().optional().default(true),
  allowFamilyMembers: z.boolean().optional().default(true),
});

const PATCH = async (
  request: NextRequest,
  { params }: { params: { partnerId: string } }
): Promise<
  NextResponse<PartnerPreferences | { message: string } | ErrorNextResponse>
> => {
  try {
    const { partnerId } = params;

    const userInfo = await getUserAndCheckAuthorized({
      request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = await getSafeTypedBody(
      request,
      partnerPreferencesUpdateSchema
    );

    if (!body.success) return body.errorResponse;

    const partner = await prisma.partner.findUnique({
      where: {
        id: partnerId,
      },
      include: {
        preferences: true,
      },
    });

    if (!partner) {
      return NextResponse.json(
        { message: 'Partner not found' },
        { status: HttpStatusCode.NOT_FOUND }
      );
    }

    if (!partner.preferences) {
      return NextResponse.json(
        {
          message:
            'Partner preferences not found. Please create the preferences.',
        },
        { status: HttpStatusCode.NOT_FOUND }
      );
    }

    const newPreferences = await prisma.partnerPreferences.update({
      where: {
        id: partner.preferences.id,
      },
      data: {
        ...body.value,
      },
    });

    return NextResponse.json(newPreferences, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/partner/[partnerId]/preferences/create/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import {
  ApiErrorHandler,
  ErrorNextResponse,
} from '@/utils/errors/apiErrorHandler';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { PartnerPreferences, UserRole } from '@prisma/client';

const partnerPreferencesCreateSchema = z.object({
  logo: z.string().optional(),
  allowIntakeByTreatment: z.boolean().optional().default(true),
  allowFamilyMembers: z.boolean().optional().default(true),
});

const POST = async (
  request: NextRequest,
  { params }: { params: { partnerId: string } }
): Promise<
  NextResponse<PartnerPreferences | { message: string } | ErrorNextResponse>
> => {
  try {
    const { partnerId } = params;

    const userInfo = await getUserAndCheckAuthorized({
      request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const body = await getSafeTypedBody(
      request,
      partnerPreferencesCreateSchema
    );

    if (!body.success) return body.errorResponse;

    const partner = await prisma.partner.findUnique({
      where: {
        id: partnerId,
      },
      include: {
        preferences: true,
      },
    });

    if (!partner) {
      return NextResponse.json(
        { message: 'Partner not found' },
        { status: HttpStatusCode.NOT_FOUND }
      );
    }

    if (partner && partner.preferences != null) {
      return NextResponse.json(
        {
          message:
            'Partner preferences already exist. Please use update API instead.',
        },
        { status: HttpStatusCode.BAD_REQUEST }
      );
    }

    const newPreferences = await prisma.partnerPreferences.create({
      data: {
        ...body.value,
        partnerId: partnerId,
      },
    });

    return NextResponse.json(newPreferences, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/heartbeat/route.ts

import { NextRequest, NextResponse } from 'next/server';

import LoggerUtil from '@/utils/clients/logging/apiUtilLogger';
import { doDailySubscriptionCheck } from '@/utils/ecommerce/subscriptionUtils';
import { triggerReportingEmails } from '@/utils/reporting/trigger-reporting-emails';
import { ApiErrorHandler } from '@utils/errors';
import HttpStatusCode from '@utils/statusCodes';

enum PingType {
  Every5Minutes = 'every_5_minutes',
  EveryHour = 'every_hour',
  EveryDay = 'every_day',
}

interface PingPayload {
  type: PingType;
  timestamp: string;
}

const POST = async (request: NextRequest) => {
  try {
    const payload: PingPayload = await request.json();

    switch (payload.type) {
      case PingType.Every5Minutes:
        await handleEvery5MinutesPing(payload);
        break;
      case PingType.EveryHour:
        await handleEveryHourPing(payload);
        break;
      case PingType.EveryDay:
        await handleEveryDayPing(payload);
        break;
      default:
        return ApiErrorHandler.handleBadRequest({
          message: 'Invalid ping type',
          reqUrl: request.url,
          reqBody: JSON.stringify(payload),
        });
    }

    return NextResponse.json(
      { message: 'Ping received' },
      { status: HttpStatusCode.OK }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem processing the ping',
      reqUrl: request.url,
      error: error,
    });
  }
};

async function handleEvery5MinutesPing(payload: PingPayload) {
  await LoggerUtil.logInfo(
    'Received every 5 minutes ping',
    'handleEvery5MinutesPing',
    payload
  );
  // Implement the specific logic for every 5 minutes ping
}

async function handleEveryHourPing(payload: PingPayload) {
  await LoggerUtil.logInfo(
    'Received every hour ping',
    'handleEveryHourPing',
    payload
  );
  // Implement the specific logic for every hour ping
}

async function handleEveryDayPing(payload: PingPayload) {
  await LoggerUtil.logInfo(
    'Received every day ping',
    'handleEveryDayPing',
    payload
  );
  // Implement the specific logic for every day ping
  const subscriptionCheck = doDailySubscriptionCheck();
  const reportsTrigger = triggerReportingEmails();

  Promise.all([subscriptionCheck, reportsTrigger]);
}

// You can add OPTIONS method for handling preflight requests if needed
async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, POST' } });
}

export { OPTIONS, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/support/new-thread/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import {
  MessageStatus,
  ThreadAction,
  ThreadParticipantStatus,
  ThreadStatus,
  ThreadType,
  UserRole,
} from '@prisma/client';

const supportThreadSchema = z.object({
  userId: z.string(),
  initialMessage: z.string(),
});

type SupportThreadBody = z.infer<typeof supportThreadSchema>;

const PUT = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.CORTINA_SUPPORT, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const threadData = await getSafeTypedBody<SupportThreadBody>(
      request,
      supportThreadSchema
    );

    if (!threadData.success) return threadData.errorResponse;

    const date = new Date();

    const participants = [
      {
        userId: threadData.value.userId, // On behalf of user
        status: ThreadParticipantStatus.ACTIVE,
      },
      {
        userId: userInfo.user.id, // Support user
        status: ThreadParticipantStatus.ACTIVE,
      },
    ] as any;

    const updateData: any = {
      user: { connect: { id: threadData.value.userId } },
      type: ThreadType.SUPPORT,
      participants: {
        createMany: { data: participants },
      },
      messages: {
        create: {
          fromUserId: userInfo.user.id,
          status: MessageStatus.SENT,
          content: threadData.value.initialMessage,
          sentWhen: date,
          readByIds: { set: [userInfo.user.id] },
        },
      },
      lastMessageDate: date,
      status: ThreadStatus.ACTIVE,
      history: {
        create: {
          triggeredById: userInfo.user.id,
          statusTo: ThreadStatus.ACTIVE,
          action: ThreadAction.CREATED,
        },
      },
    };

    const thread = await messagingClient.thread.create({
      data: updateData,
    });

    if (!thread) throw new Error('Thread was not created.');

    return NextResponse.json(thread, { status: 201 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while creating the thread.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { PUT };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/support/cases/[caseId]/archive/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { CaseStatus, UserRole } from '@prisma/client';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
): Promise<NextResponse> => {
  const userInfo = await getUserAndCheckAuthorized({
    request: request,
    roleAccess: [UserRole.CORTINA_SUPPORT, UserRole.ADMIN],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  try {
    const { caseId } = params;

    const caseLookup = await prisma.case.findUnique({
      where: {
        id: caseId,
      },
      select: {
        id: true,
        status: true,
        threadId: true,
      },
    });

    if (!caseLookup) {
      return ApiErrorHandler.handleBadRequest({
        reqUrl: request.url,
        reqHeaders: request.headers,
        message: `Case with id ${caseId} was not found or you do not have access to it.`,
      });
    }

    const allowedStatuses: CaseStatus[] = [
      CaseStatus.ASSIGNED,
      CaseStatus.OPEN,
      CaseStatus.PREPAYMENT,
    ];

    if (!allowedStatuses.includes(caseLookup.status)) {
      return ApiErrorHandler.handleBadRequest({
        reqUrl: request.url,
        reqHeaders: request.headers,
        message: `Unable to archive case ${caseId} due to it's status of ${caseLookup.status}.`,
      });
    }

    const updatedCase = await prisma.$transaction(async (prisma) => {
      // Archive the thread(s)
      caseLookup.threadId.forEach(async (threadId) => {
        await messagingClient.thread.archiveThread(threadId, userInfo.user);
      });

      // Unassign the case
      return await prisma.case.update({
        where: { id: caseId },
        data: {
          status: CaseStatus.ARCHIVED,
        },
      });
    });

    return NextResponse.json(updatedCase, { status: HttpStatusCode.OK });
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/support/cases/[caseId]/unassign/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { CaseStatus, UserRole } from '@prisma/client';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
): Promise<NextResponse> => {
  const userInfo = await getUserAndCheckAuthorized({
    request: request,
    roleAccess: [UserRole.CORTINA_SUPPORT, UserRole.ADMIN],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  try {
    const { caseId } = params;

    const caseLookup = await prisma.case.findUnique({
      where: {
        id: caseId,
      },
      select: {
        id: true,
        status: true,
        physicianId: true,
        threadId: true,
      },
    });

    if (!caseLookup) {
      return ApiErrorHandler.handleBadRequest({
        reqUrl: request.url,
        reqHeaders: request.headers,
        message: `Case with id ${caseId} was not found or you do not have access to it.`,
      });
    }

    const physicianId = caseLookup?.physicianId;
    if (physicianId == null) {
      return ApiErrorHandler.handleBadRequest({
        reqUrl: request.url,
        reqHeaders: request.headers,
        message: `Case ${caseId} is not currently assigned.`,
      });
    }

    if (caseLookup.status !== CaseStatus.ASSIGNED) {
      return ApiErrorHandler.handleBadRequest({
        reqUrl: request.url,
        reqHeaders: request.headers,
        message: `Unable to unassign case ${caseId} due to it's status of ${caseLookup.status}.`,
      });
    }

    const updatedCase = await prisma.$transaction(async (prisma) => {
      // Deactivate the physician on the thread(s)
      caseLookup.threadId.forEach(async (threadId) => {
        await messagingClient.thread.removeParticipant(
          physicianId,
          threadId,
          userInfo.user
        );
      });

      // Unassign the case
      return await prisma.case.update({
        where: { id: caseId },
        data: {
          status: CaseStatus.OPEN,
          physician: {
            disconnect: true,
          },
        },
      });
    });

    return NextResponse.json(updatedCase, { status: HttpStatusCode.OK });
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/support/get-threads/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { messagingClient } from '@models/extensions/messaging';
import { UserRole, MessageStatus } from '@prisma/client';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN, UserRole.CORTINA_SUPPORT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;
    const query = request.nextUrl.searchParams;

    const whereQuery: { status?: any; userId?: string } = {};

    if (query.has('userId')) {
      whereQuery.userId = query.get('userId') as string;
    }

    const threads = await messagingClient.thread.findMany({
      where: {
        ...whereQuery,
      },
      select: {
        id: true,
        type: true,
        status: true,
        user: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        participants: {
          select: {
            userId: true,
            user: {
              select: {
                firstName: true,
                lastName: true,
              },
            },
          },
        },
        messages: {
          where: {
            status: MessageStatus.SENT,
          },
          orderBy: { sentWhen: 'desc' },
          take: 1,
          select: {
            fromUserId: true,
            content: true,
            sentWhen: true,
          },
        },
      },
    });

    return NextResponse.json(threads, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while retrieving the threads.',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/support/get-media/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { getS3Url } from '@/utils/file-upload/file-upload';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { S3Client } from '@aws-sdk/client-s3';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const s3 = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.FORM_S3_AWS_ACCESS_KEY as string,
    secretAccessKey: process.env.FORM_S3_SECRET_ACCESS_KEY as string,
  },
});

async function GET(request: NextRequest) {
  try {
    const headerList = headers();
    const s3Url = headerList.get('s3Url');

    if (!s3Url) {
      return ApiErrorHandler.handleBadRequest({
        message: 'You must include an s3 url',
        reqUrl: request.url,
        reqBody: '',
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [
        UserRole.ADMIN,
        UserRole.PATIENT,
        UserRole.PHYSICIAN,
        UserRole.CORTINA_SUPPORT,
        UserRole.CORTINA_NURSE,
        UserRole.PHYSICIAN_SUPPORT,
      ],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const response = await getS3Url({
      mediaUrl: s3Url,
      expiresIn: 3600,
      s3Client: s3,
      source: 'get_media',
    });

    if (response.error) {
      return ApiErrorHandler.handleServerError({
        message: response.errorMessage ?? 'Error getting file',
        reqUrl: request.url,
        reqBody: '',
      });
    }

    return NextResponse.json({ s3Url: response.s3Url }, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Failed to get signed url',
      reqUrl: request.url,
      error: error,
    });
  }
}

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/support/audit/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { z } from 'zod';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { parseJSONOrDefault } from '@/utils/utils';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const messageReviewSchema = z.object({
  message: z.string(),
});

type ChatHistoryMessage = {
  content: string;
  fromUser: string;
  role: string;
};

const openai = new OpenAI({
  apiKey: `${process.env.OPEN_AI_API_KEY}`,
  organization: `${process.env.OPEN_AI_ORG}`,
});

const CHAT_PRETEXT = 'For additional context, the chat history is as follows:';
const MESSAGE_PRETEXT = 'This is the message that should be reviewed:';

const POST = async (request: NextRequest) => {
  const headerList = headers();
  const threadId = headerList.get('chatThreadId');

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.CORTINA_SUPPORT, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const bodyResult = await getSafeTypedBody(request, messageReviewSchema);

    if (!bodyResult.success) return bodyResult.errorResponse;

    const { message } = bodyResult.value;

    let previousChatContent: ChatHistoryMessage[] = [];

    if (threadId) {
      const thread = await prisma.thread.findUnique({
        where: {
          id: threadId,
        },
        include: {
          messages: {
            include: {
              fromUser: {
                select: {
                  firstName: true,
                  lastName: true,
                  id: true,
                },
              },
            },
          },
        },
      });
      previousChatContent = (thread?.messages ?? []).map((msg) => {
        return {
          content: `${msg.content}`,
          fromUser: `${msg.fromUser.firstName} ${msg.fromUser.lastName}`,
          role:
            msg.fromUser.id === userInfo.user.id
              ? 'Customer Support'
              : 'Patient',
        };
      });
    }

    const assistantThread = await openai.beta.threads.create();

    if (previousChatContent.length > 0) {
      await openai.beta.threads.messages.create(assistantThread.id, {
        role: 'user',
        content: `${CHAT_PRETEXT} ${JSON.stringify(previousChatContent)}`,
      });
    }

    await openai.beta.threads.messages.create(assistantThread.id, {
      role: 'user',
      content: `${MESSAGE_PRETEXT} ${message}`,
    });

    const runOptions: OpenAI.Beta.Threads.Runs.RunCreateParamsNonStreaming = {
      assistant_id: `${process.env.SUPPORT_AUDIT_OPEN_AI_ASSISTANT}`,
    };

    const run = await openai.beta.threads.runs.createAndPoll(
      assistantThread.id,
      runOptions
    );

    if (run.status === 'completed') {
      const messages = await openai.beta.threads.messages.list(run.thread_id);
      const reply = messages.data[0].content[0];
      if (reply.type === 'text') {
        const parsedReply = parseJSONOrDefault(reply.text.value, {});
        return NextResponse.json(
          {
            ...parsedReply,
            threadId: assistantThread.id,
            assistantId: run.assistant_id,
          },
          {
            status: HttpStatusCode.OK,
          }
        );
      }
    } else {
      throw new Error(run.last_error?.message || 'An error occurred');
    }
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem reviewing the message',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/support/users/[userId]/cancel-concierge/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserEventNames } from '@/utils/user-events/enums';
import UserEventsClient from '@/utils/user-events/user-events-client';
import { ProductCategories, UserRole } from '@prisma/client';

export async function POST(
  request: NextRequest,
  { params }: { params: { userId: string } }
) {
  try {
    const adminInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN, UserRole.CORTINA_SUPPORT],
    });

    if (!adminInfo.success) return adminInfo.unAuthorizedResponse;

    const { userId } = params;

    if (!userId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No userId sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const user = await prisma.user.findUnique({
      where: {
        id: userId,
      },
    });

    if (!user) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No user found by that ID',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    // Get all active subscriptions
    // TODO: get rid of the nested where clause for subscriptionProduct
    const subscriptions = await prisma.userSubscription.findMany({
      where: {
        userId: userId,
        ended: false,
        subscriptionProduct: {
          category: ProductCategories.CONCIERGE,
        },
      },
      select: {
        id: true,
        nextRenewalDate: true,
      },
    });

    // Update each subscription
    const updatePromises = subscriptions.map((subscription) => {
      if (subscription.nextRenewalDate) {
        return prisma.userSubscription.update({
          where: {
            id: subscription.id,
          },
          data: {
            ended: true,
            endDate: subscription.nextRenewalDate,
          },
        });
      }
    });

    await Promise.all(updatePromises);

    await UserEventsClient.addEventByUserId(
      userId,
      UserEventNames.DERMI_CONCIERGE_CANCELLED,
      {}
    );

    return NextResponse.json({}, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message:
        'Error canceling concierge subscription. Please try again or contact IT support.',
      reqUrl: request.url,
      error: error,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/support/users/[userId]/get-prescriptions/route.ts

import { NextRequest, NextResponse } from 'next/server';

import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import { reconcileUserPrescriptionsWithDosespotPrescriptions } from '@/utils/clients/dosespot/dosespotUtils';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';

const GET = async (
  request: NextRequest,
  { params }: { params: { userId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN, UserRole.CORTINA_SUPPORT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const { userId } = params;

    if (!userId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No userId sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const user = await prisma.user.findUnique({
      where: {
        id: userId,
      },
    });

    if (!user) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No user found by that ID',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const dosespotPrescriptions = await DosespotClient.getPrescriptionsByUser(
      user
    );

    // Reconcile User Prescriptions
    const userPrescriptions =
      await reconcileUserPrescriptionsWithDosespotPrescriptions(user);

    const prescriptions = dosespotPrescriptions.map((dosespotPrescription) => {
      const userPrescription = userPrescriptions.find(
        (userPrescription) =>
          Number(userPrescription.dosespotRxId) ===
          dosespotPrescription.PrescriptionId
      );

      return {
        ...dosespotPrescription,
        nextAvailableRefillDate: userPrescription?.nextAvailableRefillDate,
        refillDates: userPrescription?.refillDates,
        productId: userPrescription?.productId,
        subscriptionProductId: userPrescription?.subscriptionProductId,
      };
    });

    return NextResponse.json(prescriptions, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Failed to get user prescriptions',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/support/recent-patient-threads/route.ts

import moment from 'moment';
import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import {
  MessageStatus,
  ThreadStatus,
  ThreadType,
  UserRole,
} from '@prisma/client';

const medicalRoles: UserRole[] = [
  UserRole.PHYSICIAN,
  UserRole.PHYSICIAN_SUPPORT,
  UserRole.CORTINA_NURSE,
];

export async function GET(request: NextRequest) {
  try {
    const thirtyDaysAgo = moment().subtract(30, 'days').toDate();

    const threads = await prisma.thread.findMany({
      where: {
        type: ThreadType.MEDICAL,
        status: ThreadStatus.ACTIVE,
        lastMessageDate: {
          gte: thirtyDaysAgo,
        },
      },
      select: {
        id: true,
        userId: true,
        caseId: true,
        case: {
          select: {
            physicianId: true,
          },
        },
        messages: {
          orderBy: {
            sentWhen: 'desc',
          },
          take: 1,
          where: {
            status: MessageStatus.SENT,
          },
          select: {
            content: true,
            media: true,
            sentWhen: true,
            fromUser: {
              select: {
                roles: true,
              },
            },
          },
        },
      },
    });

    const filteredThreads = threads
      .filter((thread) => {
        const latestMessage = thread.messages[0];
        const isPatientMessage = latestMessage.fromUser.roles.includes(
          UserRole.PATIENT
        );
        const isNotPhysicianMessage = !latestMessage.fromUser.roles.some(
          (role) => medicalRoles.includes(role)
        );

        // Only return threads where the most recent message is from a patient and not a physician or physician support
        return isPatientMessage && isNotPhysicianMessage;
      })
      .map((thread) => ({
        id: thread.id,
        userId: thread.userId,
        caseId: thread.caseId,
        physicianId: thread.case?.physicianId ?? null,
        latestMessage: {
          sentWhen: thread.messages[0].sentWhen,
          content: thread.messages[0].content,
          media: thread.messages[0].media,
        },
      }));

    return NextResponse.json(filteredThreads, { status: 200 });
  } catch (error) {
    const typedError = error as Error;

    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      error: typedError,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/support/templates/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import {
  MessageTemplateCategory,
  MessageTemplateStatus,
  UserRole,
} from '@prisma/client';

const roleAccess = [UserRole.CORTINA_SUPPORT, UserRole.ADMIN];

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: roleAccess,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const templates = await prisma.messageTemplate.findMany({
      where: {
        status: MessageTemplateStatus.ACTIVE,
        rolePermissions: { has: UserRole.CORTINA_SUPPORT },
        category: { has: MessageTemplateCategory.MESSAGING },
      },
      select: {
        id: true,
        updatedAt: true,
        title: true,
        body: true,
      },
      orderBy: {
        updatedAt: 'desc',
      },
    });

    return NextResponse.json(templates, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message:
        'An error occurred while retrieving the customer support messaging templates.',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/generate-client-session/route.ts

import { NextRequest } from 'next/server';

import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { createCookieResponse } from '@/utils/responses/responseHelpers';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });
    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    return createCookieResponse(
      { 'client session': 'generated' },
      userInfo.cookieJar
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem generating the client session',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/dosespot/search-allergies/route.ts

import { NextRequest, NextResponse } from 'next/server';

import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PATIENT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const params = request.nextUrl.searchParams;

    const query = params.get('q');

    if (!query) {
      return NextResponse.json([], { status: 200 });
    }

    const allergyResults = await DosespotClient.searchAllergies(query);

    return NextResponse.json(allergyResults, {
      status: 200,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while searching allergies.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/dosespot/search-pharmacies/route.ts

import { NextRequest, NextResponse } from 'next/server';

import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PATIENT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const params = request.nextUrl.searchParams;

    const name = params.get('name');
    const city = params.get('city');
    const zip = params.get('zip');

    if (!name && !city && !zip) {
      return NextResponse.json([], { status: 200 });
    }

    const pharmacyResults = await DosespotClient.searchPharmacies(
      name,
      city,
      zip
    );

    return NextResponse.json(pharmacyResults, {
      status: 200,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while searching pharmacies.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/dosespot/get-prescribing-url/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import { UserRole } from '@prisma/client';

const GET = async (request: NextRequest) => {
  try {
    const { searchParams } = new URL(request.url);
    const caseId = searchParams.get('caseId');

    if (!caseId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No case Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN, UserRole.CORTINA_SUPPORT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    // Get Case Info
    const caseInfo = await prisma.case.findUnique({
      where: {
        id: caseId,
      },
      include: {
        user: true,
      },
    });

    if (!caseInfo) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No case found for ID',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    let physicianId = null;

    if (userInfo.user.roles.includes(UserRole.CORTINA_SUPPORT))
      physicianId = headers().get('physician-ds-id');
    else physicianId = userInfo.user.dosespotId;

    if (!physicianId)
      return ApiErrorHandler.handleBadRequest({
        message: 'Bad physician id',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });

    if (!caseInfo.user.dosespotId)
      return ApiErrorHandler.handleServerError({
        message: 'User does not exist in dosespot.',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });

    // Get Iframe URL
    const iframeURL = DosespotClient.getIframeURL(
      physicianId, // Physician ID
      caseInfo.user.dosespotId, // Patient ID
      caseId // <--- Encounter ID
    );

    return NextResponse.json({ dosespotURL: iframeURL });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while retrieving the dosespot auth token.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/dosespot/get-token/route.ts

import { NextRequest, NextResponse } from 'next/server';

import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    // Fetch Token
    const authToken = await DosespotClient.getAuthToken();

    return NextResponse.json({ dosespotToken: authToken });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while retrieving the dosespot auth token.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/dosespot/user-allergies-medications/route.ts

import { NextRequest, NextResponse } from 'next/server';

import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const params = request.nextUrl.searchParams;
    const userIdParam = params.get('userid');
    if (!userIdParam) {
      return NextResponse.json([], { status: 200 });
    }

    const userBeingRequested = await prisma.user.findUnique({
      where: {
        id: userIdParam,
      },
      include: {
        Case: true,
      },
    });

    if (!userBeingRequested) {
      return NextResponse.json([], { status: 200 });
    }

    // if the requester (userInfo) has the the same id as the user being requested, allow access
    // if the requester (userInfo) is a physician on one of the cases being requested, allow access
    // otherwise, deny access]

    if (
      userInfo.user.id !== userBeingRequested.id &&
      !userBeingRequested.Case.some(
        (caseInfo) => caseInfo.userId === userInfo.user.id
      )
    ) {
      return NextResponse.json(
        { error: "You do not have access to this user's cases." },
        { status: HttpStatusCode.UNAUTHORIZED }
      );
    }
    const results = await DosespotClient.getAllergiesAndMedicationsForUser(
      userInfo.user
    );

    return NextResponse.json(results, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while searching pharmacies.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/dosespot/search-medications/route.ts

import { NextRequest, NextResponse } from 'next/server';

import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PATIENT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const params = request.nextUrl.searchParams;

    const query = params.get('q');

    if (!query) {
      return NextResponse.json([], { status: 200 });
    }

    const medicationResults = await DosespotClient.searchMedications(query);

    return NextResponse.json(medicationResults, {
      status: 200,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while searching medications.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/marketing/company-contact/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';
import z from 'zod';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserEventNames } from '@/utils/user-events/enums';
import UserEventsClient from '@/utils/user-events/user-events-client';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const contactCreateSchema = z.object({
  firstName: z.string(),
  lastName: z.string(),
  email: z.string().email('Please provide a valid email address'),
  contactTitle: z.string(),
  companyName: z.string(),
  companyWebsite: z.string(),
});

const GET = async (request: NextRequest) => {
  const headersList = headers();

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.CORTINA_SUPPORT, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const results = await prisma.companyContact.findMany({});
    return NextResponse.json(results);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Error retrieving company contacts.',
      reqUrl: request.url,
      reqHeaders: headersList,
      error: error,
    });
  }
};

const POST = async (request: NextRequest) => {
  const typedResult = await getSafeTypedBody<
    z.infer<typeof contactCreateSchema>
  >(request, contactCreateSchema);

  if (!typedResult.success) return typedResult.errorResponse;

  try {
    const companyContact = {
      firstName: typedResult.value.firstName,
      lastName: typedResult.value.lastName,
      email: typedResult.value.email,
      contactTitle: typedResult.value.contactTitle,
      companyName: typedResult.value.companyName,
      companyWebsite: typedResult.value.companyWebsite,
    };

    await prisma.companyContact.create({
      data: companyContact,
    });

    await UserEventsClient.addEventByUserId(
      process.env.B2B_COMPLETION_ID ?? '8fdd9f78-9cd0-4c0e-b3eb-20faff74201c',
      UserEventNames.DERMI_COMPANY_CONTACT,
      {
        first_name: companyContact.firstName,
        last_name: companyContact.lastName,
        email: companyContact.email,
        contact_title: companyContact.contactTitle,
        company_name: companyContact.companyName,
        company_website: companyContact.companyWebsite,
      }
    );

    return NextResponse.json({ message: 'Company contact saved.' });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem saving the company contact',
      reqUrl: request.url,
      reqBody: JSON.stringify(typedResult.value),
      error: error,
    });
  }
};

export async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, POST, GET' } });
}

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/templates/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.CORTINA_SUPPORT, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const templates = await prisma.messageTemplate.findMany({
      include: {
        createdBy: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
        userPermissions: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    // Special data formatting for ReTool admin display
    const formattedTemplates = templates.map((template) => {
      const permissions: string[] = [];

      if (template.rolePermissions.includes(UserRole.CORTINA_SUPPORT)) {
        permissions.push('Support');
      }

      if (template.rolePermissions.includes(UserRole.PHYSICIAN)) {
        permissions.push('Physicians');
      } else {
        const users = template.userPermissions.map(
          (user) => `${user.firstName} ${user.lastName}`
        );
        permissions.push(...users);
      }

      return {
        ...template,
        createdByUser: {
          tooltip: `${template.createdBy.firstName} ${template.createdBy.lastName}`,
          display: `${template.createdBy?.firstName
            ?.charAt(0)
            .toUpperCase()}${template.createdBy?.lastName
            ?.charAt(0)
            .toUpperCase()}`,
        },
        permissions: permissions,
      };
    });

    return NextResponse.json(formattedTemplates, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem retrieving the message templates',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/templates/get-shared-templates/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { MessageTemplateStatus, UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [
        UserRole.CORTINA_SUPPORT,
        UserRole.PHYSICIAN,
        UserRole.PHYSICIAN_SUPPORT,
        UserRole.CORTINA_NURSE,
        UserRole.ADMIN,
      ],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const allowedStatuses: MessageTemplateStatus[] = [
      MessageTemplateStatus.ACTIVE,
    ];

    // Allow admins and cortina support to see archived and draft templates in shared view
    if (
      userInfo.user.roles.includes(UserRole.ADMIN) ||
      userInfo.user.roles.includes(UserRole.CORTINA_SUPPORT)
    ) {
      allowedStatuses.push(
        MessageTemplateStatus.ARCHIVED,
        MessageTemplateStatus.DRAFT
      );
    }

    const templates = await prisma.messageTemplate.findMany({
      where: {
        status: { in: allowedStatuses },
        OR: [
          {
            rolePermissions: {
              hasSome: userInfo.user.roles,
            },
          },
          {
            userPermissions: {
              some: {
                id: userInfo.user.id,
              },
            },
          },
        ],
        createdById: { not: userInfo.user.id },
      },
    });

    return NextResponse.json(templates, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem retrieving the message templates',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/templates/[templateId]/reactivate/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import SlackClient, { TemplateAction } from '@/utils/clients/slack/slackClient';
import { MessageTemplateStatus, UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { templateId: string } }
) => {
  try {
    const templateId = params.templateId;

    if (!params.templateId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A templateId param is required.',
        reqUrl: request.url,
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [
        UserRole.CORTINA_SUPPORT,
        UserRole.PHYSICIAN,
        UserRole.PHYSICIAN_SUPPORT,
        UserRole.CORTINA_NURSE,
        UserRole.ADMIN,
      ],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const template = await prisma.messageTemplate.findUnique({
      where: {
        id: templateId,
      },
    });

    if (!template) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No template found with that id',
        reqUrl: request.url,
      });
    }

    // Only allow admins, cortina support, and the creator of the template to update it
    if (
      userInfo.user.roles.includes(UserRole.ADMIN) ||
      userInfo.user.roles.includes(UserRole.CORTINA_SUPPORT) ||
      template?.createdById === userInfo.user.id
    ) {
      await prisma.messageTemplate.update({
        where: {
          id: templateId,
        },
        data: {
          status: MessageTemplateStatus.ACTIVE,
        },
      });
    } else {
      return ApiErrorHandler.handleUnauthorizedError({
        message: 'You are not authorized to reactivate this message template',
        reqUrl: request.url,
      });
    }

    await SlackClient.logMessageTemplateAction(
      userInfo.user.id,
      template.id,
      template.title,
      template.complexityScore,
      `${userInfo.user.firstName} ${userInfo.user.lastName}`,
      TemplateAction.REACTIVATE
    );

    return NextResponse.json('Successfully reactivated', {
      status: HttpStatusCode.OK,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem reactivating the message template',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/templates/[templateId]/archive/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import SlackClient, { TemplateAction } from '@/utils/clients/slack/slackClient';
import { MessageTemplateStatus, UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { templateId: string } }
) => {
  try {
    const templateId = params.templateId;

    if (!params.templateId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A templateId param is required.',
        reqUrl: request.url,
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [
        UserRole.CORTINA_SUPPORT,
        UserRole.PHYSICIAN,
        UserRole.PHYSICIAN_SUPPORT,
        UserRole.CORTINA_NURSE,
        UserRole.ADMIN,
      ],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const template = await prisma.messageTemplate.findUnique({
      where: {
        id: templateId,
      },
    });

    if (!template) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No template found with that id',
        reqUrl: request.url,
      });
    }

    // Only allow admins, cortina support, and the creator of the template to archive it
    if (
      userInfo.user.roles.includes(UserRole.ADMIN) ||
      userInfo.user.roles.includes(UserRole.CORTINA_SUPPORT) ||
      template?.createdById === userInfo.user.id
    ) {
      await prisma.messageTemplate.update({
        where: {
          id: templateId,
        },
        data: {
          status: MessageTemplateStatus.ARCHIVED,
        },
      });
    } else {
      return ApiErrorHandler.handleUnauthorizedError({
        message: 'You are not authorized to archive this message template',
        reqUrl: request.url,
      });
    }

    await SlackClient.logMessageTemplateAction(
      userInfo.user.id,
      template.id,
      template.title,
      template.complexityScore,
      `${userInfo.user.firstName} ${userInfo.user.lastName}`,
      TemplateAction.ARCHIVE
    );

    return NextResponse.json('Successfully archived', {
      status: HttpStatusCode.OK,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem archiving the message template',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/templates/[templateId]/edit/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import SlackClient, { TemplateAction } from '@/utils/clients/slack/slackClient';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import {
  MessageTemplateCategory,
  MessageTemplateStatus,
  UserRole,
} from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const messageTemplateSchema = z.object({
  title: z.string(),
  body: z.string(),
  rolePermissions: z.array(z.nativeEnum(UserRole)).optional(),
  userPermissions: z.array(z.string()).optional(),
  category: z.array(z.nativeEnum(MessageTemplateCategory)).optional(),
  complexityScore: z.number().default(0),
  status: z.nativeEnum(MessageTemplateStatus).optional(),
  threadId: z.string(),
  assistantId: z.string(),
  acceptedSuggested: z.boolean().default(false),
});

type MessageTemplateCreateInput = z.output<typeof messageTemplateSchema>;

const PATCH = async (
  request: NextRequest,
  { params }: { params: { templateId: string } }
) => {
  try {
    const templateId = params.templateId;

    if (!params.templateId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'A templateId param is required.',
        reqUrl: request.url,
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [
        UserRole.CORTINA_SUPPORT,
        UserRole.PHYSICIAN,
        UserRole.PHYSICIAN_SUPPORT,
        UserRole.CORTINA_NURSE,
        UserRole.ADMIN,
      ],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const bodyResult = await getSafeRequestBody(request);

    if (!bodyResult.isValidJson) return bodyResult.badRequestResponse;

    const validBody = messageTemplateSchema.safeParse(bodyResult.jsonBody);

    if (!validBody.success) {
      return ApiErrorHandler.handleBadRequest({
        message: 'Invalid request body',
        reqUrl: request.url,
        error: validBody.error,
      });
    }

    const templateData = validBody.data as MessageTemplateCreateInput;

    const template = await prisma.messageTemplate.findUnique({
      where: {
        id: templateId,
      },
    });

    if (!template) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No template found with that id',
        reqUrl: request.url,
      });
    }

    let userPermissions = [];
    let rolePermissions: UserRole[] = [];

    // Only allow admin to specifiy other user/role permissions
    if (
      userInfo.user.roles.includes(UserRole.CORTINA_SUPPORT) ||
      userInfo.user.roles.includes(UserRole.ADMIN)
    ) {
      userPermissions = templateData.userPermissions ?? [];
      rolePermissions = templateData.rolePermissions ?? [];
    } else {
      userPermissions = [userInfo.user.id];
    }

    // Only allow admins, cortina support, and the creator of the template to edit it
    if (
      userInfo.user.roles.includes(UserRole.ADMIN) ||
      userInfo.user.roles.includes(UserRole.CORTINA_SUPPORT) ||
      template?.createdById === userInfo.user.id
    ) {
      await prisma.messageTemplate.update({
        where: {
          id: templateId,
        },
        data: {
          title: templateData.title,
          body: templateData.body,
          rolePermissions: rolePermissions,
          userPermissions: {
            set: userPermissions?.map((up) => ({ id: up })) ?? [],
          },
          category: templateData.category,
          complexityScore: templateData.complexityScore,
          status: templateData.status,
          assistantThreadId: templateData.threadId,
          reviewedById: templateData.assistantId,
          acceptedSuggested: templateData.acceptedSuggested,
        },
      });
    } else {
      return ApiErrorHandler.handleUnauthorizedError({
        message: 'You are not authorized to edit this message template',
        reqUrl: request.url,
      });
    }

    await SlackClient.logMessageTemplateAction(
      userInfo.user.id,
      template.id,
      template.title,
      template.complexityScore,
      `${userInfo.user.firstName} ${userInfo.user.lastName}`,
      TemplateAction.UPDATE
    );

    return NextResponse.json('Successfully edited', {
      status: HttpStatusCode.OK,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem editing the message template',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/templates/get-my-templates/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [
        UserRole.CORTINA_SUPPORT,
        UserRole.PHYSICIAN,
        UserRole.PHYSICIAN_SUPPORT,
        UserRole.CORTINA_NURSE,
        UserRole.ADMIN,
      ],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const templates = await prisma.messageTemplate.findMany({
      where: {
        createdBy: {
          id: userInfo.user.id,
        },
      },
      include: {
        createdBy: {
          select: {
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    return NextResponse.json(templates, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem retrieving the message templates',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/templates/add-template/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import SlackClient, { TemplateAction } from '@/utils/clients/slack/slackClient';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import {
  MessageTemplateCategory,
  MessageTemplateStatus,
  UserRole,
} from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const messageTemplateSchema = z.object({
  title: z.string(),
  body: z.string(),
  rolePermissions: z.array(z.nativeEnum(UserRole)).optional().nullable(),
  userPermissions: z.array(z.string()).optional().nullable(),
  category: z.array(z.nativeEnum(MessageTemplateCategory)).optional(),
  complexityScore: z.number().default(0),
  threadId: z.string(),
  assistantId: z.string(),
  acceptedSuggested: z.boolean().default(false),
});

type MessageTemplateCreateInput = z.output<typeof messageTemplateSchema>;

const POST = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [
        UserRole.CORTINA_SUPPORT,
        UserRole.PHYSICIAN,
        UserRole.PHYSICIAN_SUPPORT,
        UserRole.CORTINA_NURSE,
        UserRole.ADMIN,
      ],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const bodyResult = await getSafeRequestBody(request);

    if (!bodyResult.isValidJson) return bodyResult.badRequestResponse;

    const validBody = messageTemplateSchema.safeParse(bodyResult.jsonBody);

    if (!validBody.success) {
      return ApiErrorHandler.handleBadRequest({
        message: 'Invalid request body',
        reqUrl: request.url,
        error: validBody.error,
      });
    }

    const templateData = validBody.data as MessageTemplateCreateInput;

    let userPermissions = [];
    let rolePermissions: UserRole[] = [];

    // Only allow admin to specifiy other user/role permissions
    if (
      userInfo.user.roles.includes(UserRole.CORTINA_SUPPORT) ||
      userInfo.user.roles.includes(UserRole.ADMIN)
    ) {
      userPermissions = templateData.userPermissions ?? [];
      rolePermissions = templateData.rolePermissions ?? [];
    } else {
      userPermissions = [userInfo.user.id];
    }

    const template = await prisma.messageTemplate.create({
      data: {
        createdBy: {
          connect: {
            id: userInfo.user.id,
          },
        },
        title: templateData.title,
        body: templateData.body,
        rolePermissions: rolePermissions,
        userPermissions: {
          connect: userPermissions?.map((up) => ({ id: up })) ?? [],
        },
        category: templateData.category,
        complexityScore: templateData.complexityScore,
        status: MessageTemplateStatus.ACTIVE,
        assistantThreadId: templateData.threadId,
        reviewedById: templateData.assistantId,
        acceptedSuggested: templateData.acceptedSuggested,
      },
    });

    await SlackClient.logMessageTemplateAction(
      userInfo.user.id,
      template.id,
      template.title,
      template.complexityScore,
      `${userInfo.user.firstName} ${userInfo.user.lastName}`,
      TemplateAction.CREATE
    );

    return NextResponse.json(template, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem adding the message template',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/templates/review/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { z } from 'zod';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { parseJSONOrDefault } from '@/utils/utils';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const messageReviewSchema = z.object({
  message: z.string(),
});

type MessageReviewInput = z.output<typeof messageReviewSchema>;

const openai = new OpenAI({
  apiKey: `${process.env.OPEN_AI_API_KEY}`,
  organization: `${process.env.OPEN_AI_ORG}`,
});

const findOrCreateAssistantThread = async (
  existingThreadId?: string | null
) => {
  if (existingThreadId) {
    try {
      const existingThread = await openai.beta.threads.retrieve(
        existingThreadId
      );

      // If the thread exists, return it else continue to create a new thread
      if (existingThread.id) {
        return { assistantThread: existingThread, isContinuation: true };
      }
    } catch (error) {
      return {
        assistantThread: await openai.beta.threads.create(),
        isContinuation: false,
      };
    }
  }

  return {
    assistantThread: await openai.beta.threads.create(),
    continuation: false,
  };
};

const POST = async (request: NextRequest) => {
  const headerList = headers();
  const existingThreadId = headerList.get('threadId');

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [
        UserRole.CORTINA_SUPPORT,
        UserRole.PHYSICIAN,
        UserRole.PHYSICIAN_SUPPORT,
        UserRole.CORTINA_NURSE,
        UserRole.ADMIN,
      ],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const bodyResult = await getSafeRequestBody(request);

    if (!bodyResult.isValidJson) return bodyResult.badRequestResponse;

    const validBody = messageReviewSchema.safeParse(bodyResult.jsonBody);

    if (!validBody.success) {
      return ApiErrorHandler.handleBadRequest({
        message: 'Invalid request body. Must send message to review.',
        reqUrl: request.url,
        error: validBody.error,
      });
    }

    const { message } = validBody.data as MessageReviewInput;

    const { assistantThread, isContinuation } =
      await findOrCreateAssistantThread(existingThreadId);

    await openai.beta.threads.messages.create(assistantThread.id, {
      role: 'user',
      content: message,
    });

    const runOptions: OpenAI.Beta.Threads.Runs.RunCreateParamsNonStreaming = {
      assistant_id: `${process.env.TEMPLATE_REVIEW_OPEN_AI_ASSISTANT}`,
    };

    // If the thread is a continuation, add additional instructions
    if (isContinuation) {
      runOptions.additional_instructions =
        'The user has modified the message. Please review the updated message.';
    }

    const run = await openai.beta.threads.runs.createAndPoll(
      assistantThread.id,
      runOptions
    );

    if (run.status === 'completed') {
      const messages = await openai.beta.threads.messages.list(run.thread_id);
      const reply = messages.data[0].content[0];
      if (reply.type === 'text') {
        const parsedReply = parseJSONOrDefault(reply.text.value, {});
        return NextResponse.json(
          {
            ...parsedReply,
            threadId: assistantThread.id,
            assistantId: run.assistant_id,
          },
          {
            status: HttpStatusCode.OK,
          }
        );
      }
    } else {
      throw new Error(run.last_error?.message || 'An error occurred');
    }
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem reviewing the message template',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/case/route.ts

/* eslint-disable complexity */
import { NextRequest, NextResponse } from 'next/server';
import {
  FormAnswerTypeSchema,
  InputJsonValueSchema,
} from 'prisma/generated/zod';
import { z } from 'zod';

import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import SlackClient from '@/utils/clients/slack/slackClient';
import { transformUploadToMediaType } from '@/utils/file-upload/upload-helpers';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserEventNames } from '@/utils/user-events/enums';
import UserEventsClient from '@/utils/user-events/user-events-client';
import { prisma } from '@clients/mongo/prismaClient';
import {
  Case,
  CaseStatus,
  Media,
  MessageStatus,
  ThreadAction,
  ThreadStatus,
  ThreadType,
  UserRole,
} from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';
import { redeemConsultation } from '@utils/helpers/helpers';

const typesToCoerceToString = z.union([z.string(), z.number(), z.boolean()]);

const stringCoercion = typesToCoerceToString
  .transform((val) => {
    return String(val);
  })
  .pipe(z.coerce.string())
  .refine(
    (val) => {
      return typeof val === 'string';
    },
    { message: 'Coercion to string failed' }
  );

const pharmacySchema = z.object({
  PharmacyId: z.number(),
});

const intakeFormSchema = z.object({
  intakeFormID: z.string(),
  questions: z
    .object({
      question: z.string(),
      answerSingle: stringCoercion.optional().nullable(),
      answerObject: InputJsonValueSchema.optional().nullable(),
      answerArray: stringCoercion.array().optional(),
      answerObjects: InputJsonValueSchema.array().optional(),
      answerType: FormAnswerTypeSchema,
    })
    .array(),
});

const fileUploadSchema = z.object({
  id: z.string().optional(),
  file: z.any().optional(),
  size: z.number().optional(),
  name: z.string().optional(),
  type: z.string().optional(),
  status: z.string().optional(),
  s3Url: z.string().optional(),
});

const caseFormSchema = z.object({
  complaint: z.string().optional(),
  intakeForm: intakeFormSchema.optional(),
  doctorMessage: z.string().optional(),
  conditionMedia: z.array(fileUploadSchema).optional(),
  patientMedia: z.array(fileUploadSchema).optional(),
  selectedPharmacy: pharmacySchema,
  caseId: z.string().optional(),
});

type CaseFormSubmission = z.output<typeof caseFormSchema>;
type IntakeForm = z.output<typeof intakeFormSchema>;

async function addIntakeFormToCase(
  caseId: string,
  intakeForm: IntakeForm
): Promise<Case> {
  return await prisma.case.update({
    where: {
      id: caseId,
    },
    data: {
      intakeForm: {
        formId: intakeForm.intakeFormID,
        questions: intakeForm.questions,
      },
    },
  });
}

const updateUserMedia = async (userId: string, patientMedia: Media[]) => {
  if (patientMedia.length > 0) {
    await prisma.user.update({
      where: {
        id: userId,
      },
      data: {
        media: patientMedia,
      },
    });
  }
};

const POST = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PATIENT],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const bodyResult = await getSafeRequestBody(request);

    if (!bodyResult.isValidJson) return bodyResult.badRequestResponse;

    const validBody = caseFormSchema.safeParse(bodyResult.jsonBody);

    if (!validBody.success) {
      return ApiErrorHandler.handleBadRequest({
        message: 'Invalid request body',
        reqUrl: request.url,
        error: validBody.error,
      });
    }

    const caseInput = validBody.data as CaseFormSubmission;

    const conditionMedia = transformUploadToMediaType(
      caseInput.conditionMedia as any[]
    );

    const patientMedia = transformUploadToMediaType(
      caseInput.patientMedia as any[]
    );

    await updateUserMedia(userInfo.user.id, patientMedia);

    if (!caseInput.caseId && caseInput.complaint) {
      // Redeem a consultation if this is a new case
      const availableConsultationId = await redeemConsultation(userInfo.user);

      const caseStatus = availableConsultationId
        ? CaseStatus.OPEN
        : CaseStatus.PREPAYMENT;

      let newCase = await prisma.case.create({
        data: {
          complaint: caseInput.complaint,
          userId: userInfo.user.id,
          status: caseStatus,
          redeemedProductId: availableConsultationId ?? null,
          media: conditionMedia,
          thread: {
            create: [
              {
                user: { connect: { id: userInfo.user.id } },
                type: ThreadType.MEDICAL,
                messages: {
                  create: [
                    {
                      fromUserId: userInfo.user.id,
                      status: MessageStatus.SENT,
                      content: caseInput.doctorMessage ?? "I'm ready to chat!",
                      sentWhen: new Date(Date.now()),
                      readByIds: {
                        set: [userInfo.user.id],
                      },
                    },
                  ],
                },
                lastMessageDate: new Date(Date.now()),
                status: ThreadStatus.ACTIVE,
                history: {
                  create: {
                    triggeredById: userInfo.user.id,
                    statusTo: ThreadStatus.ACTIVE,
                    action: ThreadAction.CREATED,
                  },
                },
              },
            ],
          },
        },
      });

      if (caseInput.intakeForm) {
        newCase = await addIntakeFormToCase(newCase.id, caseInput.intakeForm);
      }

      if (userInfo.user.dosespotId) {
        // Add the default pharmacy for the user
        await DosespotClient.addPatientPharmacy(
          userInfo.user.dosespotId,
          process.env.DEFAULT_PHARMACY_ID || '14973'
        );
      }

      if (caseInput.selectedPharmacy && userInfo.user.dosespotId) {
        await DosespotClient.addPatientPharmacy(
          userInfo.user.dosespotId,
          caseInput.selectedPharmacy.PharmacyId.toString()
        );
      }

      if (caseInput.complaint)
        await UserEventsClient.addEvent(
          userInfo.user,
          UserEventNames.DERMI_COMPLAINT_PREFIX + caseInput.complaint,
          {}
        );

      if (caseStatus === CaseStatus.PREPAYMENT) {
        await UserEventsClient.addEvent(
          userInfo.user,
          UserEventNames.DERMI_CASE_SUBMITTED_IN_PREPAYMENT,
          {}
        );
      } else {
        await UserEventsClient.addEvent(
          userInfo.user,
          UserEventNames.DERMI_CASE_SUBMITTED,
          {}
        );
      }

      if (process.env.ENVIRONMENT_NAME === 'production')
        await SlackClient.logNewCase(userInfo.user.email ?? 'unknown email');

      // Everything was successful clear users form data
      await prisma.formData.updateMany({
        where: {
          userId: { equals: userInfo.user.id },
        },
        data: {
          archived: true,
        },
      });

      return NextResponse.json(newCase, { status: 200 });
    } else if (caseInput.caseId) {
      let updatedCase = null;

      if (caseInput.complaint) {
        const updateData: any = {
          complaint: caseInput.complaint,
        };

        if (conditionMedia.length > 0) {
          updateData.media = conditionMedia;
        }

        updatedCase = await prisma.case.update({
          where: {
            id: caseInput.caseId,
          },
          data: updateData,
        });
      }

      if (caseInput.intakeForm) {
        updatedCase = await addIntakeFormToCase(
          caseInput.caseId,
          caseInput.intakeForm
        );
      }

      await UserEventsClient.addEvent(
        userInfo.user,
        UserEventNames.DERMI_CASE_UPDATED,
        {}
      );

      return NextResponse.json(updatedCase, { status: 200 });
    } else {
      return ApiErrorHandler.handleBadRequest({
        message: 'No valid arguments provided',
        reqUrl: request.url,
      });
    }
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem posting the case',
      reqUrl: request.url,
      error: error,
    });
  }
};

const GET = async (request: NextRequest) => {
  try {
    const { searchParams } = new URL(request.url);
    const caseId = searchParams.get('caseId');

    if (!caseId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No case Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PATIENT, UserRole.PHYSICIAN, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const returnedCase = await prisma.case.findUnique({
      where: {
        id: caseId,
      },
    });

    // Only can get your own case if you are a patient
    if (
      userInfo.user.roles.includes(UserRole.PATIENT) &&
      userInfo.user.id != returnedCase?.userId
    ) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No case found with this ID',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    return NextResponse.json(returnedCase, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the case',
      reqUrl: request.url,
      error: error,
    });
  }
};

async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, GET, POST' } });
}

export { GET, OPTIONS, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/case/[caseId]/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const GET = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
) => {
  try {
    const caseId = params.caseId;

    if (!caseId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No case Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PATIENT, UserRole.PHYSICIAN, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const returnedCase = await prisma.case.findUnique({
      where: {
        id: caseId,
      },
      include: {
        user: true,
        physician: true,
      },
    });

    // Only can get your own case if you are a patient
    if (
      userInfo.user.roles.includes(UserRole.PATIENT) &&
      userInfo.user.id != returnedCase?.userId
    ) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No case found with this ID',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    return NextResponse.json(returnedCase, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the case',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/case/[caseId]/treatment-plan/route.ts

import { NextRequest, NextResponse } from 'next/server';

import {
  ExtendedUser,
  UserPrescriptionWithPharmacy,
  UserPrescriptionsWithProduct,
} from '@/app/shared/types';
import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import { reconcileUserPrescriptionsWithDosespotPrescriptions } from '@/utils/clients/dosespot/dosespotUtils';
import SlackClient from '@/utils/clients/slack/slackClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import {
  Product,
  SubscriptionProduct,
  UserPrescriptions,
  UserRole,
} from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

interface TreatmentPlan {
  OTCProducts: Product[];
  OTCSubscriptionProducts: SubscriptionProduct[];
  cortinaRxPrescriptions: UserPrescriptions[];
  genericPrescriptions: UserPrescriptions[];
}

const GET = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
) => {
  const userInfo = await getUserAndCheckAuthorized({
    request: request,
    roleAccess: [UserRole.PATIENT, UserRole.PHYSICIAN, UserRole.ADMIN],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  try {
    const caseId = params.caseId;

    if (!caseId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No case Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const returnedCase = await prisma.case.findUnique({
      where: {
        id: caseId,
      },
      include: {
        user: true,
      },
    });

    if (
      !returnedCase ||
      (userInfo.user.roles.includes(UserRole.PATIENT) &&
        userInfo.user.id !== returnedCase?.userId)
    ) {
      throw new Error('User does have access to this case');
    }

    // Reconcile User Prescriptions
    const returnedUserPrescriptions =
      await reconcileUserPrescriptionsWithDosespotPrescriptions(
        returnedCase.user
      );

    //TODO: How do we want to load OTC Products?
    const OTCProducts: Product[] = [];
    const OTCSubscriptionProducts: SubscriptionProduct[] = [];

    const genericPrescriptions: UserPrescriptionsWithProduct[] = [];
    const cortinaRxPrescriptions: UserPrescriptionsWithProduct[] = [];
    for (const prescription of returnedUserPrescriptions) {
      if (prescription.caseId === caseId) {
        if (!prescription.productId && !prescription.subscriptionProductId) {
          genericPrescriptions.push(prescription);
        } else {
          cortinaRxPrescriptions.push(prescription);
        }
      }
    }

    for (const prescription of genericPrescriptions) {
      if (prescription.pharmacyId) {
        const pharmacy = await DosespotClient.getPharmacyById(
          prescription.pharmacyId
        );
        (prescription as UserPrescriptionWithPharmacy).pharmacy = pharmacy;
      }
    }

    const treatmentPlanToReturn: TreatmentPlan = {
      OTCProducts,
      OTCSubscriptionProducts,
      cortinaRxPrescriptions,
      genericPrescriptions:
        genericPrescriptions as UserPrescriptionWithPharmacy[],
    };

    return NextResponse.json(treatmentPlanToReturn, { status: 200 });
  } catch (error) {
    const typedError = error as Error;

    const pharmacyIssueRegex = /PharmacyID.*?is\s*inactive/;

    if (pharmacyIssueRegex.test(typedError.message))
      await SlackClient.logHighPriorityIssues(
        userInfo.user as ExtendedUser,
        'Error occurred when retrieving user treatment plan',
        (error as Error).message,
        { 'Case ID': params.caseId }
      );

    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the treatment plan',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/case/[caseId]/prescription/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { CreateUserPrescriptionSchema } from 'prisma/custom-schemas/addPrescription';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const GET = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
) => {
  try {
    const caseId = params.caseId;

    if (!caseId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No case Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PATIENT, UserRole.PHYSICIAN, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    // TODO: After we get Dosespot up, need to reconcile user prescriptions and grab user prescription object to make products and subscription products
    const userPrescriptions = await prisma.userPrescriptions.findMany({
      where: {
        caseId: caseId,
      },
      include: {
        product: true,
      },
    });

    return NextResponse.json(userPrescriptions, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the treatment plan',
      reqUrl: request.url,
      error: error,
    });
  }
};

const POST = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const caseId = params.caseId;

    if (!caseId) {
      return ApiErrorHandler.handleBadRequest({
        message: 'No case Id sent with request',
        reqUrl: request.url,
        reqHeaders: request.headers,
      });
    }

    const validatedBody = CreateUserPrescriptionSchema.parse(safeBody.jsonBody);

    const newPrescription = await prisma.userPrescriptions.create({
      data: {
        ...validatedBody,
        case: {
          connect: {
            id: caseId,
          },
        },
        user: {
          connect: {
            id: userInfo.user.id,
          },
        },
        productId: undefined,
        subscriptionProductId: undefined,
      },
    });

    return NextResponse.json(newPrescription, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem creating the prescription',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/case/[caseId]/diagnose/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { prisma } from '@clients/mongo/prismaClient';
import { CaseStatus, UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

const diagnosisInputSchema = z.object({
  diagnosisICD10Code: z.string(),
  diagnosisICD10Name: z.string(),
});

type DiagnosisInput = z.infer<typeof diagnosisInputSchema>;

const POST = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
) => {
  const safeBody = await getSafeTypedBody<DiagnosisInput>(
    request,
    diagnosisInputSchema
  );

  if (!safeBody.success) return safeBody.errorResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const diagnosisInput = safeBody.value;

    // diagnosedAt is necessary for tracking reporting metrics
    // below keeps the diagnosedAt date from being overwritten once its been set
    const existingCase = await prisma.case.findUnique({
      where: {
        id: params.caseId,
      },
    });
    const diagnosedAt = existingCase?.diagnosedAt
      ? {}
      : { diagnosedAt: new Date() };

    const diagnosedCase = await prisma.case.update({
      where: {
        id: params.caseId,
      },
      data: {
        ...diagnosedAt, // Only include diagnosedAt if it's not already set
        diagnosisICD: diagnosisInput.diagnosisICD10Code,
        diagnosisName: diagnosisInput.diagnosisICD10Name,
        physicianId: userInfo.user.id,
        status: CaseStatus.DIAGNOSED_NO_PRESCRIPTION,
      },
    });

    return NextResponse.json(diagnosedCase, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem diagnosing the case',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/case/[caseId]/diagnosis-message/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { prisma } from '@clients/mongo/prismaClient';
import { MessageStatus, ThreadType, UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';

interface diagnosisMessageInput {
  diagnosisMessage: string;
}

const POST = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
) => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const diagnosisInput: diagnosisMessageInput =
      safeBody.jsonBody as diagnosisMessageInput;

    if (diagnosisInput.diagnosisMessage) {
      const diagnosedCase = await prisma.case.update({
        where: {
          id: params.caseId,
        },
        data: {
          diagnosisMessage: diagnosisInput.diagnosisMessage,
          physicianId: userInfo.user.id,
        },
        include: {
          thread: true,
        },
      });

      if (diagnosedCase) {
        await prisma.thread.update({
          where: {
            id: diagnosedCase.thread.find((t) => t.type === ThreadType.MEDICAL)
              ?.id,
          },
          data: {
            messages: {
              create: {
                sentWhen: new Date(),
                content: diagnosisInput.diagnosisMessage,
                status: MessageStatus.SENT,
                fromUserId: userInfo.user.id,
              },
            },
          },
        });
      }

      return NextResponse.json(diagnosedCase, { status: 200 });
    } else {
      return ApiErrorHandler.handleBadRequest({
        message: 'No valid arguments provided',
        reqUrl: request.url,
      });
    }
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem adding diagnosis message to case',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/case/[caseId]/assign/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { casePrismaClient } from '@/app/shared/models/extensions/cases';
import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { CaseStatus, UserRole } from '@prisma/client';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
): Promise<NextResponse> => {
  const userInfo = await getUserAndCheckAuthorized({
    request: request,
    roleAccess: [UserRole.PHYSICIAN, UserRole.PHYSICIAN_SUPPORT],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  try {
    const { caseId } = params;

    const caseLookup = await prisma.case.findUnique({
      where: {
        id: caseId,
      },
      include: {
        thread: true,
      },
    });

    if (!caseLookup)
      return ApiErrorHandler.handleBadRequest({
        reqUrl: request.url,
        reqHeaders: request.headers,
        message: `Case with id ${caseId} was not found or you do not have access to it.`,
      });

    if (caseLookup.physicianId && caseLookup.physicianId !== userInfo.user.id) {
      return ApiErrorHandler.handleBadRequest({
        reqUrl: request.url,
        reqHeaders: request.headers,
        message: `Case with id ${caseId} is already assigned to another physician.`,
      });
    }

    const updatedCase = await casePrismaClient.case.update({
      where: { id: caseId },
      data: {
        status: CaseStatus.ASSIGNED,
        physicianId: userInfo.user.id,
        assignedAt: new Date(),
        thread: {
          update: {
            where: {
              id: caseLookup.thread[0].id,
            },
            data: {
              participants: {},
            },
          },
        },
      },
    });

    if (!updatedCase)
      return ApiErrorHandler.handleCatchAllError({
        error: `Case with id ${caseId} could not be updated.`,
        reqUrl: request.url,
        reqHeaders: request.headers,
        code: HttpStatusCode.INTERNAL_SERVER_ERROR,
      });

    await messagingClient.thread.addParticipant(
      userInfo.user.id,
      caseLookup.thread[0].id,
      userInfo.user
    );

    return NextResponse.json(updatedCase, { status: HttpStatusCode.OK });
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/case/[caseId]/generate-report/route.ts

import dayjs from 'dayjs';
import { readFileSync } from 'fs';
import { NextRequest, NextResponse } from 'next/server';
import path from 'path';
import { PDFDocument } from 'pdf-lib';

import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getS3Url } from '@/utils/file-upload/file-upload';
import { getFullName } from '@/utils/get-full-name';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { S3Client } from '@aws-sdk/client-s3';
import { UserRole } from '@prisma/client';

const s3 = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.PROFILE_AVATAR_AWS_ACCESS_KEY as string,
    secretAccessKey: process.env.PROFILE_AVATAR_SECRET_ACCESS_KEY as string,
  },
});

const GENERIC_AVATAR =
  'https://images.prismic.io/dermi/0e07f607-ce8b-4809-9d67-901472233c9d_medical-badge.png?auto=compress,format&w=50&h=50';

const getPhysicianAvatar = async (url?: string | null) => {
  if (!url) {
    return {
      imageType: 'png',
      avatarUrl: GENERIC_AVATAR,
    };
  }

  const ext = url.split('.').pop()?.toLowerCase() ?? '';
  const isJPG = ['jpg', 'jpeg'].includes(ext);
  const isPNG = ext === 'png';

  const type = isJPG ? 'jpg' : isPNG ? 'png' : 'unknown';

  const { s3Url } = await getS3Url({
    mediaUrl: url,
    expiresIn: 60,
    s3Client: s3,
    source: 'get_physician_avatar',
  });

  return {
    avatarUrl: s3Url ?? GENERIC_AVATAR,
    imageType: s3Url ? type : 'png',
  };
};

const GET = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
): Promise<NextResponse> => {
  const userInfo = await getUserAndCheckAuthorized({
    request: request,
    roleAccess: [
      UserRole.PATIENT,
      UserRole.ADMIN,
      UserRole.PHYSICIAN,
      UserRole.PHYSICIAN_SUPPORT,
    ],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;
  const user = userInfo.user;

  try {
    // LOAD TEMPLATE FILE
    const pdfPath = path.join(
      process.cwd(),
      'public',
      'templates',
      'Cortina-ConsultationReport.pdf'
    );
    const pdfBuffer = readFileSync(pdfPath);
    const pdfDoc = await PDFDocument.load(pdfBuffer);

    // GET THE DATA FOR THE PDF
    const { caseId } = params;

    const caseLookup = await prisma.case.findUnique({
      where: {
        id: caseId,
      },
      include: {
        physician: true,
      },
    });

    if (!caseLookup)
      return ApiErrorHandler.handleBadRequest({
        reqUrl: request.url,
        reqHeaders: request.headers,
        message: `Case with id ${caseId} was not found or you do not have access to it.`,
      });

    // Get physician profile image
    const { imageType, avatarUrl } = await getPhysicianAvatar(
      caseLookup.physician?.avatarUrl
    );

    const imageBuffer = await fetch(avatarUrl).then((res) => res.arrayBuffer());

    let pdfImage;

    if (imageType === 'jpg') {
      pdfImage = await pdfDoc.embedJpg(imageBuffer);
    } else if (imageType === 'png') {
      pdfImage = await pdfDoc.embedPng(imageBuffer);
    }

    // Get prescriptions from dosespot
    const dosespotPrescriptions = await DosespotClient.getPrescriptionsByUser(
      user
    );

    // Get medications and allergies from dosespot
    const medicationsAndAllergies =
      await DosespotClient.getAllergiesAndMedicationsForUser(user);

    const medications = medicationsAndAllergies.medications.map((m) => m.Name);
    const allergies = medicationsAndAllergies.allergies.map((m) => m.Name);

    // Format user fields
    const patientName = getFullName(
      user.firstName,
      user.lastName,
      'Cortina Patient'
    );

    const address = user.addresses?.find?.((a) => !!a.default);

    const formattedAddress = address
      ? `${address.address1}, ${address.city}, ${address.state} ${address.zip}`
      : 'N/A';
    const physicianName = getFullName(
      `Dr. ${caseLookup.physician?.firstName}`,
      caseLookup.physician?.lastName,
      'Cortina Physician'
    );

    // SET THE DATA FOR THE PDF
    const form = pdfDoc.getForm();

    const setText = (fieldName: string, value: string) => {
      form.getTextField(fieldName).setText(value);
    };

    if (pdfImage) {
      form.getButton('Physician Image_af_image').setImage(pdfImage);
    }

    setText('Patient Name', patientName);
    setText('Physician Name', physicianName);
    setText(
      'DOB',
      user.medicalProfile?.dob
        ? dayjs(user.medicalProfile.dob).format('MM/DD/YYYY')
        : 'N/A'
    );
    setText('Sex at Birth', `${user.medicalProfile?.sexAtBirth}`);
    setText('Email', `${user.email}`);
    setText('Phone Number', `${user.phoneNumber}`);
    setText('Address', formattedAddress);
    setText('Medical Condition', `${user.medicalProfile?.medicalConditions}`);
    setText('Skin Type', `${user.medicalProfile?.skinType}`);
    setText('Skin Profile', `${user.medicalProfile?.skinProfile}`);
    setText('Diagnosis', `ICD-10: ${caseLookup.diagnosisICD}`);
    setText('Diagnosis Message', `${caseLookup.diagnosisMessage ?? 'N/A'}`);
    setText(
      'Submitted On',
      `${dayjs(caseLookup.submittedAt ?? caseLookup.createdAt).format(
        'MM/DD/YYYY'
      )}`
    );
    setText(`Medications`, `${medications.join(', ')}`);
    setText(`Allergies`, `${allergies.join(', ')}`);

    dosespotPrescriptions.forEach((dosespotPrescription, i) => {
      setText(`Medication ${i + 1}`, `${dosespotPrescription.DisplayName}`);
      setText(
        `Dispense ${i + 1}`,
        `${dosespotPrescription.Quantity} ${dosespotPrescription.DispenseUnitDescription}`
      );
      setText(
        `Dispense Date ${i + 1}`,
        `${
          dosespotPrescription.EffectiveDate
            ? dayjs(dosespotPrescription.EffectiveDate).format('MM/DD/YYYY')
            : 'N/A'
        }`
      );
      setText(
        `Dispensings ${i + 1}`,
        `${dosespotPrescription.DaysSupply} Day Supply`
      );
    });

    form.flatten();

    // Serialize the PDFDocument to bytes (a Uint8Array)
    const pdfBytes = await pdfDoc.save();

    return new NextResponse(pdfBytes, {
      headers: { 'Content-Type': 'application/pdf' },
      status: HttpStatusCode.OK,
    });
  } catch (e) {
    return ApiErrorHandler.handleServerError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
      message: 'Error generating report',
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/case/[caseId]/finalize/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserEventNames } from '@/utils/user-events/enums';
import UserEventsClient from '@/utils/user-events/user-events-client';
import { prisma } from '@clients/mongo/prismaClient';
import { CaseStatus, UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';
import { postMessageToCaseFromUser } from '@utils/helpers/helpers';

const POST = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const safeBody = await getSafeRequestBody(request);
    if (!safeBody.isValidJson) return safeBody.badRequestResponse;

    const diagnosisMessage =
      safeBody.jsonBody?.diagnosisMsg?.diagnosisMessage ?? '';

    const diagnosedCase = await prisma.case.update({
      where: {
        id: params.caseId,
      },
      data: {
        physicianId: userInfo.user.id,
        status: CaseStatus.PHYSICIAN_FINALIZED,
        diagnosisMessage: diagnosisMessage,
      },
      include: {
        user: true,
        thread: true,
      },
    });

    await postMessageToCaseFromUser(
      diagnosedCase,
      diagnosedCase.thread,
      diagnosisMessage,
      userInfo.user
    );

    await UserEventsClient.addEvent(
      diagnosedCase.user,
      UserEventNames.DERMI_CASE_DIAGNOSED,
      {}
    );

    return NextResponse.json(diagnosedCase, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem finalizing the case',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/case/[caseId]/on-prescribe-next/route.ts

// Check Prescriptions
import { NextRequest, NextResponse } from 'next/server';

import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import {
  PrescriptionResultWithPharmacyPhysician,
  PrescriptionStatusType,
} from '@/utils/clients/dosespot/dosespotTypes';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';

interface CasePrescriptionResponse {
  goodPrescriptions: PrescriptionResultWithPharmacyPhysician[];
  badPrescriptions: BadPrescriptionItem[];
  allowedToProceed: boolean;
}
interface BadPrescriptionItem {
  prescription: PrescriptionResultWithPharmacyPhysician;
  issues: string[];
}

const GET = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const casePrescriptions: PrescriptionResultWithPharmacyPhysician[] =
      await DosespotClient.getPrescriptionsByCaseAndUser(
        params.caseId,
        userInfo.user
      );

    const mappedCasePrescriptions: CasePrescriptionResponse = {
      goodPrescriptions: [],
      badPrescriptions: [],
      allowedToProceed: true,
    };

    for (const cp of casePrescriptions) {
      const issues = checkPrescriptions(cp);

      if (issues.length > 0) {
        mappedCasePrescriptions.badPrescriptions.push({
          prescription: cp,
          issues,
        });

        mappedCasePrescriptions.allowedToProceed = false;
      } else {
        mappedCasePrescriptions.goodPrescriptions.push(cp);
      }
    }

    return NextResponse.json(mappedCasePrescriptions);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error occurred while checking the prescription.',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error,
    });
  }
};

const checkPrescriptions = (
  prescription: PrescriptionResultWithPharmacyPhysician
): string[] => {
  const issues: string[] = [];

  if (prescription.Status === PrescriptionStatusType.Entered)
    issues.push('Prescription has not been sent to the pharmacy.');
  if (prescription.Status === PrescriptionStatusType.EpcsError)
    issues.push('Prescription has an EPCS error.');

  return issues;
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/case/consultations-available/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { getFamilyIDs } from '@/utils/dependents/dependentUsersUtilities';
import { prisma } from '@clients/mongo/prismaClient';
import { CartProducts, Case, ProductCategories } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const userIds = await getFamilyIDs(userInfo.user);

    const familyOrders = await prisma.order.findMany({
      where: { userId: { in: userIds } },
      select: {
        id: true,
        cartProducts: {
          include: {
            product: {
              select: {
                category: true,
              },
            },
            case: true,
          },
        },
      },
    });

    const foundConsultations = familyOrders.reduce<
      (CartProducts & { case: Case[] })[]
    >((acc, curr) => {
      const consultation = curr.cartProducts.find(
        (cp) => cp.product.category === ProductCategories.CONSULTATION
      );

      if (consultation) acc.push(consultation);

      return acc;
    }, []);

    let consultationsAvailable = 0;
    for (let i = 0; i < foundConsultations.length; i++) {
      consultationsAvailable +=
        foundConsultations[i].quantity - foundConsultations[i].case.length;
    }

    return NextResponse.json(
      {
        consultationsAvailable: consultationsAvailable,
      },
      { status: 200 }
    );
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem counting available consultations',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/preview/route.ts

import { draftMode } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { redirectToPreviewURL } from '@prismicio/next';

import { createClient } from '../../../prismicio';

/**
 * Enables preview mode for prismic.
 * Updated function from prismic docs to *always* return a Response object.
 */
export async function GET(request: NextRequest) {
  const client = createClient();

  draftMode().enable();

  await redirectToPreviewURL({ client, request });

  return NextResponse.json('preview mode enabled');
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/maintenance/user/[userId]/unset-read-by-ids/route.ts

import { ObjectId } from 'mongodb';
import { NextRequest, NextResponse } from 'next/server';

import { updateCollectionData } from '@/utils/clients/mongo/mongoClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const DELETE = async (
  request: NextRequest,
  { params: { userId } }: { params: { userId: string } }
) => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  try {
    const updateResult = await updateCollectionData(
      'User',
      true,
      { _id: new ObjectId(userId) },
      {
        $unset: {
          readMessageIds: '',
        },
      }
    );

    return NextResponse.json(updateResult, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Failed to remove users readMessageIds',
      reqUrl: request.url,
      error,
      additionalContext: {},
    });
  }
};

export { DELETE };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/maintenance/user/prune-anonymous-users/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { userPrismaClient } from '@/app/shared/models/extensions/identity';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const MAX_ABANDONED_USER_AGE =
  parseInt(String(process.env.MAX_ABANDONED_USER_AGE), 10) ||
  1000 * 60 * 60 * 24 * 90;

const DELETE = async (request: NextRequest): Promise<NextResponse> => {
  const userResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  const count = parseInt(request.nextUrl.searchParams.get('count') ?? 'NaN');

  if (!count || Number.isNaN(count))
    return ApiErrorHandler.handleBadRequest({
      message: 'Missing or invalid count',
      reqUrl: request.url,
      additionalContext: {},
    });

  try {
    const usersToDelete = await userPrismaClient.user.findMany({
      where: {
        OR: [
          {
            email: {
              isSet: false,
            },
          },
          { email: null },
        ],
        createdAt: {
          lte: new Date(Date.now() - MAX_ABANDONED_USER_AGE),
        },
      },
      orderBy: {
        createdAt: 'asc',
      },
      take: count,
      select: {
        id: true,
        cart: {
          select: {
            id: true,
          },
        },
      },
    });

    const deletedUsers = await userPrismaClient.user.deleteMany({
      where: {
        id: {
          in: usersToDelete.map((user) => user.id),
        },
      },
    });

    return NextResponse.json(deletedUsers, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Failed to remove users readMessageIds',
      reqUrl: request.url,
      error,
      additionalContext: {},
    });
  }
};

export { DELETE };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/slack/interactivity-handler/route.ts

import * as crypto from 'crypto';
import { now } from 'moment';
import { NextRequest, NextResponse } from 'next/server';

import { ApiErrorHandler } from '@/utils/errors';

const POST = async (request: NextRequest) => {
  const requestBodyText = await request.text();

  try {
    const isValidSlackRequest = await validateSlackRequest(
      request,
      requestBodyText
    );
    if (!isValidSlackRequest.success) return isValidSlackRequest.response;

    const formData = await request.formData();

    const payload = formData.get('payload');

    if (!payload)
      return ApiErrorHandler.handleBadRequest({
        message: 'slack_interactivity_missing_payload',
        reqUrl: request.url,
        additionalContext: { formData },
      });

    const jsonBody = JSON.parse(payload.toString());

    //TODO: do something with the payload when actually using interactivity

    return NextResponse.json({}, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message:
        'An error occurred trying to process an interactivity request from slack.',
      reqUrl: request.url,
      error,
      reqBody: requestBodyText,
      reqHeaders: request.headers,
    });
  }
};

type SlackValidationResult =
  | {
      success: true;
    }
  | {
      success: false;
      response: NextResponse;
    };

const validateSlackRequest = async (
  request: NextRequest,
  requestBodyText: string
): Promise<SlackValidationResult> => {
  try {
    const slackSigningSecret = process.env.SLACK_CORTINABOT_SIGNING_SECRET;

    if (!slackSigningSecret)
      return {
        success: false,
        response: ApiErrorHandler.handleServerError({
          message: 'Missing SLACK_CORTINABOT_SIGNING_SECRET',
          reqUrl: request.url,
          reqBody: requestBodyText,
          reqHeaders: request.headers,
        }),
      };

    const stringTimestamp = request.headers.get('X-Slack-Request-Timestamp');
    const slackSignature = request.headers.get('x-slack-signature');

    if (!stringTimestamp || !slackSignature)
      return {
        success: false,
        response: ApiErrorHandler.handleBadRequest({
          message: 'Missing timestamp or signature from request',
          reqUrl: request.url,
          reqBody: requestBodyText,
          reqHeaders: request.headers,
        }),
      };

    const timestamp = parseInt(stringTimestamp);

    if (Math.floor(now() / 1000) - timestamp > 60 * 5)
      return {
        success: false,
        response: ApiErrorHandler.handleBadRequest({
          message: 'Request too old, could be replay attack.',
          reqUrl: request.url,
          reqBody: requestBodyText,
          reqHeaders: request.headers,
        }),
      };

    const signatureBaseString = 'v0:' + timestamp + ':' + requestBodyText;

    const hmac = crypto.createHmac('sha256', slackSigningSecret);
    hmac.update(signatureBaseString);

    const finalSignature = 'v0=' + hmac.digest('hex');

    if (finalSignature !== slackSignature) {
      return {
        success: false,
        response: ApiErrorHandler.handleBadRequest({
          message: 'Signature mismatch',
          reqUrl: request.url,
          reqBody: requestBodyText,
          reqHeaders: request.headers,
        }),
      };
    }

    return {
      success: true,
    };
  } catch (error) {
    return {
      success: false,
      response: ApiErrorHandler.handleBadRequest({
        message: 'An error occurred trying to validate slack signature.',
        reqUrl: request.url,
        reqBody: requestBodyText,
        reqHeaders: request.headers,
      }),
    };
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { casePrismaClient } from '@/app/shared/models/extensions/cases';
import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import {
  ClinicianRoleType,
  PhoneType,
} from '@/utils/clients/dosespot/dosespotTypes';
import { convertPhoneNumberToDoseSpotFormat } from '@/utils/clients/dosespot/dosespotUtils';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const physicianCreateSchema = z.object({
  firstName: z.string(),
  lastName: z.string(),
  email: z.string().email(),
  dob: z.coerce.date(),
  address1: z.string(),
  address2: z.string().optional(),
  city: z.string(),
  state: z.string(),
  zip: z.string(),
  phone: z.string(),
  phoneType: z.nativeEnum(PhoneType).optional(),
  fax: z.string(),
  avatarUrl: z.string().optional(),
  roles: z.nativeEnum(UserRole).array().optional(),
  clinicianRoleType: z.nativeEnum(ClinicianRoleType).optional(),
  npiNumber: z.string(),
  retoolSid: z.string(),
});

const POST = async (request: NextRequest) => {
  const userResult = await getUserAndCheckAuthorized({
    request: request,
    roleAccess: [UserRole.ADMIN],
  });

  if (!userResult.success) return userResult.unAuthorizedResponse;

  const typedResult = await getSafeTypedBody<
    z.infer<typeof physicianCreateSchema>
  >(request, physicianCreateSchema);

  if (!typedResult.success) return typedResult.errorResponse;

  const clinicianData = typedResult.value;

  try {
    const createResult = await DosespotClient.createClinician({
      Firstname: clinicianData.firstName,
      Lastname: clinicianData.lastName,
      Email: clinicianData.email,
      DateOfBirth: clinicianData.dob,
      Address1: clinicianData.address1,
      Address2: clinicianData.address2,
      City: clinicianData.city,
      State: clinicianData.state,
      ZipCode: clinicianData.zip,
      PrimaryPhone: await convertPhoneNumberToDoseSpotFormat(
        clinicianData.phone
      ),
      PrimaryPhoneType: clinicianData.phoneType ?? PhoneType.Work,
      PrimaryFax: await convertPhoneNumberToDoseSpotFormat(clinicianData.fax),
      ClinicianRoleType:
        clinicianData.clinicianRoleType ??
        ClinicianRoleType.PrescribingClinician,
      NPINumber: clinicianData.npiNumber,
    });

    if (!createResult.data.Id || parseInt(createResult.data.Id) <= 0) {
      return ApiErrorHandler.handleServerError({
        message: 'There was a problem creating the clinician in Dosespot.',
        reqUrl: request.url,
        reqBody: JSON.stringify(typedResult.value),
        error: new Error(createResult.data.Result.ResultDescription),
        code: HttpStatusCode.INTERNAL_SERVER_ERROR,
      });
    }

    const clinicianDSId = createResult.data.Id;

    const clinician = await casePrismaClient.user.create({
      data: {
        firstName: clinicianData.firstName,
        lastName: clinicianData.lastName,
        email: clinicianData.email,
        addresses: [
          {
            name: 'Work',
            default: true,
            address1: clinicianData.address1,
            address2: clinicianData.address2,
            city: clinicianData.city,
            state: clinicianData.state,
            zip: clinicianData.zip,
          },
        ],
        phoneNumber: clinicianData.phone,
        dosespotId: clinicianDSId.toString(),
        avatarUrl: clinicianData.avatarUrl,
        roles: clinicianData.roles ?? [UserRole.PHYSICIAN],
        retoolSid: clinicianData.retoolSid,
      },
    });

    if (!clinician)
      return ApiErrorHandler.handleServerError({
        message: 'There was a problem creating the clinician in the database.',
        reqUrl: request.url,
        reqBody: JSON.stringify(typedResult.value),
        error: new Error('Clinician was not created in the database.'),
        code: HttpStatusCode.INTERNAL_SERVER_ERROR,
      });

    return NextResponse.json(clinician, { status: HttpStatusCode.CREATED });
  } catch (error) {
    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      reqBody: JSON.stringify(typedResult.value),
      error: error,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/icd10/route.ts

import { NextRequest, NextResponse } from 'next/server';

import ICD10Client from '@/utils/clients/icd10/icd10Client';

const GET = async (request: NextRequest) => {
  const needleParam = request.nextUrl.searchParams.get('search');

  if (!needleParam || needleParam.length < 3)
    return NextResponse.json(
      { error: 'Needle must be at least 3 characters long' },
      { status: 400 }
    );

  const needle = decodeURIComponent(needleParam);

  return NextResponse.json(await ICD10Client.findMyNeedle(needle));
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/licenses/[userId]/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const GET = async (
  request: NextRequest,
  { params }: { params: { userId: string } }
): Promise<NextResponse> => {
  try {
    const userId = params.userId;

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const user = await prisma.user.findUnique({
      where: {
        id: userId,
      },
    });

    if (!user || !user.roles.includes(UserRole.PHYSICIAN)) {
      throw new Error('User does not exist or is not a physician');
    }

    const licenses = await prisma.license.findMany({
      where: {
        userId: userId,
      },
    });
    return NextResponse.json(licenses, { status: HttpStatusCode.OK });
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

interface licenseCreateInput {
  state: string;
  isActive: boolean;
  expiresAt?: Date;
}

const POST = async (
  request: NextRequest,
  { params }: { params: { userId: string } }
): Promise<NextResponse> => {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userId = params.userId;

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const user = await prisma.user.findUnique({
      where: {
        id: userId,
      },
    });

    if (!user || !user.roles.includes(UserRole.PHYSICIAN)) {
      throw new Error('User does not exist or is not a physician');
    }

    const bodyAsLicenseInput = safeBody.jsonBody as licenseCreateInput;

    const newLicense = await prisma.license.create({
      data: {
        state: bodyAsLicenseInput.state,
        isActive: bodyAsLicenseInput.isActive,
        userId: userId,
        expiresAt: bodyAsLicenseInput.expiresAt,
      },
    });

    return NextResponse.json(newLicense, { status: HttpStatusCode.OK });
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/cases/check-for-changes/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { casePrismaClient } from '@/app/shared/models/extensions/cases';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { CaseStatus, UserRole } from '@prisma/client';

const caseUpdatesSchema = z
  .object({
    caseId: z.string(),
    updatedAt: z.date(),
    status: z.nativeEnum(CaseStatus),
  })
  .array();

const POST = async (request: NextRequest) => {
  try {
    const bodyResult = await getSafeTypedBody(request, caseUpdatesSchema);

    if (!bodyResult.success) return bodyResult.errorResponse;

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const caseUpdates = bodyResult.value;

    const checkForUpdates = await Promise.all(
      caseUpdates.map(async (update) => {
        const updatedCase = await casePrismaClient.case.findUnique({
          where: {
            id: update.caseId,
            OR: [
              { status: { not: update.status } },
              { updatedAt: { gt: update.updatedAt } },
            ],
          },
        });

        return updatedCase;
      })
    );

    const updatedCases = checkForUpdates.filter((update) => update !== null);

    return NextResponse.json(updatedCases, { status: HttpStatusCode.OK });
  } catch (error) {
    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/cases/[caseId]/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { casePrismaClient } from '@/app/shared/models/extensions/cases';
import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const GET = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
): Promise<NextResponse> => {
  try {
    const caseId = params.caseId;

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const foundCase = await casePrismaClient.case.getCaseWithThreadByCaseId(
      caseId,
      userInfo.user
    );

    if (!foundCase)
      return ApiErrorHandler.handleCatchAllError({
        error: `Case with id ${caseId} was not found or you do not have access to it.`,
        reqUrl: request.url,
        reqHeaders: request.headers,
        code: HttpStatusCode.NOT_FOUND,
      });

    const { medications, allergies } =
      await DosespotClient.getAllergiesAndMedicationsForUser(foundCase.user);

    return NextResponse.json(
      { ...foundCase, medications, allergies },
      { status: HttpStatusCode.OK }
    );
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/cases/[caseId]/get-updates/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { casePrismaClient } from '@/app/shared/models/extensions/cases';
import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const GET = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
): Promise<NextResponse> => {
  try {
    const caseId = params.caseId;

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const foundCase = await casePrismaClient.case.findUnique({
      where: {
        id: caseId,
      },
      select: {
        id: true,
        diagnosedAt: true,
        diagnosisICD: true,
        diagnosisName: true,
        diagnosisMessage: true,
        user: true,
      },
    });

    if (!foundCase)
      return ApiErrorHandler.handleCatchAllError({
        error: `Case with id ${caseId} was not found or you do not have access to it.`,
        reqUrl: request.url,
        reqHeaders: request.headers,
        code: HttpStatusCode.NOT_FOUND,
      });

    const { medications, allergies } =
      await DosespotClient.getAllergiesAndMedicationsForUser(foundCase.user);

    const prescriptions = await DosespotClient.getPrescriptionsByCaseAndUser(
      foundCase.id,
      userInfo.user
    );

    const returnObj = {
      ...foundCase,
      medications,
      allergies,
      prescriptions,
    };

    return NextResponse.json(returnObj, { status: HttpStatusCode.OK });
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/cases/[caseId]/get-detail-object/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { casePrismaClient } from '@/app/shared/models/extensions/cases';
import { ExtendedUser } from '@/app/shared/types';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAttributes } from '@/utils/helpers/helpers';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { Prisma, UserRole } from '@prisma/client';

const GET = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
): Promise<NextResponse> => {
  try {
    const caseId = params.caseId;

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const foundCase = await casePrismaClient.case.findUnique({
      where: {
        id: caseId,
      },
      select: {
        id: true,
        status: true,
        user: {
          include: {
            guardian: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
          },
        },
      },
    });

    if (!foundCase)
      return ApiErrorHandler.handleCatchAllError({
        error: `Case with id ${caseId} was not found or you do not have access to it.`,
        reqUrl: request.url,
        reqHeaders: request.headers,
        code: HttpStatusCode.NOT_FOUND,
      });

    const userWithAttributes = await getUserAttributes(foundCase.user);
    foundCase.user = userWithAttributes as UserWithGuardian;

    return NextResponse.json(foundCase, { status: HttpStatusCode.OK });
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

type UserWithGuardian = ExtendedUser &
  Prisma.UserGetPayload<{
    include: {
      guardian: {
        select: {
          id: true;
          firstName: true;
          lastName: true;
        };
      };
    };
  }>;

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/cases/[caseId]/medical-details/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { casePrismaClient } from '@/app/shared/models/extensions/cases';
import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { UserRole } from '@prisma/client';

const GET = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
): Promise<NextResponse> => {
  try {
    const caseId = params.caseId;

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const foundCase = await casePrismaClient.case.findUnique({
      where: {
        id: caseId,
      },
      select: {
        id: true,
        user: true,
        diagnosedAt: true,
        diagnosisICD: true,
        diagnosisName: true,
        diagnosisMessage: true,
      },
    });

    if (!foundCase)
      return ApiErrorHandler.handleCatchAllError({
        error: `Case with id ${caseId} was not found or you do not have access to it.`,
        reqUrl: request.url,
        reqHeaders: request.headers,
        code: HttpStatusCode.NOT_FOUND,
      });

    const { medications, allergies } =
      await DosespotClient.getAllergiesAndMedicationsForUser(foundCase.user);

    const prescriptions = await DosespotClient.getPrescriptionsByCaseAndUser(
      foundCase.id,
      userInfo.user
    );

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { id, user, ...restOfCase } = foundCase;

    const returnObj = {
      caseId,
      ...restOfCase,
      medications,
      allergies,
      prescriptions,
    };

    return NextResponse.json(returnObj, { status: HttpStatusCode.OK });
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/cases/[caseId]/claim/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { casePrismaClient } from '@/app/shared/models/extensions/cases';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { CaseStatus, UserRole } from '@prisma/client';

const PATCH = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
): Promise<NextResponse> => {
  const userInfo = await getUserAndCheckAuthorized({
    request: request,
    roleAccess: [UserRole.PHYSICIAN, UserRole.PHYSICIAN_SUPPORT],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  try {
    const { caseId } = params;

    const caseLookup = await casePrismaClient.case.findUnique({
      where: {
        id: caseId,
        physicianId: userInfo.user.id,
      },
    });

    if (!caseLookup)
      return ApiErrorHandler.handleBadRequest({
        reqUrl: request.url,
        reqHeaders: request.headers,
        message: `Case with id ${caseId} was not found or you do not have access to it.`,
      });

    if (caseLookup.physicianId && caseLookup.physicianId !== userInfo.user.id) {
      return ApiErrorHandler.handleBadRequest({
        reqUrl: request.url,
        reqHeaders: request.headers,
        message: `Case with id ${caseId} is already assigned to another physician.`,
      });
    }

    const updatedCase = await casePrismaClient.case.update({
      where: { id: caseId },
      data: {
        status: CaseStatus.ASSIGNED,
        physicianId: userInfo.user.id,
      },
    });

    if (!updatedCase)
      return ApiErrorHandler.handleCatchAllError({
        error: `Case with id ${caseId} could not be updated.`,
        reqUrl: request.url,
        reqHeaders: request.headers,
        code: HttpStatusCode.INTERNAL_SERVER_ERROR,
      });

    return NextResponse.json(updatedCase, { status: HttpStatusCode.OK });
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { PATCH };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/cases/[caseId]/media/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { casePrismaClient } from '@/app/shared/models/extensions/cases';
import { ApiErrorHandler } from '@/utils/errors';
import { getS3Url } from '@/utils/file-upload/file-upload';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@/utils/statusCodes';
import { S3Client } from '@aws-sdk/client-s3';
import { UserRole } from '@prisma/client';

const s3 = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.FORM_S3_AWS_ACCESS_KEY as string,
    secretAccessKey: process.env.FORM_S3_SECRET_ACCESS_KEY as string,
  },
});

const GET = async (
  request: NextRequest,
  { params }: { params: { caseId: string } }
): Promise<NextResponse> => {
  try {
    const caseId = params.caseId;

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const foundCase = await casePrismaClient.case.findUnique({
      where: {
        id: caseId,
      },
      select: {
        id: true,
        user: true,
        media: true,
        status: true,
      },
    });

    if (!foundCase)
      return ApiErrorHandler.handleCatchAllError({
        error: `Case with id ${caseId} was not found or you do not have access to it.`,
        reqUrl: request.url,
        reqHeaders: request.headers,
        code: HttpStatusCode.NOT_FOUND,
      });

    const userMedia = await Promise.all(
      foundCase.user.media.map(async (media) => {
        const mediaUrl = media.mediaUrl ?? undefined;

        const response = await getS3Url({
          mediaUrl: mediaUrl,
          expiresIn: 3600,
          s3Client: s3,
          source: 'get_user_media_message',
        });

        if (!response || response.error) {
          return null;
        }

        return {
          ...media,
          signedMediaUrl: response.s3Url,
        };
      })
    );

    const caseMedia = await Promise.all(
      foundCase.media.map(async (media) => {
        const mediaUrl = media.mediaUrl ?? undefined;
        const response = await getS3Url({
          mediaUrl: mediaUrl,
          expiresIn: 3600,
          s3Client: s3,
          source: 'get_case_media_message',
        });

        if (!response || response.error) {
          return null;
        }

        return {
          ...media,
          signedMediaUrl: response.s3Url,
        };
      })
    );

    const returnObj = {
      caseMedia,
      userMedia,
    };

    return NextResponse.json(returnObj, { status: HttpStatusCode.OK });
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/cases/assigned/route.ts

import { NextRequest, NextResponse } from 'next/server';
import {
  AddressPartialSchema,
  CaseStatusSchema,
  MessageSchema,
  UserPartialSchema,
  UserSchema,
} from 'prisma/generated/zod';
import { z } from 'zod';

import { userPrismaClient } from '@/app/shared/models/extensions/identity';
import {
  AttentionReasonEnum,
  checkCaseNeedsAttention,
} from '@/utils/cases/checkCaseNeedsAttention';
import { ApiErrorHandler } from '@/utils/errors';
import { ErrorNextResponse } from '@/utils/errors/apiErrorHandler';
import { getS3Url } from '@/utils/file-upload/file-upload';
import { getSafeQueryParam } from '@/utils/requests/getSafeQueryParam';
import { SafeTypedErrorType } from '@/utils/requests/safeTypedResultTypes';
import HttpStatusCode from '@/utils/statusCodes';
import { S3Client } from '@aws-sdk/client-s3';
import {
  CaseStatus,
  MessageStatus,
  ThreadStatus,
  ThreadType,
  UserRole,
} from '@prisma/client';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';

const s3 = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.PROFILE_AVATAR_AWS_ACCESS_KEY as string,
    secretAccessKey: process.env.PROFILE_AVATAR_SECRET_ACCESS_KEY as string,
  },
});

const basicMessageSchema = MessageSchema.pick({
  id: true,
  sentWhen: true,
  status: true,
  fromUserId: true,
  content: true,
  readByIds: true,
});

const basicUserSchema = UserSchema.pick({
  id: true,
  firstName: true,
  lastName: true,
  avatarUrl: true,
}).extend({
  addresses: z.array(AddressPartialSchema),
  signedAvatarUrl: z.string().optional(),
});

const needsAttentionSchema = z
  .object({
    needsAttention: z.literal(true),
    reasons: z.array(
      z.object({
        reasonMessage: z.string(),
        reasonCode: z.nativeEnum(AttentionReasonEnum).optional(),
      })
    ),
  })
  .or(z.object({ needsAttention: z.literal(false) }));

const assignedCaseSchema = z.object({
  id: z.string(),
  status: z.nativeEnum(CaseStatus),
  user: basicUserSchema,
  thread: z
    .array(
      z.object({
        id: z.string(),
        messages: z.array(basicMessageSchema),
        status: z.nativeEnum(ThreadStatus),
        participants: z.array(
          z.object({
            userId: z.string(),
          })
        ),
      })
    )
    .optional()
    .nullable(),
  needsAttention: needsAttentionSchema.optional(),
});

const MessageSchemaWithUser = basicMessageSchema.extend({
  user: UserPartialSchema,
});

const unreadMessageSchema = z.object({
  caseId: z.string(),
  caseComplaint: z.string(),
  message: MessageSchemaWithUser,
});

const assignedCasesResponseSchema = z.object({
  openCases: assignedCaseSchema.array(),
  closedCases: assignedCaseSchema.array(),
  unreadMessages: unreadMessageSchema.array(),
});

type AssignedCase = z.infer<typeof assignedCaseSchema>;
type AssignedCasesResponse = z.infer<typeof assignedCasesResponseSchema>;

const GET = async (
  request: NextRequest
): Promise<NextResponse<AssignedCasesResponse | ErrorNextResponse>> => {
  const userInfo = await getUserAndCheckAuthorized({
    request: request,
    roleAccess: [UserRole.PHYSICIAN],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  const statusExpectedSchema = z.array(CaseStatusSchema);

  try {
    const statusParamResult = await getSafeQueryParam<CaseStatus[]>(
      request,
      statusExpectedSchema,
      'status',
      true,
      false
    );

    if (
      !statusParamResult.success &&
      statusParamResult.failureType === SafeTypedErrorType.INVALID
    )
      return statusParamResult.errorResponse;

    const statusParam = statusParamResult.success
      ? statusParamResult.value
      : undefined;

    const excludeStatuses = request.nextUrl.searchParams.has('exclude')
      ? request.nextUrl.searchParams.get('exclude') === 'true'
      : false;

    let statusParamWhere = undefined;

    if (statusParam && excludeStatuses) {
      statusParamWhere = {
        notIn: statusParam,
      };
    } else if (statusParam) {
      statusParamWhere = {
        in: statusParam,
      };
    }

    const preFilteredPhysicianCases = await userPrismaClient.case.findMany({
      where: {
        physicianId: userInfo.user.id,
        status: statusParamWhere,
      },
      include: {
        user: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            avatarUrl: true,
            addresses: {
              select: {
                default: true,
                state: true,
              },
            },
          },
        },
        thread: {
          where: {
            type: {
              equals: ThreadType.MEDICAL,
            },
          },
          select: {
            id: true,
            participants: {
              select: {
                userId: true,
              },
            },
            status: true,
            messages: {
              where: {
                status: MessageStatus.SENT,
                fromUserId: { not: userInfo.user.id },
              },
              orderBy: {
                sentWhen: 'desc',
              },
              take: 1,
            },
          },
        },
      },
    });

    if (!preFilteredPhysicianCases)
      return ApiErrorHandler.handleCatchAllError({
        error: 'There was an error looking up the physician cases',
        reqUrl: request.url,
        reqHeaders: request.headers,
        code: HttpStatusCode.INTERNAL_SERVER_ERROR,
      });

    const physicianCases = preFilteredPhysicianCases.filter(
      (c) =>
        c.status !== CaseStatus.ARCHIVED &&
        c.status !== CaseStatus.DELETED &&
        c.status !== CaseStatus.PREPAYMENT
    );

    const unreadMessages: z.infer<typeof unreadMessageSchema>[] = [];

    const openCases: AssignedCase[] = [];
    const closedCases: AssignedCase[] = [];

    const closedStatus: CaseStatus[] = [
      CaseStatus.DIAGNOSED_AWAITING_PHARMACY,
      CaseStatus.DIAGNOSED_PRESCRIBED,
      CaseStatus.PHYSICIAN_FINALIZED,
      CaseStatus.PATIENT_REVIEW,
    ];

    await Promise.all(
      physicianCases.map(async (activeCase) => {
        const assignedCase: AssignedCase = activeCase;
        const needsAttention = checkCaseNeedsAttention(activeCase);

        const firstInitial = activeCase.user.firstName
          ? activeCase.user.firstName[0]
          : 'U';

        const lastInitial = activeCase.user.lastName
          ? activeCase.user.lastName[0]
          : '';

        if (activeCase.user.avatarUrl && activeCase.user.avatarUrl !== '') {
          const response = await getS3Url({
            mediaUrl: activeCase.user.avatarUrl,
            expiresIn: 3600,
            s3Client: s3,
            source: 'get_assigned_cases',
          });
          if (!response || response.error)
            assignedCase.user.signedAvatarUrl = `https://ui-avatars.com/api/?name=${firstInitial}+${lastInitial}&size=256`;
          else assignedCase.user.signedAvatarUrl = response.s3Url;
        } else
          assignedCase.user.signedAvatarUrl = `https://ui-avatars.com/api/?name=${firstInitial}+${lastInitial}&size=256`;

        if (
          needsAttention.needsAttention &&
          needsAttention.reasons.some(
            (reason) =>
              reason.reasonCode === AttentionReasonEnum.PATIENT_AWAITING_REPLY
          )
        )
          unreadMessages.push({
            caseId: activeCase.id,
            caseComplaint: activeCase.complaint,
            message: {
              ...activeCase.thread[0].messages[0],
              user: activeCase.user,
            },
          });

        if (closedStatus.includes(assignedCase.status))
          closedCases.push({
            ...assignedCase,
            needsAttention: needsAttention,
          });
        else
          openCases.push({
            ...assignedCase,
            needsAttention,
          });
        return {
          ...assignedCase,
          needsAttention,
        };
      })
    );

    const returnObj = {
      openCases: openCases,
      closedCases: closedCases,
      unreadMessages,
    };

    return NextResponse.json(returnObj, { status: HttpStatusCode.OK });
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/cases/open/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { userPrismaClient } from '@/app/shared/models/extensions/identity';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import HttpStatusCode from '@/utils/statusCodes';
import { getStateFromAbbreviation } from '@/utils/utils';
import { CaseStatus, License, UserRole } from '@prisma/client';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';

const GET = async (request: NextRequest): Promise<NextResponse> => {
  const userInfo = await getUserAndCheckAuthorized({
    request: request,
    roleAccess: [UserRole.PHYSICIAN],
  });

  if (!userInfo.success) return userInfo.unAuthorizedResponse;

  let stateLicenses: License[] = [];

  try {
    stateLicenses = await prisma.license.findMany({
      where: {
        userId: userInfo.user.id,
      },
    });

    if (!stateLicenses) return NextResponse.json([]);

    const statesLicensed = stateLicenses.map((license) =>
      getStateFromAbbreviation(license.state)
    );

    const openCases = await userPrismaClient.case.findMany({
      where: {
        status: CaseStatus.OPEN,
        user: {
          addresses: {
            some: {
              state: {
                in: statesLicensed,
              },
            },
          },
        },
      },
      include: {
        user: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            addresses: {
              select: {
                default: true,
                state: true,
              },
            },
          },
        },
        thread: true,
      },
    });

    if (!openCases)
      return ApiErrorHandler.handleCatchAllError({
        error: 'There was an error looking up the open physician cases',
        reqUrl: request.url,
        reqHeaders: request.headers,
        code: HttpStatusCode.INTERNAL_SERVER_ERROR,
      });

    return NextResponse.json(openCases, { status: HttpStatusCode.OK });
  } catch (e) {
    return ApiErrorHandler.handleCatchAllError({
      error: e,
      reqUrl: request.url,
      reqHeaders: request.headers,
      code: HttpStatusCode.INTERNAL_SERVER_ERROR,
      additionalContext: {
        physician: userInfo.user.id,
        licenses: stateLicenses,
      },
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/audit/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { z } from 'zod';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { getSafeTypedBody } from '@/utils/requests/getSafeTypedBody';
import { parseJSONOrDefault } from '@/utils/utils';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';
import { getUserAndCheckAuthorized } from '@utils/requests/getUserAndCheckAuthorized';
import HttpStatusCode from '@utils/statusCodes';

const messageReviewSchema = z.object({
  message: z.string(),
});

type MessageReviewInput = z.output<typeof messageReviewSchema>;

type ChatHistoryMessage = {
  content: string;
  fromUser: string;
  role: string;
};

const openai = new OpenAI({
  apiKey: `${process.env.OPEN_AI_API_KEY}`,
  organization: `${process.env.OPEN_AI_ORG}`,
});

const CHAT_PRETEXT = 'For additional context, the chat history is as follows:';
const MESSAGE_PRETEXT = 'This is the message that should be reviewed:';

const POST = async (request: NextRequest) => {
  const headerList = headers();
  const threadId = headerList.get('chatThreadId');

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [
        UserRole.CORTINA_SUPPORT,
        UserRole.PHYSICIAN,
        UserRole.PHYSICIAN_SUPPORT,
        UserRole.CORTINA_NURSE,
        UserRole.ADMIN,
      ],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const bodyResult = await getSafeTypedBody(request, messageReviewSchema);

    if (!bodyResult.success) return bodyResult.errorResponse;

    const { message } = bodyResult.value;

    let previousChatContent: ChatHistoryMessage[] = [];

    if (threadId) {
      const thread = await prisma.thread.findUnique({
        where: {
          id: threadId,
        },
        include: {
          messages: {
            include: {
              fromUser: {
                select: {
                  firstName: true,
                  lastName: true,
                  id: true,
                },
              },
            },
          },
          case: {
            select: {
              physicianId: true,
            },
          },
        },
      });
      previousChatContent = (thread?.messages ?? []).map((msg) => {
        return {
          content: `${msg.content}`,
          fromUser: `${msg.fromUser.firstName} ${msg.fromUser.lastName}`,
          role:
            msg.fromUser.id === thread?.case?.physicianId
              ? 'Physician'
              : 'Patient',
        };
      });
    }

    const assistantThread = await openai.beta.threads.create();

    if (previousChatContent.length > 0) {
      await openai.beta.threads.messages.create(assistantThread.id, {
        role: 'user',
        content: `${CHAT_PRETEXT} ${JSON.stringify(previousChatContent)}`,
      });
    }

    await openai.beta.threads.messages.create(assistantThread.id, {
      role: 'user',
      content: `${MESSAGE_PRETEXT} ${message}`,
    });

    const runOptions: OpenAI.Beta.Threads.Runs.RunCreateParamsNonStreaming = {
      assistant_id: `${process.env.PHYSICIAN_AUDIT_OPEN_AI_ASSISTANT}`,
    };

    const run = await openai.beta.threads.runs.createAndPoll(
      assistantThread.id,
      runOptions
    );

    if (run.status === 'completed') {
      const messages = await openai.beta.threads.messages.list(run.thread_id);
      const reply = messages.data[0].content[0];
      if (reply.type === 'text') {
        const parsedReply = parseJSONOrDefault(reply.text.value, {});
        return NextResponse.json(
          {
            ...parsedReply,
            threadId: assistantThread.id,
            assistantId: run.assistant_id,
          },
          {
            status: HttpStatusCode.OK,
          }
        );
      }
    } else {
      throw new Error(run.last_error?.message || 'An error occurred');
    }
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem reviewing the message',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/templates/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import {
  MessageTemplateCategory,
  MessageTemplateStatus,
  UserRole,
} from '@prisma/client';

const roleAccess = [
  UserRole.PHYSICIAN,
  UserRole.PHYSICIAN_SUPPORT,
  UserRole.CORTINA_NURSE,
];

type TemplateSelect = {
  id: string;
  updatedAt: Date;
  createdById: string;
  title: string;
  body: string;
};

const GET = async (request: NextRequest) => {
  try {
    const { searchParams } = new URL(request.url);

    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: roleAccess,
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    let templateCategory: MessageTemplateCategory =
      MessageTemplateCategory.MESSAGING;

    const category = searchParams.get('category');

    if (category && category === MessageTemplateCategory.DIAGNOSIS) {
      templateCategory = MessageTemplateCategory.DIAGNOSIS;
    }

    const templates = await prisma.messageTemplate.findMany({
      where: {
        status: MessageTemplateStatus.ACTIVE,
        OR: [
          {
            rolePermissions: {
              hasSome: roleAccess,
            },
          },
          {
            userPermissionIds: { has: userInfo.user.id },
          },
        ],
        category: { has: templateCategory },
      },
      select: {
        id: true,
        updatedAt: true,
        title: true,
        body: true,
        createdById: true,
      },
      orderBy: {
        updatedAt: 'desc',
      },
    });

    const grouped = {
      mine: [] as TemplateSelect[],
      shared: [] as TemplateSelect[],
    };

    templates.forEach((template) => {
      if (template.createdById === userInfo.user.id) {
        grouped.mine.push(template);
      } else {
        grouped.shared.push(template);
      }
    });

    const sortByUpdatedAtDesc = (a: TemplateSelect, b: TemplateSelect) =>
      new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime();

    grouped.mine.sort(sortByUpdatedAtDesc);
    grouped.shared.sort(sortByUpdatedAtDesc);

    return NextResponse.json(grouped, { status: 200 });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message:
        'An error occurred while retrieving the physician diagnosis templates.',
      reqUrl: request.url,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/physician/stats/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { casePrismaClient } from '@/app/shared/models/extensions/cases';
import { messagingClient } from '@/app/shared/models/extensions/messaging';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';

const GET = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.PHYSICIAN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const messageCount = await messagingClient.message.count({
      where: {
        fromUserId: userInfo.user.id,
        createdAt: {
          gt: new Date(new Date().getTime() - 30 * 24 * 60 * 60 * 1000),
        },
      },
    });

    const caseCount = await casePrismaClient.case.count({
      where: {
        physicianId: userInfo.user.id,
        createdAt: {
          gt: new Date(new Date().getTime() - 30 * 24 * 60 * 60 * 1000),
        },
      },
    });

    return NextResponse.json({ messageCount, caseCount });
  } catch (error) {
    return ApiErrorHandler.handleCatchAllError({
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/newsletter/route.ts

import { headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';
import z from 'zod';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserEventNames } from '@/utils/user-events/enums';
import UserEventsClient from '@/utils/user-events/user-events-client';
import { UserRole } from '@prisma/client';
import { ApiErrorHandler } from '@utils/errors';

const GET = async (request: NextRequest) => {
  const headersList = headers();

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.CORTINA_SUPPORT, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const results = await prisma.newsletterEmail.findMany({});
    return NextResponse.json(results);
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Error retrieving newsletter emails.',
      reqUrl: request.url,
      reqHeaders: headersList,
      error: error,
    });
  }
};

const POST = async (request: NextRequest) => {
  const body = await request.text();
  const schema = z.object({
    email: z.string().email('Please provide a valid email address'),
  });

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request,
    });

    const jsonBody = JSON.parse(body);
    const result = schema.safeParse(jsonBody);

    if (!result.success) {
      return ApiErrorHandler.handleBadRequest({
        message: 'Please provide a valid email address',
        reqUrl: request.url,
        reqBody: body,
      });
    }

    const isExistingEmail = await prisma.newsletterEmail.findUnique({
      where: { email: result.data.email },
    });

    if (isExistingEmail) {
      return ApiErrorHandler.handleBadRequest({
        code: 409,
        message: 'Email address already exists',
        reqUrl: request.url,
        reqBody: body,
      });
    }

    await prisma.newsletterEmail.create({
      data: {
        email: result.data.email,
      },
    });

    if (userInfo.success) {
      await UserEventsClient.addEvent(
        userInfo.user,
        UserEventNames.DERMI_NEWSLETTER_SIGNUP,
        {
          signupEmail: result.data.email,
        }
      );
    } else {
      await UserEventsClient.addEventByEmail(
        result.data.email,
        UserEventNames.DERMI_NEWSLETTER_SIGNUP,
        {
          signupEmail: result.data.email,
        }
      );
    }

    return NextResponse.json({ message: 'Form data saved.' });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem saving the email address',
      reqUrl: request.url,
      reqBody: body,
      error: error,
    });
  }
};

const DELETE = async (request: NextRequest) => {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.CORTINA_SUPPORT, UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const headersList = headers();
    const idHeader = headersList.get('id');
    const emailHeader = headersList.get('email');

    const schema = z
      .object({
        id: z.string().nullable(),
        email: z.string().nullable(),
      })
      .partial()
      .refine(
        (data) => !!data.id || !!data.email,
        'Please provide an id or email.'
      );
    const result = schema.safeParse({
      id: idHeader,
      email: emailHeader,
    });

    if (!result.success) {
      return ApiErrorHandler.handleBadRequest({
        message: result.error.message,
        reqUrl: request.url,
        reqHeaders: headersList,
      });
    }

    if (result.data.email) {
      const results = await prisma.newsletterEmail.delete({
        where: { email: result.data.email },
      });
      return NextResponse.json(results);
    } else {
      const results = await prisma.newsletterEmail.delete({
        where: { id: result.data.id as string },
      });
      return NextResponse.json(results);
    }
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'Error deleting newsletter subscription',
      reqUrl: request.url,
      reqHeaders: request.headers,
      error: error,
    });
  }
};

export { DELETE, GET, POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/exit-preview/route.ts

import { NextResponse } from 'next/server';

import { exitPreview } from '@prismicio/next';

/**
 * Exits preview mode for prismic.
 * Updated function from prismic docs to *always* return a Response object.
 * Also removed await from docs since it is not an async function
 */
export async function GET() {
  const exit = exitPreview();

  if (exit instanceof Response) return exit;

  return NextResponse.json('exited preview mode');
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/test-submission/route.ts

import { NextRequest, NextResponse } from 'next/server';

/**
 * fake endpoint for options
 * TODO: remove this
 */
export async function OPTIONS() {
  return NextResponse.json({}, { headers: { Allow: 'OPTIONS, POST' } });
}

/**
 * fake endpoint for post
 * TODO: remove this
 */
export async function POST(request: NextRequest) {
  const body = await request.json();
  console.log(JSON.stringify(body, null, 4));

  return NextResponse.json({}, { status: 200 });
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/employee/route.ts

import { NextRequest, NextResponse } from 'next/server';

import { organizationClient } from '@/app/shared/models/extensions/b2b';
import { ApiErrorHandler } from '@/utils/errors';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';

const GET = async (request: NextRequest) => {
  const authResult = await getUserAndCheckAuthorized({
    request,
    roleAccess: [UserRole.ADMIN],
  });

  if (!authResult.success) return authResult.unAuthorizedResponse;

  const employees = await organizationClient.employee.findMany();

  if (!employees)
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to get the employees.',
      reqUrl: request.url,
    });

  return NextResponse.json(employees, { status: 200 });
};

export { GET };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/employee/lookup/route.ts

import { HttpStatusCode } from 'axios';
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { organizationClient } from '@/app/shared/models/extensions/b2b';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';

const employeeIdDobLookup = z.object({
  employeeId: z.string(),
  dob: z.string().datetime(),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
});

const firstLastDobLookup = z.object({
  firstName: z.string(),
  lastName: z.string(),
  dob: z.string().datetime(),
});

const employeeLookup = employeeIdDobLookup.or(firstLastDobLookup);

enum EmployeeLookupIssueCode {
  MULTIPLE_RECORDS = 'MULTIPLE_RECORDS',
  NO_RECORDS = 'NO_RECORDS',
}

interface EmployeeLookupIssue {
  message: string;
  code: EmployeeLookupIssueCode;
}

const POST = async (request: NextRequest) => {
  const safeBody = await getSafeRequestBody(request);

  if (!safeBody.isValidJson)
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid json body.',
      reqUrl: request.url,
      reqBody: safeBody.txtBody,
    });

  try {
    const validatedBody = employeeLookup.parse(safeBody.jsonBody);

    const result = await organizationClient.employee.findMany({
      where: {
        ...validatedBody,
      },
    });

    if (result.length > 1) {
      const issue: EmployeeLookupIssue = {
        message:
          'Multiple records found for that information, please provide more details',
        code: EmployeeLookupIssueCode.MULTIPLE_RECORDS,
      };

      return NextResponse.json(issue, {
        status: HttpStatusCode.Conflict,
      });
    }

    if (result.length === 1)
      return NextResponse.json(result[0], { status: HttpStatusCode.Ok });

    const issue: EmployeeLookupIssue = {
      message: 'No records found for that information.',
      code: EmployeeLookupIssueCode.NO_RECORDS,
    };

    return NextResponse.json(issue, {
      status: HttpStatusCode.NotFound,
    });
  } catch (error) {
    return ApiErrorHandler.handleServerError({
      message: 'An error ocurred trying to lookup the employee.',
      reqUrl: request.url,
      reqBody: safeBody.txtBody,
      error,
    });
  }
};

export { POST };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/user-events/route.ts

// app/api/user-event-emails/route.ts
import { NextRequest, NextResponse } from 'next/server';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { ApiErrorHandler } from '@/utils/errors';
import { getSafeRequestBody } from '@/utils/requests/getSafeRequestBody';
import { getUserAndCheckAuthorized } from '@/utils/requests/getUserAndCheckAuthorized';
import { UserRole } from '@prisma/client';

export async function POST(request: NextRequest) {
  const safeBody = await getSafeRequestBody(request);
  if (!safeBody.isValidJson) return safeBody.badRequestResponse;

  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const { id, event, template } = safeBody.jsonBody;

    if (!event || !template) {
      return NextResponse.json(
        { error: 'Event and template are required' },
        { status: 400 }
      );
    }

    let userEventEmail;

    if (id) {
      // Update existing record
      userEventEmail = await prisma.userEventEmails.update({
        where: { id },
        data: { event, template },
      });
    } else {
      // Create new record
      userEventEmail = await prisma.userEventEmails.create({
        data: { event, template },
      });
    }

    return NextResponse.json(userEventEmail, { status: id ? 200 : 201 });
  } catch (error) {
    console.error('Error creating/updating UserEventEmail:', error);

    return ApiErrorHandler.handleServerError({
      message: 'There was a problem posting the event template',
      reqUrl: request.url,
      error: error,
    });
  }
}

export async function GET(request: NextRequest) {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');

    if (id) {
      const userEventEmail = await prisma.userEventEmails.findUnique({
        where: { id },
      });

      if (!userEventEmail) {
        return NextResponse.json(
          { error: 'UserEventEmail not found' },
          { status: 404 }
        );
      }

      return NextResponse.json(userEventEmail);
    } else {
      const userEventEmails = await prisma.userEventEmails.findMany();
      return NextResponse.json(userEventEmails);
    }
  } catch (error) {
    console.error('Error fetching UserEventEmail(s):', error);
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem getting the event template',
      reqUrl: request.url,
      error: error,
    });
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const userInfo = await getUserAndCheckAuthorized({
      request: request,
      roleAccess: [UserRole.ADMIN],
    });

    if (!userInfo.success) return userInfo.unAuthorizedResponse;

    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');

    if (!id) {
      return NextResponse.json({ error: 'ID is required' }, { status: 400 });
    }

    await prisma.userEventEmails.delete({
      where: { id },
    });

    return NextResponse.json({
      message: 'UserEventEmail deleted successfully',
    });
  } catch (error) {
    console.error('Error deleting UserEventEmail:', error);
    return ApiErrorHandler.handleServerError({
      message: 'There was a problem deleting the event template',
      reqUrl: request.url,
      error: error,
    });
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/api/revalidate/route.ts

import { revalidateTag } from 'next/cache';
import { NextResponse } from 'next/server';

/**
 * Revalidates the prismic cache.
 */
export async function POST() {
  revalidateTag('prismic');

  return NextResponse.json({ revalidated: true, now: Date.now() });
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(api-docs)/api/page.tsx

import { getApiDocs } from '@/utils/swagger/swagger';

import ReactSwagger from './components/react-swagger';

export default async function IndexPage() {
  if (process.env.ENVIRONMENT_NAME === 'production')
    return <div>Swagger UI is not available in production mode</div>;

  const spec = await getApiDocs();
  return (
    <section className="container">
      <ReactSwagger spec={spec} />
    </section>
  );
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(api-docs)/api/swagger-callback/page.tsx

'use client';

import { useSearchParams } from 'next/navigation';
import { useEffect } from 'react';

interface QueryObject {
  state?: string;
  code?: string;
  error?: string;
  error_description?: string;
  error_uri?: string;
}

export default function Page() {
  const searchParams = useSearchParams();

  useEffect(() => {
    const oauth2 = window.opener.swaggerUIRedirectOauth2;
    const sentState = oauth2.state;
    const redirectUrl = oauth2.redirectUrl;

    const arr: Array<string> = [];

    searchParams.forEach((value, key) => {
      arr.push('"' + key + '":' + '"' + value + '"');
    });

    const queryObject: QueryObject = JSON.parse(
      '{' + arr.join() + '}',
      (key, value) => {
        return key === '' ? value : decodeURIComponent(value);
      }
    );

    const isValid = queryObject.state === sentState;

    if (!oauth2.auth.code) {
      if (!isValid) {
        oauth2.errCb({
          authId: oauth2.auth.name,
          source: 'auth',
          level: 'warning',
          message:
            "Authorization may be unsafe, passed state was changed in server. The passed state wasn't returned from auth server.",
        });
      }

      const authCode = queryObject.code;
      const error = queryObject.error;
      const error_description = queryObject.error_description;
      const error_uri = queryObject.error_uri;

      if (authCode) {
        delete oauth2.state;
        oauth2.auth.code = authCode;

        oauth2.callback({ auth: oauth2.auth, redirectUrl: redirectUrl });
        window.close();
      } else {
        let oauthErrorMsg;
        if (error) {
          oauthErrorMsg = `[${error}]: ${
            error_description
              ? error_description + '. '
              : 'no accessCode received from the server. '
          } ${error_uri ? 'More info: ' + error_uri : ''}`;

          oauth2.errCb({
            authId: oauth2.auth.name,
            source: 'auth',
            level: 'error',
            message:
              oauthErrorMsg ||
              '[Authorization failed]: no accessCode received from the server.',
          });
        }
      }
    } else {
      oauth2.callback({
        auth: oauth2.auth,
        token: queryObject,
        isValid: isValid,
        redirectUrl: redirectUrl,
      });
    }
  }, [searchParams]);
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(api-docs)/api/components/react-swagger.tsx

'use client';

import { SwaggerDefinition } from 'swagger-jsdoc';
import SwaggerUI from 'swagger-ui-react';
import 'swagger-ui-react/swagger-ui.css';

type Props = {
  spec: SwaggerDefinition;
};

function ReactSwagger({ spec }: Props) {
  return (
    <SwaggerUI
      spec={spec}
      oauth2RedirectUrl="http://localhost:3000/api/swagger-callback"
    />
  );
}

export default ReactSwagger;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/app/(api-docs)/api/json/route.tsx

import { NextResponse } from 'next/server';

import { getApiDocs } from '@/utils/swagger/swagger';

export const GET = async () => {
  const apiDocs = await getApiDocs();
  return NextResponse.json(apiDocs);
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/get-partner.ts

import { prisma } from './clients/mongo/prismaClient';

export type PartnerData = {
  partnerId: string;
  name: string;
  logo: string | null;
  allowFamilyMembers: boolean | null;
  allowIntakeByTreatment: boolean | null;
};

export const getPartner = async (partnerId?: string | null) => {
  try {
    if (!partnerId) {
      return null;
    }

    const partner = await prisma.partner.findFirst({
      where: {
        id: partnerId,
      },
      include: {
        preferences: true,
      },
    });

    if (!partner) {
      return null;
    }

    const preferences = partner.preferences;

    return {
      partnerId: partner.id,
      name: partner.name,
      logo: preferences?.logo,
      allowFamilyMembers: preferences?.allowFamilyMembers,
      allowIntakeByTreatment: preferences?.allowIntakeByTreatment,
    } as PartnerData;
  } catch (error) {
    console.error(error);
    return null;
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/get-available-consult.ts

import { ExtendedUser } from '@/app/shared/types';
import { CartProducts, Case, ProductCategories, User } from '@prisma/client';

import { prisma } from './clients/mongo/prismaClient';
import { getFamilyIDs } from './dependents/dependentUsersUtilities';

export const getAvailableConsult = async (user: User | ExtendedUser) => {
  const userIds = await getFamilyIDs(user);

  const familyOrders = await prisma.order.findMany({
    where: { userId: { in: userIds } },
    select: {
      id: true,
      cartProducts: {
        include: {
          product: {
            select: {
              category: true,
            },
          },
          case: true,
        },
      },
    },
  });

  const foundConsultations = familyOrders.reduce<
    (CartProducts & { case: Case[] })[]
  >((acc, curr) => {
    const consultation = curr.cartProducts.find(
      (cp) => cp.product.category === ProductCategories.CONSULTATION
    );

    if (consultation) acc.push(consultation);

    return acc;
  }, []);

  let consultationsAvailable = 0;
  for (let i = 0; i < foundConsultations.length; i++) {
    consultationsAvailable +=
      foundConsultations[i].quantity - foundConsultations[i].case.length;
  }

  return consultationsAvailable;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/generateKey.ts

export const generateKey = (pre: string) => {
  return `${pre}_${new Date().getTime()}`;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/sleep.ts

export const sleep = async (ms: number) => {
  await new Promise((r) => setTimeout(r, ms));
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/statusCodes.ts

/**
 * Hypertext Transfer Protocol (HTTP) response status codes.
 * @see {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}
 */
enum HttpStatusCode {
  /**
   * The server has received the request headers and the client should proceed to send the request body
   * (in the case of a request for which a body needs to be sent; for example, a POST request).
   * Sending a large request body to a server after a request has been rejected for inappropriate headers would be inefficient.
   * To have a server check the request's headers, a client must send Expect: 100-continue as a header in its initial request
   * and receive a 100 Continue status code in response before sending the body. The response 417 Expectation Failed indicates the request should not be continued.
   */
  CONTINUE = 100,

  /**
   * The requester has asked the server to switch protocols and the server has agreed to do so.
   */
  SWITCHING_PROTOCOLS = 101,

  /**
   * A WebDAV request may contain many sub-requests involving file operations, requiring a long time to complete the request.
   * This code indicates that the server has received and is processing the request, but no response is available yet.
   * This prevents the client from timing out and assuming the request was lost.
   */
  PROCESSING = 102,

  /**
   * Standard response for successful HTTP requests.
   * The actual response will depend on the request method used.
   * In a GET request, the response will contain an entity corresponding to the requested resource.
   * In a POST request, the response will contain an entity describing or containing the result of the action.
   */
  OK = 200,

  /**
   * The request has been fulfilled, resulting in the creation of a new resource.
   */
  CREATED = 201,

  /**
   * The request has been accepted for processing, but the processing has not been completed.
   * The request might or might not be eventually acted upon, and may be disallowed when processing occurs.
   */
  ACCEPTED = 202,

  /**
   * SINCE HTTP/1.1
   * The server is a transforming proxy that received a 200 OK from its origin,
   * but is returning a modified version of the origin's response.
   */
  NON_AUTHORITATIVE_INFORMATION = 203,

  /**
   * The server successfully processed the request and is not returning any content.
   */
  NO_CONTENT = 204,

  /**
   * The server successfully processed the request, but is not returning any content.
   * Unlike a 204 response, this response requires that the requester reset the document view.
   */
  RESET_CONTENT = 205,

  /**
   * The server is delivering only part of the resource (byte serving) due to a range header sent by the client.
   * The range header is used by HTTP clients to enable resuming of interrupted downloads,
   * or split a download into multiple simultaneous streams.
   */
  PARTIAL_CONTENT = 206,

  /**
   * The message body that follows is an XML message and can contain a number of separate response codes,
   * depending on how many sub-requests were made.
   */
  MULTI_STATUS = 207,

  /**
   * The members of a DAV binding have already been enumerated in a preceding part of the (multistatus) response,
   * and are not being included again.
   */
  ALREADY_REPORTED = 208,

  /**
   * The server has fulfilled a request for the resource,
   * and the response is a representation of the result of one or more instance-manipulations applied to the current instance.
   */
  IM_USED = 226,

  /**
   * Indicates multiple options for the resource from which the client may choose (via agent-driven content negotiation).
   * For example, this code could be used to present multiple video format options,
   * to list files with different filename extensions, or to suggest word-sense disambiguation.
   */
  MULTIPLE_CHOICES = 300,

  /**
   * This and all future requests should be directed to the given URI.
   */
  MOVED_PERMANENTLY = 301,

  /**
   * This is an example of industry practice contradicting the standard.
   * The HTTP/1.0 specification (RFC 1945) required the client to perform a temporary redirect
   * (the original describing phrase was "Moved Temporarily"), but popular browsers implemented 302
   * with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 and 307
   * to distinguish between the two behaviours. However, some Web applications and frameworks
   * use the 302 status code as if it were the 303.
   */
  FOUND = 302,

  /**
   * SINCE HTTP/1.1
   * The response to the request can be found under another URI using a GET method.
   * When received in response to a POST (or PUT/DELETE), the client should presume that
   * the server has received the data and should issue a redirect with a separate GET message.
   */
  SEE_OTHER = 303,

  /**
   * Indicates that the resource has not been modified since the version specified by the request headers If-Modified-Since or If-None-Match.
   * In such case, there is no need to retransmit the resource since the client still has a previously-downloaded copy.
   */
  NOT_MODIFIED = 304,

  /**
   * SINCE HTTP/1.1
   * The requested resource is available only through a proxy, the address for which is provided in the response.
   * Many HTTP clients (such as Mozilla and Internet Explorer) do not correctly handle responses with this status code, primarily for security reasons.
   */
  USE_PROXY = 305,

  /**
   * No longer used. Originally meant "Subsequent requests should use the specified proxy."
   */
  SWITCH_PROXY = 306,

  /**
   * SINCE HTTP/1.1
   * In this case, the request should be repeated with another URI; however, future requests should still use the original URI.
   * In contrast to how 302 was historically implemented, the request method is not allowed to be changed when reissuing the original request.
   * For example, a POST request should be repeated using another POST request.
   */
  TEMPORARY_REDIRECT = 307,

  /**
   * The request and all future requests should be repeated using another URI.
   * 307 and 308 parallel the behaviors of 302 and 301, but do not allow the HTTP method to change.
   * So, for example, submitting a form to a permanently redirected resource may continue smoothly.
   */
  PERMANENT_REDIRECT = 308,

  /**
   * The server cannot or will not process the request due to an apparent client error
   * (e.g., malformed request syntax, too large size, invalid request message framing, or deceptive request routing).
   */
  BAD_REQUEST = 400,

  /**
   * Similar to 403 Forbidden, but specifically for use when authentication is required and has failed or has not yet
   * been provided. The response must include a WWW-Authenticate header field containing a challenge applicable to the
   * requested resource. See Basic access authentication and Digest access authentication. 401 semantically means
   * "unauthenticated",i.e. the user does not have the necessary credentials.
   */
  UNAUTHORIZED = 401,

  /**
   * Reserved for future use. The original intention was that this code might be used as part of some form of digital
   * cash or micro payment scheme, but that has not happened, and this code is not usually used.
   * Google Developers API uses this status if a particular developer has exceeded the daily limit on requests.
   */
  PAYMENT_REQUIRED = 402,

  /**
   * The request was valid, but the server is refusing action.
   * The user might not have the necessary permissions for a resource.
   */
  FORBIDDEN = 403,

  /**
   * The requested resource could not be found but may be available in the future.
   * Subsequent requests by the client are permissible.
   */
  NOT_FOUND = 404,

  /**
   * A request method is not supported for the requested resource;
   * for example, a GET request on a form that requires data to be presented via POST, or a PUT request on a read-only resource.
   */
  METHOD_NOT_ALLOWED = 405,

  /**
   * The requested resource is capable of generating only content not acceptable according to the Accept headers sent in the request.
   */
  NOT_ACCEPTABLE = 406,

  /**
   * The client must first authenticate itself with the proxy.
   */
  PROXY_AUTHENTICATION_REQUIRED = 407,

  /**
   * The server timed out waiting for the request.
   * According to HTTP specifications:
   * "The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time."
   */
  REQUEST_TIMEOUT = 408,

  /**
   * Indicates that the request could not be processed because of conflict in the request,
   * such as an edit conflict between multiple simultaneous updates.
   */
  CONFLICT = 409,

  /**
   * Indicates that the resource requested is no longer available and will not be available again.
   * This should be used when a resource has been intentionally removed and the resource should be purged.
   * Upon receiving a 410 status code, the client should not request the resource in the future.
   * Clients such as search engines should remove the resource from their indices.
   * Most use cases do not require clients and search engines to purge the resource, and a "404 Not Found" may be used instead.
   */
  GONE = 410,

  /**
   * The request did not specify the length of its content, which is required by the requested resource.
   */
  LENGTH_REQUIRED = 411,

  /**
   * The server does not meet one of the preconditions that the requester put on the request.
   */
  PRECONDITION_FAILED = 412,

  /**
   * The request is larger than the server is willing or able to process. Previously called "Request Entity Too Large".
   */
  PAYLOAD_TOO_LARGE = 413,

  /**
   * The URI provided was too long for the server to process. Often the result of too much data being encoded as a query-string of a GET request,
   * in which case it should be converted to a POST request.
   * Called "Request-URI Too Long" previously.
   */
  URI_TOO_LONG = 414,

  /**
   * The request entity has a media type which the server or resource does not support.
   * For example, the client uploads an image as image/svg+xml, but the server requires that images use a different format.
   */
  UNSUPPORTED_MEDIA_TYPE = 415,

  /**
   * The client has asked for a portion of the file (byte serving), but the server cannot supply that portion.
   * For example, if the client asked for a part of the file that lies beyond the end of the file.
   * Called "Requested Range Not Satisfiable" previously.
   */
  RANGE_NOT_SATISFIABLE = 416,

  /**
   * The server cannot meet the requirements of the Expect request-header field.
   */
  EXPECTATION_FAILED = 417,

  /**
   * This code was defined in 1998 as one of the traditional IETF April Fools' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol,
   * and is not expected to be implemented by actual HTTP servers. The RFC specifies this code should be returned by
   * teapots requested to brew coffee. This HTTP status is used as an Easter egg in some websites, including Google.com.
   */
  I_AM_A_TEAPOT = 418,

  /**
   * The request was directed at a server that is not able to produce a response (for example because a connection reuse).
   */
  MISDIRECTED_REQUEST = 421,

  /**
   * The request was well-formed but was unable to be followed due to semantic errors.
   */
  UNPROCESSABLE_ENTITY = 422,

  /**
   * The resource that is being accessed is locked.
   */
  LOCKED = 423,

  /**
   * The request failed due to failure of a previous request (e.g., a PROPPATCH).
   */
  FAILED_DEPENDENCY = 424,

  /**
   * The client should switch to a different protocol such as TLS/1.0, given in the Upgrade header field.
   */
  UPGRADE_REQUIRED = 426,

  /**
   * The origin server requires the request to be conditional.
   * Intended to prevent "the 'lost update' problem, where a client
   * GETs a resource's state, modifies it, and PUTs it back to the server,
   * when meanwhile a third party has modified the state on the server, leading to a conflict."
   */
  PRECONDITION_REQUIRED = 428,

  /**
   * The user has sent too many requests in a given amount of time. Intended for use with rate-limiting schemes.
   */
  TOO_MANY_REQUESTS = 429,

  /**
   * The server is unwilling to process the request because either an individual header field,
   * or all the header fields collectively, are too large.
   */
  REQUEST_HEADER_FIELDS_TOO_LARGE = 431,

  /**
   * A server operator has received a legal demand to deny access to a resource or to a set of resources
   * that includes the requested resource. The code 451 was chosen as a reference to the novel Fahrenheit 451.
   */
  UNAVAILABLE_FOR_LEGAL_REASONS = 451,

  /**
   * A generic error message, given when an unexpected condition was encountered and no more specific message is suitable.
   */
  INTERNAL_SERVER_ERROR = 500,

  /**
   * The server either does not recognize the request method, or it lacks the ability to fulfill the request.
   * Usually this implies future availability (e.g., a new feature of a web-service API).
   */
  NOT_IMPLEMENTED = 501,

  /**
   * The server was acting as a gateway or proxy and received an invalid response from the upstream server.
   */
  BAD_GATEWAY = 502,

  /**
   * The server is currently unavailable (because it is overloaded or down for maintenance).
   * Generally, this is a temporary state.
   */
  SERVICE_UNAVAILABLE = 503,

  /**
   * The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.
   */
  GATEWAY_TIMEOUT = 504,

  /**
   * The server does not support the HTTP protocol version used in the request
   */
  HTTP_VERSION_NOT_SUPPORTED = 505,

  /**
   * Transparent content negotiation for the request results in a circular reference.
   */
  VARIANT_ALSO_NEGOTIATES = 506,

  /**
   * The server is unable to store the representation needed to complete the request.
   */
  INSUFFICIENT_STORAGE = 507,

  /**
   * The server detected an infinite loop while processing the request.
   */
  LOOP_DETECTED = 508,

  /**
   * Further extensions to the request are required for the server to fulfill it.
   */
  NOT_EXTENDED = 510,

  /**
   * The client needs to authenticate to gain network access.
   * Intended for use by intercepting proxies used to control access to the network (e.g., "captive portals" used
   * to require agreement to Terms of Service before granting full Internet access via a Wi-Fi hotspot).
   */
  NETWORK_AUTHENTICATION_REQUIRED = 511,
}

export default HttpStatusCode;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/get-is-prod.ts

export function getIsProd() {
  return (process.env.ENVIRONMENT_NAME ?? 'production') === 'production';
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/get-user-state.ts

import { cookies } from 'next/headers';

import { UserInclude } from '@/app/shared/types';
import { getBaseUrl } from '@/utils/getBaseUrl';

import LoggerUtil from './clients/logging/apiUtilLogger';
import { UserStatus } from './enums';

export const getUserStatus = async (user: UserInclude) => {
  if (isB2B(user)) {
    return UserStatus.B2B_LANDING;
  }

  if (await needsConsultation()) {
    return UserStatus.DTC_CONSULTATION_NEEDED;
  }

  if (needsProfile(user)) {
    return UserStatus.DTC_PROFILE_NEEDED;
  }

  if (needsMedical(user)) {
    return UserStatus.DTC_MEDICAL_NEEDED;
  }

  return UserStatus.DTC_CHOOSE_CASE_TYPE;
};

export const needsConsultation = async () => {
  try {
    const availableCheckUrl = `${getBaseUrl()}/api/case/consultations-available`;
    const response = await fetch(availableCheckUrl, {
      headers: {
        Cookie: cookies().toString(),
      },
    });

    const data = await response.json();

    return data.consultationsAvailable <= 0;
  } catch (error) {
    await LoggerUtil.logError(
      'failed_to_fetch_consultations_availability',
      'getUserState > needsConsultation',
      error,
      {
        cookies: cookies().toString(),
      }
    );

    return true; // Assume consultation needed on error
  }
};

export const needsProfile = (user: UserInclude) => {
  return (
    !user?.firstName ||
    !user?.lastName ||
    !user?.phoneNumber ||
    user?.addresses.length < 1
  );
};

export const needsMedical = (user: UserInclude) => {
  return (
    !user?.dosespotId ||
    !user?.medicalProfile?.dob ||
    !user?.medicalProfile?.sexAtBirth ||
    !user?.medicalProfile ||
    user.medicalProfile.medicalProfileCompletedDate === null
  );
};

export const isB2B = (user: UserInclude) => {
  return false;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/get-prismic-product-id.ts

import {
  ProductPageDocumentData,
  SubscriptionPlanSliceDefaultItem,
} from 'prismicio-types';

import { KeyTextField } from '@prismicio/client';

import { getIsProd } from './get-is-prod';

const isProd = getIsProd();

export function getPrismicProductId(
  data: ProductPageDocumentData | SubscriptionPlanSliceDefaultItem
): KeyTextField {
  return !isProd ? data.dev_product_id : data.product_id;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/handlebars-helpers.ts

import Handlebars from 'handlebars';

const helpers: {
  [key: string]: (value: any) => string | boolean;
} = {
  isDefined: (value) => {
    return value !== undefined;
  },
  json: (value) => {
    const result = JSON.stringify(value);
    return new Handlebars.SafeString(result) as any;
  },
};

const registerHelpers = () => {
  Object.keys(helpers).forEach((helperName) => {
    const helperFn = helpers[helperName];
    Handlebars.registerHelper(helperName, helperFn);
  });
};

export { registerHelpers };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/getBaseUrl.ts

export function getBaseUrl() {
  return process.env.NEXT_PUBLIC_BASE_URL;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/mergeTranslations.ts

import mergeWith from 'lodash.mergewith';

import {
  FormInclude,
  SectionInclude,
  StepInclude,
  FormElementInclude,
} from '@form/utils/types';

export const mergeContent = (content: any, locale: string) => {
  if (!content?.translations) {
    return content;
  }

  const translation = (content.translations as any).find(
    (translation: any) => translation.locale === locale
  );
  if (translation) {
    return mergeWith({}, content, translation, (a, b) =>
      b === null ? a : undefined
    );
  }

  return content;
};

const mergeFormElement: (
  content: FormElementInclude,
  locale: string
) => FormElementInclude = (content, locale) => {
  return {
    ...content,
    text: content.text ? mergeContent(content.text, locale) : null,
    field: content.field ? mergeContent(content.field, locale) : null,
  };
};

const mergeFormStep: (content: StepInclude, locale: string) => StepInclude = (
  content,
  locale
) => {
  return {
    ...content,
    formElements: content.formElements.map((formElement) =>
      mergeFormElement(formElement, locale)
    ),
  };
};

const mergeFormSection: (
  content: SectionInclude,
  locale: string
) => SectionInclude = (content, locale) => {
  return {
    ...mergeContent(content, locale),
    steps: content.steps.map((step) => mergeFormStep(step, locale)),
  };
};

export const mergeFormTranslations: (
  content: FormInclude,
  locale: string
) => FormInclude = (content, locale) => {
  return {
    ...mergeContent(content, locale),
    sections: content.sections.map((section) =>
      mergeFormSection(section, locale)
    ),
  };
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/enums.ts

export enum UploadStatus {
  UPLOADING = 'UPLOADING',
  ERROR = 'ERROR',
  SUCCESS = 'SUCCESS',
}

export enum FileType {
  IMAGE = 'IMAGE',
  VIDEO = 'VIDEO',
  DOCUMENT = 'DOCUMENT',
}

export enum UserStatus {
  B2B_LANDING = 'B2B_LANDING',
  DTC_CONSULTATION_NEEDED = 'DTC_CONSULTATION_NEEDED',
  DTC_PROFILE_NEEDED = 'DTC_PROFILE_NEEDED',
  DTC_MEDICAL_NEEDED = 'DTC_MEDICAL_NEEDED',
  DTC_CHOOSE_CASE_TYPE = 'DTC_CHOOSE_CASE_TYPE',
}

export enum FulfillmentOptions {
  ONE_TIME_PURCHASE = 'Cortina Home Delivery',
  SUBSCRIPTION = 'Auto Refill',
  REMOVE = 'Save for Later (up to 1 year)',
}

export enum FORM_KEYS {
  DEPENDENT_FORM = 'dependent_form',
  DEFAULT_FORM = 'default_form',
}

export enum ConsultationType {
  SELF = 'self',
  FAMILY = 'family',
  PREPAYMENT = 'prepayment',
}

export enum COOKIE_KEYS {
  FAMILY_MEMBER = 'for-family-member',
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/get-case-physician-access.ts

import { CaseInclude, ExtendedUserAttributes } from '@/app/shared/types';
import { User, Case } from '@prisma/client';

const accessExpiresAfterDays = parseInt(
  process.env.CASE_MESSAGING_ACCESS_EXPIRES_AFTER_DAYS || '7',
  10
);

export type IExtendedCase<T> = T & {
  hasPhysicianAccess: boolean;
  nonConciergeAccessExpiresOn: string;
};

type casePhysicianAccessType = <T extends { createdAt: Date }>(
  caseItem: T,
  userAttributes: { hasConcierge: boolean }
) => IExtendedCase<T>;

export const getCasePhysicianAccess: casePhysicianAccessType = (
  caseItem,
  userAttributes
) => {
  const createdAt = new Date(caseItem.createdAt);
  const accessExpiresOn = new Date(createdAt);
  accessExpiresOn.setDate(createdAt.getDate() + accessExpiresAfterDays);

  const today = new Date();
  const diffTime = Math.abs(today.getTime() - createdAt.getTime());
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  return {
    ...caseItem,
    hasPhysicianAccess: userAttributes.hasConcierge
      ? true
      : diffDays <= accessExpiresAfterDays,
    nonConciergeAccessExpiresOn: accessExpiresOn.toISOString().split('T')[0], // Format the date as YYYY-MM-DD
  };
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/utils.tsx

import dayjs from 'dayjs';
import advancedFormat from 'dayjs/plugin/advancedFormat';
import get from 'lodash.get';
import Cookies from 'universal-cookie';

import { CaseInclude } from '@/app/shared/types';
import { UserInclude } from '@/app/shared/types';
import { Case, Product, ProductCategories } from '@prisma/client';

import { COOKIE_KEYS, FileType } from './enums';

dayjs.extend(advancedFormat);

export const convertStringToKebabCase = (str?: string | null) => {
  const newString = str != null ? str : '';
  // Remove special characters and punctuation
  const stripped = newString.replace(/[^\w\s]/gi, '');

  // Convert spaces to hyphens and convert to lowercase
  return stripped.replace(/\s+/g, '-').toLowerCase();
};

export const stateAbbreviationMap: { [key: string]: string } = {
  Alabama: 'AL',
  Alaska: 'AK',
  Arizona: 'AZ',
  Arkansas: 'AR',
  California: 'CA',
  Colorado: 'CO',
  Connecticut: 'CT',
  Delaware: 'DE',
  Florida: 'FL',
  Georgia: 'GA',
  Guam: 'GU',
  Hawaii: 'HI',
  Idaho: 'ID',
  Illinois: 'IL',
  Indiana: 'IN',
  Iowa: 'IA',
  Kansas: 'KS',
  Kentucky: 'KY',
  Louisiana: 'LA',
  Maine: 'ME',
  Maryland: 'MD',
  Massachusetts: 'MA',
  Michigan: 'MI',
  Minnesota: 'MN',
  Mississippi: 'MS',
  Missouri: 'MO',
  Montana: 'MT',
  Nebraska: 'NE',
  Nevada: 'NV',
  'New Hampshire': 'NH',
  'New Jersey': 'NJ',
  'New Mexico': 'NM',
  'New York': 'NY',
  'North Carolina': 'NC',
  'North Dakota': 'ND',
  Ohio: 'OH',
  Oklahoma: 'OK',
  Oregon: 'OR',
  Pennsylvania: 'PA',
  'Rhode Island': 'RI',
  'South Carolina': 'SC',
  'South Dakota': 'SD',
  Tennessee: 'TN',
  Texas: 'TX',
  Utah: 'UT',
  Vermont: 'VT',
  Virginia: 'VA',
  Washington: 'WA',
  'West Virginia': 'WV',
  Wisconsin: 'WI',
  Wyoming: 'WY',
};

export const getStateFromAbbreviation = (abbr: string): string => {
  const stateObj = Object.entries(stateAbbreviationMap).find(
    ([, abbreviation]) => {
      return abbreviation === abbr;
    }
  );

  if (!stateObj) throw new Error('No state found for abbreviation: ' + abbr);

  return stateObj[0];
};

export const listOfStateAbbreviations = Object.values(stateAbbreviationMap);

export const listOfStates = Object.keys(stateAbbreviationMap);

export function convertBytes(bytes: number) {
  if (bytes === 0) {
    return '0 B';
  }

  const e = Math.floor(Math.log(bytes) / Math.log(1024));
  return (
    (bytes / Math.pow(1024, e)).toFixed(0) + ' ' + ' KMGTP'.charAt(e) + 'B'
  );
}

export const getFormattedMessageDate = (
  obj: { [key: string]: any },
  path: string,
  format = 'MMM Do, YYYY'
) => {
  const date = get(obj, path, undefined);
  if (date && dayjs(date).isValid()) {
    const sentDate = dayjs(date);
    if (sentDate.isSame(dayjs(), 'day')) {
      return 'Today';
    } else if (sentDate.isSame(dayjs().add(-1, 'day'), 'day')) {
      return 'Yesterday';
    } else {
      return dayjs(date).format(format);
    }
  }

  return '';
};

export const parseJSONOrDefault = (json: string, defaultValue: any) => {
  try {
    return JSON.parse(json);
  } catch (e) {
    return defaultValue;
  }
};

export const determineFileType = (fileType: string) => {
  if (fileType.includes('image')) {
    return FileType.IMAGE;
  } else if (fileType.includes('video')) {
    return FileType.VIDEO;
  } else {
    return FileType.DOCUMENT;
  }
};

type CaseType = Case | CaseInclude;

export const getDefaultCase = <T extends CaseType>(
  cases: T[],
  caseId?: string
) => {
  if (cases.length === 0) {
    return {} as T;
  }

  if (caseId) {
    return cases.find((c) => c.id === caseId);
  } else {
    // Define the priority for each status
    const statusPriority = {
      PREPAYMENT: 1,
      PATIENT_REVIEW: 2,
      PATIENT_OPENED: 3,
      EXPIRED: 14,
      PHYSICIAN_FINALIZED: 0,
      DIAGNOSED_PRESCRIBED: 5,
      DIAGNOSED_AWAITING_PHARMACY: 6,
      DIAGNOSED_NO_PRESCRIPTION: 7,
      ASSIGNED: 8,
      OPEN: 9,
      IMAGES_NEEDED: 10,
      PENDING: 11,
      ARCHIVED: 12,
      DELETED: 13,
    };

    // Sort cases by status priority and then by createdAt date
    const sortedCases = cases.sort((a, b) => {
      const priorityA = statusPriority[a.status];
      const priorityB = statusPriority[b.status];

      if (priorityA !== priorityB) {
        return priorityA - priorityB;
      }

      // If priorities are equal, sort by createdAt date
      return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
    });

    // Return the highest priority case
    return sortedCases[0] ?? ({} as T);
  }
};

export const formatCurrency = (amount: number) => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
  }).format(amount / 100);
};

export const classNames = (...classes: string[]) =>
  classes.filter(Boolean).join(' ');

export const formatPrice = function (price: number) {
  return `$${(price / 100).toFixed(2)}`;
};

// Sort Product Types by Category and Name for Cart Use ------------
const getProductPriority = (type: ProductCategories) => {
  const priorities = {
    [ProductCategories.PRESCRIPTION_MEDICATION]: 1,
    [ProductCategories.OTC_MEDICATION]: 2,
    [ProductCategories.CONCIERGE]: 3,
    [ProductCategories.CONSULTATION]: 4,
  };
  return priorities[type] || 5; // Default priority for unknown types
};

export const sortProducts = (products: Product[]) => {
  return products.sort((a, b) => {
    const categoryPriorityDifference =
      getProductPriority(a.category) - getProductPriority(b.category);
    if (categoryPriorityDifference === 0) {
      // Sort by name if categories are the same
      return a.name.localeCompare(b.name);
    }
    return categoryPriorityDifference;
  });
};

export const getUserFromDependents = (user: UserInclude, userId?: string) => {
  if (userId === undefined || user.id === userId) return user;

  return user?.dependents?.find((dep) => dep.id === userId) ?? undefined;
};

export const getSelectedDependentOrPrimaryUser = (
  user: UserInclude,
  userId?: string
) => {
  if (userId === undefined || user.id === userId) return user;

  return user?.dependents?.find((dep) => dep.id === userId) ?? user;
};

export const getFamilyMemberHeader = () => {
  const cookies = new Cookies();

  const familyMemberCookie = cookies.get(COOKIE_KEYS.FAMILY_MEMBER);

  if (!familyMemberCookie) {
    return undefined;
  }

  return {
    [COOKIE_KEYS.FAMILY_MEMBER]: familyMemberCookie.toString() as string,
  };
};

export const deepLog = (name: string, object: any): void => {
  console.log(`Log for ${name}:`);
  console.log(JSON.stringify(object, null, 2));
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/get-full-name.ts

export const getFullName = (
  firstName: string | null | undefined,
  lastName: string | null | undefined,
  defaultName: string | null | undefined
) => {
  if (firstName && lastName) {
    return `${firstName} ${lastName}`;
  } else if (firstName) {
    return firstName;
  } else if (lastName) {
    return lastName;
  } else if (defaultName) {
    return defaultName;
  }

  return '';
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/icd10/icd10Client.ts

import { promises as fs } from 'fs';
import path from 'path';

interface ICD10ComplexTitle {
  nemod: string;
  __text: string;
}

interface ICD10Term {
  title: string | ICD10ComplexTitle;
  see?: string;
  code?: string;
  seeAlso?: string;
  term: ICD10Term[];
  _level?: string;
}

interface ICD10File {
  index: {
    letter: {
      title: string;
      mainTerm: ICD10Term[];
    }[];
  };
}

interface ICD10TermWithPriority {
  priority: TermResulPriority;
  term: ICD10Term;
}

interface ResponseTerm {
  priority: number;
  title: string;
  code: string;
}

enum TermResulPriority {
  HIGH = 1,
  MEDIUM = 2,
  LOW = 3,
}

const getICD10Codes = async () => {
  const icd10FilePath = path.join(
    process.cwd(),
    'public',
    'icd10-codes-2024.json'
  );
  const icd10Data = await fs.readFile(icd10FilePath, 'utf8');

  return (JSON.parse(icd10Data) as ICD10File).index;
};

const processTermResults = (
  termResults: ICD10TermWithPriority[],
  secondaryTerm?: string
): ResponseTerm[] => {
  if (termResults.length === 0) return [];

  const finalResults: ResponseTerm[] = [];

  for (const termWithPriority of termResults) {
    const { term, priority } = termWithPriority;
    const code = term.code;
    const title =
      typeof term.title === 'string'
        ? term.title
        : `${term.title.__text} ${term.title.nemod}`;

    if (code) finalResults.push({ title, code, priority: priority });

    if (term.term?.length > 0)
      finalResults.push(
        ...processChildTerms(term.term, priority, title, secondaryTerm)
      );
  }

  return finalResults;
};

const processChildTerms = (
  terms: ICD10Term[],
  parentPriority: TermResulPriority,
  parentTermTitle: string,
  secondaryTerm?: string
): ResponseTerm[] => {
  const finalResults: ResponseTerm[] = [];

  for (const childTerm of terms) {
    const code = childTerm.code;
    const title =
      typeof childTerm.title === 'string'
        ? `${parentTermTitle} ${childTerm.title}`
        : `${parentTermTitle} ${childTerm.title.__text} ${childTerm.title.nemod}`;

    let priority = parentPriority;

    if (secondaryTerm && title.toUpperCase().includes(secondaryTerm))
      priority = TermResulPriority.HIGH;

    if (code) finalResults.push({ title, code, priority });

    if (childTerm.term?.length > 0)
      finalResults.push(
        ...processChildTerms(childTerm.term, priority, title, secondaryTerm)
      );
  }

  return finalResults;
};

export default class ICD10Client {
  public static async findMyNeedle(needle: string) {
    const icd10Data = await getICD10Codes();

    const needles = needle.split(' ');

    const primaryTerm = needles[0].toUpperCase();
    const secondaryTerm =
      needles.length > 1 ? needles[1].toUpperCase() : undefined;

    const letterData = icd10Data.letter.find(
      (letter) => letter.title === primaryTerm[0]
    );

    if (!letterData) {
      return null;
    }

    const termResults: ICD10TermWithPriority[] = [];

    letterData.mainTerm.forEach((term) => {
      const termToCompare =
        typeof term.title === 'string'
          ? term.title.toUpperCase()
          : term.title.__text.concat(term.title.nemod).toUpperCase();

      if (termToCompare.includes(needle.toUpperCase()))
        termResults.push({ term, priority: TermResulPriority.HIGH });
      else if (termToCompare.includes(primaryTerm.toUpperCase()))
        termResults.push({ term, priority: TermResulPriority.MEDIUM });
    });

    const responseItem: ResponseTerm[] = processTermResults(
      termResults,
      secondaryTerm
    );

    responseItem.sort((a, b) => a.priority - b.priority);

    return responseItem;
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/cognito/cognitoClient.ts

import crypto from 'crypto';

import {
  AliasExistsException,
  CodeDeliveryFailureException,
  CodeMismatchException,
  CognitoIdentityProvider,
  ConfirmSignUpCommandOutput,
  ExpiredCodeException,
  InvalidPasswordException,
  SignUpCommandOutput,
  UserLambdaValidationException,
  UsernameExistsException,
} from '@aws-sdk/client-cognito-identity-provider';

import { signup, signin, signupConfirm } from './methods';
import {
  CognitoSigninParams,
  CognitoSignupConfirmParams,
  CognitoSignupParams,
  CognitoUserPoolData,
} from './types/cognito-types';

const poolData: CognitoUserPoolData = {
  UserPoolId: String(process.env.COGNITO_USER_POOL_ID),
  ClientId: String(process.env.COGNITO_CLIENT_ID),
};

export const getSecretHash = (username: string) => {
  const clientSecret = String(process.env.COGNITO_CLIENT_SECRET);

  return crypto
    .createHmac('SHA256', clientSecret)
    .update(username + poolData.ClientId)
    .digest('base64');
};

export enum CognitoProviderEnum {
  COGNITO = 'Cognito',
  GOOGLE = 'Google',
}

export const adminIdentityProvider = new CognitoIdentityProvider({
  region: String(process.env.COGNITO_AWS_REGION),
  credentials: {
    accessKeyId: String(process.env.COGNITO_AWS_ACCESS_KEY),
    secretAccessKey: String(process.env.COGNITO_AWS_SECRET_KEY),
  },
});

export const userIdentityProvider: CognitoIdentityProvider =
  new CognitoIdentityProvider({
    region: String(process.env.COGNITO_AWS_REGION),
  });

export default class CognitoClient {
  public static async getUserAttributesBySub(userName: string) {
    const result = await adminIdentityProvider.adminGetUser({
      UserPoolId: poolData.UserPoolId,
      Username: userName,
    });

    return result.UserAttributes;
  }

  public static async updateCortinaIdByUsername(
    userName: string,
    cortinaId: string
  ) {
    await adminIdentityProvider.adminUpdateUserAttributes({
      UserAttributes: [{ Name: 'custom:cortina_id', Value: cortinaId }],
      UserPoolId: poolData.UserPoolId,
      Username: userName,
    });
  }

  // added code for future use to link accounts
  public static async linkExistingAccount(
    email: string,
    cognitoProvider: CognitoProviderEnum
  ) {
    await adminIdentityProvider.adminLinkProviderForUser({
      UserPoolId: poolData.UserPoolId,
      SourceUser: {
        ProviderName: cognitoProvider,
        ProviderAttributeName: 'email',
        ProviderAttributeValue: email,
      },
      DestinationUser: {
        ProviderName: 'Cognito',
        ProviderAttributeName: 'email',
        ProviderAttributeValue: email,
      },
    });
  }

  public static signUp({
    username,
    password,
    callback,
  }: Omit<CognitoSignupParams, 'poolData'>) {
    return signup({ username, password, callback, poolData });
  }

  public static signUpConfirm({
    username,
    confirmationCode,
    callback,
  }: Omit<CognitoSignupConfirmParams, 'poolData'>) {
    return signupConfirm({ username, confirmationCode, callback, poolData });
  }

  public static async signIn({
    username,
    password,
    callback,
  }: Omit<CognitoSigninParams, 'poolData'>) {
    return signin({ username, password, callback, poolData });
  }

  public static async getCognitoUserWithToken(accessToken: string) {
    return await userIdentityProvider.getUser({ AccessToken: accessToken });
  }

  public static async requestNewConfirmationCode(
    userName: string
  ): Promise<resendConfirmationCodeResult> {
    try {
      const secretHash = getSecretHash(userName);

      await userIdentityProvider.resendConfirmationCode({
        ClientId: poolData.ClientId,
        Username: userName,
        SecretHash: secretHash,
        ClientMetadata: { provider: 'Cognito' },
      });

      return { success: true };
    } catch (e) {
      let errorMessage =
        'An unknown problem ocurred during confirmation. Please try again.';

      if (e instanceof AliasExistsException)
        errorMessage =
          'This account has already been confirmed. Please login. ';
      else if (e instanceof CodeMismatchException)
        errorMessage =
          'The code you entered does not match the most recent code sent to you.';
      else if (e instanceof ExpiredCodeException)
        errorMessage =
          'The code you have entered has expired. Please request a new confirmation code.';

      return { success: false, errorMessage };
    }
  }

  public static async resendConfirmationCodeIfUnconfirmed(email: string) {
    try {
      const result = await adminIdentityProvider.adminGetUser({
        Username: email,
        UserPoolId: poolData.UserPoolId,
      });

      if (result && result.UserStatus === 'UNCONFIRMED') {
        await this.requestNewConfirmationCode(email);
        return true;
      }

      return false;
    } catch (e) {
      return false;
    }
  }

  public static async signUpConfirmationAction(
    userName: string,
    confirmationCode: string
  ): Promise<SignupResult<ConfirmSignUpCommandOutput>> {
    try {
      const secretHash = getSecretHash(userName);

      const confirmationResult = await userIdentityProvider.confirmSignUp({
        ClientId: poolData.ClientId,
        Username: userName,
        ConfirmationCode: confirmationCode,
        SecretHash: secretHash,
        ClientMetadata: { provider: 'Cognito' },
      });

      return { success: true, result: confirmationResult };
    } catch (e) {
      let errorMessage =
        'An unknown problem ocurred during confirmation. Please try again.';

      if (e instanceof AliasExistsException)
        errorMessage =
          'This account has already been confirmed. Please login. ';
      else if (e instanceof CodeMismatchException)
        errorMessage =
          'The code you entered does not match the most recent code sent to you.';
      else if (e instanceof ExpiredCodeException)
        errorMessage =
          'The code you have entered has expired. Please request a new confirmation code.';

      return { success: false, errorMessage };
    }
  }

  public static async signUpUser(
    userName: string,
    password: string
  ): Promise<SignupResult<SignUpCommandOutput>> {
    try {
      const secretHash = getSecretHash(userName);

      const signupResult = await userIdentityProvider.signUp({
        ClientId: poolData.ClientId,
        Username: userName,
        Password: password,
        SecretHash: secretHash,
        ClientMetadata: { provider: 'Cognito' },
      });

      return { success: true, result: signupResult };
    } catch (e) {
      console.log(e);
      let errorMessage =
        'An unknown problem ocurred during signup. Please try again.';

      if (e instanceof CodeDeliveryFailureException)
        errorMessage =
          'Failed to deliver temporary code, please ensure the email you provided is valid.';
      else if (e instanceof InvalidPasswordException)
        errorMessage =
          'The password you provided does not meet the mininmum requirements, please choose a new password.';
      else if (e instanceof UsernameExistsException) {
        const isUnconfirmed = await this.resendConfirmationCodeIfUnconfirmed(
          userName
        );

        if (isUnconfirmed) return { success: true };

        errorMessage =
          'The username you provided already exists in our system. Please login instead.';
      } else if (
        e instanceof UserLambdaValidationException &&
        e.message.includes('Google')
      )
        errorMessage =
          'The email your provided was used to "Sign in  with Google" please sign in with Google instead.';

      return { success: false, errorMessage };
    }
  }
}

type resendConfirmationCodeResult =
  | {
      success: true;
    }
  | {
      success: false;
      errorMessage: string;
    };

type SignupResult<T> =
  | {
      success: true;
      result?: T;
    }
  | {
      success: false;
      errorMessage: string;
    };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/cognito/types/cognito-types.ts

import { CognitoUserSession } from 'amazon-cognito-identity-js';

import {
  ConfirmSignUpCommandOutput,
  InitiateAuthCommandOutput,
  SignUpCommandOutput,
} from '@aws-sdk/client-cognito-identity-provider';

export interface CognitoUserPoolData {
  UserPoolId: string;
  ClientId: string;
}

export interface CognitoSessionWithNextStep {
  nextStep: string;
  loginSession: CognitoUserSession | null;
}

export interface CognitoOAuthResponse {
  refreshToken: string;
  accessToken: string;
  accessTokenExpiresAt: number;
  idToken: string;
  idTokenExpiresAt: number;
}

export interface CognitoSignupResult {
  user_id: string;
  email: string;
  user_confirmed: boolean;
}

export interface CognitoSignupParams {
  poolData: CognitoUserPoolData;
  username: string;
  password: string;
  callback: (
    error: Error | null,
    user?: CognitoSignupResult | SignUpCommandOutput
  ) => void;
}

export interface CognitoSignupConfirmParams {
  poolData: CognitoUserPoolData;
  username: string;
  confirmationCode: string;
  callback: (error: Error | null, res?: ConfirmSignUpCommandOutput) => void;
}

export interface CognitoSigninParams {
  poolData: CognitoUserPoolData;
  username: string;
  password: string;
  callback: (error: Error | null, user?: InitiateAuthCommandOutput) => void;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/cognito/methods/index.ts

import signin from './signIn';
import signup from './signUp';
import signupConfirm from './signUpConfirm';

export { signup, signin, signupConfirm };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/cognito/methods/signIn.ts

import { InitiateAuthRequest } from '@aws-sdk/client-cognito-identity-provider';

import { getSecretHash, userIdentityProvider } from '../cognitoClient';
import { CognitoSigninParams } from '../types/cognito-types';

const signin = ({
  username,
  password,
  callback,
  poolData,
}: CognitoSigninParams) => {
  const initiateAuthRequest: InitiateAuthRequest = {
    ClientId: poolData.ClientId,
    AuthFlow: 'USER_PASSWORD_AUTH',
    AuthParameters: {
      USERNAME: username,
      PASSWORD: password,
      SECRET_HASH: getSecretHash(username),
    },
  };

  userIdentityProvider
    .initiateAuth(initiateAuthRequest)
    .then((res) => {
      callback(null, res);
    })
    .catch((error) => {
      callback(error);
    });
};

export default signin;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/cognito/methods/signUp.ts

import { CognitoUserAttribute } from 'amazon-cognito-identity-js';

import { SignUpRequest } from '@aws-sdk/client-cognito-identity-provider';

import { getSecretHash, userIdentityProvider } from '../cognitoClient';
import { CognitoSignupParams } from '../types/cognito-types';

const attributes = (key: string, value: string) => ({
  Name: key,
  Value: value,
});

const signup = ({
  username,
  password,
  callback,
  poolData,
}: CognitoSignupParams) => {
  const attributesList = [attributes('email', username)];

  const cognitoAttributeList = attributesList.map(
    (element) => new CognitoUserAttribute(element)
  );

  const signupRequest: SignUpRequest = {
    ClientId: poolData.ClientId,
    Password: password,
    Username: username,
    UserAttributes: cognitoAttributeList,
    SecretHash: getSecretHash(username),
  };

  userIdentityProvider
    .signUp(signupRequest)
    .then((res) => {
      callback(null, res);
    })
    .catch((error) => {
      callback(error);
    });
};

export default signup;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/cognito/methods/signUpConfirm.ts

import {
  CognitoIdentityProvider,
  ConfirmSignUpRequest,
} from '@aws-sdk/client-cognito-identity-provider';

import { getSecretHash } from '../cognitoClient';
import { CognitoSignupConfirmParams } from '../types/cognito-types';

const signupConfirm = ({
  username,
  confirmationCode,
  callback,
  poolData,
}: CognitoSignupConfirmParams) => {
  const confirmSignupRequest: ConfirmSignUpRequest = {
    ClientId: poolData.ClientId,
    ConfirmationCode: confirmationCode,
    Username: username,
    SecretHash: getSecretHash(username),
  };

  const identityProvider: CognitoIdentityProvider = new CognitoIdentityProvider(
    { region: 'us-east-2' }
  );

  identityProvider
    .confirmSignUp(confirmSignupRequest)
    .then((res) => {
      callback(null, res);
    })
    .catch((error) => {
      callback(error);
    });
};

export default signupConfirm;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/redis/redisClient.ts

import {
  createClient,
  RedisClientType,
  RedisModules,
  RedisFunctions,
  RedisScripts,
} from 'redis';

export default class RedisClient {
  //generic methods

  public static async getCachedItem(
    cacheKey: string
  ): Promise<CacheActionResult> {
    let result: CacheActionResult;
    try {
      const client = await connectRedis();

      client.get;

      const response = await client.get(cacheKey);

      await client.quit();

      result = {
        status: CacheActionStatusTypes.Success,
        message: 'item was successfully added to cache',
      };

      if (response) result.value = response;

      return result;
    } catch (error) {
      result = {
        status: CacheActionStatusTypes.Failed,
        message: 'failed to get the cached item',
      };
      if (error instanceof Error) {
        result.detail = error.message;
        result.stacktrace = error.stack;
      }
      return result;
    }
  }

  public static async addCachedItem(
    cacheKey: string,
    data: string
  ): Promise<CacheActionResult> {
    let result: CacheActionResult;
    try {
      const client = await connectRedis();

      await client.set(cacheKey, data);

      await client.quit();

      result = {
        status: CacheActionStatusTypes.Success,
        message: 'item was successfully added to cache',
      };

      return result;
    } catch (error) {
      result = {
        status: CacheActionStatusTypes.Failed,
        message: 'failed to add the item to cache',
      };
      if (error instanceof Error) {
        result.detail = error.message;
        result.stacktrace = error.stack;
      }
      return result;
    }
  }

  public static async removeCachedItem(
    cacheKey: string
  ): Promise<CacheActionResult> {
    let result: CacheActionResult;
    try {
      const client = await connectRedis();

      await client.del(cacheKey);

      await client.quit();

      result = {
        status: CacheActionStatusTypes.Success,
        message: 'item was successfully removed from cache',
      };

      return result;
    } catch (error) {
      result = {
        status: CacheActionStatusTypes.Failed,
        message: 'failed to remove the item from cache',
      };
      if (error instanceof Error) {
        result.detail = error.message;
        result.stacktrace = error.stack;
      }
      return result;
    }
  }
}

//helpers

const connectRedis = async (): Promise<
  RedisClientType<any & RedisModules, RedisFunctions, RedisScripts>
> => {
  const client = createClient({
    url: process.env.REDIS_URI ?? '',
  });

  client.on('error', (error) => {
    throw new Error(error);
  });

  await client.connect();

  return client;
};

type CacheActionResult = {
  status: CacheActionStatusTypes;
  value?: string;
  message?: string;
  detail?: string;
  stacktrace?: string;
};

enum CacheActionStatusTypes {
  Failed,
  Success,
  Mixed,
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/curexa/curexaClient.ts

import axios from 'axios';

import { ShippingPartner } from '@prisma/client';

import LoggerUtil from '../logging/apiUtilLogger';
import SlackClient from '../slack/slackClient';

export const curexaNetworking = axios.create({
  baseURL: process.env.CUREXA_BASE_URL,
  timeout: 5000,
});

export default class CurexaClient {
  public static async post(route: string, data: any = {}): Promise<any> {
    const userNamePassCombo =
      process.env.CUREXA_USERNAME + ':' + process.env.CUREXA_PASSWORD;
    const basicAuthValue = Buffer.from(userNamePassCombo).toString('base64');

    return await curexaNetworking.post(route, data, {
      headers: {
        Authorization: `Basic ${basicAuthValue}`,
        'Content-Type': 'application/json',
      },
    });
  }

  public static async cancelOrder(orderId: string) {
    const curexaResult = await this.post('/cancel_order', {
      order_id: orderId,
    });

    if (curexaResult.data.status === 'success') {
      return true;
    }

    return false;
  }

  public static async placeOrder(curexaPayload: any) {
    const curexaResult = await this.post('/orders', curexaPayload);

    if (!curexaResult.data.order_id) {
      try {
        JSON.parse(curexaResult.data);
      } catch (e) {
        await LoggerUtil.logError(
          'curexa_data_parsing_error',
          'curexaClient > placeOrder',
          e,
          { payload: curexaPayload, result: curexaResult }
        );

        await SlackClient.logOrderIssue(
          'unknown',
          curexaPayload.patient_id,
          ShippingPartner.CUREXA,
          'Error parsing curexaResult.data',
          {
            shippingPartnerId: curexaPayload.order_id,
            curexaResult,
          }
        );

        throw new Error('Curexa JSON Parser Error');
      }
    }

    if (curexaResult.data.status === 'success') {
      return true;
    } else {
      await LoggerUtil.logError(
        'curexa_error_result',
        'curexaClient > placeOrder',
        new Error(`Curexa Ordering Error ${curexaResult.data}`),
        { curexaPayload, curexaResult }
      );

      await SlackClient.logOrderIssue(
        'unknown',
        curexaPayload.patient_id,
        ShippingPartner.CUREXA,
        'Error Status returned from curexa' + curexaResult.data.status,
        {
          shippingPartnerId: curexaPayload.order_id,
          curexaResult,
        }
      );

      throw new Error(`Curexa Ordering Error ${curexaResult.data}`);
    }
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/dosespot/dosespotClient.ts

import axios, { AxiosError } from 'axios';
import axiosRetry from 'axios-retry';
import crypto from 'crypto';
import { generate } from 'generate-password';
import moment from 'moment';
import qs from 'qs';
import { v4 as uuidv4 } from 'uuid';

import { ExtendedUser } from '@/app/shared/models/extensions/identity/types/identityTypes';
import { prisma } from '@clients/mongo/prismaClient';
import { User, UserRole } from '@prisma/client';

import LoggerUtil from '../logging/apiUtilLogger';
import { logger } from '../logging/winstonClient';
import {
  AddClinicianPayload,
  Allergy,
  AllergyReactionType,
  AllergySearchResult,
  AllergyStatusType,
  ClinicianResult,
  DSAxiosErrorResponse,
  DoseSpotCreateResult,
  DoseSpotGetItemResult,
  DoseSpotGetItemsResult,
  DoseSpotIdentificationOptions,
  DoseSpotResultCode,
  DoseSpotUpdateResult,
  MedicationAndAllergyResponse,
  MedicationSearchResult,
  PatientDemographicDataPayload,
  PatientMedicationStatusType,
  PharmacyResult,
  PrescriptionResult,
  PrescriptionResultWithPharmacyPhysician,
  PrescriptionStatusType,
  PushToDoseSpotError,
  PushToDoseSpotSuccess,
  SelfReportedAllergiesInput,
  SelfReportedAllergiesPayload,
  SelfReportedMedication,
  SelfReportedMedicationInput,
  UpdateSelfReportedMedicationStatusPayload,
  isDoseSpotCreateResult,
} from './dosespotTypes';
import {
  DoseSpotUser,
  buildDemographicDataPayload,
  isUserDoseSpotReady,
} from './dosespotUtils';

export default class DosespotClient {
  // CREATE

  // V2 Updated!!
  // Called 1 time
  public static async createClinician(
    clinicianData: AddClinicianPayload
  ): Promise<DoseSpotCreateResult> {
    try {
      return await this.postDoseSpotItem<AddClinicianPayload>(
        `/webapi/v2/api/clinicians`,
        clinicianData
      );
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_create_clinician_failed',
        'createClinician',
        error,
        {
          email: clinicianData.Email,
        }
      );

      throw error;
    }
  }

  // V2 Updated!!
  // Called 1 time
  public static async createPatientDemographicEntry(
    patientData: PatientDemographicDataPayload
  ): Promise<DoseSpotCreateResult> {
    try {
      return await this.postDoseSpotItem<PatientDemographicDataPayload>(
        `/webapi/v2/api/patients`,
        patientData
      );
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_create_patient_demo_failed',
        'createPatientDemographicEntry',
        error,
        {
          email: patientData.Email,
          patientData: patientData,
        }
      );

      throw error;
    }
  }

  // V2 Updated!!
  public static async saveSelfReportedMedications(
    medicationData: SelfReportedMedicationInput[],
    user: ExtendedUser
  ): Promise<DoseSpotUpdateResult[]> {
    if (!user.dosespotId) throw new Error('User must have dosespotId');

    try {
      const userMedications = await this.getPatientMedications(user);

      const medicationsToAdd = medicationData
        .filter(
          (md) =>
            !userMedications.some(
              (um) => um.DispensableDrugID === md.DispensableDrugId
            )
        )
        .map((medication): SelfReportedMedicationInput => {
          return {
            DispensableDrugId: medication.DispensableDrugId,
            Status: PatientMedicationStatusType.Active,
          };
        });

      const medicationsToDelete = userMedications
        .filter(
          (um) =>
            !medicationData.some(
              (md) => md.DispensableDrugId === um.DispensableDrugID
            )
        )
        .map((medication): UpdateSelfReportedMedicationStatusPayload => {
          return {
            Status: PatientMedicationStatusType.Deleted,
            SelfReportedMedicationId: medication.SelfReportedMedicationId,
            DispensableDrugId: medication.DispensableDrugID,
          };
        });

      const dsPromises = [];

      for (const medication of medicationsToAdd) {
        dsPromises.push(
          this.addPatientSelfReportedMedication(medication, user)
        );
      }

      for (const medication of medicationsToDelete) {
        dsPromises.push(
          this.deleteSelfReportedMedication(
            medication.SelfReportedMedicationId,
            user
          )
        );
      }

      const results =
        dsPromises.length > 0 ? await Promise.all(dsPromises) : [];

      const flatResults = results.flat();

      if (
        flatResults.some(
          (r) => r.data.Result.ResultCode !== DoseSpotResultCode.OK
        )
      ) {
        await LoggerUtil.logError(
          'dosespot_result_error_saving_medications',
          'saveSelfReportedMedications',
          new Error('Error saving self-reported medication.'),
          {
            flatResults,
          }
        );
        throw new Error('There was a problem saving medications in DoseSpot');
      }

      return results.flat();
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_error_saving_medications',
        'saveSelfReportedMedications',
        error,
        {
          doseSpotId: user.dosespotId,
          medicationData,
        }
      );
      throw error;
    }
  }

  // V2 Updated!
  public static async deleteSelfReportedMedication(
    SelfReportedMedicationId: number,
    user: ExtendedUser
  ): Promise<DoseSpotUpdateResult> {
    if (!user.dosespotId) throw new Error('User must have dosespotId');

    try {
      const result = this.post(
        `/webapi/v2/api/patients/${user.dosespotId}/selfReportedMedications/${SelfReportedMedicationId}/updateStatus`,
        {
          Status: PatientMedicationStatusType.Deleted,
        }
      );

      return result;
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_error_deleting_self_reported_medications',
        'deleteSelfReportedMedications',
        error,
        {
          doseSpotId: user.dosespotId,
          SelfReportedMedicationId,
        }
      );

      throw error;
    }
  }

  // V2 Updated
  public static async addPatientSelfReportedMedication(
    medicationData: SelfReportedMedicationInput,
    user: ExtendedUser
  ): Promise<DoseSpotCreateResult> {
    if (!user.dosespotId) throw new Error('User must have dosespotId');

    try {
      const result = await this.postDoseSpotItem<SelfReportedMedicationInput>(
        `/webapi/v2/api/patients/${user.dosespotId}/selfReportedMedications/coded`,
        medicationData
      );

      return result;
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_error_saving_medication',
        'savePatientMedication',
        error,
        {
          doseSpotId: user.dosespotId,
          medicationData,
        }
      );

      throw error;
    }
  }

  // V2 Updated
  public static async addPatientAllergy(
    allergyData: SelfReportedAllergiesInput,
    user: ExtendedUser
  ): Promise<DoseSpotCreateResult> {
    if (!user.dosespotId) throw new Error('User must have dosespotId');

    try {
      const result = await this.postDoseSpotItem<SelfReportedAllergiesPayload>(
        `/webapi/v2/api/patients/${user.dosespotId}/allergies/coded`,
        allergyData
      );

      return result;
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_error_saving_allergies',
        'savePatientAllergies',
        error,
        {
          doseSpotId: user.dosespotId,
          allergyData,
        }
      );

      throw error;
    }
  }

  // V2 Updated!
  public static async deletePatientAllergy(
    allergyId: number,
    user: ExtendedUser
  ): Promise<DoseSpotUpdateResult> {
    if (!user.dosespotId) throw new Error('User must have dosespotId');

    try {
      const result = this.put(
        `/webapi/v2/api/patients/${user.dosespotId}/allergies/${allergyId}`,
        {
          ReactionType: AllergyReactionType.Allergy,
          StatusType: AllergyStatusType.Deleted,
        }
      );

      return result;
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_error_saving_allergies',
        'deletePatientAllergies',
        error,
        {
          doseSpotId: user.dosespotId,
          allergyId,
        }
      );

      throw error;
    }
  }

  // V2 UPDATED!!!!!
  // THIS NEEDS A BIG TEST
  public static async savePatientAllergies(
    allergyData: SelfReportedAllergiesInput[],
    user: ExtendedUser
  ): Promise<DoseSpotUpdateResult[]> {
    if (!user.dosespotId) throw new Error('User must have dosespotId');

    try {
      const userAllergies = (await this.getPatientAllergies(user)) ?? [];

      const allergiesToAdd = allergyData
        .filter(
          (allergy) =>
            !userAllergies.some(
              (ua) =>
                ua.AllergenId === allergy.AllergenId &&
                (ua.StatusType === AllergyStatusType.Active ||
                  (ua.StatusType as any) === 'Active')
            ) // for some reason the status is a string sometimes
        )
        .map((allergy) => {
          return {
            AllergenId: allergy.AllergenId,
            ReactionType: AllergyReactionType.Allergy,
            StatusType: AllergyStatusType.Active,
          };
        });

      const allergiesToDelete = userAllergies
        .filter(
          (ua) =>
            !allergyData.some(
              (ad) =>
                ad.AllergenId === ua.AllergenId &&
                (ua.StatusType === AllergyStatusType.Active ||
                  (ua.StatusType as any) === 'Active') // for some reason the status is a string sometimes
            )
        )
        .map((allergy) => {
          return {
            PatientAllergyId: allergy.PatientAllergyId,
            ReactionType: AllergyReactionType.Allergy,
            StatusType: AllergyStatusType.Deleted,
          };
        });

      const dsPromises = [];

      if (allergiesToAdd.length > 0)
        for (const allergy of allergiesToAdd) {
          dsPromises.push(this.addPatientAllergy(allergy, user));
        }

      if (allergiesToDelete.length > 0) {
        for (const allergy of allergiesToDelete) {
          dsPromises.push(
            this.deletePatientAllergy(allergy.PatientAllergyId, user)
          );
        }
      }

      const results =
        dsPromises.length > 0 ? await Promise.all(dsPromises) : [];

      return results.flat();
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_error_saving_allergies',
        'savePatientAllergies',
        error,
        {
          doseSpotId: user.dosespotId,
          allergyData,
        }
      );

      throw error;
    }
  }

  // V2 Updated!!
  public static async getAllergiesAndMedicationsForUser(
    user: ExtendedUser
  ): Promise<MedicationAndAllergyResponse> {
    if (!user.dosespotId) throw new Error('User must have dosespotId');

    const allergies = (await this.getPatientAllergies(user)) ?? [];
    const medications = (await this.getPatientMedications(user)) ?? [];

    const allergiesAndMedications: MedicationAndAllergyResponse = {
      allergies: allergies.map((a) => {
        return {
          AllergenId: a.AllergenId,
          Name: a.DisplayName,
        };
      }),
      medications: medications.map((m) => {
        return {
          DispensableDrugId: m.DispensableDrugID,
          Name: m.DisplayName,
          DisplayName: m.DisplayName,
        };
      }),
    };

    return allergiesAndMedications;
  }

  // v2 Updated!!
  public static async addPatientPharmacy(
    patientId: string,
    pharmacyId: string,
    setAsPrimary = true
  ) {
    try {
      if (!patientId || !pharmacyId)
        throw new Error('PatientId and PharmacyId are required');

      const resp: DoseSpotCreateResult = await this.post(
        `/webapi/v2/api/patients/${patientId}/pharmacies`,
        {
          SetAsPrimary: setAsPrimary,
          pharmacyId,
        }
      );

      if (resp.data.Result.ResultCode === DoseSpotResultCode.ERROR)
        throw Error(resp.data.Result.ResultDescription);

      return resp;
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_error_adding_patient_pharmacy',
        'addPatientPharmacy',
        error,
        {
          patientId,
          pharmacyId,
        }
      );
      throw error;
    }
  }

  // CALLED 0 TIMES DELETE
  // public static async updatePatientMedicalRecord(
  //   patientId: string,
  //   data: PatientDemographicDataPayload
  // ) {
  //   try {
  //     const validatedData = patientDemographicDataSchema.parse(data);

  //     const resp: DoseSpotCreateResult = await this.post(
  //       `/webapi/api/patients/${patientId}`,
  //       validatedData
  //     );
  //     if (resp.data.Result.ResultCode === DoseSpotResultCode.ERROR)
  //       throw Error(resp.data.Result.ResultDescription);

  //     return resp;
  //   } catch (error) {
  //     await LoggerUtil.logError(
  //       'dosespot_error_updating_patient_medical_record',
  //       'updatePatientMedicalRecord',
  //       error,
  //       { patientId, data }
  //     );

  //     throw error;
  //   }
  // }

  // V2 UPdated!!
  public static async updatePatientDemographicData(
    patientId: string,
    data: PatientDemographicDataPayload
  ): Promise<DoseSpotUpdateResult> {
    try {
      // const validatedData = patientDemographicDataSchema.parse(data);

      const resp: DoseSpotUpdateResult = await this.put(
        `/webapi/v2/api/patients/${patientId}`,
        data
      );

      if (resp.data.Result.ResultCode === DoseSpotResultCode.ERROR)
        throw Error(resp.data.Result.ResultDescription);

      return resp;
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_error_updating_patient_demo_data',
        'updatePatientDemographicData',
        error,
        { patientId, data }
      );
      throw error;
    }
  }

  // SEARCH

  // V2 UPDATED!
  public static async searchAllergies(
    allergyName: string
  ): Promise<AllergySearchResult[]> {
    return await this.getDoseSpotItems<AllergySearchResult[]>(
      `/webapi/v2/api/allergens/search?name=${allergyName}`
    );
  }

  // V2 UPDATED!
  public static async searchMedications(
    medicationName: string
  ): Promise<MedicationSearchResult[]> {
    return await this.getDoseSpotItems<MedicationSearchResult[]>(
      `/webapi/v2/api/medications/search?name=${medicationName}&drugStatus=Active`
    );
  }

  // V2 UPDATED!
  public static async searchPharmacies(
    name?: string | null,
    city?: string | null,
    zip?: string | null
  ): Promise<PharmacyResult[]> {
    const params = new URLSearchParams();
    if (name) params.append('name', name);
    if (city) params.append('city', city);
    if (zip) params.append('zip', zip);

    return await this.getDoseSpotItems<PharmacyResult[]>(
      `/webapi/v2/api/pharmacies/search?${params.toString()}`
    );
  }

  // GET

  // V2 Updated!!!
  public static async getPrescriptionsByUser(
    user: User
  ): Promise<PrescriptionResultWithPharmacyPhysician[]> {
    const dsResult = await this.getDoseSpotItems<PrescriptionResult[]>(
      `/webapi/v2/api/patients/${user.dosespotId}/prescriptions`
    );

    const result: PrescriptionResultWithPharmacyPhysician[] = [];

    if (!dsResult) return result;

    const filteredResult = dsResult.filter((dsItem) => {
      const prescriptionIsErrored =
        dsItem.Status === PrescriptionStatusType.Error;

      const prescriptionNotActive =
        dsItem.MedicationStatus !== PatientMedicationStatusType.Active;

      const prescriptionExpired =
        moment(dsItem.WrittenDate).diff(moment(), 'years', true) < -1;

      // return false if any of these are true
      return !(
        prescriptionIsErrored ||
        prescriptionNotActive ||
        prescriptionExpired
      );
    });

    const prescriptionData: PrescriptionResultWithPharmacyPhysician[] =
      await Promise.all(
        filteredResult.map(async (element) => {
          const physicianResult = await this.getDoseSpotItem<ClinicianResult>(
            `/webapi/v2/api/clinicians/${element.PrescriberId}`
          );

          const pharmacyResult = await this.getDoseSpotItem<PharmacyResult>(
            `/webapi/v2/api/pharmacies/${element.PharmacyId}`
          );

          return {
            ...element,
            Prescriber: physicianResult,
            Pharmacy: pharmacyResult,
          };
        })
      );

    return prescriptionData;
  }

  public static async getPrescriptionsByCaseId(
    caseId: string
  ): Promise<PrescriptionResultWithPharmacyPhysician[]> {
    const foundCaseInfo = await prisma.case.findUnique({
      where: {
        id: caseId,
      },
      include: {
        user: true,
      },
    });

    if (!foundCaseInfo) throw Error('Case not found');

    return await this.getPrescriptionsByUser(foundCaseInfo.user);
  }

  private static canUserViewPrescriptionInfo(
    caseUserId: string,
    user: User
  ): boolean {
    if (caseUserId === user.id) return true;

    if (
      user.roles.includes(UserRole.ADMIN) ||
      user.roles.includes(UserRole.CORTINA_NURSE) ||
      user.roles.includes(UserRole.CORTINA_SUPPORT) ||
      user.roles.includes(UserRole.PHYSICIAN) ||
      user.roles.includes(UserRole.PHYSICIAN_SUPPORT)
    ) {
      return true;
    }

    return false;
  }

  // V2 Updated!!!
  public static async getPrescriptionsByCaseAndUser(
    caseId: string,
    user: User
  ) {
    const foundCaseInfo = await prisma.case.findUnique({
      where: {
        id: caseId,
      },
      include: {
        user: true,
      },
    });

    if (!foundCaseInfo) throw Error('Case not found');

    if (!this.canUserViewPrescriptionInfo(foundCaseInfo.user.id, user))
      throw Error('User does not have permission to view case');

    const userPrescriptions = await this.getPrescriptionsByUser(
      foundCaseInfo.user
    );

    const casePrescriptions: PrescriptionResultWithPharmacyPhysician[] = [];

    for (const userPrescription of userPrescriptions) {
      if (userPrescription.Encounter === caseId) {
        casePrescriptions.push(userPrescription);
      }
    }

    return casePrescriptions;
  }

  // Called 1 time
  // V2 Updated
  public static async getPatientMedications(
    user: ExtendedUser,
    ignoreStatus = false //used for getting all medications for doctors
  ): Promise<SelfReportedMedication[]> {
    if (!user.dosespotId) throw new Error('User must have dosespot id');

    const medications = await this.getDoseSpotItems<SelfReportedMedication[]>(
      `/webapi/v2/api/patients/${user.dosespotId}/selfReportedMedications`
    );

    if (ignoreStatus) return medications;

    const filtered = medications.filter(
      (m) =>
        m.Status !== PatientMedicationStatusType.Deleted &&
        (m.Status as any) !== 'Deleted'
    );

    return filtered;
  }

  // Called 1 Time
  // V2 Updated!
  public static async getPatientAllergies(
    user: ExtendedUser,
    ignoreStatus = false //used for getting all allergies for doctors
  ): Promise<Allergy[]> {
    if (!user.dosespotId) throw new Error('User must have dosespot id');

    const allergyResults = await this.getDoseSpotItems<Allergy[]>(
      `/webapi/v2/api/patients/${user.dosespotId}/allergies`
    );

    if (!allergyResults) return allergyResults;

    if (ignoreStatus) return allergyResults;

    return allergyResults.filter(
      (a) => a.StatusType !== AllergyStatusType.Deleted
    );
  }

  // NEVER CALLED
  // public static async getPatientPharmacies(
  //   user: ExtendedUser
  // ): Promise<PharmacyResult[]> {
  //   if (!user.dosespotId) throw new Error('User must have dosespot id');

  //   const pharamacies = await this.getDoseSpotItems<PharmacyResult[]>(
  //     `/webapi/api/patients/${user.dosespotId}/pharmacies`
  //   );

  //   return pharamacies.map((p) => {
  //     return {
  //       ...p,
  //       PharmacyServices: getServicesFromServiceLevel(p.ServiceLevel),
  //     };
  //   });
  // }

  // V2 Updated
  public static async getPharmacyById(id: string): Promise<PharmacyResult> {
    return await this.getDoseSpotItem<PharmacyResult>(
      `/webapi/v2/api/pharmacies/${id}`
    );
  }

  // V2 Updated
  public static getIframeURL(
    physicianID: string,
    patientID: string,
    caseID: string
  ) {
    const randomPhrase = this.createRandomPhrase();

    const encryptedClinicID = encodeURIComponent(
      this.getEncryptedClinicID(
        randomPhrase,
        process.env.DOSESPOT_CLINIC_KEY ?? ''
      )
    );
    const encryptedUserID = encodeURIComponent(
      this.getEncryptedUserID(
        randomPhrase,
        String(physicianID),
        process.env.DOSESPOT_CLINIC_KEY ?? ''
      )
    );
    const clinicID = process.env.DOSESPOT_CLINIC_ID;

    const iFrameURL =
      process.env.DOSE_SPOT_BASE_URL +
      '/LoginSingleSignOn.aspx?' +
      `SingleSignOnClinicId=${clinicID}&` +
      `SingleSignOnUserId=${physicianID}&` +
      'SingleSignOnPhraseLength=32&' +
      `SingleSignOnCode=${encryptedClinicID}&` +
      `SingleSignOnUserIdVerify=${encryptedUserID}&` +
      `PatientId=${patientID}&` +
      `EncounterID=${caseID}`;

    return iFrameURL;
  }

  // HELPERS

  public static async getDoseSpotItems<T>(route: string): Promise<T> {
    try {
      const resp: DoseSpotGetItemsResult<T> = await this.get(route);

      if (resp.data.Result.ResultCode !== DoseSpotResultCode.OK) {
        await LoggerUtil.logError(
          'dosespot_getitems_badresponse',
          'getDoseSpotItems',
          {
            code: resp.data?.Result?.ResultCode,
            name: 'dosespot_getitems_badresponse',
            message: resp.data?.Result?.ResultDescription,
          },
          { route }
        );
        throw new Error(resp.data.Result.ResultDescription);
      }

      return resp.data.Items;
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_error_caught_getdosespotitems',
        'getDoseSpotItems',
        error,
        { route }
      );
      throw error;
    }
  }

  public static async getDoseSpotItem<T>(route: string): Promise<T> {
    try {
      const resp: DoseSpotGetItemResult<T> = await this.get(route);

      if (resp.data.Result.ResultCode !== DoseSpotResultCode.OK) {
        const error = {
          code: resp.data?.Result?.ResultCode,
          name: 'dosespot_getitem_badresponse',
          message: resp.data?.Result?.ResultDescription,
        };

        await LoggerUtil.logError(
          'dosespot_getitem_badresponse',
          'getDoseSpotItem',
          error,
          {
            route,
          }
        );
        throw new Error(resp.data.Result.ResultDescription);
      }

      return resp.data.Item;
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_getitem_failed',
        'getDoseSpotItem',
        error,
        {
          route,
        }
      );

      throw error;
    }
  }

  public static async postDoseSpotItem<T>(
    route: string,
    data: T
  ): Promise<DoseSpotCreateResult> {
    const requestId = uuidv4();
    try {
      logger.info('dosespot_post_item_request', {
        metadata: {
          service: 'dermi-api',
          client: 'postDoseSpotItem',
          requestId,
          route: route,
        },
      });

      const resp = await this.post(route, data);

      if (resp.data.Result.ResultCode !== DoseSpotResultCode.OK) {
        const error = {
          name:
            'dosespot_post_item_result_errorcode_' +
              resp.data.Result.ResultCode ?? '',
          message: resp.data.Result.ResultDescription,
          code: resp.data.Result.ResultCode,
        };

        await LoggerUtil.logError(
          'dosespot_post_item_result_error',
          'postDoseSpotItem',
          error,
          {
            requestId,
            route,
            data,
          }
        );

        throw new Error(resp.data.Result.ResultDescription);
      }

      logger.info('dosespot_post_item_success', {
        metadata: {
          service: 'dermi-api',
          client: 'postDoseSpotItem',
          requestId,
          route,
        },
      });

      return resp;
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_post_item_error',
        'postDoseSpotItem',
        error,
        {
          requestId,
          route,
          data,
        }
      );
      throw error;
    }
  }

  public static async postDoseSpotItems<T>(
    route: string,
    dataList: T[],
    dynamicRouteKey?: string,
    removeDynamicKeyFromData = false,
    routeAfterDynamicKey = ''
  ): Promise<DoseSpotCreateResult[]> {
    try {
      logger.info('dosespot_post_items_start', {
        metadata: { service: 'dermi-api', client: 'postDoseSpotItems', route },
      });
      const results = await Promise.all(
        dataList.map(async (dataItem, index) => {
          let dataToSend: any = dataItem;

          if (removeDynamicKeyFromData) {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const { [dynamicRouteKey as keyof T]: _, ...rest } = dataItem;
            dataToSend = rest;
          }

          const requestId = uuidv4();

          const itemRoute =
            dynamicRouteKey && dynamicRouteKey.length > 0
              ? `${route}/${
                  dataItem[dynamicRouteKey as keyof T]
                }${routeAfterDynamicKey}`
              : route;

          logger.info('dosespot_post_items_item_request', {
            metadata: {
              service: 'dermi-api',
              client: 'postDoseSpotItems',
              itemIndex: index,
              requestId,
              route: itemRoute,
            },
          });

          const resp = await this.postDoseSpotItem(itemRoute, dataToSend);

          if (resp.data.Result.ResultCode !== DoseSpotResultCode.OK) {
            const error = {
              name:
                'dosespot_post_items_result_errorcode_' +
                  resp.data.Result.ResultCode ?? '',
              message: resp.data.Result.ResultDescription,
              code: resp.data.Result.ResultCode,
            };

            await LoggerUtil.logError(
              'dosespot_post_items_error_result',
              'postDoseSpotItems',
              error,
              {
                itemIndex: index,
                requestId,
                route,
              }
            );

            throw new Error(resp.data.Result.ResultDescription);
          }

          logger.info('dosespot_post_items_item_success', {
            metadata: {
              service: 'dermi-api',
              client: 'postDoseSpotItems',
              itemIndex: index,
              requestId,
              route,
            },
          });

          return resp;
        })
      );

      return results;
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_post_items_promiseall_error',
        'postDoseSpotItems',
        error,
        {
          route,
          data: dataList,
          dynamicRouteKey,
          removeDynamicKeyFromData,
          routeAfterDynamicKey,
        }
      );
      throw error;
    }
  }

  // LOGIC

  // V2 Updated
  // eslint-disable-next-line complexity
  public static async pushUserDataToDoseSpot(
    dataToUpdate: DoseSpotUser,
    user: ExtendedUser
  ): Promise<PushToDoseSpotSuccess | PushToDoseSpotError> {
    try {
      if (!isUserDoseSpotReady(user, dataToUpdate)) {
        const error = {
          code: 400,
          message: 'User is not ready for dosespot',
        };

        await LoggerUtil.logError(
          'dosespot_user_not_ready',
          'pushUserDataToDoseSpot',
          error,
          {
            dataToUpdate,
            user,
          }
        );

        return {
          success: false,
          error: {
            shouldContinue: true,
            errorMessage: 'User is not dosespot ready',
          },
        };
      }

      const dsData: PatientDemographicDataPayload =
        await buildDemographicDataPayload(dataToUpdate, user);

      const doseSpotResponse: DoseSpotCreateResult | DoseSpotUpdateResult =
        user.dosespotId
          ? ((await DosespotClient.updatePatientDemographicData(
              user.dosespotId,
              dsData
            )) as DoseSpotUpdateResult)
          : ((await DosespotClient.createPatientDemographicEntry(
              dsData
            )) as DoseSpotCreateResult);

      const patientDSId = isDoseSpotCreateResult(doseSpotResponse)
        ? parseInt(doseSpotResponse.data.Id)
        : -1;

      if (!user.dosespotId && (isNaN(patientDSId) || patientDSId < 0)) {
        await LoggerUtil.logError(
          'There was a problem creating the patient in DoseSpot',
          'pushUserDataToDoseSpot',
          {
            message: 'There was a problem creating the patience in Dosespot.',
            name: 'dosespot_patient_create_error',
          },
          { userDSId: user.dosespotId, patientDSId, doseSpotResponse }
        );
        return {
          success: false,
          error: {
            shouldContinue: false,
            errorMessage:
              'There was a problem creating the patient in DoseSpot',
            errorDetail: doseSpotResponse,
          },
        };
      }

      if (!user.dosespotId && patientDSId > 0) {
        user.dosespotId = patientDSId.toString();
      }

      if ('medicalProfile' in dataToUpdate && dataToUpdate.medicalProfile) {
        const { medications, allergies } = dataToUpdate.medicalProfile;

        if (medications) {
          const medicationResults = await this.saveSelfReportedMedications(
            medications,
            user
          );

          if (
            medicationResults.some(
              (r) => r.data.Result.ResultCode !== DoseSpotResultCode.OK
            )
          )
            return {
              success: false,
              error: {
                shouldContinue: false,
                errorMessage:
                  'There was a problem saving medications in DoseSpot',
                errorDetail: medicationResults,
              },
            };
        }

        if (allergies) {
          const allergyResults = await this.savePatientAllergies(
            allergies,
            user
          );
          if (
            allergyResults.some(
              (r) => r.data.Result.ResultCode !== DoseSpotResultCode.OK
            )
          )
            return {
              success: false,
              error: {
                shouldContinue: false,
                errorMessage:
                  'There was a problem saving allergies in DoseSpot',
                errorDetail: allergyResults,
              },
            };
        }
      }

      return {
        success: true,
        patientDoseSpotId: user.dosespotId ?? patientDSId.toString(),
      };
    } catch (error) {
      await LoggerUtil.logError(
        'dosespot_create_user_failed',
        'pushUserDataToDoseSpot',
        error,
        { userDSId: user.dosespotId }
      );

      return {
        success: false,
        error: {
          shouldContinue: false,
          errorMessage: 'There was a problem creating the patient in DoseSpot',
          errorDetail: error,
        },
      };
    }
  }

  // CLIENT BASE

  private static async get(route: string, dosespotId?: string): Promise<any> {
    try {
      const bearer = await this.getAuthToken();

      const timeout = parseInt(
        process.env.DOSESPOT_GET_RETRY_TIMEOUT_MS ?? '5000'
      );

      const axiosInstance = dsNetworking(timeout);

      axiosRetry(axiosInstance, {
        shouldResetTimeout: true,
        retries: parseInt(process.env.DOSESPOT_GET_RETRY_COUNT ?? '3'),
        retryDelay: () =>
          parseInt(process.env.DOSESPOT_GET_RETRY_DELAY_MS ?? '300'),
        retryCondition(error) {
          switch (error.code) {
            // retry on timeout only
            case 'ECONNABORTED':
              return true;
            default:
              return false;
          }
        },
      });

      return await axiosInstance.get(route, {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          Authorization: `Bearer ${bearer}`,
          'Subscription-Key': process.env.DOSESPOT_SUBSCRIPTION_KEY,
        },
      });
    } catch (error) {
      await LoggerUtil.logError(
        'generic_dosespot_get_error',
        'dsNetworking > get',
        error,
        { route }
      );
      if (error instanceof AxiosError) {
        const dsError = error as AxiosError<DSAxiosErrorResponse>;

        if (dsError.response?.data) {
          throw new Error(dsError.response.data.Message, {
            cause: dsError.response.data.ModelState,
          });
        } else {
          throw error;
        }
      } else {
        throw error;
      }
    }
  }

  private static async post(route: string, data: any = {}): Promise<any> {
    try {
      const bearer = await this.getAuthToken();

      const headers = {
        'Content-Type': 'application/x-www-form-urlencoded',
        Authorization: `Bearer ${bearer}`,
        'Subscription-Key': process.env.DOSESPOT_SUBSCRIPTION_KEY,
      };

      const response = await dsNetworking().post(route, qs.stringify(data), {
        headers,
      });

      return response;
    } catch (error) {
      if (error instanceof AxiosError) {
        const dsError = error as AxiosError<DSAxiosErrorResponse>;

        if (dsError.response?.data) {
          throw new Error(dsError.response.data.Message, {
            cause: dsError.response.data.ModelState,
          });
        } else {
          throw error;
        }
      } else {
        throw error;
      }
    }
  }

  private static async put(
    route: string,
    data: any = {},
    dosespotId?: string
  ): Promise<any> {
    try {
      const bearer = await this.getAuthToken();

      const headers = {
        'Content-Type': 'application/x-www-form-urlencoded',
        Authorization: `Bearer ${bearer}`,
        'Subscription-Key': process.env.DOSESPOT_SUBSCRIPTION_KEY,
      };

      const response = await dsNetworking().put(route, qs.stringify(data), {
        headers,
      });

      console.log(response);

      return response;
    } catch (error) {
      await LoggerUtil.logError(
        'generic_dosespot_post_error',
        'dsNetworking > post',
        error,
        { route, data }
      );
      if (error instanceof AxiosError) {
        const dsError = error as AxiosError<DSAxiosErrorResponse>;

        if (dsError.response?.data) {
          throw new Error(dsError.response.data.Message, {
            cause: dsError.response.data.ModelState,
          });
        } else {
          throw error;
        }
      } else {
        throw error;
      }
    }
  }

  private static createRandomPhrase() {
    const randomPhrase = generate({
      length: 32,
      numbers: true,
    });

    return randomPhrase;
  }

  private static getEncryptedClinicID(randomPhrase: string, clinicKey: string) {
    // Calculate Encrypted Clinic ID

    const encryptedPhraseClinicKey = crypto
      .createHash('sha512')
      .update(randomPhrase + clinicKey)
      .digest('base64')
      .replace(/=/g, '');
    const encryptedClinicID = randomPhrase + encryptedPhraseClinicKey;

    return encryptedClinicID;
  }

  private static getEncryptedUserID(
    randomPhrase: string,
    userID: string,
    clinicKey: string
  ) {
    const combinedUserIDClinicKeyPhrase =
      userID + randomPhrase.substring(0, 22) + clinicKey;

    const encryptedUserID = crypto
      .createHash('sha512')
      .update(combinedUserIDClinicKeyPhrase)
      .digest('base64')
      .replace(/=/g, '');

    return encryptedUserID;
  }

  // V2 Updated!!
  private static async generateV2AuthToken(
    options: DoseSpotIdentificationOptions
  ): Promise<string> {
    const authData: {
      grant_type: string;
      client_id: string;
      client_secret: string;
      username: string;
      Password: string;
      scope: string;
      acr_values?: string; // Optional property
    } = {
      grant_type: 'password',
      client_id: options.clinicID,
      client_secret: options.clinicKey,
      username: options.userID,
      Password: options.clinicKey,
      scope: 'api',
      // acr_values: `OnBehalfOfUserId=${process.env.DOSESPOT_PHYSICIAN_ID}`,
    };

    try {
      const stringAuthData = qs.stringify(authData);

      const resp = await dsNetworking().post(
        '/webapi/v2/connect/token',
        stringAuthData,
        {
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Subscription-Key': process.env.DOSESPOT_SUBSCRIPTION_KEY,
          },
        }
      );

      return resp.data.access_token;
    } catch (error) {
      throw new Error('Failed to get auth token');
    }
  }

  // private static async generateAuthToken(
  //   options: DoseSpotIdentificationOptions
  // ): Promise<string> {
  //   const randomPhrase = this.createRandomPhrase();

  //   const encryptedClinicID = this.getEncryptedClinicID(
  //     randomPhrase,
  //     options.clinicKey
  //   );

  //   const encryptedUserID = this.getEncryptedUserID(
  //     randomPhrase,
  //     options.userID,
  //     options.clinicKey
  //   );

  //   // Send the data to Dosespot
  //   const authorizationDataToConvert =
  //     options.clinicID + ':' + encryptedClinicID;
  //   const authorizationDataBase64 =
  //     'Basic ' + Buffer.from(authorizationDataToConvert).toString('base64');

  //   const resp = await dsNetworking().post(
  //     '/webapi/token',
  //     qs.stringify({
  //       grant_type: 'password',
  //       Username: options.userID,
  //       Password: encryptedUserID,
  //     }),
  //     {
  //       headers: {
  //         'Content-Type': 'application/x-www-form-urlencoded',
  //         Authorization: authorizationDataBase64,
  //       },
  //     }
  //   );

  //   const accessToken = resp.data.access_token;
  //   return accessToken;
  // }

  public static async getAuthToken(): Promise<string> {
    const identificationOptions: DoseSpotIdentificationOptions = {
      userID: process.env.DOSESPOT_ADMIN_CLINICIAN_ID ?? '',
      clinicID: process.env.DOSESPOT_CLINIC_ID ?? '',
      clinicKey: process.env.DOSESPOT_CLINIC_KEY ?? '',
    };
    return await this.generateV2AuthToken(identificationOptions);
  }
}

export const dsNetworking = (timeout = 10000) =>
  axios.create({
    baseURL: process.env.DOSE_SPOT_BASE_URL,
    timeout: timeout,
    transformRequest: [
      function (data, headers) {
        headers['x-cortina-tid'] = uuidv4();
        return data;
      },
    ],
  });


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/dosespot/dosespotUtils.ts

import _ from 'lodash';
import { UpdateMedicalProfileSchema } from 'prisma/custom-schemas/updateMedicalProfile';
import { UserPartial } from 'prisma/generated/zod';

import { UserPrescriptionsWithProduct } from '@/app/shared/types';
import { stateAbbreviationMap } from '@/utils/utils';
import {
  ExtendedUser,
  MedicalProfileWithoutUser,
} from '@models/extensions/identity/types/identityTypes';
import {
  Address,
  HeightUnit,
  Prisma,
  Product,
  ProductCategories,
  SubscriptionProduct,
  UserPrescriptions,
  WeightUnit,
} from '@prisma/client';
import { testPhoneNumber } from '@prisma/custom-validators/phoneNumberValidation';

import LoggerUtil from '../logging/apiUtilLogger';
import { prisma } from '../mongo/prismaClient';
import DosespotClient from './dosespotClient';
import {
  AllergyCodeType,
  HeightUnitItem,
  PatientDemographicDataPayload,
  PharmacyServiceLevels,
  PhoneType,
  WeightUnitItem,
} from './dosespotTypes';
import { testState } from './dosespotValidations';

export const convertPhoneNumberToDoseSpotFormat = async (
  phoneNumber: string
): Promise<string> => {
  const countryCode = '+1';
  const isE164Format = testPhoneNumber(phoneNumber);

  if (!isE164Format) throw new Error('Phone number is not in standard format');

  const slicedNumber = phoneNumber.slice(countryCode.length);

  return slicedNumber;
};

export const convertHeightToDoseSpotFormat = (
  user: ExtendedUser,
  height?: string
): {
  height: number;
  dsUnits: HeightUnitItem;
  units: HeightUnit;
} => {
  if (height) {
    const [feet, inches] = height
      .split("'")
      .map((part) => parseInt(part.trim(), 10));

    const feetInInches = feet * 12;
    const totalInches = feetInInches + inches;
    return {
      height: totalInches,
      dsUnits: HeightUnitItem.INCH,
      units: HeightUnit.INCHES,
    };
  }

  if (user.medicalProfile?.height && user.medicalProfile?.heightUnit) {
    return {
      height: user.medicalProfile.height,
      dsUnits:
        user.medicalProfile.heightUnit === HeightUnit.INCHES
          ? HeightUnitItem.INCH
          : HeightUnitItem.CM,
      units: user.medicalProfile.heightUnit,
    };
  }

  return {
    height: 167,
    dsUnits: HeightUnitItem.CM,
    units: HeightUnit.CENTIMETERS,
  };
};

export const convertWeightToDoseSpotFormat = (
  user: ExtendedUser,
  weight?: string
): {
  weight: number;
  dsUnits: WeightUnitItem;
  units: WeightUnit;
} => {
  const dsWeight = weight ? parseInt(weight) : undefined;
  if (dsWeight) {
    return {
      weight: dsWeight,
      dsUnits: WeightUnitItem.LB,
      units: WeightUnit.LBS,
    };
  }

  if (user.medicalProfile?.weight && user.medicalProfile?.weightUnit) {
    return {
      weight: user.medicalProfile.weight,
      dsUnits:
        user.medicalProfile.weightUnit === WeightUnit.LBS
          ? WeightUnitItem.LB
          : WeightUnitItem.KG,
      units: user.medicalProfile.weightUnit,
    };
  }

  return {
    weight: 65,
    dsUnits: WeightUnitItem.KG,
    units: WeightUnit.KGS,
  };
};

export const convertAddressToDoseSpotFormat = async (
  address: Address | Prisma.AddressCreateInput
): Promise<Address | Prisma.AddressCreateInput> => {
  const addressIsTwoLetterState = testState(address.state);

  if (addressIsTwoLetterState) return address;

  const twoLetterState = stateAbbreviationMap[address.state];

  if (!twoLetterState) throw new Error('State is not valid');

  const updatedAddress = {
    ...address,
    state: twoLetterState,
  };

  return updatedAddress;
};

export const buildDemographicDataPayload = async (
  dataToUpdate: any,
  user: ExtendedUser
): Promise<PatientDemographicDataPayload> => {
  const addressInData = dataToUpdate.addresses?.find((x: any) => x.default);

  const userPrimaryAddress = user.addresses?.find((x) => x.default);
  const phoneNumber = dataToUpdate.phoneNumber ?? user.phoneNumber;

  if (!phoneNumber) throw new Error('Phone number is required');
  if (!addressInData && !userPrimaryAddress)
    throw new Error('Address is required');

  const dsPhoneNumber = await convertPhoneNumberToDoseSpotFormat(phoneNumber);
  const dsAddress = await convertAddressToDoseSpotFormat(
    addressInData ?? userPrimaryAddress
  );

  const dsHeight = convertHeightToDoseSpotFormat(user, dataToUpdate?.height);
  const dsWeight = convertWeightToDoseSpotFormat(user, dataToUpdate?.weight);
  const genderFromData =
    dataToUpdate.sexAtBirth ?? dataToUpdate.medicalProfile?.sexAtBirth;
  const dobFromData = dataToUpdate.dob ?? dataToUpdate.medicalProfile?.dob;

  return {
    Active: true,
    Gender: genderFromData ?? user.medicalProfile?.sexAtBirth,
    DateOfBirth: dobFromData ?? user.medicalProfile?.dob,
    FirstName: _.deburr(dataToUpdate.firstName ?? user.firstName),
    LastName: _.deburr(dataToUpdate.lastName ?? user.lastName),
    Email: dataToUpdate.email ?? user.email,
    Address1: _.deburr(dsAddress.address1),
    Address2: dsAddress.address2 ? _.deburr(dsAddress.address2) : undefined,
    City: _.deburr(dsAddress.city),
    State: dsAddress.state,
    ZipCode: dsAddress.zip,
    PrimaryPhone: dsPhoneNumber,
    PrimaryPhoneType: PhoneType.Primary,
    Weight: dsWeight.weight,
    Height: dsHeight.height,
    WeightMetric: dsWeight.dsUnits,
    HeightMetric: dsHeight.dsUnits,
  };
};

type RegisteredUserRequiredProperties = {
  firstName: string;
  lastName: string;
  phoneNumber: string;
  addresses: Address[];
};

export type DoseSpotEligibleUser = Required<
  Omit<ExtendedUser, keyof RegisteredUserRequiredProperties> &
    RegisteredUserRequiredProperties
>;

const hasValue = (value: any) => !!value;

const hasValueOrUser = (value: any, userValue: any) =>
  hasValue(value || userValue);

const hasDefaultAddress = (
  addresses: Address[] | Prisma.AddressCreateInput[] | undefined
) => !!addresses && addresses.some((x) => x.default);

const hasMedicalProfile = (
  profile:
    | Prisma.MedicalProfileUpdateInput
    | MedicalProfileWithoutUser
    | null
    | undefined
) => !!profile && hasValue(profile.sexAtBirth) && hasValue(profile.dob);

export type DoseSpotUser = UserPartial & {
  addresses?: Prisma.AddressCreateInput[];
  medicalProfile?: Zod.infer<typeof UpdateMedicalProfileSchema>;
  height?: string;
  weight?: string;
};

export const isUserDoseSpotReady = (
  user: ExtendedUser,
  dataToUpdate: DoseSpotUser
): user is DoseSpotEligibleUser => {
  return (
    hasValueOrUser(dataToUpdate.firstName, user.firstName) &&
    hasValueOrUser(dataToUpdate.lastName, user.lastName) &&
    hasValueOrUser(dataToUpdate.email, user.email) &&
    hasValueOrUser(dataToUpdate.phoneNumber, user.phoneNumber) &&
    (hasDefaultAddress(dataToUpdate.addresses) ||
      hasDefaultAddress(user.addresses)) &&
    hasMedicalProfile(dataToUpdate.medicalProfile || user.medicalProfile)
  );
};

export const getServicesFromServiceLevel = (
  serviceLevel: number
): PharmacyServiceLevels[] => {
  const pharmacyLevels = Object.values(PharmacyServiceLevels)
    .map(Number)
    .filter((level) => serviceLevel & level)
    .map((level) => level);

  return pharmacyLevels;
};

function getProductIdForPrescription(
  pharmacyNotes: string,
  productList: Product[],
  pharmacyId: number
): string | null {
  if (pharmacyId !== Number(process.env.DEFAULT_PHARMACY_ID)) return null;

  for (const product of productList) {
    if (pharmacyNotes.includes(product.id)) {
      return product.id;
    }
  }
  return null;
}

function getProductIdForPrescriptionUsingName(
  displayName: string,
  productList: Product[],
  pharmacyId: number
): string | null {
  if (pharmacyId !== Number(process.env.DEFAULT_PHARMACY_ID)) return null;

  const bestMatch = findBestMatch(displayName, productList);

  return bestMatch?.id ?? null;
}

function getSubscriptionProductIdForPrescription(
  pharmacyNotes: string,
  subscriptionProductList: SubscriptionProduct[],
  pharmacyId: number
): string | null {
  if (pharmacyId !== Number(process.env.DEFAULT_PHARMACY_ID)) return null;

  for (const subscriptionProduct of subscriptionProductList) {
    if (pharmacyNotes.includes(subscriptionProduct.id)) {
      return subscriptionProduct.id;
    }
  }

  return null;
}

function getProductIdForPrescriptionSubscriptionUsingName(
  displayName: string,
  productList: SubscriptionProduct[],
  pharmacyId: number
): string | null {
  if (pharmacyId !== Number(process.env.DEFAULT_PHARMACY_ID)) return null;

  const bestMatch = findBestMatch(displayName, productList);

  return bestMatch?.id ?? null;
}

function isIDMongoID(iDToTest: string): boolean {
  const objectIdPattern = /^[0-9a-fA-F]{24}$/;
  return objectIdPattern.test(iDToTest);
}

export async function reconcileUserPrescriptionsWithDosespotPrescriptions(
  user: ExtendedUser
): Promise<UserPrescriptionsWithProduct[]> {
  const dosespotPrescriptions = await DosespotClient.getPrescriptionsByUser(
    user
  );

  const prescriptionProducts = await prisma.product.findMany({
    where: {
      category: ProductCategories.PRESCRIPTION_MEDICATION,
    },
  });

  const prescriptionSubscriptionProducts =
    await prisma.subscriptionProduct.findMany({
      where: {
        category: ProductCategories.PRESCRIPTION_MEDICATION,
      },
    });

  const userPrescriptionArrayToReturn: UserPrescriptionsWithProduct[] = [];

  for (const dosespotPrescription of dosespotPrescriptions) {
    // Loop through the products and see if the pharmacy notes contain a product ID. If so, then link it to user prescriptions.
    // In all events update / add the user prescriptions
    if (!dosespotPrescription.Encounter) {
      await LoggerUtil.logInfo(
        'prescription_without_encounter',
        'reconcileUserPrescriptionsWithDosespotPrescriptions',
        { dosespotPrescription }
      );
      continue;
    }

    // Resolve Product IDs. Any non-curexa prescription should ahve a null product ID since it may not be purchased
    let productId = getProductIdForPrescription(
      dosespotPrescription.PharmacyNotes,
      prescriptionProducts,
      dosespotPrescription.PharmacyId
    );
    let subscriptionProductId = getSubscriptionProductIdForPrescription(
      dosespotPrescription.PharmacyNotes,
      prescriptionSubscriptionProducts,
      dosespotPrescription.PharmacyId
    );

    let caseId = dosespotPrescription.Encounter;

    // Start to migrate Spot 1 Cases
    if (!isIDMongoID(dosespotPrescription.Encounter)) {
      await LoggerUtil.logInfo(
        'prescription_without_notes_found',
        'reconcileUserPrescriptionsWithDosespotPrescriptions',
        { dosespotPrescription }
      );

      productId = getProductIdForPrescriptionUsingName(
        dosespotPrescription.DisplayName,
        prescriptionProducts,
        dosespotPrescription.PharmacyId
      );
      subscriptionProductId = getProductIdForPrescriptionSubscriptionUsingName(
        dosespotPrescription.DisplayName,
        prescriptionSubscriptionProducts,
        dosespotPrescription.PharmacyId
      );

      const migratedCase = await prisma.case.findFirst({
        where: {
          spotCaseId: caseId,
        },
      });

      if (!migratedCase) {
        await LoggerUtil.logError(
          'prescription_without_migratable_case',
          'reconcileUserPrescriptionsWithDosespotPrescriptions',
          new Error('Prescription without migratable case found, continue'),
          {
            user: user.id,
            caseId,
            productId,
            subscriptionProductId,
          }
        );
        continue;
      }
      caseId = migratedCase.id;
    } else {
      // Is a non migrated case, but the doctor may have failed to prescribe with proper pharmacy notes.
      //  So we fall back to name reconciliation if the productID is null
      if (!productId) {
        productId = getProductIdForPrescriptionUsingName(
          dosespotPrescription.DisplayName,
          prescriptionProducts,
          dosespotPrescription.PharmacyId
        );
      }

      if (!subscriptionProductId) {
        subscriptionProductId =
          getProductIdForPrescriptionSubscriptionUsingName(
            dosespotPrescription.DisplayName,
            prescriptionSubscriptionProducts,
            dosespotPrescription.PharmacyId
          );
      }
    }

    const currentPrescription = await prisma.userPrescriptions.findFirst({
      where: {
        dosespotRxId: String(dosespotPrescription.PrescriptionId),
        userId: user.id,
      },
    });

    const prescriptionData: Omit<
      UserPrescriptions,
      | 'id'
      | 'createdAt'
      | 'updatedAt'
      | 'nextAvailableRefillDate'
      | 'refillDates'
    > = {
      caseId,
      userId: user.id,
      productId: productId,
      subscriptionProductId: subscriptionProductId,
      dosespotRxId: String(dosespotPrescription.PrescriptionId),
      maxRefills: Number(dosespotPrescription.Refills),
      pharmacyId: String(dosespotPrescription.PharmacyId),
      prescribingPhysicianName: `${dosespotPrescription.Prescriber.FirstName} ${dosespotPrescription.Prescriber.LastName}`,
      quantityDispensed: Number(dosespotPrescription.Quantity),
      daysSupply: dosespotPrescription.DaysSupply,
      instructions: dosespotPrescription.Directions,
      medicationName: dosespotPrescription.DisplayName,
    };

    // Update
    if (currentPrescription) {
      userPrescriptionArrayToReturn.push(
        await prisma.userPrescriptions.update({
          where: {
            id: currentPrescription.id,
          },
          data: prescriptionData,
          include: {
            product: true,
            subscriptionProduct: true,
          },
        })
      );
    }
    // Create
    else {
      userPrescriptionArrayToReturn.push(
        await prisma.userPrescriptions.create({
          data: prescriptionData,
          include: {
            product: true,
            subscriptionProduct: true,
          },
        })
      );
    }
  }

  return userPrescriptionArrayToReturn;
}

export const cachedStringToAllergyCodeType = (
  codeType: string
): AllergyCodeType | undefined => {
  switch (codeType) {
    case '1':
    case 'AllergyClass':
      return AllergyCodeType.AllergyClass;
    case '2':
    case 'GenericDrug':
      return AllergyCodeType.GenericDrug;
    case '3':
    case 'SNOMED':
      return AllergyCodeType.SNOMED;
    default:
      return undefined;
  }
};

const findBestMatch = (
  displayName: string,
  products: Product[] | SubscriptionProduct[]
): Product | SubscriptionProduct | null => {
  const matches: (Product | SubscriptionProduct)[] = [];

  // if its a basic product include is enough
  products.forEach((product) => {
    if (product.rxName) {
      if (displayName.includes(product.rxName)) {
        matches.push(product);
      }
    }
  });

  const bestMatch = matches.reduce<Product | SubscriptionProduct | null>(
    (prev, curr) => {
      return (prev?.rxName?.length ?? 0) > (curr?.rxName?.length ?? 0)
        ? prev
        : curr;
    },
    null
  );

  return bestMatch;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/dosespot/dosespotCacheClient.ts

// import { PharmacyCacheItem, Prisma } from '@prisma/client';
// import { PrismaClientValidationError } from '@prisma/client/runtime/library';

// import LoggerUtil from '../logging/apiUtilLogger';
// import { prisma } from '../mongo/prismaClient';
// import DosespotClient from './dosespotClient';
// import {
//   AllergyCodeType,
//   AllergySearchResult,
//   MedicationSearchResult,
//   PharmacyResult,
//   PharmacyServiceLevels,
//   PharmacySpecialityType,
//   PhoneType,
// } from './dosespotTypes';
// import { cachedStringToAllergyCodeType } from './dosespotUtils';

// type PharmacySearchQuery = {
//   name: string | null;
//   city: string | null;
//   zip: string | null;
// };

// type CachedDataResponse<T> = {
//   results: T[];
//   dataSource: ServedFromEnum;
// };

// enum ServedFromEnum {
//   Cache = 'cache',
//   DoseSpot = 'dosespot',
//   EmptyQuery = 'empty_query',
// }

// export default class DosespotCacheClient {
//   public static async searchCachedPharmacies(
//     query: PharmacySearchQuery,
//     forceRefreshCache = false
//   ): Promise<{ results: PharmacyResult[]; dataSource: ServedFromEnum }> {
//     const { name, city, zip } = query;

//     if (!name && !city && !zip) {
//       return { results: [], dataSource: ServedFromEnum.EmptyQuery };
//     }

//     const cacheKey = getCacheKeyFromQuery(query);

//     const cacheTimeMS = process.env.DOSESPOT_PHARMACY_CACHE_MS
//       ? parseInt(process.env.DOSESPOT_PHARMACY_CACHE_MS)
//       : 48 * 60 * 60 * 1000;

//     const currentTime = new Date();
//     const cacheExpiration = new Date(currentTime.getTime() - cacheTimeMS);

//     const cachedPharmacyResult = forceRefreshCache
//       ? null
//       : await prisma.pharmacyCache.findUnique({
//           where: {
//             cacheKey: cacheKey,
//             lastRefresh: { gt: cacheExpiration },
//           },
//         });

//     if (
//       cachedPharmacyResult &&
//       cachedPharmacyResult.cachedPharmacies.length > 0
//     ) {
//       const mappedCacheItems = await Promise.all(
//         cachedPharmacyResult.cachedPharmacies.map(
//           async (ci) => await mapCachedPharmacyToPharmacyResult(ci)
//         )
//       );

//       return { results: mappedCacheItems, dataSource: ServedFromEnum.Cache };
//     } else {
//       const results = await DosespotClient.searchPharmacies(name, city, zip);

//       if (results && results.length > 0) {
//         try {
//           await DosespotCacheClient.cachePharmacyResults(
//             { name, city, zip },
//             results
//           );
//         } catch (error) {
//           await LoggerUtil.logError(
//             'pharmacy_caching_failed',
//             'searchCachedPharmacies',
//             error,
//             { name, city, zip }
//           );
//           // proceed, don't throw an error and block the user from getting results
//         }
//       }

//       return { results: results ?? [], dataSource: ServedFromEnum.DoseSpot };
//     }
//   }

//   public static async searchCachedAllergies(
//     allergyName: string,
//     forceRefreshCache = false
//   ): Promise<CachedDataResponse<AllergySearchResult>> {
//     const firstThreeLetters = allergyName.substring(0, 3);

//     const cacheTimeMS = process.env.DOSESPOT_ALLERGY_CACHE_MS
//       ? parseInt(process.env.DOSESPOT_ALLERGY_CACHE_MS)
//       : 48 * 60 * 60 * 1000;

//     const currentTime = new Date();
//     const cacheExpiration = new Date(currentTime.getTime() - cacheTimeMS);

//     let dataSource = ServedFromEnum.Cache;

//     const cacheItem = forceRefreshCache
//       ? null
//       : await prisma.allergyCache.findUnique({
//           where: {
//             threeLetterKey: firstThreeLetters,
//             lastRefresh: {
//               gt: cacheExpiration,
//             },
//           },
//         });

//     let allergyCacheItems = [] as AllergySearchResult[];

//     if (!cacheItem || cacheItem.allergyCacheItems.length < 1) {
//       dataSource = ServedFromEnum.DoseSpot;

//       const freshCache = await DosespotClient.searchAllergies(
//         firstThreeLetters
//       );

//       if (!freshCache || freshCache.length < 1)
//         return { results: [], dataSource };

//       try {
//         await this.cacheAllergyResults(firstThreeLetters, freshCache);
//       } catch (error) {
//         await LoggerUtil.logError(
//           'error_caching_allergies',
//           'searchCachedAllergies',
//           error,
//           { firstThreeLetters }
//         );
//       }

//       allergyCacheItems = freshCache;
//     } else {
//       allergyCacheItems = cacheItem.allergyCacheItems.map((cachedAllergy) => {
//         const { CodeType, ...rest } = cachedAllergy;

//         const convertedAllergyCodeType =
//           cachedStringToAllergyCodeType(CodeType);

//         return {
//           ...rest,
//           CodeType: convertedAllergyCodeType, // force the numerical representation
//         } as AllergySearchResult;
//       });
//     }

//     if (allergyName.length > 3) {
//       // Creating a regex pattern with the variable
//       const words = allergyName.toLowerCase().split(' ');

//       const filteredResult = allergyCacheItems.filter((allergy) =>
//         words.every((word) => preprocessString(allergy.Name).includes(word))
//       );

//       if (filteredResult && isAllergySearchResult(filteredResult)) {
//         return { results: filteredResult, dataSource };
//       }
//     }

//     return {
//       results: allergyCacheItems,
//       dataSource,
//     };
//   }

//   public static async searchCachedMedications(
//     medicationName: string,
//     forceRefreshCache = false
//   ): Promise<CachedDataResponse<MedicationSearchResult>> {
//     const firstThreeLetters = medicationName.substring(0, 3);

//     const cacheTimeMS = process.env.DOSESPOT_MEDICATION_CACHE_MS
//       ? parseInt(process.env.DOSESPOT_MEDICATION_CACHE_MS)
//       : 48 * 60 * 60 * 1000;

//     const currentTime = new Date();
//     const cacheExpiration = new Date(currentTime.getTime() - cacheTimeMS);

//     const cacheItem = forceRefreshCache
//       ? null
//       : await prisma.medicationCache.findUnique({
//           where: {
//             threeLetterKey: firstThreeLetters,
//             lastRefresh: { gt: cacheExpiration },
//           },
//         });

//     let medicationCacheItems: MedicationSearchResult[] = [];
//     let dataSource = ServedFromEnum.Cache;

//     if (!cacheItem || cacheItem.medicationCacheItems.length < 1) {
//       const freshCache = await DosespotClient.searchMedications(
//         firstThreeLetters
//       );

//       dataSource = ServedFromEnum.DoseSpot;

//       if (!freshCache || freshCache.length < 1)
//         return {
//           results: [],
//           dataSource,
//         };

//       try {
//         await this.cacheMedicationResults(firstThreeLetters, freshCache);
//       } catch (error) {
//         await LoggerUtil.logError(
//           'error_caching_medications',
//           'searchCachedMedications',
//           error,
//           { firstThreeLetters }
//         );
//       }

//       medicationCacheItems = freshCache;
//     } else {
//       medicationCacheItems = cacheItem.medicationCacheItems;
//     }

//     if (medicationName.length > 3) {
//       const words = medicationName.toLowerCase().split(' ');

//       return {
//         results: medicationCacheItems.filter((med) => {
//           return words.every((word) =>
//             preprocessString(med.NameWithRouteDoseForm).includes(word)
//           );
//         }),
//         dataSource,
//       };
//     }

//     return { results: medicationCacheItems, dataSource };
//   }

//   public static async cachePharmacyResults(
//     query: PharmacySearchQuery,
//     results: PharmacyResult[]
//   ) {
//     try {
//       const cacheKey = getCacheKeyFromQuery(query);

//       const pharmacyQueryExists = await prisma.pharmacyCache.count({
//         where: {
//           cacheKey: cacheKey,
//         },
//       });

//       const pharmacyCacheItems = await Promise.all(
//         results.map(async (pr) => {
//           return await mapPharmacyResultToCachedPharmacy(pr);
//         })
//       );

//       if (pharmacyQueryExists) {
//         await prisma.pharmacyCache.update({
//           where: {
//             cacheKey: cacheKey,
//           },
//           data: {
//             cachedPharmacies: pharmacyCacheItems,
//           },
//         });
//       } else {
//         await prisma.pharmacyCache.create({
//           data: {
//             cacheKey,
//             cachedPharmacies: pharmacyCacheItems,
//           },
//         });
//       }
//     } catch (error) {
//       await LoggerUtil.logError(
//         'There was an issue adding the pharmacy result to cache.',
//         'cachePharmaccyResults',
//         error instanceof PrismaClientValidationError
//           ? (error as PrismaClientValidationError)
//           : error,
//         {
//           query,
//           prismaError:
//             error instanceof PrismaClientValidationError
//               ? (error as PrismaClientValidationError).message
//               : (error as Error).message,
//         }
//       );
//       //dont throw an error, this will not affect the user.
//     }
//   }

//   public static async cacheMedicationResults(
//     searchName: string,
//     medicationsToCache: MedicationSearchResult[]
//   ) {
//     const firstThreeLetters = searchName.substring(0, 3);

//     try {
//       const medicationSearchExists = await prisma.medicationCache.count({
//         where: {
//           threeLetterKey: firstThreeLetters,
//         },
//       });

//       if (medicationSearchExists > 0) {
//         await prisma.medicationCache.update({
//           where: { threeLetterKey: firstThreeLetters },
//           data: {
//             threeLetterKey: firstThreeLetters,
//             medicationCacheItems: medicationsToCache,
//           },
//         });
//       } else {
//         await prisma.medicationCache.create({
//           data: {
//             threeLetterKey: firstThreeLetters,
//             medicationCacheItems: medicationsToCache,
//           },
//         });
//       }
//     } catch (error) {
//       await LoggerUtil.logError(
//         'Error storing the medications results in cache.',
//         'cacheMedicationResults',
//         error,
//         {
//           searchName,
//           medicationsToCache,
//           prismaError:
//             error instanceof PrismaClientValidationError
//               ? (error as PrismaClientValidationError).message
//               : (error as Error).message,
//         }
//       );
//     }
//   }

//   public static async cacheAllergyResults(
//     searchName: string,
//     allergiesToCache: AllergySearchResult[]
//   ) {
//     const firstThreeLetters = searchName.substring(0, 3);

//     try {
//       const allergySearchExists = await prisma.allergyCache.count({
//         where: {
//           threeLetterKey: firstThreeLetters,
//         },
//       });

//       if (allergySearchExists > 0)
//         await prisma.allergyCache.update({
//           where: { threeLetterKey: firstThreeLetters },
//           data: {
//             threeLetterKey: firstThreeLetters,
//             allergyCacheItems: allergiesToCache.map((allergy) => {
//               const mappedAllergy: Prisma.AllergyCacheItemCreateInput = {
//                 ...allergy,
//                 CodeType: allergy.CodeType.toString(),
//               };

//               return mappedAllergy;
//             }),
//           },
//         });
//       else
//         await prisma.allergyCache.create({
//           data: {
//             threeLetterKey: firstThreeLetters,
//             allergyCacheItems: allergiesToCache.map((allergy) => {
//               const mappedAllergy: Prisma.AllergyCacheItemCreateInput = {
//                 ...allergy,
//                 CodeType: allergy.CodeType.toString(),
//               };

//               return mappedAllergy;
//             }),
//           },
//         });
//     } catch (error) {
//       await LoggerUtil.logError(
//         'Error storing the allergy results in cache.',
//         'cacheAllergyResults',
//         error,
//         { searchName, allergiesToCache }
//       );
//     }
//   }
// }

// const mapPharmacyResultToCachedPharmacy = async (
//   result: PharmacyResult
// ): Promise<PharmacyCacheItem> => {
//   const {
//     IsPreferred,
//     IsDefault,
//     PharmacyId,
//     PharmacyServices,
//     PharmacySpecialties,
//     PhoneAdditional1,
//     PhoneAdditionalType1,
//     PhoneAdditional2,
//     PhoneAdditionalType2,
//     PhoneAdditional3,
//     PhoneAdditionalType3,
//     PrimaryPhone,
//     PrimaryPhoneType,
//     ...rest
//   } = result;

//   const mappedServices = PharmacyServices
//     ? PharmacyServices.map((ps) => ps.toString())
//     : [];

//   const mappedSpecialities = PharmacySpecialties
//     ? PharmacySpecialties.map((ps) => ps.toString())
//     : [];

//   const mappedPhoneAdditionalType1 = PhoneAdditionalType1
//     ? PhoneAdditionalType1.toString()
//     : null;
//   const mappedPhoneAdditionalType2 = PhoneAdditionalType2
//     ? PhoneAdditionalType2.toString()
//     : null;
//   const mappedPhoneAdditionalType3 = PhoneAdditionalType3
//     ? PhoneAdditionalType3.toString()
//     : null;

//   const mappedPrimaryPhoneType = PrimaryPhoneType
//     ? PrimaryPhoneType.toString()
//     : null;

//   const mappedIsPreferred = IsPreferred ?? null;
//   const mappedIsDefault = IsDefault ?? null;

//   const cachedItem: PharmacyCacheItem = {
//     ...rest,
//     PharmacyId: PharmacyId.toString(),
//     IsPreferred: mappedIsPreferred,
//     IsDefault: mappedIsDefault,
//     PrimaryPhone: PrimaryPhone ?? null,
//     PharmacyServices: mappedServices,
//     PharmacySpecialties: mappedSpecialities,
//     PhoneAdditional1: PhoneAdditional1 ?? null,
//     PhoneAdditionalType1: mappedPhoneAdditionalType1,
//     PhoneAdditional2: PhoneAdditional2 ?? null,
//     PhoneAdditionalType2: mappedPhoneAdditionalType2,
//     PhoneAdditional3: PhoneAdditional3 ?? null,
//     PhoneAdditionalType3: mappedPhoneAdditionalType3,
//     PrimaryPhoneType: mappedPrimaryPhoneType,
//   };

//   return cachedItem;
// };

// const mapCachedPharmacyToPharmacyResult = async (
//   cachItem: PharmacyCacheItem
// ): Promise<PharmacyResult> => {
//   const {
//     IsPreferred,
//     IsDefault,
//     PharmacyId,
//     PharmacyServices,
//     PharmacySpecialties,
//     PhoneAdditionalType1,
//     PhoneAdditionalType2,
//     PhoneAdditionalType3,
//     PrimaryPhone,
//     PrimaryPhoneType,
//     ...rest
//   } = cachItem;

//   const mappedServices = PharmacyServices
//     ? PharmacyServices.map(
//         (ps) => PharmacyServiceLevels[ps as keyof typeof PharmacyServiceLevels]
//       )
//     : undefined;

//   const mappedSpecialities = PharmacySpecialties.map(
//     (ps) => PharmacySpecialityType[ps as keyof typeof PharmacySpecialityType]
//   );

//   const mappedPhoneAdditionalType1 = PhoneAdditionalType1
//     ? PhoneType[PhoneAdditionalType1 as keyof typeof PhoneType]
//     : undefined;
//   const mappedPhoneAdditionalType2 = PhoneAdditionalType2
//     ? PhoneType[PhoneAdditionalType2 as keyof typeof PhoneType]
//     : undefined;
//   const mappedPhoneAdditionalType3 = PhoneAdditionalType3
//     ? PhoneType[PhoneAdditionalType3 as keyof typeof PhoneType]
//     : undefined;

//   const mappedPrimaryPhoneType = PrimaryPhoneType
//     ? PhoneType[PrimaryPhoneType as keyof typeof PhoneType]
//     : undefined;

//   const mappedIsPreferred = IsPreferred ?? undefined;
//   const mappedIsDefault = IsDefault ?? undefined;

//   const pharmacyItem: PharmacyResult = {
//     ...rest,
//     PharmacyId: parseInt(PharmacyId),
//     IsPreferred: mappedIsPreferred,
//     IsDefault: mappedIsDefault,
//     PharmacyServices: mappedServices,
//     PharmacySpecialties: mappedSpecialities,
//     PhoneAdditionalType1: mappedPhoneAdditionalType1,
//     PhoneAdditionalType2: mappedPhoneAdditionalType2,
//     PhoneAdditionalType3: mappedPhoneAdditionalType3,
//     PrimaryPhone: PrimaryPhone ?? undefined,
//     PrimaryPhoneType: mappedPrimaryPhoneType,
//   };

//   return pharmacyItem;
// };

// const getCacheKeyFromQuery = (query: PharmacySearchQuery): string => {
//   const safeQuery = {
//     name: query.name ?? '',
//     city: query.city ?? '',
//     zip: query.zip ?? '',
//   };

//   return JSON.stringify(safeQuery);
// };

// const isAllergySearchResult = (obj: any[]): obj is AllergySearchResult[] => {
//   if (obj.length == 0) return true;
//   return (
//     obj[0].CodeType &&
//     Object.values(AllergyCodeType).includes(obj[0].CodeType as string)
//   );
// };

// const preprocessString = (str: string): string => {
//   // Remove special characters and convert to lowercase
//   return str.replace(/[^\w\s]/gi, '').toLowerCase();
// };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/dosespot/dosespotValidations.ts

import { z } from 'zod';

import { SexAtBirthEnum } from '@prisma/client';

import {
  AllergyReactionType,
  AllergyStatusType,
  HeightUnitItem,
  PatientDemographicDataPayload,
  PatientMedicationStatusType,
  PhoneType,
  SelfReportedAllergiesInput,
  SelfReportedMedicationInput,
  WeightUnitItem,
} from './dosespotTypes';

// Zip Code:
// • 5 digits or 5 digits + 4 digit code extension
export const zipCodeRegex = /^\d{5}(?:[-\s]\d{4})?$/;
export const zipCodeSchema = z.string().regex(zipCodeRegex, 'Invalid zip code');

// State:
// • Must be a valid US state two-letter abbreviation or full name
export const stateRegex = /^([A-Z]{2})$/;
export const stateSchema = z
  .string()
  .regex(stateRegex, 'State should be 2 uppercase letters');

export const testState = (state: string): boolean => {
  const stateIsTwoLetter = stateRegex.test(state);

  return stateIsTwoLetter;
};

// Phone Numbers:
// • Must be formatted for the United States with 3 digit area code and then 7 digits
// • Must not contain 7 or more repeated numbers
// • Extensions are allowed by using an ‘x’ before them
// • Must have a valid area code which is currently in service.
// o All area codes are now supported with the exception of ‘555’ and codes that start with ‘0’ or ‘1’
export const phoneNumberRegex = /^(?!555|0\d|1\d)\d{3}\d{7}$/;
export const phoneNumberSchema = z
  .string()
  .regex(phoneNumberRegex, 'Invalid phone number');

export const patientDemographicDataSchema: z.ZodType<PatientDemographicDataPayload> =
  z.object({
    Active: z.boolean(),
    Prefix: z.string().max(10).optional(),
    MiddleName: z.string().max(35).optional(),
    FirstName: z.string().max(35),
    LastName: z.string().max(35),
    Suffix: z.string().max(10).optional(),
    DateOfBirth: z.date(),
    Gender: z.nativeEnum(SexAtBirthEnum),
    Email: z.string().email().optional(),
    Address1: z.string().max(35),
    Address2: z.string().max(35).optional(),
    City: z.string().max(35),
    State: stateSchema,
    ZipCode: zipCodeSchema,
    PrimaryPhone: phoneNumberSchema,
    PrimaryPhoneType: z.nativeEnum(PhoneType),
    Height: z.number().optional(),
    HeightMetric: z.nativeEnum(HeightUnitItem).optional(),
    Weight: z.number().optional(),
    WeightMetric: z.nativeEnum(WeightUnitItem).optional(),
  });

export const patientSelfReportedMedicationSchema: z.ZodType<SelfReportedMedicationInput> =
  z.object({
    DispensableDrugId: z.number().int(),
    Status: z.nativeEnum(PatientMedicationStatusType),
  });

export const patientSelfReportedMedicationsSchema: z.ZodType<
  SelfReportedMedicationInput[]
> = z.array(patientSelfReportedMedicationSchema);

export const patientSelfReportedAllergySchema: z.ZodType<SelfReportedAllergiesInput> =
  z.object({
    AllergenId: z.number().int(),
    ReactionType: z.nativeEnum(AllergyReactionType),
    StatusType: z.nativeEnum(AllergyStatusType),
  });

export const patientSelfreportedAllergiesSchema: z.ZodType<
  SelfReportedAllergiesInput[]
> = z.array(patientSelfReportedAllergySchema);


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/dosespot/dosespotTypes.ts

import { AxiosResponse } from 'axios';

import { SexAtBirthEnum } from '@prisma/client';

// ENUMS

export enum AllergyCodeType {
  AllergyClass = 1,
  GenericDrug = 2,
  SNOMED = 3,
}

export enum AllergyReactionType {
  Allergy = 1,
  AdverseReaction = 2,
}

export enum AllergyStatusType {
  Active = 1,
  Inactive = 2,
  Deleted = 3,
}

export enum PharmacySpecialityType {
  EPCS = 2048,
  TwentyFourHourPharmcy = 64,
  LongTermCarePharmcy = 32,
  MailOrder = 1,
  Retail = 8,
  SpecialtyPharmacy = 16,
}

export enum ClinicianRoleType {
  PrescribingClinician = 1,
  ReportingClinician = 2,
  EpcsClinician = 3,
  ClinicianAdmin = 4,
  PrescribingAgentClinician = 5,
  ProxyClinician = 6,
}

export enum PharmacyServiceLevels {
  NewRx = 1,
  Refill = 2,
  Change = 4,
  RxFill = 8,
  Cancel = 16,
  MedHistory = 32,
  Eligibility = 64,
  Resupply = 256,
  Census = 256,
  CCR = 1024,
  ControlledSubstance = 2048,
}

export enum PhoneType {
  Beeper = 1,
  Cell = 2,
  Fax = 3,
  Home = 4,
  Work = 5,
  Night = 6,
  Primary = 7,
}

export enum PrescriptionStatusType {
  Entered = 'Entered',
  Printed = 'Printed',
  Sending = 'Sending',
  eRXSent = 'eRXSent',
  Error = 'Error',
  Deleted = 'Deleted',
  Requested = 'Requested',
  Edited = 'Edited',
  EpcsError = 'EpcsError',
  EpcsSigned = 'EpcsSigned',
  ReadyToSign = 'ReadyToSign',
  PharmacyVerified = 'PharmacyVerified',
}

export enum PrescriptionType {
  Coded = 1,
  FreeText = 2,
  PartnerNDC = 3,
}

export enum HeightUnitItem {
  INCH = 1,
  CM = 2,
}

export enum WeightUnitItem {
  LB = 1,
  KG = 2,
}

export enum DoseSpotResultCode {
  OK = 'OK',
  ERROR = 'ERROR',
}

export enum PatientMedicationStatusType {
  Active = 'Active',
  Discontinued = 'Discontinued',
  Deleted = 'Deleted',
  Completed = 'Completed',
  CancelRequested = 'CancelRequested',
  CancelPending = 'CancelPending',
  Cancelled = 'Cancelled',
  CancelDenied = 'CancelDenied',
  Changed = 'Changed',
}

export enum ClinicianRoleType {
  PRESCRIBING_CLINICIAN = 1,
  REPORTING_CLINICIAN = 2,
  EPCS_CLINICIAN = 3,
  CLINICIAN_ADMIN = 4,
  PRESCRIBING_AGENT_CLINICIAN = 5,
  PROXY_CLINICIAN = 6,
}

// PAYLOADS

export interface DoseSpotIdentificationOptions {
  clinicID: string;
  userID: string;
  clinicKey: string;
}

export interface PatientDemographicDataPayload {
  Active: boolean;
  Prefix?: string;
  MiddleName?: string;
  FirstName: string;
  LastName: string;
  Suffix?: string;
  DateOfBirth: Date;
  Gender: SexAtBirthEnum;
  Email?: string;
  Address1: string;
  Address2?: string | null;
  City: string;
  State: string;
  ZipCode: string;
  PrimaryPhone: string;
  PrimaryPhoneType: PhoneType;
  Height?: number;
  HeightMetric?: HeightUnitItem;
  Weight?: number;
  WeightMetric?: WeightUnitItem;
}

export interface AddClinicianPayload {
  Firstname: string;
  Lastname: string;
  DateOfBirth: Date;
  Email?: string;
  Address1: string;
  Address2?: string;
  City: string;
  State: string;
  ZipCode: string;
  PrimaryPhone: string;
  PrimaryPhoneType: PhoneType;
  PrimaryFax: string;
  DEANumber?: string | string[];
  NPINumber: string;
  ClinicianRoleType: ClinicianRoleType;
  EPCSRequested?: boolean;
  Active?: boolean;
}

export interface SelfReportedMedicationInput {
  DispensableDrugId: number;
  Status: PatientMedicationStatusType;
}

export interface UpdateSelfReportedMedicationPayload
  extends SelfReportedMedicationPayload {
  SelfReportedMedicationId: number;
}

export interface UpdateSelfReportedMedicationStatusPayload {
  SelfReportedMedicationId: number;
  Status: PatientMedicationStatusType;
  DispensableDrugId: number;
}

export interface SelfReportedMedicationPayload {
  DispensableDrugId: number;
  Status: PatientMedicationStatusType;
}

export interface UpdateSelfReportedAllergiesPayload {
  PatientAllergyId: number;
  ReactionType: AllergyReactionType;
  StatusType: AllergyStatusType;
  OnsetDate?: Date;
  Reaction?: string;
}

export interface SelfReportedAllergiesInput {
  AllergenId: number;
  ReactionType: AllergyReactionType;
  StatusType: AllergyStatusType;
}

export interface SelfReportedAllergiesPayload {
  AllergenId: number;
  ReactionType: AllergyReactionType;
  StatusType: AllergyStatusType;
}

export interface SelfReportedMedication {
  SelfReportedMedicationId: number;
  DisplayName: string;
  Status: PatientMedicationStatusType;
  DispensableDrugID: number;
  NameWithRouteDoseForm?: string;
}

export interface Allergy {
  PatientAllergyId: number;
  DisplayName: string;
  AllergenId: number;
  StatusType: AllergyStatusType;
}

// RESULTS
export interface PrescriptionResult {
  PrescriptionId: number;
  WrittenDate: Date;
  Directions: string;
  Quantity: string;
  DispenseUnitId: number;
  DispenseUnitDescription: string;
  Refills: string;
  DaysSupply: number;
  PharmacyId: number;
  PharmacyNotes: string;
  NoSubstitutions: boolean;
  EffectiveDate: Date;
  LastFillDate: Date;
  PrescriberId: number;
  PrescriberAgentId: number;
  RxReferenceNumber: string;
  Status: PrescriptionStatusType;
  Formulary: boolean;
  EligibilityId: number;
  Type: PrescriptionType;
  NonDoseSpotPrescriptionId: string;
  PatientMedicationId: number;
  MedicationStatus: PatientMedicationStatusType;
  Comment: string;
  DateInactive: Date;
  Encounter: string;
  DoseForm: string;
  Route: string;
  Strength: string;
  GenericProductName: string;
  LexiGenProductId: number;
  LexiDrugSynId: number;
  LexiSynonymTypeId: number;
  LexiGenDrugId: string;
  RxCUI: string;
  OTC: boolean;
  NDC: string;
  Schedule: string;
  DisplayName: string;
  MonographPath: string;
  DrugClassification: string;
  StateSchedules: StateSchedule[];
}

export interface PrescriptionResultWithPharmacyPhysician
  extends PrescriptionResult {
  Pharmacy: PharmacyResult;
  Prescriber: ClinicianResult;
}

export interface AllergenSearchResult {
  Name: string;
  BrandName: string;
  AllergenId: string;
  AllergenType: string;
  IsActive?: boolean;
}

export interface AllergySearchResult {
  Items: AllergenSearchResult[];
}

export interface MedicationSearchItem {
  DispensableDrugId: number;
  RoutedDoseFormDrugId: number;
  NDC: string;
  RxCUI: number | null;
  NameWithRouteDoseForm: string;
  Strength: string;
  IsObsolete: boolean;
}

export interface MedicationSearchResult {
  Items: MedicationSearchItem[];
}

export interface PatientPrescriptionResult {
  prescriptionId: string;
  displayName: string;
  directions: string;
  quantity: number;
  refills: number;
  dispenseUnitId: string;
  dispenseUnitDescription: string;
  daysSupply: number;
  pharmacy: string;
  prescriptionStatus: string;
  medicationStatus: string;
  effectiveDate: Date;
  prescriberName: string;
}

export interface StateSchedule {
  StateName: string;
  Schedule: number;
}

export interface MedicationResult {
  LexiGenProductId?: number;
  LexiDrugSynId: number;
  LexiSynonymTypeId?: number;
  LexiGenDrugId?: string;
  GenericProductName: string;
  GenericDrugName: string;
  DisplayName: string;
  RxCUI?: string;
  OTC: boolean;
  NDC?: string;
  Schedule: string;
  StateSchedules?: StateSchedule[];
}

export interface SelfReportedMedicationResult extends MedicationResult {
  SelfReportedMedicationId: number;
  PatientMedicationId: number;
  DateReported: Date;
  DateInactive?: Date;
  MedicationStatus: PatientMedicationStatusType;
  DaysSupply?: number;
}

export interface AllergyResult {
  Items: Allergy[];
  Result: DoseSpotUpdateResult;
}

export interface ClinicianResult {
  ClinicianId: number;
  Prefix?: string;
  FirstName: string;
  MiddleName?: string;
  LastName: string;
  Suffix?: string;
  DateOfBirth: Date;
  Email: string;
  Address1: string;
  Address2?: string;
  City: string;
  State: string;
  ZipCode: string;
  PrimaryPhone: string;
  PrimaryPhoneType: PhoneType;
  PrimaryFax: string;
  DEANumber: string;
  NPUNumber: string;
  Roles: ClinicianRoleType[];
}

export interface PharmacyResult {
  IsPreferred?: boolean;
  IsDefault?: boolean;
  PharmacyId: number;
  StoreName: string;
  Address1: string;
  Address2: string;
  City: string;
  State: string;
  ZipCode: string;
  PrimaryPhone?: string;
  PrimaryPhoneType?: PhoneType;
  PrimaryFax: string;
  PhoneAdditional1: string | null;
  PhoneAdditionalType1?: PhoneType;
  PhoneAdditional2: string | null;
  PhoneAdditionalType2?: PhoneType;
  PhoneAdditional3: string | null;
  PhoneAdditionalType3?: PhoneType;
  PharmacySpecialties: PharmacySpecialityType[];
  ServiceLevel: number;
  Latitude: number;
  Longitude: number;
  // custom field to put calculated services offered based on bitwise "ServiceLevel"
  PharmacyServices?: PharmacyServiceLevels[];
}

export interface PatientDemographicUpdateResult {
  PatientId: string;
  PatientDoseSpotId: string;
}

// AXIOS RESPONSES

export interface DoseSpotGetItemResult<T> extends AxiosResponse {
  data: {
    Item: T;
    Result: {
      ResultCode: DoseSpotResultCode;
      ResultDescription: string;
    };
  };
}

export interface DoseSpotGetItemsResult<T> extends AxiosResponse {
  data: {
    Items: T;
    Result: {
      ResultCode: DoseSpotResultCode;
      ResultDescription: string;
    };
  };
}

export interface DoseSpotUpdateResult extends AxiosResponse {
  data: {
    Result: {
      ResultCode: DoseSpotResultCode;
      ResultDescription: string;
    };
  };
}

export interface DoseSpotCreateResult extends AxiosResponse {
  data: {
    Id: string;
    Result: {
      ResultCode: DoseSpotResultCode;
      ResultDescription: string;
    };
  };
}

// TYPE GUARDS

export const isDoseSpotCreateResult = (
  doseSpotResult: any
): doseSpotResult is DoseSpotCreateResult => {
  return (doseSpotResult as DoseSpotCreateResult).data.Id !== undefined;
};

// CUSTOM

export interface PushToDoseSpotSuccess {
  success: true;
  patientDoseSpotId: string;
}

export interface MedicationAndAllergyResponse {
  medications: {
    Name: string;
  }[];
  allergies: {
    Name: string;
  }[];
}

// ERRORS
export interface PushToDoseSpotError {
  success: false;
  error: {
    shouldContinue: boolean;
    errorMessage: string;
    errorDetail?: any;
  };
}

export interface DSAxiosErrorResponse {
  Message: string;
  ModelState: { [key: string]: string[] };
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/shiphero/shipheroClient.ts

import axios from 'axios';
import { v4 } from 'uuid';

import {
  Address,
  CartProducts,
  CartSubscriptionProducts,
  Order,
  Shipment,
  ShipmentStatus,
  ShippingCarrier,
  ShippingMethod,
  ShippingPartner,
  User,
} from '@prisma/client';

import LoggerUtil from '../logging/apiUtilLogger';
import { prisma } from '../mongo/prismaClient';

export const shipHeroAuthNetworking = axios.create({
  baseURL: process.env.SHIPHERO_AUTH_URL,
  timeout: 5000,
});

export const shipHeroGraphqlNetworking = axios.create({
  baseURL: process.env.SHIPHERO_GRAPHQL_API_URL,
  timeout: 5000,
});

export default class ShipheroClient {
  public static async postGraphQL(
    data: any = {},
    authToken: string
  ): Promise<any> {
    const shipheroGraphQLData = await shipHeroGraphqlNetworking.post('', data, {
      headers: {
        Authorization: `Bearer ${authToken}`,
        'Content-Type': 'application/json',
      },
    });

    return shipheroGraphQLData;
  }

  public static async postAuth(data: any = {}): Promise<any> {
    const shipheroAuthData = await shipHeroAuthNetworking.post('', data, {
      headers: {
        'Content-Type': 'application/json',
      },
    });

    return shipheroAuthData;
  }

  public static async fetchAuthToken(): Promise<string> {
    const shipHeroAuthData = await this.postAuth({
      username: 'tim.ritzema@cortinahealth.com',
      password: 'arv!Y9m9sANT2C8',
    });

    return shipHeroAuthData.data.access_token;
  }

  public static async createOrder(
    address: Address,
    user: User,
    order: Order,
    cartProducts: CartProducts[],
    cartSubscriptionProducts: CartSubscriptionProducts[]
  ): Promise<Shipment | null> {
    // Don't order anything if you have no products to order
    if (cartProducts.length <= 0 && cartSubscriptionProducts.length <= 0) {
      return null;
    }

    // Determine if we've tried to make a shipment before
    const previousShipHeroShippingAttempt = await prisma.shipment.findFirst({
      where: {
        orderId: order.id,
        shippingPartner: ShippingPartner.SHIP_HERO,
      },
    });

    // TODO: CHECK IF WE NEED TO RETRY SHIP HERO SHIPMENT AND DETERMINE BEST MECHANISM FOR NOW IF A PREVIOUS SHIPMENT EXISTS WE JUST RETURN IT
    if (previousShipHeroShippingAttempt) {
      return previousShipHeroShippingAttempt;
    }

    const accessToken = await this.fetchAuthToken();

    // Generate an Order ID
    const orderId = v4().substring(0, 32); // Maximum of 32 characters for order number
    const todayDateString = new Date().toISOString().split('T')[0];

    // Create an array of products to ship
    let itemString = '';

    // Add Products
    const productIDsToShip: string[] = [];
    for (const cartProduct of cartProducts) {
      const product = await prisma.product.findUnique({
        where: {
          id: cartProduct.productId,
        },
      });

      if (product && product?.shippingPartnerSKU) {
        const lineItemId = v4().substring(0, 32); // TODO: I have no idea what this means

        // Prices are adjusted to be dollars and cents since our DB stores the prices in Stripe's format (cents)
        itemString += `
            {
                sku: "${product.shippingPartnerSKU}"
                partner_line_item_id: "${lineItemId}"
                quantity: ${cartProduct.quantity}
                price: "${product.price / 10}"
                product_name: "${product.name}"
                fulfillment_status: "pending"
                quantity_pending_fulfillment: ${cartProduct.quantity}
                warehouse_id: "V2FyZWhvdXNlOjEwMDQ4MQ=="
            },`;
        productIDsToShip.push(product.id);
      } else {
        await LoggerUtil.logError(
          'sh_product_not_found',
          'shipHeroClient > createOrder',
          new Error(
            `Product SKU not found: Product ID: ${cartProduct.productId}`
          ),
          {
            userId: user.id,
            orderId,
            cartProduct,
          }
        );
      }
    }

    // Add Subscription Products
    const subscriptionProductIdsToShip: string[] = [];
    for (const subscriptionCartProduct of cartSubscriptionProducts) {
      const subscriptionProduct = await prisma.subscriptionProduct.findUnique({
        where: {
          id: subscriptionCartProduct.subscriptionProductId,
        },
      });

      if (subscriptionProduct && subscriptionProduct?.shippingPartnerSKU) {
        const lineItemId = v4().substring(0, 32); // TODO: I have no idea what this means

        // Prices are adjusted to be dollars and cents since our DB stores the prices in Stripe's format (cents)
        itemString += `
              {
                  sku: "${subscriptionProduct.shippingPartnerSKU}"
                  partner_line_item_id: "${lineItemId}"
                  quantity: ${subscriptionCartProduct.quantity}
                  price: "${subscriptionProduct.price / 10}"
                  product_name: "${subscriptionProduct.name}"
                  fulfillment_status: "pending"
                  quantity_pending_fulfillment: ${
                    subscriptionCartProduct.quantity
                  }
                  warehouse_id: "V2FyZWhvdXNlOjEwMDQ4MQ=="
              },`;
        subscriptionProductIdsToShip.push(subscriptionProduct.id);
      } else {
        await LoggerUtil.logError(
          'sh_sub_product_not_found',
          'shipHeroClient > createOrder',
          new Error(
            `Subscription Product SKU not found: Subscription Product ID: ${subscriptionCartProduct.subscriptionProductId}`
          ),
          {
            userId: user.id,
            orderId,
            subscriptionCartProduct,
          }
        );
      }
    }

    // Create the Order
    const mutation = `mutation {
        order_create(
          data: {
            order_number: "${orderId}"
            shop_name: "Cortina"
            fulfillment_status: "pending"
            order_date: "${todayDateString}"
            total_tax: "0"
            subtotal: "0"
            total_discounts: "0"
            total_price: "0"
            shipping_lines: {
              title: "USPS"
              price: "0.00"
              carrier: "USPS"
              method: "Ground"
            }
            shipping_address: {
              first_name: "${user.firstName}"
              last_name: "${user.lastName}"
              company: ""
              address1: "${address.address1}"
              address2: "${address.address2}"
              city: "${address.city}"
              state: "${address.state}"
              state_code: "${address.state}"
              zip: "${address.zip}"
              country: "US"
              country_code: "US"
              email: "${user.email}"
              phone: "${user.phoneNumber}"
            }
            billing_address: {
                first_name: "${user.firstName}"
                last_name: "${user.lastName}"
                company: ""
                address1: "${address.address1}"
                address2: "${address.address2}"
                city: "${address.city}"
                state: "${address.state}"
                state_code: "${address.state}"
                zip: "${address.zip}"
                country: "US"
                country_code: "US"
                email: "${user.email}"
                phone: "${user.phoneNumber}"
            }
            line_items: [
              ${itemString}
            ]
            required_ship_date: "${todayDateString}"
          }
        ) {
          request_id
          complexity
          order {
            id
            order_number
            shop_name
            fulfillment_status
            order_date
            total_tax
            subtotal
            total_discounts
            total_price
            custom_invoice_url
            account_id
            email
            profile
            packing_note
            required_ship_date
          }
        }
      }`;

    const graphQLResult = await this.postGraphQL(
      { query: mutation },
      accessToken
    );

    await LoggerUtil.logInfo(
      'sh_graphql_results',
      'shipheroClient > createOrder',
      {
        userId: user.id,
        orderId,
        graphQLResultData: graphQLResult.data,
      }
    );

    if (graphQLResult.data.errors) {
      let errorMessage = '';
      for (const currentError of graphQLResult.data.errors) {
        errorMessage += currentError.message + '; ';
      }

      await LoggerUtil.logError(
        'sh_graphql_error',
        'shipheroClient > createOrder',
        new Error('Shiphero Had an error: ' + errorMessage),
        {
          userId: user.id,
          orderId,
          graphQLResultData: graphQLResult.data,
        }
      );

      const errorShipment = await prisma.shipment.create({
        data: {
          orderId: order.id,
          userId: user.id,
          shippingPartnerId: orderId,
          shippingPartner: ShippingPartner.SHIP_HERO,
          shippingCarrier: ShippingCarrier.USPS,
          shippingMethod: ShippingMethod.USPS_PRIORITY,
          shipmentStatus: ShipmentStatus.FAILED,
          shippingAddress: address,
          rawShippingData: mutation,
          productIds: productIDsToShip,
          subscriptionProductIds: subscriptionProductIdsToShip,
          errorDetails: errorMessage,
        },
      });

      return errorShipment;
    }

    // TODO: CREATE A SHIPMENT AND RETURN THE DATA
    const shipment = await prisma.shipment.create({
      data: {
        orderId: order.id,
        userId: user.id,
        shippingPartnerId: orderId,
        shippingPartner: ShippingPartner.SHIP_HERO,
        shippingCarrier: ShippingCarrier.USPS,
        shippingMethod: ShippingMethod.USPS_PRIORITY,
        shipmentStatus: ShipmentStatus.PENDING,
        shippingAddress: address,
        rawShippingData: mutation,
        productIds: productIDsToShip,
        subscriptionProductIds: subscriptionProductIdsToShip,
      },
    });

    return shipment;
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/slack/slackClient.ts

import moment from 'moment';

import { ExtendedUser } from '@/app/shared/types';
import { ShippingPartner, UserSubscription } from '@prisma/client';

import LoggerUtil from '../logging/apiUtilLogger';
import { logger } from '../logging/winstonClient';

const slackToken = process.env.SLACK_TOKEN;

const slackCaseUpdates = process.env.CASE_UPDATE_SLACK_WEBHOOK;
const slackDevUpdates = process.env.DEV_UPDATES_SLACK_WEBHOOK;
const slackOrderIssues = process.env.ORDER_ISSUES_SLACK_WEBHOOK;
const slackConciergeCancellations = process.env.CANCEL_CONCIERGE_SLACK_WEBHOOK;
const slackHighPriority = process.env.HIGH_PRIORITY_ISSUE_SLACK_WEBHOOK;
const slackMessageTemplates = process.env.MESSAGE_TEMPLATES_SLACK_WEBHOOK;

const sendSlackMessage = async (
  slackUrl: string | undefined,
  body: string
): Promise<boolean> => {
  try {
    if (!slackUrl) {
      logger.log('error', 'slack_message_url_missing', {
        metadata: { source: 'SlackClient', slackUrl, body },
      });
      return false;
    }

    const response = await fetch(slackUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body,
    });

    if (!response.ok) {
      logger.log('error', 'slack_message_failed', {
        metadata: { slackUrl, body },
      });
      await LoggerUtil.logError(
        'slack_message_bad_response',
        'sendSlackMessage',
        new Error('Bad response from slack.'),
        { response, responseBody: await response.text() }
      );
      return false;
    }

    return true;
  } catch (error) {
    await LoggerUtil.logError(
      'slack_message_failed',
      'sendSlackMessage',
      error,
      {}
    );
    return false;
  }
};

type ConciergeUser = Pick<
  ExtendedUser,
  'id' | 'spotUserId' | 'email' | 'firstName' | 'lastName' | 'stripeId'
>;

type ConciergeSubscription = Pick<UserSubscription, 'id' | 'nextRenewalDate'>;

export default class SlackClient {
  public static async logOrderIssue(
    orderId: string,
    customerId: string,
    provider: ShippingPartner,
    issueDescription: string,
    additionalContext?: {
      [key: string]: string | number | boolean | Date | null;
    }
  ): Promise<boolean> {
    const additionalFields = additionalContext
      ? Object.entries(additionalContext).map(([key, value]) => {
          return { type: 'mrkdwn', text: `*${key}:*\n${value}` };
        })
      : [];

    return await sendSlackMessage(
      slackOrderIssues,
      JSON.stringify({
        blocks: [
          {
            type: 'header',
            text: {
              type: 'plain_text',
              text: `Problem with ${provider} order with id: ${orderId}`,
            },
          },
          {
            type: 'section',
            fields: [
              {
                type: 'mrkdwn',
                text: `*Order ID:*\n${orderId}`,
              },
              {
                type: 'mrkdwn',
                text: `*Customer ID:*\n${customerId}`,
              },
              {
                type: 'mrkdwn',
                text: `*Provider:*\n${provider}`,
              },
              {
                type: 'mrkdwn',
                text: `*Issue Description:*\n${issueDescription}`,
              },
              ...additionalFields,
            ],
          },
        ],
      })
    );
  }

  public static async logNewCase(email: string): Promise<boolean> {
    return await sendSlackMessage(
      slackCaseUpdates,
      JSON.stringify({
        blocks: [
          {
            type: 'header',
            text: {
              type: 'plain_text',
              text: 'A new case has been submitted',
            },
          },
          {
            type: 'section',
            fields: [
              {
                type: 'mrkdwn',
                text: `*Email:*\n${email}`,
              },
            ],
          },
        ],
      })
    );
  }

  public static async logHighPriorityIssues(
    user: ExtendedUser,
    title: string,
    detail: string,
    additionalContext?: { [key: string]: string | number | boolean | Date }
  ): Promise<boolean> {
    const additionalFields = additionalContext
      ? Object.entries(additionalContext).map(([key, value]) => {
          return { type: 'mrkdwn', text: `*${key}:*\n${value}` };
        })
      : [];

    const bugUrl = getBugButtonLink(
      title,
      detail,
      undefined,
      undefined,
      additionalContext,
      BugImpact.High
    );

    return await sendSlackMessage(
      slackHighPriority,
      JSON.stringify({
        blocks: [
          {
            type: 'header',
            text: {
              type: 'plain_text',
              text: title,
            },
          },
          {
            type: 'section',
            fields: [
              {
                type: 'mrkdwn',
                text: `*User ID:*\n${user.id}`,
              },
              {
                type: 'mrkdwn',
                text: `*Customer Name:*\n${user.firstName} ${user.lastName}`,
              },
              {
                type: 'mrkdwn',
                text: `*Email:*\n${user.email}`,
              },
              ...additionalFields,
            ],
          },
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `*Detail:*\n${detail}`,
            },
            accessory: {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'Log Bug',
              },
              url: bugUrl,
            },
          },
        ],
      })
    );
  }

  public static async logConciergeCancellation(
    user: ConciergeUser,
    subscriptions: ConciergeSubscription[]
  ): Promise<boolean> {
    return await sendSlackMessage(
      slackConciergeCancellations,
      JSON.stringify({
        blocks: [
          {
            type: 'header',
            text: {
              type: 'plain_text',
              text: 'New Request to Cancel Concierge Subscription',
            },
          },
          {
            type: 'section',
            fields: [
              {
                type: 'mrkdwn',
                text: `*User ID:*\n${user.id}`,
              },
              {
                type: 'mrkdwn',
                text: `*Customer Name:*\n${user.firstName} ${user.lastName}`,
              },
              {
                type: 'mrkdwn',
                text: `*Email:*\n${user.email}`,
              },
              {
                type: 'mrkdwn',
                text: `*Stripe ID:*\n${user.stripeId}`,
              },
              ...subscriptions.map((subscription) => ({
                type: 'mrkdwn',
                text: `*Cancelled UserSubscription ID:*\n${subscription.id}`,
              })),
            ],
          },
        ],
      })
    );
  }

  public static async logMessageTemplateAction(
    userId: string,
    templateId: string,
    title: string,
    reviewScore: number,
    userName: string,
    action: TemplateAction = TemplateAction.CREATE
  ): Promise<boolean> {
    let slackTitle;
    switch (action) {
      case TemplateAction.UPDATE:
        slackTitle = 'Message Template Updated';
        break;
      case TemplateAction.ARCHIVE:
        slackTitle = 'Message Template Archived';
        break;
      case TemplateAction.REACTIVATE:
        slackTitle = 'Message Template Reactivated';
        break;
      default:
        slackTitle = 'New Message Template Created';
        break;
    }

    return await sendSlackMessage(
      slackMessageTemplates,
      JSON.stringify({
        blocks: [
          {
            type: 'header',
            text: {
              type: 'plain_text',
              text: `${slackTitle} (${process.env.ENVIRONMENT_NAME})`,
            },
          },
          {
            type: 'section',
            fields: [
              {
                type: 'mrkdwn',
                text: `*User ID:*\n${userId}`,
              },
              {
                type: 'mrkdwn',
                text: `*Template ID:*\n${templateId}`,
              },
              {
                type: 'mrkdwn',
                text: `*Template Title:*\n${title}`,
              },
              {
                type: 'mrkdwn',
                text: `*Complexity Score:*\n${reviewScore}`,
              },
              {
                type: 'mrkdwn',
                text: `*User Name:*\n${userName}`,
              },
            ],
          },
        ],
      })
    );
  }
}

export enum TemplateAction {
  CREATE = 'CREATE',
  UPDATE = 'UPDATE',
  ARCHIVE = 'ARCHIVE',
  REACTIVATE = 'REACTIVATE',
}

export enum BugImpact {
  High = 'High+Impact',
  Normal = 'Normal',
  Low = 'Low+Impact',
}

const getBugButtonLink = (
  bugTitle: string,
  bugDescription: string,
  bugDate?: Date,
  relevantUrl?: string,
  additionalContext?: { [key: string]: string | number | boolean | Date },
  impactLevel?: BugImpact
) => {
  const additionalFields = additionalContext
    ? Object.entries(additionalContext)
        .map(([key, value]) => {
          return `${key}:+${value.toString()}`;
        })
        .join('%0A')
    : '';

  const bugOccurredAt = moment(bugDate ?? new Date()).format('YYYY-MM-DD');

  return encodeURI(
    'https://docs.google.com/forms/d/e/1FAIpQLSefZuJqv7ute0oeBsJbJq5bQ4ah-hFs6StfLLZD825gdbKDSA/viewform?usp=pp_url&' +
      `entry.1060472253=${bugTitle}` +
      `&entry.240740935=${bugDescription}` +
      `&entry.466912416=${bugOccurredAt}` + // when the bug occurred
      `&entry.288713975=${relevantUrl ?? ''}` +
      `&entry.1618498056=${additionalFields}` +
      `&entry.74352180=${impactLevel ?? BugImpact.Normal}`
  );
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/mongo/mongoClient.ts

import { MongoClient } from 'mongodb';
import type {
  Collection,
  Document,
  Filter,
  UpdateFilter,
  UpdateOptions,
  UpdateResult,
} from 'mongodb';

import LoggerUtil from '@/utils/clients/logging/apiUtilLogger';

let client: MongoClient | null = null;

let connection: MongoClient | null = null;

const ensureConnection = async (): Promise<MongoClient> => {
  if (!client)
    client = new MongoClient(process.env.DATABASE_URL || 'mongodb+srv://');

  if (!connection) {
    return await client.connect();
  }
  return connection;
};

export const updateCollectionData = async (
  collection: string,
  updateOne = true,
  filter: Filter<Document>,
  update: UpdateFilter<Document> | Partial<Document>,
  options?: UpdateOptions
): Promise<UpdateResult<Document>> => {
  try {
    let result: UpdateResult<Document> | null = null;

    const coll = await getCollection(collection);

    if (updateOne) result = await coll.updateOne(filter, update, options);
    else result = await coll.updateMany(filter, update, options);

    return result;
  } catch (error) {
    LoggerUtil.logError(
      'mongo_update_error',
      'updateCollectionData',
      error,
      {}
    );

    throw error;
  }
};

const getCollection = async (
  collection: string
): Promise<Collection<Document>> => {
  connection = await ensureConnection();

  const database = connection.db();

  const coll = database.collection(collection);

  return coll;
};

const checkMongoConnection = async (): Promise<boolean> => {
  try {
    // Connect to the MongoDB server
    const connection = await ensureConnection();

    // Ping the server to check the connection
    await connection.db().command({ ping: 1 });

    return true;
  } catch (error) {
    await LoggerUtil.logError(
      'mongo_connection_failure',
      'checkMongoConnection',
      error,
      {}
    );
    return false;
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/mongo/prismaTypes.ts

/** Prisma Client (Query Engine) Error Codes `P2XXX` */
export const PrismaQueryError = {
  /**
   * The provided value for the column is too long for the column's type. Column: `{column_name}`
   */
  ValueTooLongForColumnType: 'P2000',

  /**
   * The record searched for in the where condition (`{model_name}.{argument_name} = {argument_value}`) does not exist
   */
  RecordDoesNotExist: 'P2001',

  /**
   * Unique constraint failed on the `{constraint}`
   */
  UniqueConstraintViolation: 'P2002',

  /**
   * Foreign key constraint failed on the field: `{field_name}`
   */
  ForeignConstraintViolation: 'P2003',

  /**
   * A constraint failed on the database: `{database_error}`
   */
  ConstraintViolation: 'P2004',

  /**
   * The value `{field_value}` stored in the database for the field `{field_name}` is invalid for the field's type
   */
  InvalidValueForFieldType: 'P2005',

  /**
   * The provided value `{field_value}` for `{model_name}` field `{field_name}` is not valid
   */
  InvalidValue: 'P2006',

  /**
   * Data validation error `{database_error}`
   */
  ValidationError: 'P2007',

  /**
   * Failed to parse the query `{query_parsing_error}` at `{query_position}`
   */
  QueryParsingError: 'P2008',

  /**
   * Failed to validate the query: `{query_validation_error}` at `{query_position}`
   */
  QueryValidationError: 'P2009',

  /**
   * Raw query failed. Code: `{code}`. Message: `{message}`
   */
  RawQueryError: 'P2010',

  /**
   * Null constraint violation on the `{constraint}`
   */
  NullConstraintViolation: 'P2011',

  /**
   * Missing a required value at `{path}`
   */
  MissingRequiredValue: 'P2012',

  /**
   * Missing the required argument `{argument_name}` for field `{field_name}` on `{object_name}`.
   */
  MissingRequiredArgument: 'P2013',

  /**
   * The change you are trying to make would violate the required relation '{relation_name}' between the `{model_a_name}` and `{model_b_name}` models.
   */
  RequiredRelationViolation: 'P2014',

  /**
   * A related record could not be found. `{details}`
   */
  RelatedRecordNotFound: 'P2015',

  /**
   * Query interpretation error. `{details}`
   */
  InterpretationError: 'P2016',

  /**
   * The records for relation `{relation_name}` between the `{parent_name}` and `{child_name}` models are not connected.
   */
  RecordsForParentAndChildNotConnected: 'P2017',

  /**
   * The required connected records were not found. `{details}`
   */
  RequiredConnnectedRecordsNotFound: 'P2018',

  /**
   * Input error. `{details}`
   */
  InputError: 'P2019',

  /**
   * Value out of range for the type. `{details}`
   */
  ValueOutOfRange: 'P2020',

  /**
   * The table `{table}` does not exist in the current database.
   */
  TableDoesNotExist: 'P2021',

  /**
   * The column `{column}` does not exist in the current database.
   */
  ColumnDoesNotExist: 'P2022',

  /**
   * Inconsistent column data: `{message}`
   */
  InconsistentColumnData: 'P2023',

  /**
   * Timed out fetching a new connection from the connection pool. (More info: {@link http://pris.ly/d/connection-pool} (Current connection pool timeout: {timeout}, connection limit: {connection_limit})
   */
  TimedOutFetchingConnectionFromThePool: 'P2024',

  /**
   * An operation failed because it depends on one or more records that were required but not found. `{cause}`
   */
  RecordsNotFound: 'P2025',

  /**
   * The current database provider doesn't support a feature that the query used: `{feature}`
   */
  UnsupportedProviderFeature: 'P2026',

  /**
   * Multiple errors occurred on the database during query execution: `{errors}`
   */
  MultipleErrors: 'P2027',

  /**
   * Transaction API error: {error}
   */
  TransactionAPIError: 'P2028',

  /**
   * Cannot find a fulltext index to use for the search, try adding a @@fulltext([Fields...]) to your schema
   */
  NoFulltextIndex: 'P2030',

  /**
   * Prisma needs to perform transactions, which requires your MongoDB server to be run as a replica set. See details: {@link https://pris.ly/d/mongodb-replica-set}
   */
  MongoDbReplicaSetRequired: 'P2031',

  /**
   * A number used in the query does not fit into a 64 bit signed integer. Consider using `BigInt` as field type if you're trying to store large integers
   */
  NumberOutOfRange: 'P2033',

  /**
   * Transaction failed due to a write conflict or a deadlock. Please retry your transaction
   */
  TransactionFailed: 'P2034',
} as const;

export type PrismaQueryError = typeof PrismaQueryError;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/mongo/prismaClient.ts

import { PrismaClient, Prisma, elementType, PromoCodes } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

export const prismaFormClient = prisma.$extends({
  name: 'prismaFormClient',
  model: {
    formElement: {
      async createElement(data: any) {
        return await prisma.$transaction(async (prisma) => {
          const element = await prisma.formElement.create({
            data: {
              elementType: data.elementType,
              name: data.name,
            },
          });

          if (data.elementType === elementType.FormText) {
            await prisma.formText.create({
              data: {
                formElement: { connect: { id: element.id } },
                componentType: data.componentType,
                text: data.text,
                showLogic: data.showLogic,
                translations: data.translations,
                formTextProperties: data.formTextProperties,
              },
            });
          } else if (data.elementType === elementType.FormField) {
            await prisma.formField.create({
              data: {
                formElement: { connect: { id: element.id } },
                label: data.label,
                helperText: data.helperText,
                fieldType: data.fieldType,
                fieldProperties: data.fieldProperties,
                showLogic: data.showLogic,
                validation: data.validation,
                required: data.required,
                translations: data.translations,
              },
            });
          } else {
            throw new Error('Invalid element type');
          }
          return element;
        });
      },
    },
  },
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/logging/apiUtilLogger.ts

import { logger } from './winstonClient';

// logger util to attempt to simplify log formatting in app
export default class LoggerUtil {
  public static async logInfo(
    message: string,
    source: string,
    addtionalContext: any
  ) {
    try {
      logger.info(message, {
        metadata: {
          service: 'dermi-api',
          sourceDetail: { source },
          ...addtionalContext,
        },
      });
    } catch (e) {
      // if the logger fails, log why to cloudwatch
      console.error(e);
      return;
    }
  }
  public static async logError(
    message: string,
    source: string,
    error: unknown,
    addtionalContext: any
  ) {
    try {
      let typedError;

      // just in case
      if (typeof error === 'object') typedError = error as Error;
      else if (typeof error === 'string') typedError = new Error(error);
      else typedError = { error: error };

      const errorDetail = { ...typedError, source };

      logger.error(message, {
        metadata: {
          service: 'dermi-api',
          errorString: error ? error.toString() : 'Error undefined or null',
          typedError,
          errorDetail,
          ...addtionalContext,
        },
      });
    } catch (e) {
      // if the logger fails, log why to cloudwatch
      console.error(e);
      return;
    }
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/clients/logging/winstonClient.ts

// import path from 'path';
import axios from 'axios';
import type { LogEntry } from 'winston';
import { config, createLogger, exceptions, format, transports } from 'winston';
import Transport from 'winston-transport';
import { ConsoleTransportOptions } from 'winston/lib/winston/transports';

const httpTransportOptions = {
  host: 'http-intake.logs.datadoghq.com',
  path: `/api/v2/logs?dd-api-key=${process.env.DATADOG_API_KEY}&ddsource=nodejs`,
  ssl: true,
  level: 'info',
  service: process.env.APPLICATION_NAME,
  ddsource: 'nodejs',
  ddtags: `env:${process.env.ENVIRONMENT_NAME}`,
};

const { combine, timestamp, json, errors } = format;
const errorsFormat = errors({ stack: true });

const datadogTransporter = async (payload: LogEntry) => {
  const { level, message, timestamp, metadata = {} } = payload;

  const hostname = process.env.BASE_URL ?? 'https://www.cortinahealth.com';

  const data: { [key: string]: any } = {
    level,
    message,
    service: metadata?.service,
    hostname,
    metadata: metadata ?? {},
    ddsource: httpTransportOptions.ddsource,
    ddtags: httpTransportOptions.ddtags,
    timestamp,
  };

  if (metadata.error) {
    data.metadata.error = {
      code: metadata.error?.code,
      message: metadata.error?.message,
      stack: metadata.error?.stack?.toString?.(),
    };
  }

  return axios
    .post(
      `https://${httpTransportOptions.host}${httpTransportOptions.path}&service=${metadata.service}`,
      data,
      {
        headers: {
          'Content-Type': 'application/json',
        },
      }
    )
    .catch((error) => {
      console.log('Error on transport', error?.response, error?.response?.data);
    });
};

class CustomTransport extends Transport {
  log(payload: LogEntry, cb: any) {
    //Call datadog messages
    datadogTransporter(payload);
    cb(null);
  }
}

const apiErrorLogger = createLogger({
  levels: config.syslog.levels,
  exitOnError: false,
  format: format.json(),
  transports: [
    new CustomTransport({
      format: combine(timestamp(), json(), errorsFormat),
    }),
  ],
});

const logger = createLogger({
  levels: config.syslog.levels,
  exitOnError: false,
  format: format.json(),
  transports: [
    new CustomTransport({
      format: combine(timestamp(), json(), errorsFormat),
    }),
  ],
});

if (process.env.ENVIRONMENT_NAME !== 'production') {
  // If we're not in production then **ALSO** log to the `console`
  const logFormat = format.printf(function (info) {
    return `${
      info.level
    }: ${JSON.stringify(info.message, null, 4)},\n${JSON.stringify(info.metadata, null, 4)}\n}`;
  });
  const consoleLoggerConfig: ConsoleTransportOptions = {
    format: format.combine(format.colorize(), logFormat),
  };
  apiErrorLogger.add(new transports.Console(consoleLoggerConfig));
  logger.add(new transports.Console(consoleLoggerConfig));
  //exceptions.handle(new transports.Console({ format: format.json() }));
}

// export const fsLogger = createLogger({
//   level: 'error',
//   exitOnError: false,
//   format: format.json(),
//   transports: [
//     new transports.File({
//       filename: path.join(process.cwd(), 'logs', 'errors.log'),
//     }),
//   ],
// });

export { apiErrorLogger, logger };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/reporting/consultations-helpers.tsx

import moment from 'moment';

import { prisma } from '@/utils/clients/mongo/prismaClient';
import { CaseStatus, ProductCategories } from '@prisma/client';

interface diagnosisGroups {
  count: number;
  diagnosisName?: string | null;
  icd10Code: string | null;
}

interface complaintGroups {
  count: number;
  complaintName?: string | null;
}

interface physicianCountInfo {
  id: string;
  firstName?: string | null;
  lastName?: string | null;
  activeSubscribers?: number | null;
  caseCount?: number | null;
  avatarURL?: string | null;
}

interface diagnosisTimes {
  physicianId: string;
  lessThan6Hours: number;
  lessThan12Hours: number;
  lessThan24Hours: number;
  lessThan2Days: number;
  lessThan3Days: number;
  lessThan4Days: number;
  lessThan6Days: number;
  greaterThanOrEqualTo6Days: number;
}

interface assignedCase {
  id: string;
  userId: string;
  physicianName: string;
  assignedAt: Date | null;
  avatarURL?: string | null;
  lastMessageSentName: string | null;
}

interface consultationsReport {
  submittedCases: number;
  openCases: number;
  assignedCases: assignedCase[];
  diagnosedCases: number;
  averageTimeToDiagnose: number;
  diagnoses: diagnosisGroups[];
  complaints: complaintGroups[];
  consultationAndConciergeOrders: number;
  consultationOrders: number;
  promoCodeOrders: number;
  diagnosisTimes: diagnosisTimes[];
  existingSubscribers: number;
  physicianCases: physicianCountInfo[];
}

async function getAssignedCases(
  start?: Date,
  end?: Date
): Promise<assignedCase[]> {
  // Cases Assigned
  const assignedCasesFromDB = await prisma.case.findMany({
    where: {
      submittedAt: {
        gte: start,
        lte: end,
      },
      status: CaseStatus.ASSIGNED,
    },
    select: {
      physician: true,
      id: true,
      userId: true,
      assignedAt: true,
      thread: {
        select: {
          messages: {
            orderBy: {
              sentWhen: 'desc',
            },
            take: 1,
            select: {
              fromUser: {
                select: {
                  firstName: true,
                  lastName: true,
                },
              },
            },
          },
        },
      },
    },
  });

  const assignedCases: assignedCase[] = [];
  for (const assignedCase of assignedCasesFromDB) {
    let lastMessageSender = 'No Messages';
    if (
      assignedCase?.thread?.[0]?.messages?.[0]?.fromUser?.firstName &&
      assignedCase?.thread?.[0]?.messages?.[0]?.fromUser?.lastName
    ) {
      lastMessageSender =
        `${assignedCase.thread[0].messages[0].fromUser.firstName} ${assignedCase.thread[0].messages[0].fromUser.lastName}`.trim();
    }

    assignedCases.push({
      id: assignedCase.id,
      userId: assignedCase.userId,
      physicianName:
        assignedCase.physician?.firstName +
        ' ' +
        assignedCase.physician?.lastName,
      assignedAt: assignedCase.assignedAt,
      avatarURL: assignedCase.physician?.avatarUrl,
      lastMessageSentName: lastMessageSender,
    });
  }

  return assignedCases;
}

async function getCaseCounts(
  start?: Date,
  end?: Date
): Promise<{
  submittedCaseCount: number;
  openCaseCount: number;
}> {
  // Cases submittted (Gets all submitted cases because submitted is filled in)
  const submittedCaseCount = await prisma.case.count({
    where: {
      submittedAt: {
        gte: start,
        lte: end,
      },
    },
  });

  // Cases Open
  const openCaseCount = await prisma.case.count({
    where: {
      submittedAt: {
        gte: start,
        lte: end,
      },
      status: CaseStatus.OPEN,
    },
  });

  return {
    submittedCaseCount,
    openCaseCount,
  };
}

async function getDiagnosedCaseInfo(
  start?: Date,
  end?: Date
): Promise<{ diagnosedCaseCount: number; averageDiagnosisTime: number }> {
  // Cases Diagnosed (Acquire latest diagnoses from these, and also average submitted ot diagnosed time, gets all diagnosed cases because diagnosed is not null, also can get complaint frequencies)
  const diagnosedCases = await prisma.case.findMany({
    where: {
      diagnosedAt: {
        gte: start,
        lte: end,
      },
    },
  });

  const diagnosedCaseCount = diagnosedCases.length;

  // Calculate the average time to diagnose
  let totalTimeToDiagnose = 0;
  let totalCasesInCount = 0;
  for (let i = 0; i < diagnosedCases.length; i++) {
    const currentCase = diagnosedCases[i];
    if (currentCase.diagnosedAt && currentCase.submittedAt) {
      const timeDiff =
        currentCase.diagnosedAt.getTime() - currentCase.submittedAt.getTime();
      totalCasesInCount++;
      totalTimeToDiagnose += timeDiff;
    }
  }

  const averageTimeToDiagnose = totalTimeToDiagnose / totalCasesInCount;

  // Convert milliseconds to a more readable format (e.g., hours)
  const averageTimeToDiagnoseInHours = averageTimeToDiagnose / (1000 * 60 * 60);

  return {
    diagnosedCaseCount,
    averageDiagnosisTime: averageTimeToDiagnoseInHours,
  };
}

async function getExistingSubscribersCount(
  start?: Date,
  end?: Date
): Promise<number> {
  // Get existing subscriber count
  const existingSubscriberCount = await prisma.order.count({
    where: {
      createdAt: {
        gte: start,
        lte: end,
      },
      user: {
        NOT: {
          userSubscriptions: {
            some: {
              AND: [
                {
                  subscriptionProduct: {
                    category: ProductCategories.CONCIERGE,
                  },
                },
                {
                  ended: false,
                },
              ],
            },
          },
        },
      },
      OR: [
        {
          cartProducts: {
            some: {
              product: {
                category: 'CONSULTATION',
              },
            },
          },
        },
        {
          cartSubscriptionProducts: {
            some: {
              subscriptionProduct: {
                category: 'CONSULTATION',
              },
            },
          },
        },
      ],
      NOT: {
        OR: [
          {
            cartProducts: {
              some: {
                product: {
                  category: 'CONCIERGE',
                },
              },
            },
          },
          {
            cartSubscriptionProducts: {
              some: {
                subscriptionProduct: {
                  category: 'CONCIERGE',
                },
              },
            },
          },
        ],
      },
    },
  });

  return existingSubscriberCount;
}

async function getConsultationAndConciergePurchases(
  start?: Date,
  end?: Date
): Promise<{
  consultationOrderCount: number;
  consultationAndConciergeOrderCount: number;
}> {
  // Concierge and consultation case count
  const consultationAndConciergeOrderCount = await prisma.order.count({
    where: {
      createdAt: {
        gte: start,
        lte: end,
      },
      AND: [
        {
          OR: [
            {
              cartProducts: {
                some: {
                  product: {
                    category: 'CONSULTATION',
                  },
                },
              },
            },
            {
              cartSubscriptionProducts: {
                some: {
                  subscriptionProduct: {
                    category: 'CONSULTATION',
                  },
                },
              },
            },
          ],
        },
        {
          OR: [
            {
              cartProducts: {
                some: {
                  product: {
                    category: 'CONCIERGE',
                  },
                },
              },
            },
            {
              cartSubscriptionProducts: {
                some: {
                  subscriptionProduct: {
                    category: 'CONCIERGE',
                  },
                },
              },
            },
          ],
        },
      ],
    },
  });

  // Get consultation count
  const consultationOrderCount = await prisma.order.count({
    where: {
      createdAt: {
        gte: start,
        lte: end,
      },
      OR: [
        {
          cartProducts: {
            some: {
              product: {
                category: 'CONSULTATION',
              },
            },
          },
        },
        {
          cartSubscriptionProducts: {
            some: {
              subscriptionProduct: {
                category: 'CONSULTATION',
              },
            },
          },
        },
      ],
    },
  });

  return {
    consultationOrderCount,
    consultationAndConciergeOrderCount,
  };
}

async function getDiagnosisAndComplaintGroups(
  start?: Date,
  end?: Date
): Promise<{
  diagnosisResults: diagnosisGroups[];
  complaintResults: complaintGroups[];
}> {
  const diagnosisGroups = await prisma.case.groupBy({
    by: ['diagnosisName', 'diagnosisICD'],
    where: {
      diagnosedAt: {
        gte: start,
        lte: end,
      },
      diagnosisName: {
        not: null,
      },
      diagnosisICD: {
        not: null,
      },
    },
    _count: {
      diagnosisName: true,
    },
  });

  const diagnosisResults: diagnosisGroups[] = diagnosisGroups.map((group) => ({
    count: group._count.diagnosisName,
    diagnosisName: group.diagnosisName,
    icd10Code: group.diagnosisICD,
  }));

  const complaintGroups = await prisma.case.groupBy({
    by: ['complaint'],
    where: {
      diagnosedAt: {
        gte: start,
        lte: end,
      },
    },
    _count: {
      complaint: true,
    },
  });

  const complaintResults = complaintGroups.map((group) => ({
    complaintName: group.complaint,
    count: group._count.complaint,
  }));

  return {
    diagnosisResults,
    complaintResults,
  };
}

async function getPhysicianCaseInfo(
  start?: Date,
  end?: Date
): Promise<{
  physicianCountInfo: physicianCountInfo[];
}> {
  const physicianActiveSubscribers = await prisma.case.groupBy({
    by: ['physicianId'],
    where: {
      diagnosedAt: {
        gte: start,
        lte: end,
      },
      user: {
        userSubscriptions: {
          some: {
            AND: [
              {
                subscriptionProduct: {
                  category: ProductCategories.CONCIERGE,
                },
              },
              {
                ended: false,
              },
            ],
          },
        },
      },
    },
    _count: {
      id: true,
    },
  });

  const physicianCases = await prisma.case.groupBy({
    by: ['physicianId'],
    where: {
      diagnosedAt: {
        gte: start,
        lte: end,
      },
    },
    _count: {
      id: true,
    },
  });

  const physicianInformation: physicianCountInfo[] = [];

  for (let i = 0; i < physicianActiveSubscribers.length; i++) {
    const currentPhysician = physicianActiveSubscribers[i];
    if (currentPhysician.physicianId) {
      const physicianObject = await prisma.user.findUnique({
        where: {
          id: currentPhysician.physicianId,
        },
      });

      const physicianCaseCount = physicianCases.find(
        (item) => item.physicianId === currentPhysician.physicianId
      );

      physicianInformation.push({
        id: currentPhysician.physicianId,
        firstName: physicianObject?.firstName,
        lastName: physicianObject?.lastName,
        activeSubscribers: currentPhysician._count.id,
        caseCount: physicianCaseCount?._count.id,
        avatarURL: physicianObject?.avatarUrl,
      });
    }
  }

  return {
    physicianCountInfo: physicianInformation,
  };
}

async function getAverageDiagnosisTime(
  start?: Date,
  end?: Date
): Promise<diagnosisTimes[]> {
  const physicianUsers = await prisma.user.findMany({
    where: {
      roles: {
        has: 'PHYSICIAN',
      },
    },
    select: {
      id: true,
    },
  });

  const diagnosisTimes: diagnosisTimes[] = await Promise.all(
    physicianUsers.map(async (physician) => {
      const cases = await prisma.case.findMany({
        where: {
          physicianId: physician.id,
          submittedAt: { not: null },
          diagnosedAt: {
            gte: start,
            lte: end,
          },
        },
        select: {
          diagnosedAt: true,
          submittedAt: true,
        },
      });

      const diagnosisTimeBuckets = cases.reduce(
        (acc, currentCase) => {
          // Additional null checks
          if (currentCase.diagnosedAt && currentCase.submittedAt) {
            const diagnosisTime =
              currentCase.diagnosedAt.getTime() -
              currentCase.submittedAt.getTime();
            const hoursDifference = diagnosisTime / (1000 * 60 * 60);

            if (hoursDifference < 6) acc.lessThan6Hours++;
            else if (hoursDifference < 12) acc.lessThan12Hours++;
            else if (hoursDifference < 24) acc.lessThan24Hours++;
            else if (hoursDifference < 48) acc.lessThan2Days++;
            else if (hoursDifference < 72) acc.lessThan3Days++;
            else if (hoursDifference < 96) acc.lessThan4Days++;
            else if (hoursDifference < 144) acc.lessThan6Days++;
            else acc.greaterThanOrEqualTo6Days++;
          } else {
            console.warn(
              'Encountered a case with null diagnosedAt or submittedAt despite query filters:',
              currentCase
            );
          }

          return acc;
        },
        {
          physicianId: physician.id,
          lessThan6Hours: 0,
          lessThan12Hours: 0,
          lessThan24Hours: 0,
          lessThan2Days: 0,
          lessThan3Days: 0,
          lessThan4Days: 0,
          lessThan6Days: 0,
          greaterThanOrEqualTo6Days: 0,
        } as diagnosisTimes
      );

      return diagnosisTimeBuckets;
    })
  );

  return diagnosisTimes;
}

async function getOrdersWithPromoCode(
  start?: Date,
  end?: Date
): Promise<{
  ordersWithPromoCode: number;
}> {
  const ordersWithPromocode = await prisma.order.count({
    where: {
      AND: [
        {
          createdAt: {
            gte: start,
            lte: end,
          },
        },
        {
          promoCodeCode: {
            not: null,
          },
        },
      ],
    },
  });

  return {
    ordersWithPromoCode: ordersWithPromocode,
  };
}

const complaintMapping: { [key: string]: string } = {
  acne: 'Acne',
  'hair loss men': 'Hair Loss Men',
  hair_loss_men: 'Hair Loss Men',
  'hair loss': 'Hair Loss Men',
  rash: 'Rash',
  'dark spots': 'Dark Spots',
  rosacea: 'Rosacea',
  'hair loss women': 'Hair Loss Women',
  eczema: 'Eczema',
  psoriasis: 'Psoriasis',
};

const getStandardName = (name: string | null | undefined) => {
  if (!name) return 'Other';

  const lowercaseName = name.toLowerCase();
  return complaintMapping?.[lowercaseName] ?? 'Other';
};

export const groupComplaints = (complaints: complaintGroups[]) => {
  const groupedComplaints = complaints.reduce((acc, complaint) => {
    const standardName = getStandardName(complaint.complaintName);

    if (!acc[standardName]) {
      acc[standardName] = { complaintName: standardName, count: 0 };
    }

    acc[standardName].count += complaint.count;
    return acc;
  }, {} as { [key: string]: { complaintName: string; count: number } });

  return Object.values(groupedComplaints).map((group) => ({
    complaint: `${group.complaintName} (${group.count})`,
  }));
};

export const formatDiagnosisAverageTime = (averageTime: number) => {
  if (averageTime === 0) {
    return '0 hours';
  }
  const days = Math.floor(averageTime / 24);
  const hours = (averageTime % 24).toFixed(1);

  return `${days} days and ${hours} hours`;
};

type dateTimeType = string | Date | null;

export const getConsultationReport = async (
  startTime: dateTimeType,
  endTime: dateTimeType
) => {
  const start = startTime ? moment(startTime).toDate() : undefined;
  const end = endTime ? moment(endTime).toDate() : undefined;

  if (end && start && end < start) {
    throw new Error('End date cannot be before start date');
  }

  const caseCounts = await getCaseCounts(start, end);
  const diagnosisInfo = await getDiagnosedCaseInfo(start, end);
  const consultationAndConciergeOrderCounts =
    await getConsultationAndConciergePurchases(start, end);
  const diagnosisAndComplaintGroups = await getDiagnosisAndComplaintGroups(
    start,
    end
  );
  const physicianResults = await getPhysicianCaseInfo(start, end);
  const ordersWithPromoCode = await getOrdersWithPromoCode(start, end);
  const assignedCases = await getAssignedCases(start, end);
  const existingSubscriberCount = await getExistingSubscribersCount(start, end);
  const averageDiagnosisTimes = await getAverageDiagnosisTime(start, end);

  const reportToSend: consultationsReport = {
    submittedCases: caseCounts.submittedCaseCount,
    openCases: caseCounts.openCaseCount,
    assignedCases: assignedCases,
    diagnosedCases: diagnosisInfo.diagnosedCaseCount,
    averageTimeToDiagnose: diagnosisInfo.averageDiagnosisTime,
    consultationAndConciergeOrders:
      consultationAndConciergeOrderCounts.consultationAndConciergeOrderCount,
    consultationOrders:
      consultationAndConciergeOrderCounts.consultationOrderCount,
    promoCodeOrders: ordersWithPromoCode.ordersWithPromoCode,
    existingSubscribers: existingSubscriberCount,
    diagnosisTimes: averageDiagnosisTimes,
    diagnoses: diagnosisAndComplaintGroups.diagnosisResults,
    complaints: diagnosisAndComplaintGroups.complaintResults,
    physicianCases: physicianResults.physicianCountInfo,
  };

  return reportToSend;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/reporting/user-trends.tsx

import moment from 'moment';

import { SexAtBirthEnum } from '@prisma/client';

import { prisma } from '../clients/mongo/prismaClient';
import { listCognitoUsers } from './cognito/list-cognito-users';
import {
  getDeviceCategoryData,
  getNewUserData,
} from './google-analytics/transform-reports';

interface userFromStates {
  userCount: number;
  state: string;
}

type AgeSexData = {
  profile_age_bracket: string[];
  [SexAtBirthEnum.MALE]: string[];
  [SexAtBirthEnum.FEMALE]: string[];
  [SexAtBirthEnum.UNKNOWN]: string[];
};

type DemographicsResult = {
  countByState: userFromStates[];
  totalFemaleCount: number;
  totalMaleCount: number;
  totalUnknownCount: number;
  ageSexData: AgeSexData;
};

const AGE_BRACKETS = [
  '< 18',
  '18 - 24',
  '25 - 34',
  '35 - 44',
  '45 - 54',
  '54 - 64',
  '> 65',
];

function getAgeBracketIndex(dob: Date): number {
  const age = moment().diff(moment(dob), 'years');
  if (age < 18) return 0;
  if (age < 25) return 1;
  if (age < 35) return 2;
  if (age < 45) return 3;
  if (age < 55) return 4;
  if (age < 65) return 5;
  else return AGE_BRACKETS.length - 1;
}

async function getUserDemographics(
  start?: Date,
  end?: Date
): Promise<DemographicsResult> {
  // Get user counts
  const usersCreatedInRange = await prisma.user.findMany({
    where: {
      createdAt: {
        gte: start,
        lte: end,
      },
      anonymousUser: false,
    },
    select: {
      id: true,
      addresses: true,
      medicalProfile: {
        select: {
          sexAtBirth: true,
          dob: true,
        },
      },
    },
  });

  const result: DemographicsResult = {
    countByState: [],
    totalFemaleCount: 0,
    totalMaleCount: 0,
    totalUnknownCount: 0,
    ageSexData: {
      profile_age_bracket: AGE_BRACKETS,
      [SexAtBirthEnum.MALE]: Array(AGE_BRACKETS.length).fill('0'),
      [SexAtBirthEnum.FEMALE]: Array(AGE_BRACKETS.length).fill('0'),
      [SexAtBirthEnum.UNKNOWN]: Array(AGE_BRACKETS.length).fill('0'),
    },
  };

  const usersWithAddresses = usersCreatedInRange.filter(
    (user) => user.addresses.length > 0
  );

  // Count by state
  const userCountByState = usersWithAddresses.reduce((acc, user) => {
    const state = user.addresses[0]?.state || 'Unknown';

    if (!acc[state]) {
      acc[state] = 0;
    }
    acc[state]++;

    return acc;
  }, {} as Record<string, number>);

  result.countByState = Object.entries(userCountByState)
    .map(([state, userCount]) => ({
      state,
      userCount,
    }))
    .sort((a, b) => b.userCount - a.userCount);

  const usersWithMedicalProfiles = usersCreatedInRange.filter(
    (user) =>
      user.medicalProfile != null &&
      user.medicalProfile.dob != null &&
      user.medicalProfile.sexAtBirth != null
  );

  // Age Gender Breakdown
  usersWithMedicalProfiles.forEach((user) => {
    const sex = user.medicalProfile?.sexAtBirth || 'UNKNOWN';
    const dob = user.medicalProfile?.dob;

    // Increment total counts
    switch (sex) {
      case SexAtBirthEnum.FEMALE:
        result.totalFemaleCount++;
        break;
      case SexAtBirthEnum.MALE:
        result.totalMaleCount++;
        break;
      default:
        result.totalUnknownCount++;
        break;
    }

    // Increment age bracket counts
    if (dob) {
      const bracketIndex = getAgeBracketIndex(dob);
      result.ageSexData[sex][bracketIndex] = (
        parseInt(result.ageSexData[sex][bracketIndex]) + 1
      ).toString();
    }
  });

  return result;
}

export const getDemographicReport = async (start: Date, end: Date) => {
  const demographics = await getUserDemographics(start, end);

  return {
    demographics,
  };
};

export const getFullGAReport = async (start: Date, end: Date) => {
  const [newUserData, deviceCategoryData] = await Promise.all([
    getNewUserData(start, end),
    getDeviceCategoryData(start, end),
  ]);

  return {
    newUserData,
    deviceCategoryData,
  };
};

export const getMigratedUserStatistics = async () => {
  const cognitoUsers = await listCognitoUsers();

  const mongoUsers = await prisma.user.findMany({
    where: {
      AND: [
        { spotUserId: { not: null } },
        { spotUserId: { not: '' } },
        { spotUserId: { not: undefined } },
      ],
      cognitoId: {
        not: null,
      },
    },
    select: {
      id: true,
      cognitoId: true,
      spotUserId: true,
    },
  });

  const matchedUsers: {
    mongoId: string;
    cognitoId: string | null;
    spotUserId: string | null;
    status: string | undefined;
  }[] = [];

  mongoUsers.forEach((mongoUser) => {
    const congitoUser = cognitoUsers.find(
      (cognitoUser) => mongoUser.cognitoId === cognitoUser.userId
    );

    matchedUsers.push({
      mongoId: mongoUser.id,
      cognitoId: mongoUser.cognitoId,
      spotUserId: mongoUser.spotUserId,
      status: congitoUser?.status,
    });
  });

  const usersMigrated = matchedUsers.filter((user) =>
    ['CONFIRMED', 'FORCE_CHANGE_PASSWORD'].includes(user.status as string)
  );

  const usersNotMigrated = matchedUsers.filter(
    (user) => user.status === 'RESET_REQUIRED'
  );

  return {
    usersMigrated: usersMigrated.length,
    usersNotMigrated: usersNotMigrated.length,
    totalUsersMigrated: matchedUsers.length,
  };
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/reporting/orders-helpers.tsx

import moment from 'moment';

import { prismaEcomClient } from '@/app/shared/models/extensions/ecommerce';
import { Product, SubscriptionProduct } from '@prisma/client';

type dateTimeType = string | Date | null;

export interface IOrderSummary {
  product: Product | SubscriptionProduct;
  qty: number;
}

export const getOrderSummary = async (
  startTime: dateTimeType,
  endTime: dateTimeType
) => {
  const start = startTime ? moment(startTime).toDate() : undefined;
  const end = endTime ? moment(endTime).toDate() : undefined;

  if (end && start && end < start) {
    throw new Error('End date cannot be before start date');
  }

  const filter =
    start || end
      ? {
          where: {
            createdAt: {
              gte: start,
              lte: end,
            },
          },
        }
      : {};

  const orders =
    (await prismaEcomClient.order.findMany({
      ...filter,
      include: {
        cartProducts: { include: { product: true } },
        cartSubscriptionProducts: { include: { subscriptionProduct: true } },
      },
    })) ?? [];

  const productResult = orders.reduce((acc, order) => {
    order.cartProducts.forEach((product) => {
      const existingProduct = acc.find(
        (item) => item.product.id === product.productId
      );
      if (existingProduct) {
        existingProduct.qty += product.quantity;
      } else {
        acc.push({ product: product.product, qty: product.quantity });
      }
    });
    order.cartSubscriptionProducts.forEach((product) => {
      const existingProduct = acc.find(
        (item) => item.product.id === product.subscriptionProductId
      );
      if (existingProduct) {
        existingProduct.qty += product.quantity;
      } else {
        acc.push({
          product: product.subscriptionProduct,
          qty: product.quantity,
        });
      }
    });

    return acc;
  }, [] as IOrderSummary[]);

  return productResult;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/reporting/trigger-reporting-emails.tsx

import moment from 'moment';

import LoggerUtil from '../clients/logging/apiUtilLogger';
import { UserEventNames } from '../user-events/enums';
import UserEventsClient from '../user-events/user-events-client';
import { formatCurrency, formatPrice } from '../utils';
import {
  formatDiagnosisAverageTime,
  getConsultationReport,
  groupComplaints,
} from './consultations-helpers';
import { getOrderSummary } from './orders-helpers';
import { getDemographicReport, getFullGAReport } from './user-trends';

const REPORTING_USER_ID =
  process.env.REPORTING_USER_ID ?? '66d07f22aa7534c8649416b1';

export const triggerReportingEmails = async () => {
  // Only send emails on Monday
  if (moment().day() !== 1) {
    return;
  }

  const today = moment().startOf('day');
  const sevenDaysAgo = moment(today).subtract(7, 'days');

  // Send Orders Report
  try {
    await sendOrdersReport(sevenDaysAgo, today);
  } catch (error) {
    await LoggerUtil.logError(
      'Unable to send orders report',
      'triggerReportingEmails',
      error,
      {}
    );
  }

  // // Send Consultations Report
  try {
    await sendConsultationsReport(sevenDaysAgo, today);
  } catch (error) {
    await LoggerUtil.logError(
      'Unable to send consultations report',
      'triggerReportingEmails',
      error,
      {}
    );
  }

  // User Trend Report (Google Analytics data takes 24 - 48 hours to update so we show the previous weeks data ending 2 days ago)
  try {
    await sendUserTrendReport(
      sevenDaysAgo.subtract(2, 'days'),
      today.subtract(2, 'days')
    );
  } catch (error) {
    await LoggerUtil.logError(
      'Unable to send user trend report',
      'triggerReportingEmails',
      error,
      {}
    );
  }
};

const sendOrdersReport = async (start: moment.Moment, end: moment.Moment) => {
  const orders = await getOrderSummary(start.toDate(), end.toDate());

  const formattedOrders = orders.map((orderItem) => ({
    name: orderItem.product.name,
    quantity: orderItem.qty,
    price: formatCurrency(orderItem.product.price),
    total: formatPrice(orderItem.qty * orderItem.product.price),
  }));

  // Send email
  await UserEventsClient.addEventByUserId(
    REPORTING_USER_ID,
    UserEventNames.DERMI_SEND_ORDERS_REPORT,
    {
      start: start.format('MMM DD, YYYY h:mm a'),
      end: end.format('MMM DD, YYYY h:mm a'),
      orders: formattedOrders,
    }
  );
};

const sendConsultationsReport = async (
  start: moment.Moment,
  end: moment.Moment
) => {
  const consultationReport = await getConsultationReport(
    start.toDate(),
    end.toDate()
  );

  const emailFormattedReport = {
    submittedCases: consultationReport.submittedCases,
    diagnosedCases: consultationReport.diagnosedCases,
    consultationAndConciergeOrders:
      consultationReport.consultationAndConciergeOrders,
    consultationOrders: consultationReport.consultationOrders,
    promoCodeOrders: consultationReport.promoCodeOrders,
    existingSubscribers: consultationReport.existingSubscribers,
    consultationTypes: groupComplaints(consultationReport.complaints),
    openCases: consultationReport.openCases,
    assignedCasesCount: consultationReport.assignedCases.length,
    diagnosisAvg: formatDiagnosisAverageTime(
      consultationReport.averageTimeToDiagnose
    ),
    physicianCases: consultationReport.physicianCases.map((physicianCase) => ({
      physicianName: `${physicianCase.firstName} ${physicianCase.lastName}`,
      completed: physicianCase.caseCount,
      activeSubscribers: physicianCase.activeSubscribers,
    })),
    diagnoses: consultationReport.diagnoses.map((diagnosis) => ({
      diagnosisName: diagnosis.diagnosisName,
      diagnosisFrequency: diagnosis.count,
      icd10Code: diagnosis.icd10Code,
    })),
  };

  // Send email
  await UserEventsClient.addEventByUserId(
    REPORTING_USER_ID,
    UserEventNames.DERMI_SEND_CONSULTATIONS_REPORT,
    {
      start: start.format('MMM DD, YYYY h:mm a'),
      end: end.format('MMM DD, YYYY h:mm a'),
      ...emailFormattedReport,
    }
  );
};

const sendUserTrendReport = async (
  start: moment.Moment,
  end: moment.Moment
) => {
  const [demographics, gaReport] = await Promise.all([
    getDemographicReport(start.toDate(), end.toDate()),
    getFullGAReport(start.toDate(), end.toDate()),
  ]);

  const formattedData = {
    start: start.format('MMM DD, YYYY h:mm a'),
    end: end.format('MMM DD, YYYY h:mm a'),
    newUSUsers: gaReport.newUserData.newUSUsers,
    newUserAccounts: gaReport.newUserData.newUserAccounts,
    deviceCategoryData: gaReport.deviceCategoryData,
    totalFemaleCount: demographics.demographics.totalFemaleCount,
    totalMaleCount: demographics.demographics.totalMaleCount,
    totalUnknownCount: demographics.demographics.totalUnknownCount,
    ageSexData: demographics.demographics.ageSexData,
    countByState: demographics.demographics.countByState,
  };

  // Send email
  await UserEventsClient.addEventByUserId(
    REPORTING_USER_ID,
    UserEventNames.DERMI_SEND_USER_TREND_REPORT,
    formattedData
  );
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/reporting/google-analytics/transform-reports.ts

/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { UserRole } from '@prisma/client';

import { prisma } from '../../clients/mongo/prismaClient';
import {
  runDeviceCategoryReport,
  runUserReport,
} from './run-user-trend-reports';

type DailyData = {
  date: string;
  newUSUsers: number;
  newUserAccounts: number;
};

type AnalyticsResponse = {
  newUSUsers: number;
  newUserAccounts: number;
  dailyData: DailyData[];
};

export const getNewUserData = async (start: Date, end: Date) => {
  const gaResponse = await runUserReport(start, end);

  const newAccountUsers = await prisma.user.findMany({
    where: {
      createdAt: {
        gte: new Date(start),
        lte: new Date(end),
      },
      // Filter for patients only
      roles: {
        has: UserRole.PATIENT,
      },
      anonymousUser: false,
    },
    select: {
      createdAt: true,
    },
  });

  // Process and combine data
  const dailyData: { [key: string]: DailyData } = {};
  let newUSUsers = 0;

  gaResponse.rows?.forEach((row) => {
    const date =
      row.dimensionValues![0].value!.substring(0, 4) +
      '-' +
      row.dimensionValues![0].value!.substring(4, 6) +
      '-' +
      row.dimensionValues![0].value!.substring(6, 8);
    const newUsers = parseInt(row.metricValues![0].value!);

    if (!dailyData[date]) {
      dailyData[date] = {
        date,
        newUSUsers: 0,
        newUserAccounts: 0,
      };
    }

    dailyData[date].newUSUsers += newUsers;
    newUSUsers += newUsers;
  });

  // Process Mongo data
  newAccountUsers.forEach((user) => {
    const date = user.createdAt.toISOString().split('T')[0];
    if (dailyData[date]) {
      dailyData[date].newUserAccounts++;
    }
  });

  const newUserAccounts = newAccountUsers.length;

  // Prepare the final response
  const response: AnalyticsResponse = {
    newUSUsers,
    newUserAccounts,
    dailyData: Object.values(dailyData),
  };

  return response;
};

export const getDeviceCategoryData = async (start: Date, end: Date) => {
  const gaResponse = await runDeviceCategoryReport(start, end);

  const deviceData: { [key: string]: number } = {};
  let totalUsers = 0;

  // First pass: count total users and users per device category
  gaResponse.rows?.forEach((row) => {
    const deviceCategory = row.dimensionValues![1].value!;
    const newUsers = parseInt(row.metricValues![0].value!);

    if (!deviceData[deviceCategory]) {
      deviceData[deviceCategory] = 0;
    }

    deviceData[deviceCategory] += newUsers;
    totalUsers += newUsers;
  });

  // Second pass: calculate percentages and create array of objects
  const devicePercentages: Array<{ deviceName: string; percentage: number }> =
    [];

  Object.entries(deviceData).forEach(([device, count]) => {
    const percentage = Number(((count / totalUsers) * 100).toFixed(2));
    devicePercentages.push({ deviceName: device, percentage });
  });

  // Sort device categories by percentage (descending order)
  devicePercentages.sort((a, b) => b.percentage - a.percentage);

  return devicePercentages;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/reporting/google-analytics/run-user-trend-reports.ts

import { BetaAnalyticsDataClient } from '@google-analytics/data';

// 👇 Setting PropertyId
const propertyId = process.env.GA_PROPERTY_ID;

const analyticsDataClient = new BetaAnalyticsDataClient({
  credentials: {
    client_email: process.env.GA_CLIENT_EMAIL,
    private_key: Buffer.from(
      `${process.env.GA_PRIVATE_KEY}`,
      'base64'
    ).toString('utf-8'),
  },
});

export const runUserReport = async (startDate: Date, endDate: Date) => {
  const [response] = await analyticsDataClient.runReport({
    property: `properties/${propertyId}`,
    dateRanges: [
      {
        startDate: startDate.toISOString().split('T')[0],
        endDate: endDate.toISOString().split('T')[0],
      },
    ],
    dimensions: [
      {
        name: 'date',
      },
    ],
    metrics: [
      {
        name: 'newUsers',
      },
    ],
    dimensionFilter: {
      filter: {
        fieldName: 'country',
        stringFilter: {
          value: 'United States',
        },
      },
    },
  });

  return response;
};

export const runDeviceCategoryReport = async (
  startDate: Date,
  endDate: Date
) => {
  const [response] = await analyticsDataClient.runReport({
    property: `properties/${propertyId}`,
    dateRanges: [
      {
        startDate: startDate.toISOString().split('T')[0],
        endDate: endDate.toISOString().split('T')[0],
      },
    ],
    dimensions: [
      {
        name: 'date',
      },
      {
        name: 'deviceCategory',
      },
      {
        name: 'country',
      },
    ],
    metrics: [
      {
        name: 'newUsers',
      },
    ],
    dimensionFilter: {
      filter: {
        fieldName: 'country',
        stringFilter: {
          value: 'United States',
        },
      },
    },
  });

  return response;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/reporting/cognito/list-cognito-users.ts

import {
  CognitoIdentityProviderClient,
  ListUsersCommand,
  ListUsersCommandInput,
} from '@aws-sdk/client-cognito-identity-provider';

interface ICognitoUser {
  userId: string;
  status?: string;
}

const client = new CognitoIdentityProviderClient({
  region: 'us-east-2',
  credentials: {
    accessKeyId: `${process.env.COGNITO_AWS_ACCESS_KEY}`,
    secretAccessKey: `${process.env.COGNITO_AWS_SECRET_KEY}`,
  },
});

export const listCognitoUsers: () => Promise<ICognitoUser[]> = async () => {
  const userPoolId = process.env.REPORTING_COGNITO_POOL_ID;

  const users: ICognitoUser[] = [];

  let paginationToken: string | undefined;

  do {
    const input: ListUsersCommandInput = {
      UserPoolId: userPoolId,
      PaginationToken: paginationToken,
    };

    const command = new ListUsersCommand(input);
    const response = await client.send(command);

    response.Users?.forEach((user) => {
      if (user.Username) {
        users.push({
          userId: user.Username,
          status: user.UserStatus,
        });
      }
    });

    paginationToken = response.PaginationToken;
  } while (paginationToken);

  const filteredUsers = users.filter(
    (user) => user.userId && user.status && user.userId.length === 36
  );

  return filteredUsers;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/payments/stripe-utils.ts

import Stripe from 'stripe';

import { prisma } from '@clients/mongo/prismaClient';
import {
  Address,
  Cart,
  CartProducts,
  CartSubscriptionProducts,
  Order,
  PaymentProviders,
  PromoCodes,
  User,
} from '@prisma/client';

import LoggerUtil from '../clients/logging/apiUtilLogger';
import {
  postPurchaseEvent,
  postSubscriptionPurchaseEvent,
} from '../user-events/user-event-utils';
import {
  GetProductPriceDetails,
  GetSubscriptionProductPriceDetails,
  PostPurchaseProcessSubscription,
  PostPurchaseProducts,
  PurchaseSystem,
  calculateNextRefillDatesFromToday,
  canAllProductsBePurchased,
  canAllSubscriptionProductsBePurchased,
  purchaseReturnType,
} from './purchaseSystem';
import { IBillingCharge, IPaymentMethod } from './types';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string);

export class StripePurchaseSystem extends PurchaseSystem {
  async captureCustomerPayment(
    paymentMethodId: string,
    paymentProvider: PaymentProviders,
    user: User,
    amount: number
  ): Promise<string> {
    if (!user.stripeId) {
      throw new Error('Please setup stripe customer before paying');
    }

    const paymentIntentData: Stripe.PaymentIntentCreateParams = {
      amount: amount,
      currency: 'usd',
      payment_method: paymentMethodId,
      customer: user.stripeId,
      metadata: {},
      automatic_payment_methods: {
        enabled: true,
        allow_redirects: 'never',
      },
    };

    const pi = await stripe.paymentIntents.create(paymentIntentData);

    // Confirm and Capture Case Payment
    const piResult = await stripe.paymentIntents.confirm(pi.id);

    if (piResult.status != 'succeeded') {
      throw new Error('Failed to pay for medical purchases');
    }

    return piResult.id;
  }

  async captureCustomerMedicalPayment(
    paymentMethodId: string,
    paymentProvider: PaymentProviders,
    user: User,
    amount: number,
    address: Address
  ): Promise<string> {
    if (!user.stripeId) {
      throw new Error('Please setup stripe customer before paying');
    }

    const paymentTransferInfo = await prisma.paymentRoutingInfo.findFirst({
      where: {
        state: address.state,
        paymentProvider: paymentProvider,
      },
    });

    let paymentIntentData: Stripe.PaymentIntentCreateParams = {
      amount: amount,
      currency: 'usd',
      payment_method: paymentMethodId,
      customer: user.stripeId,
      metadata: {},
      automatic_payment_methods: {
        enabled: true,
        allow_redirects: 'never',
      },
    };

    // Transfer data to correct acccount if it exists
    if (paymentTransferInfo) {
      paymentIntentData = {
        amount: amount,
        currency: 'usd',
        payment_method: paymentMethodId,
        customer: user.stripeId,
        capture_method: 'automatic',
        metadata: {},
        automatic_payment_methods: {
          enabled: true,
          allow_redirects: 'never',
        },
        transfer_data: {
          destination: paymentTransferInfo.paymentAccountId,
        },
      };
    }

    const pi = await stripe.paymentIntents.create(paymentIntentData);

    // Confirm and Capture Case Payment
    const piResult = await stripe.paymentIntents.confirm(pi.id);

    if (piResult.status != 'succeeded') {
      throw new Error('Failed to pay for medical purchases');
    }

    return piResult.id;
  }

  async BuyMedicalSubscription(
    paymentMethodId: string,
    paymentProvider: PaymentProviders,
    user: User,
    address: Address,
    subscriptionsToPurchase: CartSubscriptionProducts[],
    order: Order,
    cart: Cart,
    promoCode: PromoCodes | null,
    conciergeInCart: boolean
  ): Promise<purchaseReturnType> {
    if (!user.stripeId) {
      throw new Error(
        'Please setup the user in Stripe before retrieving payment methods'
      );
    }

    if (subscriptionsToPurchase.length < 1)
      return {
        paymentId: user.stripeId,
        numberProductsPurchased: subscriptionsToPurchase.length,
      };

    const prescriptionProductOrderCheckResult =
      await canAllSubscriptionProductsBePurchased(
        subscriptionsToPurchase,
        user
      );

    if (!prescriptionProductOrderCheckResult.canBePurchased) {
      throw new Error('Prescriptions that are not refillable are in cart');
    }

    const { totalPrice, subscriptionPriceDetails } =
      await GetSubscriptionProductPriceDetails(
        user,
        subscriptionsToPurchase,
        promoCode,
        conciergeInCart
      );

    await LoggerUtil.logInfo(
      'purchase_medical_subscription_start',
      'StripePurchaseSystem > BuyMedicalSubscription',
      {
        userId: user.id,
        subscriptionsToPurchase,
        totalPrice,
        subscriptionPriceDetails,
      }
    );

    let paymentIntentId = null;
    if (totalPrice > 0) {
      paymentIntentId = await this.captureCustomerMedicalPayment(
        paymentMethodId,
        paymentProvider,
        user,
        totalPrice,
        address
      );
    }

    await postSubscriptionPurchaseEvent(user, subscriptionPriceDetails);

    await PostPurchaseProcessSubscription(
      user,
      subscriptionsToPurchase,
      order,
      paymentIntentId,
      paymentMethodId,
      paymentProvider,
      address
    );
    await calculateNextRefillDatesFromToday(
      prescriptionProductOrderCheckResult.validPrescriptions
    );

    return {
      paymentId: paymentIntentId ? paymentIntentId : undefined,
      numberProductsPurchased: subscriptionsToPurchase.length,
    };
  }

  async BuyOTCSubscription(
    paymentMethodId: string,
    paymentProvider: PaymentProviders,
    user: User,
    address: Address,
    subscriptionsToPurchase: CartSubscriptionProducts[],
    order: Order,
    cart: Cart,
    promoCode: PromoCodes | null,
    conciergePriceInCart: number | null
  ): Promise<purchaseReturnType> {
    if (!user.stripeId) {
      throw new Error(
        'Please setup the user in Stripe before retrieving payment methods'
      );
    }

    if (subscriptionsToPurchase.length < 1)
      return {
        paymentId: user.stripeId,
        numberProductsPurchased: subscriptionsToPurchase.length,
      };

    const { totalPrice, subscriptionPriceDetails } =
      await GetSubscriptionProductPriceDetails(
        user,
        subscriptionsToPurchase,
        promoCode,
        conciergePriceInCart && conciergePriceInCart > 0 ? true : false
      );

    await LoggerUtil.logInfo(
      'purchase_otc_subscription_start',
      'StripePurchaseSystem > BuyOTCSubscription',
      {
        userId: user.id,
        subscriptionsToPurchase,
        totalPrice,
        subscriptionPriceDetails,
      }
    );

    let paymentIntentId = null;
    if (totalPrice > 0) {
      paymentIntentId = await this.captureCustomerPayment(
        paymentMethodId,
        paymentProvider,
        user,
        totalPrice
      );
    }

    await postSubscriptionPurchaseEvent(user, subscriptionPriceDetails);

    await PostPurchaseProcessSubscription(
      user,
      subscriptionsToPurchase,
      order,
      paymentIntentId,
      paymentMethodId,
      paymentProvider,
      address
    );

    return {
      paymentId: paymentIntentId ? paymentIntentId : undefined,
      numberProductsPurchased: subscriptionsToPurchase.length,
    };
  }

  async BuyOTC(
    paymentMethodId: string,
    paymentProvider: PaymentProviders,
    user: User,
    address: Address,
    productsToPurchase: CartProducts[],
    order: Order,
    cart: Cart,
    promoCode: PromoCodes | null,
    conciergeInCart: boolean
  ): Promise<purchaseReturnType> {
    if (!user.stripeId) {
      throw new Error(
        'Please setup the user in Stripe before retrieving payment methods'
      );
    }

    if (productsToPurchase.length < 1)
      return {
        paymentId: user.stripeId,
        numberProductsPurchased: productsToPurchase.length,
      };

    const { totalPrice, productPriceDetails } = await GetProductPriceDetails(
      user,
      productsToPurchase,
      promoCode,
      conciergeInCart
    );

    let paymentIntentId = null;
    if (totalPrice > 0) {
      paymentIntentId = await this.captureCustomerPayment(
        paymentMethodId,
        paymentProvider,
        user,
        totalPrice
      );
    }

    await postPurchaseEvent(user, productPriceDetails);

    // Post Process
    await PostPurchaseProducts(productsToPurchase, order, paymentIntentId);

    return {
      paymentId: paymentIntentId ? paymentIntentId : undefined,
      numberProductsPurchased: productsToPurchase.length,
    };
  }

  async BuyMedical(
    paymentMethodId: string,
    paymentProvider: PaymentProviders,
    user: User,
    address: Address,
    productsToPurchase: CartProducts[],
    order: Order,
    cart: Cart,
    promoCode: PromoCodes | null,
    conciergeInCart: boolean
  ): Promise<purchaseReturnType> {
    if (!user.stripeId) {
      throw new Error(
        'Please setup the user in Stripe before retrieving payment methods'
      );
    }

    if (productsToPurchase.length < 1)
      return {
        paymentId: user.stripeId,
        numberProductsPurchased: productsToPurchase.length,
      };

    const prescriptionProductOrderCheckResult = await canAllProductsBePurchased(
      productsToPurchase,
      user
    );

    if (!prescriptionProductOrderCheckResult.canBePurchased) {
      throw new Error('Prescriptions that are not refillable are in cart');
    }

    const { totalPrice, productPriceDetails } = await GetProductPriceDetails(
      user,
      productsToPurchase,
      promoCode,
      conciergeInCart
    );

    await LoggerUtil.logInfo(
      'purchase_medical_start',
      'StripePurchaseSystem > BuyMedical',
      {
        userId: user.id,
        productsToPurchase,
        totalPrice,
        productPriceDetails,
      }
    );

    let paymentIntentId = null;
    if (totalPrice > 0) {
      paymentIntentId = await this.captureCustomerMedicalPayment(
        paymentMethodId,
        paymentProvider,
        user,
        totalPrice,
        address
      );
    }

    await postPurchaseEvent(user, productPriceDetails);

    // Post Process
    await PostPurchaseProducts(productsToPurchase, order, paymentIntentId);
    await calculateNextRefillDatesFromToday(
      prescriptionProductOrderCheckResult.validPrescriptions
    );

    return {
      paymentId: paymentIntentId ? paymentIntentId : undefined,
      numberProductsPurchased: productsToPurchase.length,
    };
  }
}

export const createOrUpdateStripeCustomer = async (user: User) => {
  // This information is required before a payment can be created
  if (!user.email) {
    throw new Error('Please setup user profile before adding payment methods.');
  }

  const params: Stripe.CustomerCreateParams = {
    email: user.email,
    ...(user.firstName &&
      user.lastName && { name: `${user.firstName} ${user.lastName}` }),
  };

  // Add Phone Number if Exists
  if (user.phoneNumber) {
    params.phone = user.phoneNumber;
  }

  // Add Address if exists
  const address =
    user.addresses.find((address) => address.default) ?? user.addresses?.[0];

  if (address) {
    params.address = {
      line1: address.address1,
      line2: address.address2 ?? '',
      city: address.city,
      state: address.state,
      postal_code: address.zip,
      country: 'US',
    };
  }

  let stripeResponse = null;

  if (user.stripeId) {
    stripeResponse = await stripe.customers.update(user.stripeId, params);
  } else {
    stripeResponse = await stripe.customers.create(params);
  }

  return stripeResponse;
};

export const getPaymentMethods = async (user: User) => {
  const stripeId = user.stripeId;

  if (!stripeId) {
    throw new Error(
      'Please setup the user in Stripe before retrieving payment methods'
    );
  }

  const paymentMethods = await stripe.paymentMethods.list({
    customer: stripeId,
    type: 'card',
  });

  return paymentMethods.data.map((paymentMethod) => ({
    id: paymentMethod.id,
    brand: paymentMethod.card?.brand ?? '',
    expMonth: paymentMethod.card?.exp_month ?? '',
    expYear: paymentMethod.card?.exp_year ?? '',
    last4: paymentMethod.card?.last4 ?? '',
  })) as IPaymentMethod[];
};

export const getPaymentMethodById = async (paymentMethodId: string) => {
  const stripePaymentMethod = await stripe.paymentMethods.retrieve(
    paymentMethodId
  );
  const paymentMethodToReturn: IPaymentMethod = {
    id: stripePaymentMethod.id,
    brand: stripePaymentMethod.card?.brand ?? '',
    expMonth: stripePaymentMethod.card?.exp_month ?? '',
    expYear: stripePaymentMethod.card?.exp_year ?? '',
    last4: stripePaymentMethod.card?.last4 ?? '',
    default: false,
  };

  return paymentMethodToReturn;
};

export const setDefaultPaymentMethod = async (
  stripeId: string,
  paymentMethodId: string
) => {
  const updatedCustomer = await stripe.customers.update(stripeId, {
    invoice_settings: {
      default_payment_method: paymentMethodId,
    },
  });

  return updatedCustomer.invoice_settings?.default_payment_method;
};

export const detachPaymentMethod = async (paymentMethodId: string) => {
  const updatedPaymentMethod = await stripe.paymentMethods.detach(
    paymentMethodId
  );

  return updatedPaymentMethod.id;
};

export const attachPaymentMethod = async (
  paymentMethodId: string,
  user: User
) => {
  if (!user.stripeId) {
    throw new Error(
      'Please setup the user in Stripe before adding a payment method'
    );
  }

  const attachedPaymentMethod = await stripe.paymentMethods.attach(
    paymentMethodId,
    {
      customer: user.stripeId,
    }
  );

  return attachedPaymentMethod;
};

export const setupIntent = async (stripeId: string) => {
  const intent = await stripe.setupIntents.create({
    customer: stripeId,
    automatic_payment_methods: { enabled: true },
  });

  return intent.client_secret;
};

export const getChargeHistory = async (stripeId: string) => {
  const params: Stripe.ChargeListParams = {
    customer: stripeId,
    limit: 10,
  };

  const charges = await stripe.charges.list(params);

  return charges.data.map((charge) => ({
    id: charge.id,
    amount: charge.amount,
    created: charge.created,
    currency: charge.currency,
    description: charge.description,
    status: charge.status,
    receipt: charge.receipt_url,
  })) as IBillingCharge[];
};

export const createPaymentIntent = async (
  stripeId: string,
  paymentMethodId: string,
  amount: number
) => {
  const intent = await stripe.paymentIntents.create({
    customer: stripeId,
    amount,
    currency: 'usd',
    payment_method: paymentMethodId,
    automatic_payment_methods: { enabled: true, allow_redirects: 'never' },
    on_behalf_of: 'acct_1OP6ujRQP81UlHhG',
    transfer_data: {
      destination: 'acct_1OP6ujRQP81UlHhG',
    },
  });

  await LoggerUtil.logInfo(
    'payment_intent_created',
    'StripeUtils > createPaymentIntent',
    {
      stripeId,
      paymentMethodId,
      amount,
    }
  );

  return intent.status;
};

export const createSubscription = async (
  stripeId: string,
  paymentMethodId: string,
  priceId: string,
  ip: string,
  userAgent: any
) => {
  const subscription = await stripe.subscriptions.create({
    customer: stripeId,
    items: [
      {
        price: 'price_1O08tEIc4CxnPcF9sCg3XHyj',
      },
    ],
    payment_behavior: 'default_incomplete',
    payment_settings: { save_default_payment_method: 'on_subscription' },
    expand: ['latest_invoice.payment_intent'],
  });

  const latestInvoice = subscription?.latest_invoice;

  if (!latestInvoice || typeof latestInvoice === 'string') {
    throw new Error('Failed to create subscription');
  }

  const paymentIntent = latestInvoice.payment_intent;

  if (!paymentIntent || typeof paymentIntent === 'string') {
    throw new Error('Failed to create subscription');
  }

  // Confirm intent with collected payment method
  const { status, client_secret } = await stripe.paymentIntents.confirm(
    paymentIntent.id,
    {
      payment_method: paymentMethodId,
      mandate_data: {
        customer_acceptance: {
          type: 'online',
          online: {
            ip_address: ip,
            user_agent: userAgent,
          },
        },
      },
    }
  );

  return { status, client_secret };
};

export const confirmConsultationPayment = async (paymentIntentId: string) => {
  const intent = await stripe.paymentIntents.confirm(paymentIntentId);

  return intent.status;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/payments/types.ts

import Stripe from 'stripe';

export interface IPaymentMethod {
  id: string;
  brand: string;
  expMonth: string | number;
  expYear: string | number;
  last4: string;
  default: boolean;
}

export interface IBillingCharge {
  id: string;
  amount: number;
  created: number;
  currency: string;
  description: string | null;
  status: Stripe.Charge.Status;
  receipt: string | null;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/payments/purchaseSystem.ts

import { prismaEcomClient } from '@/app/shared/models/extensions/ecommerce';
import { prisma } from '@clients/mongo/prismaClient';
import {
  Address,
  Cart,
  CartProducts,
  CartSubscriptionProducts,
  Order,
  PaymentProviders,
  Product,
  ProductCategories,
  PromoCodes,
  SubscriptionFrequencyUnits,
  SubscriptionProduct,
  User,
  UserPrescriptions,
} from '@prisma/client';

import { reconcileUserPrescriptionsWithDosespotPrescriptions } from '../clients/dosespot/dosespotUtils';
import LoggerUtil from '../clients/logging/apiUtilLogger';
import { isUserConciergeMember } from '../ecommerce/conciergeUtils';

// Function to get the purchase system currently in use
// Get Demo Purchase System
// export function GetPurchaseSystem(): PurchaseSystem {
//   return new PurchaseSystem();
// }
// Get Stripe Purchase System

export async function GetPurchaseSystem(): Promise<PurchaseSystem> {
  const { StripePurchaseSystem } = await import('./stripe-utils');
  return new StripePurchaseSystem();
}

////////////////////////////////////////////////////////
//////////// PROMO CODE IMPLEMENTATION
function getPromoCodePrice(promoCode: PromoCodes, price: number): number {
  // Arbitrary decision... Apply Amount off Before Percent off
  price = price - promoCode.amountOff;
  price = price * (1 - promoCode.percentOff);

  return price;
}

function getPromoCodePriceSubscriptionProduct(
  promoCode: PromoCodes | null,
  subscriptionProduct: SubscriptionProduct
): number {
  if (!promoCode) {
    return subscriptionProduct.price;
  }

  if (
    promoCode.active &&
    (promoCode.worksForAllProducts ||
      promoCode.associatedSubscriptionIds.includes(subscriptionProduct.id))
  ) {
    return getPromoCodePrice(promoCode, subscriptionProduct.price);
  }

  return subscriptionProduct.price;
}

function getPromoCodePriceProduct(
  promoCode: PromoCodes | null,
  product: Product
): number {
  if (!promoCode) {
    return product.price;
  }

  if (
    promoCode.active &&
    (promoCode.worksForAllProducts ||
      promoCode.associatedProductIds.includes(product.id))
  ) {
    return getPromoCodePrice(promoCode, product.price);
  }

  return product.price;
}

////////////////////////////////////////////////////////
//////////// SUBSCRIPTION UTILITIES - TODO: SHOULD MOVE TO OWN FILE
export async function GetSumSubscriptionPrices(
  subscriptionsToPurchase: CartSubscriptionProducts[],
  promoCodeInfo: PromoCodes | null
): Promise<number> {
  let totalSubscriptionPrice = 0;
  for (const subscriptionToPurchase of subscriptionsToPurchase) {
    const subscription = await prisma.subscriptionProduct.findUnique({
      where: {
        id: subscriptionToPurchase.subscriptionProductId,
      },
    });

    if (!subscription) continue;

    const priceAfterPromo = getPromoCodePriceSubscriptionProduct(
      promoCodeInfo,
      subscription
    );

    // Check if the subscription has a trial. If it doesn't, then charge them now. Otherwise, let it ride
    if (subscription?.trialPeriodLength) {
      if (subscription.trialPeriodLength <= 0) {
        totalSubscriptionPrice +=
          priceAfterPromo * subscriptionToPurchase.quantity;
      }
    } else {
      totalSubscriptionPrice +=
        priceAfterPromo * subscriptionToPurchase.quantity;
    }
  }

  return Math.round(totalSubscriptionPrice);
}

export async function GetSubscriptionProductPriceDetails(
  user: User,
  subscriptionsToPurchase: CartSubscriptionProducts[],
  promoCodeInfo: PromoCodes | null,
  conciergeInCart: boolean
) {
  const userHasConcierge =
    conciergeInCart || (await isUserConciergeMember(user));

  const conciergeDiscountAmt = Number(process.env.CONCIERGE_DISCOUNT_AMOUNT)
    ? Number(process.env.CONCIERGE_DISCOUNT_AMOUNT)
    : 0.2;

  let totalPrice = 0;
  const subscriptionPriceDetails = [];

  for (const subscriptionToPurchase of subscriptionsToPurchase) {
    const subscription = await prisma.subscriptionProduct.findUnique({
      where: {
        id: subscriptionToPurchase.subscriptionProductId,
      },
    });

    if (!subscription) continue;

    const priceAfterPromo = getPromoCodePriceSubscriptionProduct(
      promoCodeInfo,
      subscription
    );

    const shouldApplyConcierge =
      userHasConcierge && subscription.category !== ProductCategories.CONCIERGE;

    const priceAfterConcierge = shouldApplyConcierge
      ? (1 - conciergeDiscountAmt) * priceAfterPromo
      : priceAfterPromo;

    const subscriptionOnTrial =
      !!subscription?.trialPeriodLength && subscription.trialPeriodLength > 0;

    const subscriptionData = {
      productId: subscription.id,
      unitPrice: subscription.price,
      priceAfterPromo,
      priceAfterConcierge,
      subscriptionDetails: subscription,
      quantity: subscriptionToPurchase.quantity,
      amountDueToday: 0,
      subscriptionOnTrial,
    };

    // Check if the subscription has a trial. If it doesn't, then charge them now. Otherwise, let it ride

    if (subscriptionOnTrial) {
      subscriptionData.amountDueToday = 0;
    } else {
      totalPrice += priceAfterConcierge * subscriptionToPurchase.quantity;
      subscriptionData.amountDueToday =
        priceAfterConcierge * subscriptionToPurchase.quantity;
    }

    subscriptionPriceDetails.push(subscriptionData);
  }

  return { totalPrice: Math.round(totalPrice), subscriptionPriceDetails };
}

interface initialTrialRenewalData {
  trialPeriodEndDate: Date | undefined;
  nextRenewalDate: Date;
}
export function getTimeOffsetFromCurrentDate(
  length: number,
  lengthUnit: SubscriptionFrequencyUnits
): Date {
  const today = new Date();
  return getTimeOffsetFromDate(length, lengthUnit, today);
}

export function getTimeOffsetFromDate(
  length: number,
  lengthUnit: SubscriptionFrequencyUnits,
  dateToOffset: Date
): Date {
  // we should create a seperate date object if we are returning the date,
  // as the expected result would be a new date object, not a mutation of the existing date object
  const newDate = new Date(dateToOffset);

  switch (lengthUnit) {
    case SubscriptionFrequencyUnits.DAY:
      newDate.setDate(dateToOffset.getDate() + length);
      break;
    case SubscriptionFrequencyUnits.MONTH:
      newDate.setMonth(dateToOffset.getMonth() + length);
      break;
    case SubscriptionFrequencyUnits.YEAR: // year is the default, adjust if this changes
    default:
      newDate.setFullYear(dateToOffset.getFullYear() + length);
      break;
  }

  return newDate;
}

function getInitialTrialAndRenewalDates(
  promoTrialPeriod: number,
  promoTrialUnit: SubscriptionFrequencyUnits,
  productTrialPeriod: number | null,
  productTrialPeriodUnit: SubscriptionFrequencyUnits | null,
  frequency: number,
  frequencyUnit: SubscriptionFrequencyUnits
): initialTrialRenewalData {
  let trialPeriodEndDate: Date | undefined = undefined;

  // offset based on promo trial window
  if (promoTrialPeriod && promoTrialUnit) {
    trialPeriodEndDate = getTimeOffsetFromDate(
      promoTrialPeriod,
      promoTrialUnit,
      trialPeriodEndDate ?? new Date()
    );
  }

  // offset based on product trial window
  if (productTrialPeriod && productTrialPeriodUnit) {
    trialPeriodEndDate = getTimeOffsetFromDate(
      productTrialPeriod,
      productTrialPeriodUnit,
      trialPeriodEndDate ?? new Date()
    );
  }

  // get offset based on trial period and frequency
  const nextRenewalDate = getTimeOffsetFromDate(
    frequency,
    frequencyUnit,
    trialPeriodEndDate ?? new Date()
  );

  // set dates based on start of day
  trialPeriodEndDate?.setHours(0, 0, 0, 0);
  nextRenewalDate.setHours(0, 0, 0, 0);

  return {
    nextRenewalDate,
    trialPeriodEndDate,
  };
}

export async function PostPurchaseProcessSubscription(
  user: User,
  subscriptionsToPurchase: CartSubscriptionProducts[],
  order: Order,
  externalPaymentId: string | null,
  paymentMethodId: string,
  paymentProvider: PaymentProviders,
  address: Address
) {
  // Remove the subscriptions from the cart and put them in the order if successful
  // Write a for loop that removes the cart and adds the order to the cart subscription products
  // It does this now by updating the cartSubscriptionItems to remove their cartID and updates their orderID
  for (const purchasedSubscription of subscriptionsToPurchase) {
    await prisma.cartSubscriptionProducts.update({
      where: {
        id: purchasedSubscription.id,
      },
      data: {
        cartId: null,
        orderId: order.id,
        externalPaymentId: externalPaymentId,
      },
    });

    const subscriptionData = await prisma.subscriptionProduct.findUnique({
      where: {
        id: purchasedSubscription.subscriptionProductId,
      },
    });

    await LoggerUtil.logInfo(
      'found_subscription_product',
      'PostPurchaseProcessSubscription',
      {
        userId: user.id,
        orderId: order.id,
        purchasedSubscription,
        subscriptionData,
        order,
      }
    );

    // Create User Subscriptions
    if (subscriptionData) {
      const pc = order.promoCodeCode
        ? await prismaEcomClient.promoCodes.findUnique({
            where: { code: order.promoCodeCode },
          })
        : null;

      const promo =
        pc &&
        pc.associatedSubscriptionIds.includes(
          purchasedSubscription.subscriptionProductId
        )
          ? pc
          : null;

      const initialRenewalAndTrialDate = getInitialTrialAndRenewalDates(
        promo?.subscriptionTrialTime ?? 0,
        promo?.subscriptionTrialTimeUnit ?? SubscriptionFrequencyUnits.DAY,
        subscriptionData.trialPeriodLength,
        subscriptionData.trialPeriodUnit,
        subscriptionData.frequency,
        subscriptionData.frequencyUnit
      );

      address.name = `Order ${order.id} Shipping Address`;
      address.default = false;

      const userSubscription = await prisma.userSubscription.create({
        data: {
          subscriptionProductId: subscriptionData.id,
          price: subscriptionData.price,
          frequency: subscriptionData.frequency,
          frequencyUnit: subscriptionData.frequencyUnit,
          nextRenewalDate: initialRenewalAndTrialDate.nextRenewalDate,
          trialEndDate: initialRenewalAndTrialDate.trialPeriodEndDate,
          endDate: promo?.disableSubscriptionAutoRenew
            ? initialRenewalAndTrialDate.nextRenewalDate
            : undefined,
          userId: user.id,
          orderId: order.id,
          paymentMethodId: paymentMethodId,
          paymentprovider: paymentProvider,
          shippingAddress: address,
        },
      });

      await LoggerUtil.logInfo(
        'created_user_subscription',
        'PostPurchaseProcessSubscription',
        {
          userId: user.id,
          orderId: order.id,
          purchasedSubscription,
          userSubscription,
          promoCode: order.promoCodeCode,
          promo,
          initialRenewalAndTrialDate,
        }
      );
    }
  }
}

////////////////////////////////////////////////////////
//////////// PRODUCT UTILITIES - TODO: SHOULD MOVE TO OWN FILE
export async function GetProductPriceDetails(
  user: User,
  productsToPurchase: CartProducts[],
  promoCodeInfo: PromoCodes | null,
  conciergeInCart: boolean
) {
  const userHasConcierge =
    conciergeInCart || (await isUserConciergeMember(user));

  const conciergeDiscountAmt = Number(process.env.CONCIERGE_DISCOUNT_AMOUNT)
    ? Number(process.env.CONCIERGE_DISCOUNT_AMOUNT)
    : 0.2;

  let totalPrice = 0;
  const productPriceDetails = [];

  for (const productToPurchase of productsToPurchase) {
    const product = await prisma.product.findUnique({
      where: {
        id: productToPurchase.productId,
      },
    });

    if (!product) continue;

    const priceAfterPromo = getPromoCodePriceProduct(promoCodeInfo, product);
    const priceAfterConcierge = userHasConcierge
      ? (1 - conciergeDiscountAmt) * priceAfterPromo
      : priceAfterPromo;

    productPriceDetails.push({
      productId: product.id,
      unitPrice: product.price,
      priceAfterPromo,
      priceAfterConcierge,
      productDetails: product,
      quantity: productToPurchase.quantity,
    });

    totalPrice += priceAfterConcierge * productToPurchase.quantity;
  }

  return { totalPrice: Math.round(totalPrice), productPriceDetails };
}

export async function GetSumProductPrices(
  productsToPurchase: CartProducts[],
  promoCodeInfo: PromoCodes | null
): Promise<number> {
  let totalProductPrice = 0;
  for (const productToPurchase of productsToPurchase) {
    const product = await prisma.product.findUnique({
      where: {
        id: productToPurchase.productId,
      },
    });

    if (!product) continue;

    const priceAfterPromo = getPromoCodePriceProduct(promoCodeInfo, product);

    totalProductPrice += priceAfterPromo * productToPurchase.quantity;
  }

  return Math.round(totalProductPrice);
}

export async function PostPurchaseProducts(
  purchasedProducts: CartProducts[],
  order: Order,
  externalPaymentId?: string | null
) {
  // Remove the subscriptions from the cart and put them in the order if successful
  // Write a for loop that removes the cart and adds the order to the cart subscription products
  // It does this now by updating the cartSubscriptionItems to remove their cartID and updates their orderID
  for (const purchasedProduct of purchasedProducts) {
    const cartProduct = await prisma.cartProducts.update({
      where: {
        id: purchasedProduct.id,
      },
      data: {
        cartId: null,
        orderId: order.id,
        externalPaymentId: externalPaymentId,
      },
    });

    await LoggerUtil.logInfo('purchase_otc_product', 'PostPurchaseProducts', {
      userId: order.userId,
      orderId: order.id,
      purchasedProduct,
      cartProduct,
    });
  }
}

////////////////////////////////////////////////////
/////// Check if rx product can be purchased
function arePrescriptionRefillsRemaining(
  userPrescription: UserPrescriptions
): boolean {
  if (
    userPrescription.maxRefills &&
    userPrescription.refillDates.length < userPrescription.maxRefills
  ) {
    return true;
  } else if (!userPrescription.maxRefills) {
    return true;
  } else {
    return false;
  }
}

function checkIfPrescriptionOrderable(
  userPrescription: UserPrescriptions
): boolean {
  if (
    userPrescription.nextAvailableRefillDate &&
    userPrescription.nextAvailableRefillDate <= new Date()
  ) {
    return arePrescriptionRefillsRemaining(userPrescription);
  } else if (userPrescription.nextAvailableRefillDate) {
    return false; // Prescription may not be refilled until refill date comes up
  }

  return arePrescriptionRefillsRemaining(userPrescription);
}

interface productPurchaseCheckReturn {
  canBePurchased: boolean;
  validPrescriptions: UserPrescriptions[];
}

export async function canAllProductsBePurchased(
  productsToPurchase: CartProducts[],
  user: User
): Promise<productPurchaseCheckReturn> {
  const userPrescriptions =
    await reconcileUserPrescriptionsWithDosespotPrescriptions(user);

  await LoggerUtil.logInfo(
    'reconcile_prescriptions_with_dosespot',
    'canAllProductsBePurchased',
    {
      userId: user.id,
      productsToPurchase,
      userPrescriptions: userPrescriptions.map((userScript) => {
        return {
          productId: userScript.productId,
          userPrescriptionid: userScript.id,
          dosespotRxId: userScript.dosespotRxId,
        };
      }),
    }
  );

  const validUserPrescriptions: UserPrescriptions[] = [];
  for (let i = 0; i < productsToPurchase.length; i++) {
    const product = await prisma.product.findUnique({
      where: {
        id: productsToPurchase[i].productId,
      },
    });

    // Only react if product is a prescription
    if (
      product &&
      product.category === ProductCategories.PRESCRIPTION_MEDICATION
    ) {
      let isPrescriptionOrderable = false;
      for (let j = 0; j < userPrescriptions.length; j++) {
        if (userPrescriptions[j].productId === product.id) {
          // Keep checking if prescription is orderable. We only need one to return true to place an order
          isPrescriptionOrderable = checkIfPrescriptionOrderable(
            userPrescriptions[j]
          );

          if (!isPrescriptionOrderable) {
            await LoggerUtil.logError(
              'prescription_not_orderable',
              'canAllProductsBePurchased',
              new Error('Prescription is not orderable.'),
              {
                userId: user.id,
                productsToPurchase,
                userPrescription: userPrescriptions[j],
              }
            );
            return {
              canBePurchased: false,
              validPrescriptions: validUserPrescriptions,
            };
          }

          validUserPrescriptions.push(userPrescriptions[j]);
        }
      }
    }
  }

  await LoggerUtil.logInfo(
    'validated_user_prescriptions',
    'canAllProductsBePurchased',
    {
      userId: user.id,
      productsToPurchase,
      validUserPrescriptions: validUserPrescriptions.map((userScript) => {
        return {
          productId: userScript.productId,
          userPrescriptionid: userScript.id,
          dosespotRxId: userScript.dosespotRxId,
        };
      }),
    }
  );

  return {
    canBePurchased: true,
    validPrescriptions: validUserPrescriptions,
  };
}

export async function canAllSubscriptionProductsBePurchased(
  subscriptionProductsToPurchase: CartSubscriptionProducts[],
  user: User
): Promise<productPurchaseCheckReturn> {
  const userPrescriptions =
    await reconcileUserPrescriptionsWithDosespotPrescriptions(user);

  await LoggerUtil.logInfo(
    'reconcile_sub_prescriptions_with_dosespot',
    'canAllSubscriptionProductsBePurchased',
    {
      userId: user.id,
      subscriptionProductsToPurchase,
      userPrescriptions: userPrescriptions.map((userScript) => {
        return {
          subcriptionProductId: userScript.subscriptionProductId,
          userPrescriptionid: userScript.id,
          dosespotRxId: userScript.dosespotRxId,
        };
      }),
    }
  );

  const validUserPrescriptions: UserPrescriptions[] = [];

  for (let i = 0; i < subscriptionProductsToPurchase.length; i++) {
    const subscriptionProduct = await prisma.subscriptionProduct.findUnique({
      where: {
        id: subscriptionProductsToPurchase[i].subscriptionProductId,
      },
    });

    // Only react if product is a prescription

    if (
      subscriptionProduct &&
      subscriptionProduct.category === ProductCategories.PRESCRIPTION_MEDICATION
    ) {
      let isPrescriptionOrderable = false;
      for (let j = 0; j < userPrescriptions.length; j++) {
        if (
          userPrescriptions[j].subscriptionProductId === subscriptionProduct.id
        ) {
          isPrescriptionOrderable = checkIfPrescriptionOrderable(
            userPrescriptions[j]
          );
          if (!isPrescriptionOrderable) {
            await LoggerUtil.logError(
              'sub_prescription_not_orderable',
              'canAllSubscriptionProductsBePurchased',
              new Error('Prescription sub is not orderable.'),
              {
                userId: user.id,
                subscriptionProduct,
                userPrescription: userPrescriptions[j],
              }
            );
            return {
              canBePurchased: false,
              validPrescriptions: validUserPrescriptions,
            };
          }

          validUserPrescriptions.push(userPrescriptions[j]);
        }
      }
    }
  }

  await LoggerUtil.logInfo(
    'validated_user_sub_prescriptions',
    'canAllSubscriptionProductsBePurchased',
    {
      userId: user.id,
      subscriptionProductsToPurchase,
      validUserPrescriptions: validUserPrescriptions.map((userScript) => {
        return {
          subscriptionProductId: userScript.subscriptionProductId,
          userPrescriptionid: userScript.id,
          dosespotRxId: userScript.dosespotRxId,
        };
      }),
    }
  );

  return {
    canBePurchased: true,
    validPrescriptions: validUserPrescriptions,
  };
}

export async function calculateNextRefillDatesFromToday(
  userPrescriptions: UserPrescriptions[]
) {
  // TODO: Return Prescriptions from cart all products be purchased then pass it to this

  // This will calculate next renewal date
  for (const prescription of userPrescriptions) {
    const nextRefillDate = new Date();
    nextRefillDate.setDate(nextRefillDate.getDate() + prescription.daysSupply);

    await prisma.userPrescriptions.update({
      where: {
        id: prescription.id,
      },
      data: {
        nextAvailableRefillDate: nextRefillDate,
      },
    });

    await LoggerUtil.logInfo(
      'calculate_refill_date',
      'calculateNextRefillDatesFromToday',
      {
        userId: prescription.userId,
        prescriptionId: prescription.id,
        nextRefillDate,
      }
    );
  }
}

export interface purchaseReturnType {
  paymentId?: string;
  numberProductsPurchased: number;
}

////////////////////////////////////////////////////
/////// DEFINE THE PURCHASE SYSTEM OBJECT
export class PurchaseSystem {
  async captureCustomerPayment(
    paymentMethodId: string,
    paymentProvider: PaymentProviders,
    user: User,
    amount: number
  ): Promise<string> {
    console.log('Purchased the product!');

    return 'successfulPurchase';
  }

  async captureCustomerMedicalPayment(
    paymentMethodId: string,
    paymentProvider: PaymentProviders,
    user: User,
    amount: number,
    address: Address
  ): Promise<string> {
    console.log('Purchased the product!');

    return 'successfulPurchase';
  }

  async BuyOTCSubscription(
    paymentMethodId: string,
    paymentProvider: PaymentProviders,
    user: User,
    address: Address,
    subscriptionsToPurchase: CartSubscriptionProducts[],
    order: Order,
    cart: Cart,
    promoCode: PromoCodes | null,
    conciergePriceInCart: number | null
  ): Promise<purchaseReturnType> {
    // If there are no products in this category skip checks.
    if (subscriptionsToPurchase.length < 1)
      return { numberProductsPurchased: subscriptionsToPurchase.length };

    // Sum it all up and create an order object
    const totalSubscriptionPrice = await GetSumSubscriptionPrices(
      subscriptionsToPurchase,
      promoCode
    );

    // Purchase the Subscriptions
    await LoggerUtil.logInfo(
      'otc_prescription_purchase',
      'PurchaseSystem.BuyOTCSubscription',
      {
        userId: user.id,
        orderId: order.id,
        subscriptionsToPurchase,
        promoCode,
        totalSubscriptionPrice,
      }
    );

    await PostPurchaseProcessSubscription(
      user,
      subscriptionsToPurchase,
      order,
      null,
      paymentMethodId,
      paymentProvider,
      address
    );

    return { numberProductsPurchased: subscriptionsToPurchase.length };
  }

  async BuyMedicalSubscription(
    paymentMethodId: string,
    paymentProvider: PaymentProviders,
    user: User,
    address: Address,
    subscriptionsToPurchase: CartSubscriptionProducts[],
    order: Order,
    cart: Cart,
    promoCode: PromoCodes | null,
    conciergeInCart: boolean
  ): Promise<purchaseReturnType> {
    // If there are no products in this category skip checks.
    if (subscriptionsToPurchase.length < 1)
      return { numberProductsPurchased: subscriptionsToPurchase.length };

    // Sum it all up and create an order object
    const totalSubscriptionPrice = await GetSumSubscriptionPrices(
      subscriptionsToPurchase,
      promoCode
    );

    const prescriptionProductOrderCheckResult =
      await canAllSubscriptionProductsBePurchased(
        subscriptionsToPurchase,
        user
      );

    await LoggerUtil.logInfo(
      'medical_subscription_purchase',
      'PurchaseSystem.BuyMedicalSubscription',
      {
        userId: user.id,
        orderId: order.id,
        subscriptionsToPurchase,
        promoCode,
        totalSubscriptionPrice,
        prescriptionProductOrderCheckResult,
      }
    );

    if (!prescriptionProductOrderCheckResult.canBePurchased) {
      throw new Error('Prescriptions that are not refillable are in cart');
    }

    // Purchase the subscription
    await PostPurchaseProcessSubscription(
      user,
      subscriptionsToPurchase,
      order,
      null,
      paymentMethodId,
      paymentProvider,
      address
    );
    await calculateNextRefillDatesFromToday(
      prescriptionProductOrderCheckResult.validPrescriptions
    );

    return { numberProductsPurchased: subscriptionsToPurchase.length };
  }

  async BuyOTC(
    paymentMethodId: string,
    paymentProvider: PaymentProviders,
    user: User,
    address: Address,
    productsToPurchase: CartProducts[],
    order: Order,
    cart: Cart,
    promoCode: PromoCodes | null,
    conciergeInCart: boolean
  ): Promise<purchaseReturnType> {
    // If there are no products in this category skip checks.
    if (productsToPurchase.length < 1)
      return { numberProductsPurchased: productsToPurchase.length };

    // Get Sum of Values
    const totalProductPrice = await GetSumProductPrices(
      productsToPurchase,
      promoCode
    );

    // Purchase through main Cortina
    await LoggerUtil.logInfo('purchase_otc', 'PurchaseSystem.BuyOTC', {
      userId: user.id,
      orderId: order.id,
      totalProductPrice,
    });

    // Post Process
    PostPurchaseProducts(productsToPurchase, order);

    return { numberProductsPurchased: productsToPurchase.length };
  }

  async BuyMedical(
    paymentMethodId: string,
    paymentProvider: PaymentProviders,
    user: User,
    address: Address,
    productsToPurchase: CartProducts[],
    order: Order,
    cart: Cart,
    promoCode: PromoCodes | null,
    conciergeInCart: boolean
  ): Promise<purchaseReturnType> {
    // If there are no products in this category skip checks.
    if (productsToPurchase.length < 1)
      return { numberProductsPurchased: productsToPurchase.length };

    // Get Sum of Values
    const totalProductPrice = await GetSumProductPrices(
      productsToPurchase,
      promoCode
    );

    const prescriptionProductOrderCheckResult = await canAllProductsBePurchased(
      productsToPurchase,
      user
    );

    await LoggerUtil.logInfo('purchase_medical', 'PurchaseSystem.BuyMedical', {
      userId: user.id,
      orderId: order.id,
      totalProductPrice,
      prescriptionProductOrderCheckResult,
    });

    if (!prescriptionProductOrderCheckResult.canBePurchased) {
      throw new Error('Prescriptions that are not refillable are in cart');
    }

    // Post Process
    await PostPurchaseProducts(productsToPurchase, order);
    await calculateNextRefillDatesFromToday(
      prescriptionProductOrderCheckResult.validPrescriptions
    );

    return { numberProductsPurchased: productsToPurchase.length };
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/forms/export-utils.ts

import { prismaFormClient } from '../clients/mongo/prismaClient';
import { FORM_EXPORT_INCLUDE } from './export-import-types';

export const exportForm = async (formId: string) => {
  return await prismaFormClient.form.findUnique({
    where: { id: formId },
    include: FORM_EXPORT_INCLUDE,
  });
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/forms/import-utils.ts

import { ElementType } from '@/app/(non-account)/(features)/(form)/utils/enums';
import { prisma } from '@/utils/clients/mongo/prismaClient';
import { Prisma, PrismaClient } from '@prisma/client';
import { DefaultArgs } from '@prisma/client/runtime/library';

import {
  FormElementImportType,
  FormFieldImportType,
  FormImportType,
  FormTextImportType,
  ImportOptions,
  SectionImportType,
  StepImportType,
} from './export-import-types';

type PrismaTransactionClient = Omit<
  PrismaClient<Prisma.PrismaClientOptions, never, DefaultArgs>,
  '$connect' | '$disconnect' | '$on' | '$transaction' | '$use' | '$extends'
>;

export const importForm = async (
  exportedForm: FormImportType,
  options: ImportOptions
) => {
  const { updateForm = false } = options;

  let newForm;
  const id = await prisma.$transaction(
    async (tx) => {
      if (updateForm) {
        // Update existing form
        const { id, ...formData } = exportedForm;
        newForm = await tx.form.update({
          where: { id },
          data: {
            ...formData,
            apiMapping: exportedForm.apiMapping as Prisma.InputJsonValue,
            sectionIDs: { set: [] }, // Clear existing sections
            sections: undefined,
          },
        });
      } else {
        // Create a new form
        newForm = await tx.form.create({
          data: {
            ...exportedForm,
            id: undefined,
            apiMapping: exportedForm.apiMapping as Prisma.InputJsonValue,
            sectionIDs: undefined,
            sections: undefined,
          },
        });
      }

      // Process sections
      for (const section of exportedForm.sections) {
        const updatedSection = await processSection(
          tx,
          newForm.id,
          section,
          options
        );

        // Process steps
        for (const step of section.steps) {
          const updatedStep = await processStep(
            tx,
            updatedSection.id,
            step,
            options
          );

          // Process form elements
          for (const element of step.formElements) {
            const updatedElement = await processFormElement(
              tx,
              updatedStep.id,
              element,
              options
            );

            if (
              element.elementType === ElementType.FormField &&
              element.field
            ) {
              await processFormField(
                tx,
                updatedElement.id,
                element.field,
                options
              );
            }

            if (element.elementType === ElementType.FormText && element.text) {
              await processFormText(
                tx,
                updatedElement.id,
                element.text,
                options
              );
            }
          }
        }
      }
      return newForm.id;
    },
    {
      maxWait: 10000,
      timeout: 110000,
    }
  );

  return id;
};

const processSection = async (
  tx: PrismaTransactionClient,
  formId: string,
  section: SectionImportType,
  options: ImportOptions
) => {
  const { createNewElements } = options;

  const existingSection = createNewElements
    ? null
    : await tx.formSection.findUnique({
        where: { id: section.id },
      });

  if (existingSection) {
    const { id, ...sectionData } = section;
    await tx.formSection.update({
      where: { id },
      data: {
        ...sectionData,
        stepIDs: { set: [] },
        steps: undefined,
      },
    });
    // Connect existing section to the new form
    await tx.form.update({
      where: { id: formId },
      data: { sections: { connect: { id } } },
    });

    return existingSection;
  } else {
    // Create new section
    const newSection = await tx.formSection.create({
      data: {
        ...section,
        id: createNewElements ? undefined : section.id,
        stepIDs: { set: [] },
        steps: undefined,
        formIDs: undefined,
        forms: { connect: { id: formId } },
      },
    });

    return newSection;
  }
};

const processStep = async (
  tx: PrismaTransactionClient,
  sectionId: string,
  step: StepImportType,
  options: ImportOptions
) => {
  const { createNewElements } = options;

  const existingStep = createNewElements
    ? null
    : await tx.formStep.findUnique({
        where: { id: step.id },
      });

  if (existingStep) {
    const { id, ...stepData } = step;

    await tx.formStep.update({
      where: { id },
      data: { ...stepData, formElements: undefined },
    });

    // Connect existing step to the new section
    await tx.formSection.update({
      where: { id: sectionId },
      data: { steps: { connect: { id } } },
    });

    return existingStep;
  } else {
    // Create new step
    return await tx.formStep.create({
      data: {
        ...(createNewElements ? { ...step, id: undefined } : step),
        formElementIDs: undefined,
        formElements: undefined,
        sectionIDs: undefined,
        sections: { connect: { id: sectionId } },
      },
    });
  }
};

const processFormElement = async (
  tx: PrismaTransactionClient,
  stepId: string,
  element: FormElementImportType,
  options: ImportOptions
) => {
  const { createNewElements } = options;

  const existingElement = createNewElements
    ? null
    : await tx.formElement.findUnique({
        where: { id: element.id },
      });

  if (existingElement) {
    const { id, ...elementData } = element;
    await tx.formElement.update({
      where: { id },
      data: { ...elementData, text: undefined, field: undefined },
    });

    // Connect existing element to the new step
    await tx.formStep.update({
      where: { id: stepId },
      data: { formElements: { connect: { id } } },
    });

    return existingElement;
  } else {
    // Create new element
    return await tx.formElement.create({
      data: {
        ...(createNewElements ? { ...element, id: undefined } : { ...element }),
        formStepIDs: undefined,
        formStep: { connect: { id: stepId } },
        field: undefined,
        text: undefined,
      },
    });
  }
};

const processFormText = async (
  tx: PrismaTransactionClient,
  elementId: string,
  text: FormTextImportType,
  options: ImportOptions
) => {
  if (text == null) {
    return null;
  }

  const { createNewElements } = options;

  const existingText = createNewElements
    ? null
    : await tx.formText.findUnique({
        where: { id: text.id },
      });

  if (existingText) {
    const { id, ...textData } = text;
    await tx.formText.update({
      where: { id },
      data: textData,
    });

    // Connect existing text to the new element
    await tx.formElement.update({
      where: { id: elementId },
      data: { text: { connect: { id } } },
    });
  } else {
    // Create new text
    return await tx.formText.create({
      data: {
        id: createNewElements ? undefined : text.id,
        formElement: { connect: { id: elementId } },
        text: text.text ?? '',
        showLogic: text.showLogic,
        translations: text.translations,
        formTextProperties: text.formTextProperties,
        componentType: text.componentType,
      },
    });
  }
};

const processFormField = async (
  tx: PrismaTransactionClient,
  elementId: string,
  field: FormFieldImportType,
  options: ImportOptions
) => {
  if (field == null) {
    return null;
  }

  const { createNewElements } = options;

  const existingField = createNewElements
    ? null
    : await tx.formField.findUnique({
        where: { id: field.id },
      });

  if (existingField) {
    const { id, fieldProperties, ...fieldData } = field;
    await tx.formField.update({
      where: { id },
      data: {
        ...fieldData,
        fieldProperties: {
          ...(fieldProperties ?? {}),
          acceptedFileTypes: fieldProperties?.acceptedFileTypes ?? [],
          options: fieldProperties?.options ?? [],
          imageOptions: field.fieldProperties?.imageOptions ?? [],
          innerFormValidation: field.fieldProperties?.innerFormValidation ?? [],
        },
      },
    });

    // Connect existing text to the new element
    await tx.formElement.update({
      where: { id: elementId },
      data: { field: { connect: { id } } },
    });
  } else {
    // Create new field
    return await tx.formField.create({
      data: {
        id: createNewElements ? undefined : field.id,
        formElement: { connect: { id: elementId } },
        label: field.label,
        helperText: field.helperText,
        fieldType: field.fieldType,
        fieldProperties: {
          ...(field.fieldProperties ?? {}),
          acceptedFileTypes: field.fieldProperties?.acceptedFileTypes ?? [],
          options: field.fieldProperties?.options ?? [],
          imageOptions: field.fieldProperties?.imageOptions ?? [],
          innerFormValidation: field.fieldProperties?.innerFormValidation ?? [],
        },
        validation: field.validation,
        required: field.required,
        translations: field.translations,
      },
    });
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/forms/export-import-types.ts

import { z } from 'zod';

import { Prisma } from '@prisma/client';
import {
  FormElementFieldPropertiesSchema,
  FormElementSchema,
  FormElementValidationSchema,
  FormElementsShowLogicRuleSchema,
  FormFieldSchema,
  FormFieldTranslationSchema,
  FormImageSchema,
  FormSchema,
  FormSectionSchema,
  FormStepSchema,
  FormTextPropertiesSchema,
  FormTextSchema,
  FormTextTranslationSchema,
  ImageOptionSchema,
} from '@prisma/generated/zod';

export const FORM_EXPORT_INCLUDE = {
  sections: {
    include: {
      steps: {
        include: { formElements: { include: { text: true, field: true } } },
      },
    },
  },
};

export type ExportedFormType = Prisma.FormGetPayload<{
  include: typeof FORM_EXPORT_INCLUDE;
}>;

export interface ImportOptions {
  createNewElements: boolean;
  updateForm?: boolean;
}

// Zod validation schemas

const FormElementShowLogicSchema = z.object({
  ruleset: z.array(FormElementsShowLogicRuleSchema),
});

const FormImportTextPropertiesSchema = FormTextPropertiesSchema.merge(
  z.object({
    imageTop: FormImageSchema.optional().nullable(),
    imageBottom: FormImageSchema.optional().nullable(),
  })
);

const FormImportElementFieldPropertiesSchema =
  FormElementFieldPropertiesSchema.merge(
    z.object({
      acceptedFileTypes: z.array(z.string()).nullable().optional().default([]),
      options: z.array(z.string()).nullable().optional().default([]),
      imageOptions: z
        .array(ImageOptionSchema)
        .nullable()
        .optional()
        .default([]),
      innerFormValidation: z
        .array(FormElementValidationSchema)
        .nullable()
        .optional()
        .default([]),
    })
  );

const FormImportFieldSchema = FormFieldSchema.merge(
  z.object({
    showLogic: z.array(FormElementShowLogicSchema),
    validation: z.array(FormElementValidationSchema),
    translations: z.array(FormFieldTranslationSchema),
    fieldProperties:
      FormImportElementFieldPropertiesSchema.optional().nullable(),
  })
);

const FormImportTextSchema = FormTextSchema.merge(
  z.object({
    showLogic: z.array(FormElementShowLogicSchema),
    translations: z.array(FormTextTranslationSchema),
    formTextProperties: FormImportTextPropertiesSchema.optional().nullable(),
  })
);

const FormImportElementSchema = FormElementSchema.merge(
  z.object({
    field: FormImportFieldSchema.optional().nullable(),
    text: FormImportTextSchema.optional().nullable(),
  })
);

const FormImportStepSchema = FormStepSchema.merge(
  z.object({
    formElements: z.array(FormImportElementSchema),
  })
);

const FormImportSectionSchema = FormSectionSchema.merge(
  z.object({
    steps: z.array(FormImportStepSchema),
  })
);

export const FormImportSchema = FormSchema.merge(
  z.object({
    sections: z.array(FormImportSectionSchema),
  })
);

export const FormImportPayloadSchema = z.object({
  exportedForm: FormImportSchema,
  options: z.object({
    createNewElements: z.boolean(),
    updateForm: z.boolean().optional().default(false),
  }),
});

export type FormImportType = z.infer<typeof FormImportSchema>;
export type SectionImportType = z.infer<typeof FormImportSectionSchema>;
export type StepImportType = z.infer<typeof FormImportStepSchema>;
export type FormElementImportType = z.infer<typeof FormImportElementSchema>;
export type FormFieldImportType = z.infer<typeof FormImportFieldSchema>;
export type FormTextImportType = z.infer<typeof FormImportTextSchema>;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/ecommerce/conciergeUtils.ts

import { ProductCategories, User } from '@prisma/client';

import { prisma } from '../clients/mongo/prismaClient';

export async function isUserConciergeMember(user: User): Promise<boolean> {
  //TODO: get rid of nested where clause to fix prisma inefficient call
  const conciergeSubscriptions = await prisma.userSubscription.findFirst({
    where: {
      userId: user.id,
      subscriptionProduct: {
        category: ProductCategories.CONCIERGE,
      },
      ended: false,
    },
    include: {
      subscriptionProduct: true,
    },
  });

  return !!conciergeSubscriptions;
}

export async function applyConciergeDiscount(
  totalToApplyDiscountTo: number,
  user: User,
  conciergeInCartPrice: number | null
): Promise<number> {
  // Deals with negative number edge case
  if (totalToApplyDiscountTo <= 0) {
    return 0;
  }

  const conciergeDiscountAmt = Number(process.env.CONCIERGE_DISCOUNT_AMOUNT)
    ? Number(process.env.CONCIERGE_DISCOUNT_AMOUNT)
    : 0.2;

  if (conciergeInCartPrice !== null) {
    const conciergeDiscountedPrice =
      (1 - conciergeDiscountAmt) *
        (totalToApplyDiscountTo - conciergeInCartPrice) +
      conciergeInCartPrice;
    // Assuming we should not discount the concierge purchase
    return Math.round(conciergeDiscountedPrice);
  } else if (await isUserConciergeMember(user)) {
    const conciergeDiscountedPrice =
      (1 - conciergeDiscountAmt) * totalToApplyDiscountTo;

    return Math.round(conciergeDiscountedPrice);
  }

  return totalToApplyDiscountTo;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/ecommerce/cartUtils.ts

import { prismaEcomClient } from '@/app/shared/models/extensions/ecommerce';
import { CartInclude } from '@/app/shared/types';
import {
  CartProducts,
  CartSubscriptionProducts,
  Product,
  ProductCategories,
  PromoCodes,
  SubscriptionProduct,
  User,
} from '@prisma/client';

import { prisma } from '../clients/mongo/prismaClient';
import {
  postUserAddToCartEvent,
  postUserRemoveFromCartEvent,
} from '../user-events/user-event-utils';

export interface userCartReturn {
  cart: CartInclude & { promo?: PromoCodes };
  cartProducts: Array<CartProducts & { product: Product }>;
  cartSubscriptionProducts: Array<
    CartSubscriptionProducts & { subscriptionProduct: SubscriptionProduct }
  >;
  conciergeInCartPrice: number | null;
}

export interface cartPriceReturn {
  subTotalPrice: number;
  productPrice: number;
  subscriptionPrice: number;
  promoCodeDiscount: number;
  conciergeDiscount: number;
  tax: number;
  shipping: number;
  totalPrice: number;
}

export async function getUserCart(user: User): Promise<userCartReturn> {
  const currentCart = await prisma.cart.findUnique({
    where: {
      userId: user.id,
    },
    include: {
      cartProducts: { include: { product: true } },
      cartSubscriptionProducts: { include: { subscriptionProduct: true } },
    },
  });

  let conciergeInCartPrice = null;
  if (currentCart?.cartSubscriptionProducts) {
    for (const subscriptionProduct of currentCart.cartSubscriptionProducts) {
      if (
        subscriptionProduct.subscriptionProduct.category ===
        ProductCategories.CONCIERGE
      ) {
        conciergeInCartPrice = subscriptionProduct.subscriptionProduct.price;
      }
    }
  }

  if (!currentCart) {
    const newCart = await prisma.cart.create({
      data: {
        userId: user.id,
      },
      include: {
        cartProducts: { include: { product: true } },
        cartSubscriptionProducts: { include: { subscriptionProduct: true } },
      },
    });

    const cartToReturn: userCartReturn = {
      cart: newCart,
      cartProducts: newCart.cartProducts,
      cartSubscriptionProducts: newCart.cartSubscriptionProducts,
      conciergeInCartPrice: conciergeInCartPrice,
    };

    return cartToReturn;
  }

  const promo = currentCart.promoCodeCode
    ? await prismaEcomClient.promoCodes.findUnique({
        where: { code: currentCart.promoCodeCode },
      })
    : undefined;

  const cartToReturn: userCartReturn = {
    cart: { ...currentCart, promo: promo ?? undefined },
    cartProducts: currentCart.cartProducts,
    cartSubscriptionProducts: currentCart.cartSubscriptionProducts,
    conciergeInCartPrice: conciergeInCartPrice,
  };

  return cartToReturn;
}

////////////////////////////////////////////////////////
////////////// PRODUCT CART UTILITIES //////////////////
export async function addProductToCart(
  user: User,
  productId: string,
  setAbsoluteAmount: boolean,
  amount: number
): Promise<userCartReturn> {
  const cartObject = await getUserCart(user);

  for (let i = 0; i < cartObject.cartProducts.length; i++) {
    if (cartObject.cartProducts[i].productId === productId) {
      const amountOfProduct = setAbsoluteAmount
        ? amount
        : cartObject.cartProducts[i].quantity + amount;

      if (amountOfProduct > 0) {
        await prisma.cartProducts.update({
          where: {
            id: cartObject.cartProducts[i].id,
          },
          data: {
            quantity: amountOfProduct,
          },
        });

        await postUserAddToCartEvent(user, productId, amount);
      } else {
        await prisma.cartProducts.delete({
          where: {
            id: cartObject.cartProducts[i].id,
          },
        });

        await postUserRemoveFromCartEvent(
          user,
          productId,
          cartObject.cartProducts[i].quantity
        );
      }

      return await getUserCart(user);
    }
  }

  // No pre-existing product found, so now we create a cart product
  if (amount > 0) {
    await prisma.cartProducts.create({
      data: {
        productId: productId,
        quantity: amount,
        cartId: cartObject.cart.id,
      },
    });
  }

  await postUserAddToCartEvent(user, productId, amount);

  return await getUserCart(user);
}

export async function removeProductFromCart(
  user: User,
  productId: string
): Promise<userCartReturn> {
  const cartObject = await getUserCart(user);

  for (let i = 0; i < cartObject.cartProducts.length; i++) {
    if (cartObject.cartProducts[i].productId === productId) {
      if (cartObject.cartProducts[i].quantity > 1) {
        await prisma.cartProducts.update({
          where: {
            id: cartObject.cartProducts[i].id,
          },
          data: {
            quantity: cartObject.cartProducts[i].quantity - 1,
          },
        });
      } else {
        // Just delete the product if there are no more items in it
        await prisma.cartProducts.delete({
          where: {
            id: cartObject.cartProducts[i].id,
          },
        });

        await postUserRemoveFromCartEvent(user, productId, 1);
      }

      return await getUserCart(user);
    }
  }

  // No pre-existing product found, just return the cart as usual
  return await getUserCart(user);
}

////////////////////////////////////////////////////////
////// SUBSCRIPTION PRODUCT CART UTILITIES /////////////
export async function addSubscriptionProductToCart(
  user: User,
  subscriptionProductId: string,
  setAbsoluteAmount: boolean,
  amount: number
): Promise<userCartReturn> {
  const cartObject = await getUserCart(user);

  for (let i = 0; i < cartObject.cartSubscriptionProducts.length; i++) {
    if (
      cartObject.cartSubscriptionProducts[i].subscriptionProductId ===
      subscriptionProductId
    ) {
      const amountOfProduct = setAbsoluteAmount
        ? amount
        : cartObject.cartSubscriptionProducts[i].quantity + amount;

      if (amountOfProduct > 0) {
        await prisma.cartSubscriptionProducts.update({
          where: {
            id: cartObject.cartSubscriptionProducts[i].id,
          },
          data: {
            quantity: amountOfProduct,
          },
        });

        await postUserAddToCartEvent(user, subscriptionProductId, amount, true);
      } else {
        await prisma.cartSubscriptionProducts.delete({
          where: {
            id: cartObject.cartSubscriptionProducts[i].id,
          },
        });
        await postUserRemoveFromCartEvent(
          user,
          subscriptionProductId,
          cartObject.cartSubscriptionProducts[i].quantity,
          true
        );
      }

      return await getUserCart(user);
    }
  }

  // No pre-existing product found, so now we create a cart product
  if (amount > 0) {
    await prisma.cartSubscriptionProducts.create({
      data: {
        subscriptionProductId: subscriptionProductId,
        quantity: amount,
        cartId: cartObject.cart.id,
      },
    });

    await postUserAddToCartEvent(user, subscriptionProductId, amount, true);
  }

  return await getUserCart(user);
}

export async function removeSubscriptionProductFromCart(
  user: User,
  subscriptionProductId: string
): Promise<userCartReturn> {
  const cartObject = await getUserCart(user);

  for (let i = 0; i < cartObject.cartSubscriptionProducts.length; i++) {
    if (
      cartObject.cartSubscriptionProducts[i].subscriptionProductId ===
      subscriptionProductId
    ) {
      if (cartObject.cartSubscriptionProducts[i].quantity > 1) {
        await prisma.cartSubscriptionProducts.update({
          where: {
            id: cartObject.cartSubscriptionProducts[i].id,
          },
          data: {
            quantity: cartObject.cartSubscriptionProducts[i].quantity - 1,
          },
        });
      } else {
        // Just delete the product if there are no more items in it
        await prisma.cartSubscriptionProducts.delete({
          where: {
            id: cartObject.cartSubscriptionProducts[i].id,
          },
        });

        await postUserRemoveFromCartEvent(user, subscriptionProductId, 1, true);
      }

      return await getUserCart(user);
    }
  }

  // No pre-existing product found, just return the cart as usual
  return await getUserCart(user);
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/ecommerce/subscriptionUtils.ts

import {
  OrderType,
  ProductCategories,
  SubscriptionProduct,
  User,
  UserSubscription,
} from '@prisma/client';

import LoggerUtil from '../clients/logging/apiUtilLogger';
import { prisma } from '../clients/mongo/prismaClient';
import {
  GetPurchaseSystem,
  PurchaseSystem,
  getTimeOffsetFromDate,
} from '../payments/purchaseSystem';
import { shipOrder } from '../shipping/shippingUtils';
import { postSubscriptionPurchaseEvent } from '../user-events/user-event-utils';
import { applyConciergeDiscount } from './conciergeUtils';

async function onPaymentFailure(
  error: unknown,
  subscription: UserSubscription
) {
  await prisma.userSubscription.update({
    where: {
      id: subscription.id,
    },
    data: {
      endDate: new Date(),
      ended: true,
    },
  });

  const errorString = `Renewal payment for subscription failed: ${error}`;
  const thrownError = new Error(errorString);

  await LoggerUtil.logError(
    'subscription_payment_failure',
    'subscriptionUtils > onPaymentFailure',
    thrownError,
    { userId: subscription.userId, subscription, error }
  );

  throw thrownError;
}

async function renewSubscription(
  subscription: UserSubscription,
  purchaseSystem: PurchaseSystem,
  subscriptionProduct: SubscriptionProduct,
  user: User
) {
  // Check if subscription is supposed to be active
  const today = new Date();
  today.setHours(23, 59, 59, 999);

  // This subscription should have ended and just wasn't
  //    detected immediately after being set to ended
  if (subscription.endDate && subscription.endDate <= today) {
    return;
  }

  // Still Trialing
  if (subscription.trialEndDate && subscription.trialEndDate >= today) {
    return;
  }

  const userPurchaseObject = {
    productId: subscription.subscriptionProductId,
    unitPrice: subscription.price,
    quantity: 1,
    priceAfterPromo: subscription.price,
    priceAfterConcierge: subscription.price,
    subscriptionDetails: subscriptionProduct,
    amountDueToday: subscription.price,
    subscriptionOnTrial: false,
  };

  // Handle Payment Routing
  let paymentId = '';
  let subscriptionIsOTC = false;
  if (subscriptionProduct.category === ProductCategories.CONCIERGE) {
    // Branch that runs on subscription renewal
    // On Subscription renewal do not applyConciergeDiscount
    await LoggerUtil.logInfo(
      'subscription_concierge_renewal_standard_payment',
      'subscriptionUtils > renewSubscription',
      {
        userId: user.id,
        subscription,
      }
    );

    try {
      paymentId = await purchaseSystem.captureCustomerPayment(
        subscription.paymentMethodId,
        subscription.paymentprovider,
        user,
        subscription.price
      );
    } catch (error) {
      await onPaymentFailure(error, subscription);
    }

    subscriptionIsOTC = true;
  } else if (
    subscriptionProduct.category === ProductCategories.CONSULTATION ||
    subscriptionProduct.category === ProductCategories.PRESCRIPTION_MEDICATION
  ) {
    await LoggerUtil.logInfo(
      'subscription_renewal_medical_payment',
      'subscriptionUtils > renewSubscription',
      {
        userId: user.id,
        subscription,
      }
    );
    const priceAfterConcierge = await applyConciergeDiscount(
      subscription.price,
      user,
      null
    );

    try {
      paymentId = await purchaseSystem.captureCustomerMedicalPayment(
        subscription.paymentMethodId,
        subscription.paymentprovider,
        user,
        priceAfterConcierge,
        subscription.shippingAddress
      );
    } catch (error) {
      await onPaymentFailure(error, subscription);
    }

    // Update the price sent to user events after concierge is applied
    userPurchaseObject.priceAfterConcierge = priceAfterConcierge;
    userPurchaseObject.amountDueToday = priceAfterConcierge;
  } else {
    await LoggerUtil.logInfo(
      'subscription_renewal_generic_standard_payment',
      'subscriptionUtils > renewSubscription',
      {
        userId: user.id,
        subscription,
      }
    );
    const priceAfterConcierge = await applyConciergeDiscount(
      subscription.price,
      user,
      null
    );

    try {
      paymentId = await purchaseSystem.captureCustomerPayment(
        subscription.paymentMethodId,
        subscription.paymentprovider,
        user,
        priceAfterConcierge
      );
    } catch (error) {
      await onPaymentFailure(error, subscription);
    }

    subscriptionIsOTC = true;

    // Update the price sent to user event after concierge is applied
    userPurchaseObject.priceAfterConcierge = priceAfterConcierge;
    userPurchaseObject.amountDueToday = priceAfterConcierge;
  }

  // Send the purchase event to user events
  await postSubscriptionPurchaseEvent(user, [userPurchaseObject], true);
  await LoggerUtil.logInfo(
    'subscription_renewal_payment_intent_id',
    'subscriptionUtils > renewSubscription',
    {
      userId: user.id,
      subscription,
      paymentId,
    }
  );

  // Create an order on the patient's page
  const newOrder = await prisma.order.create({
    data: {
      userId: user.id,
      paymentMethodId: subscription.paymentMethodId,
      paymentProvider: subscription.paymentprovider,
      orderType: OrderType.SUBSCRIPTION_RENEWAL,
      shippingAddress: subscription.shippingAddress,
      otcSubscriptionPaymentId: subscriptionIsOTC ? paymentId : undefined,
      medicalSubscriptionPaymentId: subscriptionIsOTC ? undefined : paymentId,
    },
  });

  await LoggerUtil.logInfo(
    'subscription_renewal_order_id',
    'subscriptionUtils > renewSubscription',
    {
      userId: user.id,
      subscription,
      newOrder,
    }
  );

  // Create the product that was purchased for storing on an order
  const cartSubscriptionProducts = await prisma.cartSubscriptionProducts.create(
    {
      data: {
        quantity: 1,
        subscriptionProductId: subscription.subscriptionProductId,
        externalPaymentId: paymentId,
        orderId: newOrder.id,
      },
    }
  );

  await LoggerUtil.logInfo(
    'subscription_renewal_product_id',
    'subscriptionUtils > renewSubscription',
    {
      userId: user.id,
      subscription,
      cartSubscriptionProducts,
    }
  );

  // Update the subscription
  const nextRenewalDate = getTimeOffsetFromDate(
    subscription.frequency,
    subscription.frequencyUnit,
    subscription.nextRenewalDate ? subscription.nextRenewalDate : new Date()
  );

  await LoggerUtil.logInfo(
    'subscription_renewal_next_renewal_date',
    'subscriptionUtils > renewSubscription',
    {
      userId: user.id,
      subscription,
      nextRenewalDate,
    }
  );

  await prisma.userSubscription.update({
    where: {
      id: subscription.id,
    },
    data: {
      nextRenewalDate: nextRenewalDate,
    },
  });

  await LoggerUtil.logInfo(
    'subscription_renewal_updated',
    'subscriptionUtils > renewSubscription',
    {
      userId: user.id,
      subscription,
    }
  );

  // Ship any products that must be shipped
  await shipOrder(user, newOrder, subscription.shippingAddress, null, [
    cartSubscriptionProducts,
  ]);

  await LoggerUtil.logInfo(
    'subscription_renewal_shipped',
    'subscriptionUtils > renewSubscription',
    {
      userId: user.id,
      subscription,
    }
  );

  // That's it! We've renewed the subscription
}

export async function doDailySubscriptionCheck() {
  try {
    await handleDailySubscriptionCheck();
  } catch (error) {
    await LoggerUtil.logError(
      'subscription_check_error',
      'doDailySubscriptionCheck',
      error,
      {}
    );
  }
}

async function handleDailySubscriptionCheck() {
  const today = new Date();
  today.setHours(23, 59, 59, 999); // Optional, to compare dates without time component. Including whole day

  // Ignore any subscription that is ended
  // If a subscription's ended at date is in the past or today, set ended to true
  // If a subscription's next renewal date is today or earlier, it is not ended, its end date is null or greater than today,
  //        and its trial end date is null or less than or equal today, then we can charge the subscription
  // TODO: Should we do pro-rated charges for subscrpitions that have trials that end before next renewal date?

  // End any subscriptions that are over
  const subscriptionsThatEnded = await prisma.userSubscription.updateMany({
    where: {
      endDate: {
        lte: today,
      },
    },
    data: {
      ended: true,
    },
  });

  const subscriptionsToCharge = await prisma.userSubscription.findMany({
    where: {
      nextRenewalDate: {
        lte: today,
      },
      ended: false, // Ensure subscription hasn't ended
    },
    include: {
      user: true,
      subscriptionProduct: true,
    },
  });

  const purchaseSystem = await GetPurchaseSystem();
  for (const subscription of subscriptionsToCharge) {
    try {
      await renewSubscription(
        subscription,
        purchaseSystem,
        subscription.subscriptionProduct,
        subscription.user
      );
    } catch (error) {
      await LoggerUtil.logError(
        'subscription_purchase_error',
        'doDailySubscriptionCheck',
        error,
        {
          subscription: subscription,
          userId: subscription.userId,
        }
      );
    }
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/submit/submitFormUtils.ts

import { revalidateTag } from 'next/cache';
import { UpdateMeSchema } from 'prisma/custom-schemas/updateMe';
import { UpdateMedicalProfileSchema } from 'prisma/custom-schemas/updateMedicalProfile';

import DosespotClient from '@/utils/clients/dosespot/dosespotClient';
import {
  addDependentToUser,
  convertStringDateToISOString,
  transformAllergenPayloadToDSInput,
  transformMedicationPayloadToDSInput,
} from '@/utils/helpers/helpers';
import { User } from '@prisma/client';
import { prisma } from '@utils/clients/mongo/prismaClient';

import {
  convertHeightToDoseSpotFormat,
  convertWeightToDoseSpotFormat,
} from '../clients/dosespot/dosespotUtils';

export const upsertUserData = async (
  currentUser: User | null | undefined,
  data: any
): Promise<User | null> => {
  if (!currentUser) return null;

  if (data.DOB) {
    data.DOB = convertStringDateToISOString(data.DOB);
  }

  const userData = {
    firstName: data.firstName,
    lastName: data.lastName,
    addresses: data.addresses,
    phoneNumber: data.phone,
    sexAtBirth: data.sexAtBirth,
    dob: data.DOB,
    skinType: data.skinType ?? 'Olive or Medium',
    skinProfile: data.skinProfile ?? 'Normal',
  };

  const updateData = UpdateMeSchema.parse(userData);
  const {
    firstName,
    lastName,
    addresses,
    phoneNumber,
    sexAtBirth,
    dob,
    skinType,
    skinProfile,
  } = updateData;

  // Map the allergies and medications to the correct format for Dosespot
  const allergensInput = transformAllergenPayloadToDSInput(data.allergies);
  const medicationsInput = transformMedicationPayloadToDSInput(
    data.medications
  );

  const medicalData = UpdateMedicalProfileSchema.parse({
    ...data,
    allergies: allergensInput,
    medications: medicationsInput,
  });

  const {
    medicalConditions,
    medications,
    allergies,
    primaryCarePhysicianAddress,
    primaryCarePhysicianName,
  } = medicalData;

  // First, update user basic info
  let updatedUser = await prisma.user.update({
    where: { id: currentUser.id },
    data: {
      firstName,
      lastName,
      addresses,
      phoneNumber,
    },
  });

  // send updated user data to DoseSpot
  const dsResult = await DosespotClient.pushUserDataToDoseSpot(
    {
      ...updateData,
      medicalProfile: { dob, sexAtBirth, medications, allergies },
    },
    updatedUser
  );

  if (!dsResult.success && !dsResult.error.shouldContinue) return null;

  // Add dosespotId to user if it doesn't exist
  updatedUser = await prisma.user.update({
    where: { id: currentUser.id },
    data: {
      dosespotId:
        currentUser.dosespotId ??
        (dsResult.success ? dsResult.patientDoseSpotId : undefined),
    },
  });

  // Check if medical profile exists
  const existingMedicalProfile = await prisma.medicalProfile.findUnique({
    where: { userId: currentUser.id },
  });

  // Update or Create Medical Profile
  if (existingMedicalProfile) {
    // Update existing medical profile
    await prisma.medicalProfile.update({
      where: { id: existingMedicalProfile.id },
      data: {
        dob,
        sexAtBirth,
        skinType,
        skinProfile,
        medicalConditions,
        primaryCarePhysicianName,
        primaryCarePhysicianAddress,
        medicalProfileCompletedDate: new Date(Date.now()),
      },
    });
  } else {
    // Create new medical profile
    await prisma.medicalProfile.create({
      data: {
        userId: currentUser.id,
        dob,
        sexAtBirth,
        skinType,
        skinProfile,
        medicalConditions,
        primaryCarePhysicianName,
        primaryCarePhysicianAddress,
        medicalProfileCompletedDate: new Date(Date.now()),
      },
    });
  }

  return prisma.user.findUnique({
    where: { id: currentUser.id },
    include: {
      medicalProfile: true,
    },
  });
};

export const upsertGuardianUserData = async (
  currentUser: User | null | undefined,
  data: any
): Promise<User | null> => {
  if (!currentUser) return null;

  if (data.guardianDOB) {
    data.guardianDOB = convertStringDateToISOString(data.guardianDOB);
  }

  const guardianData = {
    firstName: data.guardianFirstName,
    lastName: data.guardianLastName,
    addresses: data.guardianAddresses,
    phoneNumber: data.guardianPhone,
    sexAtBirth: data.guardianSexAtBirth,
    dob: data.guardianDOB,
    skinType: data.guardianSkinType ?? 'Olive or Medium',
    skinProfile: data.guardianSkinProfile ?? 'Normal',
  };

  const updateData = UpdateMeSchema.parse(guardianData);
  const {
    firstName,
    lastName,
    addresses,
    phoneNumber,
    sexAtBirth,
    dob,
    skinType,
    skinProfile,
  } = updateData;

  // First, update user basic info
  let updatedUser = await prisma.user.update({
    where: { id: currentUser.id },
    data: {
      firstName,
      lastName,
      addresses,
      phoneNumber,
    },
  });

  // send updated user data to DoseSpot
  const dsResult = await DosespotClient.pushUserDataToDoseSpot(
    { ...updateData, medicalProfile: { dob, sexAtBirth } },
    updatedUser
  );

  if (!dsResult.success && !dsResult.error.shouldContinue) return null;

  // Add dosespotId to user if it doesn't exist
  updatedUser = await prisma.user.update({
    where: { id: currentUser.id },
    data: {
      dosespotId:
        currentUser.dosespotId ??
        (dsResult.success ? dsResult.patientDoseSpotId : undefined),
    },
  });

  // Check if medical profile exists
  const existingMedicalProfile = await prisma.medicalProfile.findUnique({
    where: { userId: currentUser.id },
  });

  // Update or Create Medical Profile
  if (existingMedicalProfile) {
    // Update existing medical profile
    await prisma.medicalProfile.update({
      where: { id: existingMedicalProfile.id },
      data: {
        dob,
        sexAtBirth,
        skinType,
        skinProfile,
      },
    });
  } else {
    // Create new medical profile
    await prisma.medicalProfile.create({
      data: {
        userId: currentUser.id,
        dob,
        sexAtBirth,
        skinType,
        skinProfile,
      },
    });
  }

  return prisma.user.findUnique({
    where: { id: currentUser.id },
    include: {
      medicalProfile: true,
    },
  });
};

export const upsertMemberData = async (
  existingMember: User | string | null | undefined,
  data: any
): Promise<User | null> => {
  revalidateTag('user');
  let member = existingMember;

  if (data.dob) {
    data.dob = convertStringDateToISOString(data.dob);
  }
  const updateData = UpdateMeSchema.parse(data);
  const {
    firstName,
    lastName,
    addresses,
    sexAtBirth,
    dob,
    skinType,
    skinProfile,
  } = updateData;

  // Map the allergies and medications to the correct format for Dosespot
  const allergensInput = transformAllergenPayloadToDSInput(data.allergies);
  const medicationsInput = transformMedicationPayloadToDSInput(
    data.medications
  );

  const medicalData = UpdateMedicalProfileSchema.parse({
    ...data,
    allergies: allergensInput,
    medications: medicationsInput,
  });

  const {
    medicalConditions,
    medications,
    allergies,
    primaryCarePhysicianAddress,
    primaryCarePhysicianName,
  } = medicalData;

  // If the member/dependent didn't exist, create it
  if (
    member === null ||
    member === undefined ||
    typeof existingMember === 'string'
  ) {
    if (!firstName || !lastName) {
      return null;
    }
    const newDependent = await addDependentToUser(firstName, lastName);
    member = newDependent;
  }

  if (!member || typeof member === 'string') {
    return null;
  }

  // send updated user data to DoseSpot
  const dsResult = await DosespotClient.pushUserDataToDoseSpot(
    {
      ...updateData,
      medicalProfile: {
        dob,
        sexAtBirth,
        medications,
        allergies,
      },
      height: data.height,
      weight: data.weight,
    },
    member
  );

  if (!dsResult.success && !dsResult.error.shouldContinue) return null;

  const dsHeight = convertHeightToDoseSpotFormat(member, data.height);
  const dsWeight = convertWeightToDoseSpotFormat(member, data.weight);

  // First, update user basic info
  const updatedUser = await prisma.user.update({
    where: { id: member.id },
    data: {
      firstName,
      lastName,
      addresses,
      dosespotId:
        member.dosespotId ??
        (dsResult.success ? dsResult.patientDoseSpotId : undefined),
    },
    include: {
      medicalProfile: true,
    },
  });

  // Check if medical profile exists
  const existingMedicalProfile = await prisma.medicalProfile.findUnique({
    where: { userId: member.id },
  });

  // Update or Create Medical Profile
  if (existingMedicalProfile) {
    // Update existing medical profile
    await prisma.medicalProfile.update({
      where: { id: existingMedicalProfile.id },
      data: {
        dob,
        sexAtBirth,
        skinType,
        skinProfile,
        medicalConditions,
        primaryCarePhysicianName,
        primaryCarePhysicianAddress,
        medicalProfileCompletedDate: new Date(Date.now()),
        height: dsHeight.height,
        heightUnit: dsHeight.units,
        weight: dsWeight.weight,
        weightUnit: dsWeight.units,
      },
    });
  } else {
    // Create new medical profile
    await prisma.medicalProfile.create({
      data: {
        userId: member.id,
        dob,
        sexAtBirth,
        skinType,
        skinProfile,
        medicalConditions,
        primaryCarePhysicianName,
        primaryCarePhysicianAddress,
        medicalProfileCompletedDate: new Date(Date.now()),
        height: dsHeight.height,
        heightUnit: dsHeight.units,
        weight: dsWeight.weight,
        weightUnit: dsWeight.units,
      },
    });
  }

  return prisma.user.findUnique({
    where: { id: member.id },
    include: {
      medicalProfile: true,
    },
  });
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/swagger/swagger.ts

import { createSwaggerSpec } from 'next-swagger-doc';
import { OAS3Definition, Options, SwaggerDefinition } from 'swagger-jsdoc';

import packageInfo from '../../../package.json';

type SwaggerOptions = Options & {
  apiFolder?: string;
  schemaFolders?: string[];
  definition: OAS3Definition;
  outputFile?: string;
};

export const swaggerOptions: SwaggerOptions = {
  apiFolder: 'src/app',
  definition: {
    openapi: '3.1.0',
    info: {
      title: 'Dermi API',
      version: packageInfo.apiVersion,
    },
    components: {
      securitySchemes: {
        cognito: {
          type: 'openIdConnect',
          openIdConnectUrl:
            process.env.COGNITO_ISSUER + '/.well-known/openid-configuration',
        },
      },
    },
    security: [
      {
        cognito: [],
      },
    ],
  },
  schemaFolders: ['app/shared/swagger'],
};

export const getApiDocs = async () => {
  const spec = createSwaggerSpec(swaggerOptions) as SwaggerDefinition;
  return spec;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/auth/auth.ts

import crypto from 'crypto';
import {
  AuthOptions,
  NextAuthOptions,
  User as NextAuthUser,
  Session,
  getServerSession,
} from 'next-auth';
import CognitoProvider from 'next-auth/providers/cognito';
import CredentialsProvider from 'next-auth/providers/credentials';
import { cookies, headers } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { userPrismaClient } from '@/app/shared/models/extensions/identity';
import { ExtendedUser } from '@/app/shared/models/extensions/identity/types/identityTypes';
import CognitoClient from '@clients/cognito/cognitoClient';
import { User, UserRole } from '@prisma/client';

import LoggerUtil from '../clients/logging/apiUtilLogger';
import { COOKIE_KEYS } from '../enums';
import { ApiErrorHandler } from '../errors';
import { CookieJar } from '../responses/responseHelpers';
import { WithRequiredProperty } from '../utility-types/withRequiredProperty';

// Session User Responses
interface SessionUserInfoSuccessResponse {
  user: WithRequiredProperty<NextAuthUser, 'cortinaId'>;
}
interface SessionUserInfoFailedResponse {
  unauthorizedApiResponse: NextResponse;
}

export const isSessionUserInfoSuccessResponse = (
  sessionResponse:
    | SessionUserInfoSuccessResponse
    | SessionUserInfoFailedResponse
): sessionResponse is SessionUserInfoSuccessResponse => {
  return (sessionResponse as SessionUserInfoSuccessResponse).user !== undefined;
};

export const authOptions: NextAuthOptions = {
  secret: process.env.NEXTAUTH_SECRET,
  session: {
    strategy: 'jwt',
  },
  pages: {
    signIn: '/signin',
  },
  providers: [
    CredentialsProvider({
      credentials: {
        username: {
          label: 'Email',
          type: 'text',
        },
        password: {
          label: 'Password',
          type: 'password',
        },
      },
      authorize: async (credentials, req) => {
        if (!credentials) {
          await LoggerUtil.logError(
            'cognito_client_missing_credentials',
            'CredentialsProvider > authorize',
            new Error('Missing login credentials.'),
            {
              credentials,
              req,
            }
          );

          return null;
        }

        const { username, password } = credentials;

        let user = null;

        await new Promise((resolve, reject) => {
          CognitoClient.signIn({
            username,
            password,
            callback: async (error, authResult) => {
              if (authResult && authResult.AuthenticationResult?.AccessToken) {
                const cognitoUser = await CognitoClient.getCognitoUserWithToken(
                  authResult.AuthenticationResult?.AccessToken
                );

                const cortinaId = cognitoUser.UserAttributes?.find(
                  (x) => x.Name === 'custom:cortina_id'
                )?.Value;
                const email = cognitoUser.UserAttributes?.find(
                  (x) => x.Name === 'email'
                )?.Value;
                const identities = cognitoUser.UserAttributes?.find(
                  (x) => x.Name === 'identities'
                )?.Value;

                user = {
                  id: cognitoUser.Username,
                  sub: cognitoUser.Username,
                  email,
                  identities,
                  userName: cognitoUser.Username,
                  cortinaId,
                };
                resolve(user);
              } else {
                if (error) {
                  await LoggerUtil.logError(
                    'cognito_client_callback_error',
                    'CognitoClient.signIn > callback',
                    error,
                    { username }
                  );
                }
                resolve(null);
              }
            },
          });
        });

        return user;
      },
      type: 'credentials',
    }),
    CognitoProvider({
      checks: ['pkce', 'nonce'],
      clientId: String(process.env.COGNITO_CLIENT_ID),
      clientSecret: String(process.env.COGNITO_CLIENT_SECRET),
      issuer: process.env.COGNITO_ISSUER,
      region: process.env.COGNITO_AWS_REGION ?? 'us-east-2',
      authorization: {
        params: {
          scope: 'openid profile email',
        },
      },
      profile(profile) {
        const user = mapProfileToUser(profile);
        return user;
      },
    }),
  ],
  callbacks: {
    async signIn() {
      return true;
    },
    async redirect({ url, baseUrl }: { url: string; baseUrl: string }) {
      if (url.startsWith('/')) return `${baseUrl}${url}`;
      return url;
    },
    async session({ session, token }: { session: any; token: any }) {
      if (!token) return session;

      session.user.userName = token.userName;
      session.user.identities = token.identities;
      session.user.cortinaId = token.cortinaId;
      session.user.sub = token.sub;
      session.user.email = token.email;
      return session;
    },
    async jwt({ token, user }: { token: any; user: any }) {
      if (!user) return token;

      token.userName = user.userName;
      token.identities = user.identities;
      token.cortinaId = user.cortinaId;
      token.sub = user.sub;
      token.email = user.email;

      return token;
    },
  },
};

export async function getSessionUserInfo(
  request: NextRequest
): Promise<SessionUserInfoSuccessResponse | SessionUserInfoFailedResponse> {
  const session = await getServerSession<AuthOptions, Session>(authOptions);

  let userInfo: NextAuthUser | null = null;

  if (!session || !session.user) {
    // If Failed to get Cookie, then get authorization header
    const awsAccessToken = request.headers.get('Authorization');

    if (!awsAccessToken) {
      // Create a NextResponse object directly with the custom message
      return {
        unauthorizedApiResponse: new NextResponse(
          JSON.stringify({ error: 'Missing session or authorized token' }),
          { status: 401, headers: { 'Content-Type': 'application/json' } }
        ),
      };
    }

    // convert the aws access token into a user profile
    const response = await fetch(
      process.env.COGNITO_DOMAIN + '/oauth2/userInfo',
      {
        method: 'GET',
        headers: {
          Authorization: awsAccessToken,
        },
      }
    );

    const awsProfile = await response.json();

    if (awsProfile satisfies NextAuthUser) {
      userInfo = mapProfileToUser(awsProfile);
    } else {
      return {
        unauthorizedApiResponse: getErrorResponse(
          'Failed to decode id token',
          request
        ),
      };
    }
  } else {
    userInfo = session.user as NextAuthUser;

    if (!userInfo.cortinaId) {
      const cognitoUserAttributes = await CognitoClient.getUserAttributesBySub(
        userInfo.userName
      );

      // Cortina ID Must be nullable for user linking
      userInfo.cortinaId = cognitoUserAttributes?.find(
        (element) => element.Name === process.env.COGNITO_CORTINA_ID_KEY
      )?.Value;

      if (!userInfo.cortinaId) {
        const extendedUser = await createOrLinkUserFromSessionuser(userInfo);
        userInfo.cortinaId = extendedUser.id;
        session.user = userInfo;
      }
    }
  }

  try {
    validateUserOrThrow(userInfo);
  } catch (error) {
    await LoggerUtil.logError(
      'session_validation_failure',
      'getSessionUserInfo',
      error,
      {
        user: userInfo,
      }
    );
    return {
      unauthorizedApiResponse: getErrorResponse(
        `Validation of user failed with error: ${(error as Error).message}`,
        request,
        error
      ),
    };
  }

  return {
    user: userInfo as WithRequiredProperty<NextAuthUser, 'cortinaId'>,
  };
}

async function linkAnonymousUserToSessionUser(
  anonymousUserID: string,
  sessionUser: NextAuthUser
): Promise<ExtendedUser> {
  const partner = await getPartnerIfExists(sessionUser);

  const newUser = await userPrismaClient.user.update({
    where: {
      id: anonymousUserID,
    },
    data: {
      email: sessionUser.email,
      cognitoId: sessionUser.sub,
      roles: [UserRole.PATIENT],
      anonymousUser: false,
      partnerId: partner?.id,
    },
  });

  await CognitoClient.updateCortinaIdByUsername(
    sessionUser.userName,
    newUser.id
  );

  await transferExistingCartsToNewUser(anonymousUserID, newUser.id);

  return newUser;
}

async function createUserFromSessionUser(sessionUser: NextAuthUser) {
  const existingUser = await userPrismaClient.user.findFirst({
    where: {
      email: sessionUser.email,
    },
  });

  if (existingUser) {
    return existingUser;
  }

  const partner = await getPartnerIfExists(sessionUser);

  const newUser = await userPrismaClient.user.create({
    data: {
      email: sessionUser.email,
      cognitoId: sessionUser.sub,
      roles: [UserRole.PATIENT],
      partnerId: partner?.id,
    },
  });

  await CognitoClient.updateCortinaIdByUsername(
    sessionUser.userName,
    newUser.id
  );

  return newUser;
}

// Link current anonymous user to new cognito ID if anonymous user exists
async function createOrLinkUserFromSessionuser(
  sessionUser: NextAuthUser
): Promise<ExtendedUser> {
  const anonymousUserId = getAnonymousUserID();

  if (anonymousUserId) {
    try {
      return await linkAnonymousUserToSessionUser(anonymousUserId, sessionUser);
    } catch (error) {
      await LoggerUtil.logError(
        'anonymous_user_conversion_failure',
        'createOrLinkUserFromSessionUser',
        error,
        {
          sessionUser,
        }
      );
    }
  }

  return await createUserFromSessionUser(sessionUser);
}

async function createAnonymousUser(
  cookieJar: CookieJar
): Promise<ExtendedUser> {
  const anonymousUser = await userPrismaClient.user.create({
    data: {
      roles: [UserRole.ANONYMOUS_PATIENT],
      anonymousUser: true,
    },
  });

  // Create the cookie for the anonymous user session
  cookieJar.cookies.push({
    name: 'cortina-user-session',
    value: anonymousUser.id,
    maxAge: 60 * 60 * 24,
  });

  return anonymousUser;
}

function getAnonymousUserID(): string | undefined {
  const cookieStore = cookies();
  const userInfo = cookieStore.get('cortina-user-session');
  return userInfo?.value;
}

function getUserFamilyMemberID(): string | undefined {
  const cookieStore = cookies();
  const headersList = headers();
  const cookieUserId = cookieStore.get(COOKIE_KEYS.FAMILY_MEMBER);
  const headerUserId = headersList.get(COOKIE_KEYS.FAMILY_MEMBER);

  return headerUserId ?? cookieUserId?.value;
}

async function getAnonymousUser(cookieJar: CookieJar): Promise<ExtendedUser> {
  const anonymousUserId = getAnonymousUserID();
  if (!anonymousUserId) {
    return await createAnonymousUser(cookieJar);
  } else {
    const foundUser = await userPrismaClient.user.findUnique({
      where: {
        id: anonymousUserId,
      },
    });

    // Verify that the found user has only one role and that that role is Anonymous Patient
    if (
      foundUser &&
      foundUser.roles.length === 1 &&
      isUserAuthorized(foundUser, [UserRole.ANONYMOUS_PATIENT])
    ) {
      return foundUser;
    }

    return await createAnonymousUser(cookieJar);
  }
}

async function getUserFromDB(userId: string): Promise<ExtendedUser> {
  const userToReturn = await userPrismaClient.user.findUnique({
    where: {
      id: userId,
    },
    include: { medicalProfile: true },
  });
  if (userToReturn) {
    return userToReturn;
  } else {
    throw new Error('No user found for request');
  }
}

async function verifyTOTPToken(
  cortinaTOTPToken: string
): Promise<ExtendedUser | null> {
  const startTime = Date.UTC(2001, 7, 17, 3, 21, 0);
  const currentTime = new Date().getTime();
  const quantizedTime = 30000;
  const TOTPIndex = Math.floor((currentTime - startTime) / quantizedTime);
  const TOTPIndexPlus = Math.floor(
    (currentTime + 30000 - startTime) / quantizedTime
  );
  const TOTPIndexMinus = Math.floor(
    (currentTime - 30000 - startTime) / quantizedTime
  );

  const splitReceivedTOTP = cortinaTOTPToken.split('_');

  const userId = splitReceivedTOTP[1];
  const receivedTOTPHash = splitReceivedTOTP[0];

  const userFromDB = await getUserFromDB(userId);

  if (!userFromDB.retoolSid) {
    throw new Error('User has no external access key');
  }

  const sidHash = crypto
    .createHash('sha512')
    .update(userFromDB.retoolSid)
    .digest('hex');

  const hashesToCheck = [
    crypto
      .createHash('sha512')
      .update(sidHash + '_' + TOTPIndex)
      .digest('hex'), // current
    crypto
      .createHash('sha512')
      .update(sidHash + '_' + TOTPIndexPlus)
      .digest('hex'), // future
    crypto
      .createHash('sha512')
      .update(sidHash + '_' + TOTPIndexMinus)
      .digest('hex'), // past
  ];

  if (hashesToCheck.includes(receivedTOTPHash)) return userFromDB;

  return null;
}

export async function getUserInfo(
  request: NextRequest,
  cookieJar: CookieJar
): Promise<ExtendedUser> {
  const reqHeaders = headers();
  const cortinaTOTPToken = reqHeaders.get('cortinaKey');

  if (cortinaTOTPToken) {
    const TOTPUser = await verifyTOTPToken(cortinaTOTPToken);

    if (TOTPUser) {
      return TOTPUser;
    }
  }

  const session = await getSessionUserInfo(request);

  if (!isSessionUserInfoSuccessResponse(session)) {
    return await getAnonymousUser(cookieJar);
  } else {
    // Link current anonymous user to new cognito ID
    if (!session.user.cortinaId) {
      return await createOrLinkUserFromSessionuser(session.user);
    }
    // Ignore any previous anonymous user because session user already has an ID
    else {
      const userToReturn = await userPrismaClient.user.findUnique({
        where: {
          id: session.user.cortinaId,
        },
        include: {
          partner: true,
          medicalProfile: true,
          dependents: {
            include: {
              medicalProfile: true,
            },
          },
        },
      });

      if (!userToReturn) {
        return await createOrLinkUserFromSessionuser(session.user);
      } else {
        const anonymousUserID = getAnonymousUserID();
        if (anonymousUserID && userToReturn.id !== anonymousUserID)
          await transferExistingCartsToNewUser(
            anonymousUserID,
            userToReturn.id
          );
      }

      const forFamilyMember = getUserFamilyMemberID();

      try {
        if (
          forFamilyMember &&
          userToReturn.dependents.some(
            (dependent) => dependent.id === forFamilyMember
          )
        ) {
          const familyMemberToReturn = await userPrismaClient.user.findUnique({
            where: {
              id: forFamilyMember,
            },
            include: { medicalProfile: true, guardian: true },
          });

          if (familyMemberToReturn) return familyMemberToReturn;
        }
      } catch (error) {
        await LoggerUtil.logError(
          'error_getting_family_member',
          'getUserInfo',
          error,
          {
            familyMemberHeader: forFamilyMember,
            userId: userToReturn.id,
          }
        );
      }

      return userToReturn;
    }
  }
}

export function isUserAuthorized(user: User, roles: UserRole[]): boolean {
  return user.roles.some((ur) => roles.some((r) => r === ur));
}

export const mapProfileToUser = (profile: any): NextAuthUser => {
  return {
    id: profile.sub, // profile requires an id
    sub: profile.sub,
    name: profile.name,
    email: profile.email,
    image: profile.picture,
    identities: profile.identities ?? [],
    userName: profile['cognito:username'],
    cortinaId: profile['custom:cortina_id'],
  };
};

const validateUserOrThrow = (user: NextAuthUser) => {
  if (!user.email) throw new Error('User email is missing');
};

const getErrorResponse = (
  message: string,
  req: NextRequest,
  error?: any
): NextResponse => {
  return ApiErrorHandler.handleUnauthorizedError({
    message: message,
    reqUrl: req.url,
    reqHeaders: req.headers,
    error: error,
  });
};

const transferExistingCartsToNewUser = async (
  anonymousUserID: string,
  sessionUserId: string
) => {
  const anonymousUserCart = await userPrismaClient.cart.findUnique({
    where: {
      userId: anonymousUserID,
    },
    include: {
      _count: {
        select: {
          cartProducts: true,
          cartSubscriptionProducts: true,
        },
      },
    },
  });

  if (
    !anonymousUserCart ||
    (anonymousUserCart._count.cartProducts < 1 &&
      anonymousUserCart._count.cartSubscriptionProducts < 1)
  )
    return;

  const sessionUserCart = await userPrismaClient.cart.findUnique({
    where: {
      userId: sessionUserId,
    },
    include: {
      _count: {
        select: {
          cartProducts: true,
          cartSubscriptionProducts: true,
        },
      },
    },
  });

  let hasExistingCart = !!sessionUserCart;

  const cartHasProducts =
    !!sessionUserCart &&
    (sessionUserCart._count.cartProducts > 0 ||
      sessionUserCart._count.cartSubscriptionProducts > 0);

  if (hasExistingCart && !cartHasProducts) {
    await userPrismaClient.cart.delete({
      where: {
        userId: sessionUserId,
      },
    });

    hasExistingCart = false;
  }

  if (!hasExistingCart) {
    await userPrismaClient.cart.updateMany({
      where: {
        userId: anonymousUserID,
      },
      data: {
        userId: sessionUserId,
      },
    });
  }
};

const getPartnerIfExists = async (sessionUser: NextAuthUser) => {
  const partnerIdentity =
    sessionUser.identities && sessionUser.identities.length === 1
      ? sessionUser.identities[0]
      : undefined;

  if (partnerIdentity) {
    const partners = await userPrismaClient.partner.findMany();

    const foundPartner = partners.find(
      (x) => x.cognitoId === partnerIdentity.providerName
    );

    if (foundPartner) return foundPartner;
  }

  return undefined;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/location/countryChecker.ts

import axios, { Axios, HttpStatusCode } from 'axios';

import LoggerUtil from '../clients/logging/apiUtilLogger';

export const getUserCountry = async (): Promise<string> => {
  try {
    const response = await axios.get('https://api.country.is');

    if (response.status === HttpStatusCode.Ok) {
      return response.data?.country ?? 'US';
    }

    // fallback to US in case the service has issues
    return 'US';
  } catch (error) {
    await LoggerUtil.logError(
      'failed_country_lookup_by_ip',
      'getUserCountry',
      error,
      {}
    );
    // fallback to US in case the service has issues
    return 'US';
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/dependents/dependentUsersUtilities.ts

import { User } from '@prisma/client';

import { prisma } from '../clients/mongo/prismaClient';

export async function getDependentUsers(user: User): Promise<User[]> {
  return await prisma.user.findMany({
    where: {
      guardianId: user.id,
    },
  });
}

export async function getGuardianUser(user: User): Promise<User | null> {
  if (!user.guardianId) return null;

  return await prisma.user.findUnique({
    where: {
      id: user.guardianId,
    },
  });
}

export async function getUserFamily(user: User): Promise<User[]> {
  // If the user has a guardian, then get the guardian's dependents + the guardian to get the family
  const guardian = await getGuardianUser(user);

  if (guardian) {
    const guardianDependents = await getDependentUsers(guardian);
    guardianDependents.push(guardian);
    return guardianDependents;
  }

  // If the user has no guardian, then they are the guardian and we just get their dependents and them add them back to the array
  const family = await getDependentUsers(user);
  family.push(user);

  return family;
}

export async function getFamilyIDs(user: User): Promise<string[]> {
  const family = await getUserFamily(user);

  const familyIDs = [];
  for (const familyMember of family) {
    familyIDs.push(familyMember.id);
  }

  return familyIDs;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/responses/responseHelpers.ts

import { ResponseCookie } from 'next/dist/compiled/@edge-runtime/cookies';
import { NextResponse } from 'next/server';

import HttpStatusCode from '@utils/statusCodes';

export class CookieJar {
  cookies: ResponseCookie[] = [];
}

export const createCookieResponse = (
  message: any,
  cookieJarToSend: CookieJar,
  responseCode: HttpStatusCode = HttpStatusCode.OK
): NextResponse => {
  const response = NextResponse.json(message, { status: responseCode });

  cookieJarToSend.cookies.forEach((cookie) => {
    response.cookies.set(cookie);
  });

  return response;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/cases/checkCaseNeedsAttention.ts

import { Address, Case, Message, Thread, User } from '@prisma/client';

export enum AttentionReasonEnum {
  PATIENT_AWAITING_REPLY,
  CASE_SUB_PAST_DUE,
  ORDER_ERROR,
  OVER_SLA,
}

type CheckCaseAttentionProps = Case & {
  thread: (Pick<Thread, 'id'> & {
    messages: Message[];
  })[];
  user: Pick<User, 'id' | 'firstName' | 'lastName' | 'avatarUrl'> & {
    addresses: Pick<Address, 'default' | 'state'>[];
  };
};

interface NeedsAttentionReason {
  reasonCode?: AttentionReasonEnum;
  reasonMessage: string;
}

export type NeedsAttentionResult =
  | {
      needsAttention: true;
      reasons: NeedsAttentionReason[];
    }
  | {
      needsAttention: false;
    };

export const checkCaseNeedsAttention = (
  caseProps: CheckCaseAttentionProps
): NeedsAttentionResult => {
  let needsAttention = false;
  const reasons: NeedsAttentionReason[] = [];

  const patientAwaitingReply = checkPatientAwaitingReply(caseProps);

  if (patientAwaitingReply) {
    needsAttention = true;
    reasons.push(patientAwaitingReply);
  }

  //TODO check other things on the case that would require a physician attention

  if (needsAttention)
    return {
      needsAttention: true,
      reasons: reasons,
    };

  return {
    needsAttention: false,
  };
};

const checkPatientAwaitingReply = (caseProps: CheckCaseAttentionProps) => {
  // should never happen, just here to make TS feel good
  if (!caseProps.physicianId) return null;

  const userHasMessagesToCheck = caseProps.thread[0]?.messages?.length > 0;

  const hasUserReadLatestMessage = userHasMessagesToCheck
    ? caseProps.thread[0].messages[0].readByIds?.includes(caseProps.physicianId)
    : true;

  if (!hasUserReadLatestMessage) {
    return {
      reasonCode: AttentionReasonEnum.PATIENT_AWAITING_REPLY,
      reasonMessage: 'New unread message is available for this case.',
    };
  }

  return null;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/shipping/shippingUtils.ts

import moment from 'moment';
import { v4 } from 'uuid';

import {
  Address,
  CartProducts,
  CartSubscriptionProducts,
  Order,
  Product,
  Shipment,
  ShipmentStatus,
  ShippingCarrier,
  ShippingMethod,
  ShippingPartner,
  SubscriptionProduct,
  User,
  UserPrescriptions,
} from '@prisma/client';

import CurexaClient from '../clients/curexa/curexaClient';
import { reconcileUserPrescriptionsWithDosespotPrescriptions } from '../clients/dosespot/dosespotUtils';
import LoggerUtil from '../clients/logging/apiUtilLogger';
import { prisma } from '../clients/mongo/prismaClient';
import ShipheroClient from '../clients/shiphero/shipheroClient';

function checkRefills(prescription: UserPrescriptions): boolean {
  if (prescription.maxRefills) {
    // Check if we have refills. If not, just continue and maybe we have another prescription that matches that product
    if (prescription.refillDates.length < prescription.maxRefills) {
      return true;
    }
  } else {
    return true; // Can always refill if max refills not defined
  }
  return false;
}

function isProductInPrescriptionListAndOrderable(
  product: Product,
  userPrescriptions: UserPrescriptions[]
): UserPrescriptions | null {
  for (const prescription of userPrescriptions) {
    if (prescription.productId === product.id) {
      if (checkRefills(prescription)) return prescription;
    }
  }

  return null;
}

function isSubscriptionProductInPrescriptionList(
  subscriptionProduct: SubscriptionProduct,
  userPrescriptions: UserPrescriptions[]
): UserPrescriptions | null {
  for (const prescription of userPrescriptions) {
    if (prescription.productId === subscriptionProduct.id) {
      if (checkRefills(prescription)) return prescription;
    }
  }

  return null;
}

// Drug shipping info in Curexa's format
interface CurexaDrugShippingInfo {
  rx_id: string;
  medication_name: string;
  non_child_resistant_acknowledgement: boolean;
  quantity_dispensed: number;
  days_supply: number;
  prescribing_doctor: string;
  medication_sig: string;
}

// THIS IS THE SPECIAL HANDLING FOR CREATING A CUREXA SHIPMENT. ALL PRODUCTS ARE EXPECTED TO HAVE AN ASSOCIATED PRESCRIPTION
async function createCurexaShipment(
  user: User,
  order: Order,
  address: Address,
  products: Product[],
  subscriptionProducts: SubscriptionProduct[]
): Promise<Shipment> {
  // Determine if we've tried to make a shipment before
  const previousCurexaShippingAttempt = await prisma.shipment.findFirst({
    where: {
      orderId: order.id,
      shippingPartner: ShippingPartner.CUREXA,
    },
  });

  // If a previous shipment exists and its in anything excpet an error state, we stop here
  if (previousCurexaShippingAttempt) {
    if (
      previousCurexaShippingAttempt.shipmentStatus !== ShipmentStatus.FAILED &&
      previousCurexaShippingAttempt.shipmentStatus !== ShipmentStatus.CANCELLED
    ) {
      return previousCurexaShippingAttempt;
    }
  }

  // Create objects for storing whether or not we have an error
  const curexaID = v4(); // Create CurexaID
  let curexaPayload;

  try {
    // Create the shipment
    const userPrescriptions =
      await reconcileUserPrescriptionsWithDosespotPrescriptions(user);

    const curexaRxItems: CurexaDrugShippingInfo[] = [];

    for (const product of products) {
      // Make sure the product has an associated prescription and refills
      const foundPrescription = isProductInPrescriptionListAndOrderable(
        product,
        userPrescriptions
      );
      if (!foundPrescription) {
        throw new Error(`User has no valid prescription for ${product.name}`);
      }

      curexaRxItems.push({
        rx_id: foundPrescription.dosespotRxId,
        medication_name: foundPrescription.medicationName,
        non_child_resistant_acknowledgement: true,
        quantity_dispensed: foundPrescription.quantityDispensed,
        days_supply: foundPrescription.daysSupply,
        prescribing_doctor: foundPrescription.prescribingPhysicianName,
        medication_sig: foundPrescription.instructions,
      });
    }

    for (const subscriptionProduct of subscriptionProducts) {
      // Make sure the subscription product has an associated prescription and refills
      const foundPrescription = isSubscriptionProductInPrescriptionList(
        subscriptionProduct,
        userPrescriptions
      );
      if (!foundPrescription) {
        throw new Error(
          `User has no valid prescription for subscription of ${subscriptionProduct.name}`
        );
      }

      curexaRxItems.push({
        rx_id: foundPrescription.dosespotRxId,
        medication_name: foundPrescription.medicationName,
        non_child_resistant_acknowledgement: true,
        quantity_dispensed: foundPrescription.quantityDispensed,
        days_supply: foundPrescription.daysSupply,
        prescribing_doctor: foundPrescription.prescribingPhysicianName,
        medication_sig: foundPrescription.instructions,
      });
    }

    // We now have the body of Rx Items Create the shipment

    // let shippingCarrier: Carriers = Carriers.USPS;
    // let shippingMethod: ShippingMethods = ShippingMethods.USPS_FIRST_CLASS;

    const userMedicalProfile = await prisma.medicalProfile.findUnique({
      where: {
        userId: user.id,
      },
    });

    if (!userMedicalProfile) {
      throw new Error(
        'Cannot order prescription medication until user sets up medical profile'
      );
    }

    curexaPayload = {
      order_id: curexaID,
      patient_id: user.id,
      patient_first_name: user.firstName,
      patient_last_name: user.lastName,
      patient_dob: moment(userMedicalProfile.dob).format('YYYYMMDD'),
      carrier: ShippingCarrier.USPS,
      shipping_method: ShippingMethod.USPS_FIRST_CLASS,
      address_to_name: `${user.firstName} ${user.lastName}`,
      address_to_street1: address.address1,
      address_to_street2: address.address2,
      address_to_city: address.city,
      address_to_state: address.state,
      address_to_zip: address.zip,
      address_to_phone: user.phoneNumber,
      patient_known_allergies: 'None', // TODO: GET THIS FROM DOSESPOT
      patient_other_medications: 'None', // TODO: GET THIS FROM DOSEPOT
      rx_items: curexaRxItems,
    };

    // Create the shipment using Curexa Payload
    await CurexaClient.placeOrder(curexaPayload);

    // Now we've made the shipment, save into a shipment object
    if (previousCurexaShippingAttempt) {
      return await prisma.shipment.update({
        where: {
          id: previousCurexaShippingAttempt.id,
        },
        data: {
          orderId: order.id,
          shippingPartner: ShippingPartner.CUREXA,
          shippingCarrier: ShippingCarrier.USPS,
          shippingMethod: ShippingMethod.USPS_FIRST_CLASS,
          shipmentStatus: ShipmentStatus.PENDING,
          shippingAddress: address,
          rawShippingData: curexaPayload as any,
          shippingPartnerId: curexaID,
          userId: user.id,
          // TODO: ADD PRODUCTS AND SUBSCRIPTION PRODUCTS
        },
      });
    } else {
      return await prisma.shipment.create({
        data: {
          orderId: order.id,
          shippingPartner: ShippingPartner.CUREXA,
          shippingCarrier: ShippingCarrier.USPS,
          shippingMethod: ShippingMethod.USPS_FIRST_CLASS,
          shipmentStatus: ShipmentStatus.PENDING,
          shippingAddress: address,
          rawShippingData: curexaPayload as any,
          shippingPartnerId: curexaID,
          userId: user.id,
          // TODO: ADD PRODUCTS AND SUBSCRIPTION PRODUCTS
        },
      });
    }
  } catch (e) {
    await LoggerUtil.logError(
      'curexa_shipment_failed',
      'createCurexaShipment',
      e,
      {
        userId: user.id,
        orderId: order.id,
        shippingAddress: address,
        products,
        subscriptionProducts,
      }
    );

    // Return a failed shipment if there was an exception. The shipment will need to be recalculated
    if (previousCurexaShippingAttempt) {
      return await prisma.shipment.update({
        where: {
          id: previousCurexaShippingAttempt.id,
        },
        data: {
          orderId: order.id,
          shippingPartner: ShippingPartner.CUREXA,
          shippingCarrier: ShippingCarrier.USPS,
          shippingMethod: ShippingMethod.USPS_FIRST_CLASS,
          shipmentStatus: ShipmentStatus.FAILED,
          shippingAddress: address,
          userId: user.id,
          rawShippingData: curexaPayload as any,
          shippingPartnerId: curexaID,
        },
      });
    } else {
      return await prisma.shipment.create({
        data: {
          orderId: order.id,
          shippingPartner: ShippingPartner.CUREXA,
          shippingCarrier: ShippingCarrier.USPS,
          shippingMethod: ShippingMethod.USPS_FIRST_CLASS,
          shipmentStatus: ShipmentStatus.FAILED,
          shippingAddress: address,
          userId: user.id,
          rawShippingData: curexaPayload as any,
          shippingPartnerId: curexaID,
        },
      });
    }
  }
}

interface productsByShippingPartner {
  curexaProducts: Product[];
  shipHeroProducts: CartProducts[];
}

async function splitProductsByShippingPartner(
  cartProducts: CartProducts[] | null
): Promise<productsByShippingPartner> {
  const curexaProducts: Product[] = [];
  const shipHeroProducts: CartProducts[] = [];

  if (cartProducts) {
    for (const cartProduct of cartProducts) {
      const product = await prisma.product.findUnique({
        where: {
          id: cartProduct.productId,
        },
      });

      // TODO: Split by Ship Hero As Well
      if (product && product.shippingPartner === ShippingPartner.CUREXA) {
        curexaProducts.push(product);
      } else if (
        product &&
        product.shippingPartner === ShippingPartner.SHIP_HERO
      ) {
        shipHeroProducts.push(cartProduct);
      }
    }
  }

  return {
    curexaProducts,
    shipHeroProducts,
  };
}

interface subscriptionProductsByShippingPartner {
  curexaSubscriptionProducts: SubscriptionProduct[];
  shipHeroSubscriptionProducts: CartSubscriptionProducts[];
}

async function splitSubscriptionProductsByShippingPartner(
  cartSubscriptionProducts: CartSubscriptionProducts[] | null
): Promise<subscriptionProductsByShippingPartner> {
  const curexaSubscriptionProducts: SubscriptionProduct[] = [];
  const shipHeroSubscriptionProducts: CartSubscriptionProducts[] = [];

  if (cartSubscriptionProducts) {
    for (const cartSubscriptionProduct of cartSubscriptionProducts) {
      const subscriptionProduct = await prisma.subscriptionProduct.findUnique({
        where: {
          id: cartSubscriptionProduct.subscriptionProductId,
        },
      });

      // TODO: Split by Ship Hero As Well
      if (
        subscriptionProduct &&
        subscriptionProduct.shippingPartner === ShippingPartner.CUREXA
      ) {
        curexaSubscriptionProducts.push(subscriptionProduct);
      } else if (
        subscriptionProduct &&
        subscriptionProduct.shippingPartner === ShippingPartner.SHIP_HERO
      ) {
        shipHeroSubscriptionProducts.push(cartSubscriptionProduct);
      }
    }
  }

  return {
    curexaSubscriptionProducts,
    shipHeroSubscriptionProducts,
  };
}

// All shipments go through this function. Subscription shipments only happen on initial purchase or renewal, so an order is always associated with a shipment
export async function shipOrder(
  user: User,
  order: Order,
  address: Address,
  cartProducts: CartProducts[] | null,
  cartSubscriptionProducts: CartSubscriptionProducts[] | null
): Promise<Shipment[]> {
  // Split by shipping providers

  const productsByShippingPartner: productsByShippingPartner =
    await splitProductsByShippingPartner(cartProducts);
  const subscriptionProductsByPartner: subscriptionProductsByShippingPartner =
    await splitSubscriptionProductsByShippingPartner(cartSubscriptionProducts);

  const shipments: Shipment[] = [];

  address.name = `Order: ${order.id} Shipping Address`;
  address.default = false;

  // Return the shipment whether or not it failed
  if (
    productsByShippingPartner.curexaProducts.length > 0 ||
    subscriptionProductsByPartner.curexaSubscriptionProducts.length > 0
  ) {
    const curexaShipment = await createCurexaShipment(
      user,
      order,
      address,
      productsByShippingPartner.curexaProducts,
      subscriptionProductsByPartner.curexaSubscriptionProducts
    );
    shipments.push(curexaShipment);
  }

  // Create Ship hero shipment
  if (
    productsByShippingPartner.shipHeroProducts.length > 0 ||
    subscriptionProductsByPartner.shipHeroSubscriptionProducts.length > 0
  ) {
    const shipHeroShipment = await ShipheroClient.createOrder(
      address,
      user,
      order,
      productsByShippingPartner.shipHeroProducts,
      subscriptionProductsByPartner.shipHeroSubscriptionProducts
    );

    shipHeroShipment && shipments.push(shipHeroShipment);
  }

  return shipments;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/validations/zodJsonValidate.ts

import { z } from 'zod';

const literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);
type Literal = z.infer<typeof literalSchema>;
type Json = Literal | { [key: string]: Json } | Json[];
const jsonSchema: z.ZodType<Json> = z.lazy(() =>
  z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])
);

export const zodJsonValidate =
  <T>(schema: z.ZodType<T>) =>
  (json: Json): T | null => {
    try {
      return schema.parse(json);
    } catch (error) {
      return null;
    }
  };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/requests/getUserAndCheckAuthorized.ts

import { NextRequest, NextResponse } from 'next/server';

import { ExtendedUser } from '@/app/shared/models/extensions/identity/types/identityTypes';
import { UserRole } from '@prisma/client';

import { getUserInfo, isUserAuthorized } from '../auth/auth';
import { ApiErrorHandler } from '../errors';
import { ErrorNextResponse } from '../errors/apiErrorHandler';
import { CookieJar } from '../responses/responseHelpers';

interface UserIsAuthorizedParams {
  request: NextRequest;
  authMethod?: (...authParams: any[]) => Promise<boolean>;
  beforeUserParams?: any[];
  afterUserParams?: any[];
  roleAccess?: UserRole[];
  customErrorMessage?: string;
}

interface UserIsAuthorizedResult {
  success: true;
  user: ExtendedUser;
  cookieJar: CookieJar;
}

interface UserIsNotAuthorizedResult {
  success: false;
  unAuthorizedResponse: NextResponse<ErrorNextResponse>;
}

type UserIsAuthorizedResultType =
  | UserIsAuthorizedResult
  | UserIsNotAuthorizedResult;

export const getUserAndCheckAuthorized = async (
  props: UserIsAuthorizedParams
): Promise<UserIsAuthorizedResultType> => {
  const {
    request,
    authMethod,
    roleAccess,
    beforeUserParams,
    afterUserParams,
    customErrorMessage,
  } = props;

  const cookieJar: CookieJar = { cookies: [] };

  const user = await getUserInfo(request, cookieJar);

  if (roleAccess !== undefined && isUserAuthorized(user, roleAccess)) {
    return {
      success: true,
      user: user,
      cookieJar: cookieJar,
    };
  } else if (roleAccess !== undefined) {
    const error: Error = {
      message: `User does not have any of the required roles: (${roleAccess?.join(
        ', '
      )})`,
      name: 'failed_role_access_check',
      cause: {
        userId: user.id,
        userEmail: user.email,
        userRoles: user.roles,
        userRetoolSid: user.retoolSid,
        requiredRoles: roleAccess?.join(', '),
      },
    };

    return {
      success: false,
      unAuthorizedResponse: ApiErrorHandler.handleUnauthorizedError({
        message: customErrorMessage ? customErrorMessage : error.message,
        error: error,
        reqUrl: request.url,
        reqHeaders: request.headers,
      }),
    };
  }

  if (authMethod !== undefined) {
    const authParams: any[] = beforeUserParams ? beforeUserParams : [];
    authParams.push(user);
    if (afterUserParams) authParams.push(...afterUserParams);

    const userIsAuthorized = await authMethod(...authParams);

    if (!userIsAuthorized)
      return {
        success: false,
        unAuthorizedResponse: ApiErrorHandler.handleUnauthorizedError({
          message: customErrorMessage
            ? customErrorMessage
            : 'You are not authorized to perform this action.',
          reqUrl: request.url,
          reqHeaders: request.headers,
          error: {
            name: 'api_unauthorized_per_' + authMethod.name,
            message:
              'User is not authorized to access this resource per policy ' +
              authMethod.name,
            cause: {
              function: authMethod.name,
              beforeUserParams,
              afterUserParams,
            },
          },
        }),
      };

    return {
      success: true,
      user: user,
      cookieJar: cookieJar,
    };
  }

  return {
    success: true,
    user: user,
    cookieJar: cookieJar,
  };
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/requests/getSafeTypedBody.ts

import { NextRequest } from 'next/server';
import { ZodError, z } from 'zod';

import { ApiErrorHandler } from '../errors';
import HttpStatusCode from '../statusCodes';
import {
  SafeTypedError,
  SafeTypedErrorType,
  SafeTypedResult,
} from './safeTypedResultTypes';

export const getSafeTypedBody = async <T>(
  request: NextRequest,
  schema: z.Schema<T>,
  requestBodyText?: string
): Promise<SafeTypedResult<T> | SafeTypedError> => {
  const txtBody = requestBodyText ?? (await request.text());

  try {
    const jsonData = JSON.parse(txtBody);

    const parsedBody = schema.parse(jsonData);

    return {
      success: true,
      value: parsedBody,
    };
  } catch (error) {
    let errorMessage = (error as Error).message;

    if (error instanceof ZodError) {
      errorMessage = error.issues
        .map(
          (issue) => (issue.path[0] ? issue.path[0] + ': ' : '') + issue.message
        )
        .join(' | ');
    }

    return {
      success: false,
      failureType: SafeTypedErrorType.INVALID,
      error: errorMessage,
      errorResponse: ApiErrorHandler.handleCatchAllError({
        error: error,
        reqUrl: request.url,
        reqHeaders: request.headers,
        code: HttpStatusCode.BAD_REQUEST,
      }),
    };
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/requests/getSafeQueryParam.ts

import { NextRequest } from 'next/server';
import { z } from 'zod';

import { ApiErrorHandler } from '../errors';
import {
  SafeTypedError,
  SafeTypedErrorType,
  SafeTypedResult,
} from './safeTypedResultTypes';

export const getSafeQueryParam = async <T>(
  request: NextRequest,
  schema: z.Schema<T>,
  paramName: string,
  parseJSON = false,
  logError = true
): Promise<SafeTypedResult<T> | SafeTypedError> => {
  const paramExists = request.nextUrl.searchParams.has(paramName);

  if (!paramExists)
    return {
      success: false,
      failureType: SafeTypedErrorType.MISSING,
      error: `Query parameter ${paramName} is missing.`,
      errorResponse: ApiErrorHandler.handleBadRequest({
        message: `Query parameter ${paramName} is missing.`,
        reqUrl: request.url,
        reqHeaders: request.headers,
        logError: logError,
      }),
    };

  const queryParam = request.nextUrl.searchParams.get(paramName);

  if (!queryParam) throw new Error('queryParam is undefined'); // Satisfying TS, this should never happen

  try {
    if (parseJSON) {
      const jsonData = JSON.parse(queryParam);

      return {
        success: true,
        value: schema.parse(jsonData),
      };
    }

    return {
      success: true,
      value: schema.parse(queryParam),
    };
  } catch (error) {
    return {
      success: false,
      failureType: SafeTypedErrorType.INVALID,
      error: `Query parameter ${paramName} is invalid.`,
      errorResponse: ApiErrorHandler.handleBadRequest({
        message: (error as Error).message,
        error: error,
        reqUrl: request.url,
        reqHeaders: request.headers,
      }),
    };
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/requests/checkBodyForParams.ts

import { NextRequest, NextResponse } from 'next/server';

import { ApiErrorHandler } from '../errors';
import { SafeRequestBody } from '../requests/getSafeRequestBody';

interface BodyParamsCheckResultSuccess {
  success: true;
}

interface BodyParamsCheckResultWithBadRequestResponse {
  success: false;
  badRequestResponse: NextResponse;
}

export type BodyParamsCheckResult =
  | BodyParamsCheckResultSuccess
  | BodyParamsCheckResultWithBadRequestResponse;

export interface BodyParam {
  prop: string;
  validator?: (param: any) => boolean;
  orProps?: string[]; // this field or the prop field must be presents
}

export const checkBodyForParams = async (
  request: NextRequest,
  safeBody: SafeRequestBody,
  params: BodyParam[]
): Promise<BodyParamsCheckResult> => {
  let paramMissing = false;
  let paramInvalid = false;

  params.forEach((param) => {
    if (!safeBody.jsonBody[param.prop]) {
      if (!param.orProps) {
        paramMissing = true;
      } else {
        let found = false;
        param.orProps.forEach((orProp) => {
          if (safeBody.jsonBody[orProp]) {
            found = true;
          }
        });
        if (!found) {
          paramMissing = true;
        }
      }
    } else {
      if (param.validator && !param.validator(safeBody.jsonBody[param.prop])) {
        paramInvalid = true;
      }
    }
  });

  if (paramMissing || paramInvalid) {
    const message = paramMissing
      ? 'Missing one or more required parameter(s): ' + params.join(', ')
      : 'One or more parameters are invalid: ' + params.join(', ');

    const badRequestResponse = ApiErrorHandler.handleBadRequest({
      message: message,
      reqUrl: request.url,
      reqBody: safeBody.txtBody,
    });

    return {
      success: false,
      badRequestResponse: badRequestResponse,
    };
  } else {
    return { success: true };
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/requests/getSafeRequestBody.ts

import { NextRequest, NextResponse } from 'next/server';

import { ApiErrorHandler } from '../errors';

export interface SafeRequestBodyValid {
  isValidJson: true;
  txtBody: string;
  jsonBody?: any;
}
export interface SafeRequestBodyInvalid {
  isValidJson: false;
  txtBody: string;
  jsonBody?: any;
  badRequestResponse: NextResponse;
}

export type SafeRequestBody = SafeRequestBodyValid | SafeRequestBodyInvalid;

export const getSafeRequestBody = async (
  req: NextRequest
): Promise<SafeRequestBody> => {
  const txtBody = await req.text();

  try {
    const jsonBody = JSON.parse(txtBody);

    return {
      isValidJson: true,
      jsonBody: jsonBody,
      txtBody: txtBody,
    };
  } catch (error) {
    const badRequestResponse = ApiErrorHandler.handleBadRequest({
      message: 'Malformed JSON body.',
      reqUrl: req.url,
      reqBody: txtBody,
      error,
    });

    return {
      isValidJson: false,
      txtBody: txtBody,
      badRequestResponse: badRequestResponse,
    };
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/requests/safeTypedResultTypes.ts

import { NextResponse } from 'next/server';

import { ErrorNextResponse } from '../errors/apiErrorHandler';

export enum SafeTypedErrorType {
  MISSING,
  INVALID,
  BAD_JSON,
}

export interface SafeTypedResult<T> {
  success: true;
  value: T;
}

export interface SafeTypedError {
  success: false;
  failureType: SafeTypedErrorType;
  error: string;
  errorResponse: NextResponse<ErrorNextResponse>;
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/prismic/prismic.ts

import { notFound } from 'next/navigation';
import {
  AccountNavigationDocument,
  AccountNextStepsSectionDocument,
  AllDocumentTypes,
  BillingDocument,
  BlogAdCardDocument,
  BlogAuthorDocument,
  BlogNewsletterDocument,
  FooterDocument,
  FormDocument,
  GlobalBannerDocument,
  HelpFooterDocument,
  HelpHeaderDocument,
  NavigationDocument,
  OrderHistoryDocument,
  ShopCartDocument,
  SubscriptionsDocument,
} from 'prismicio-types';

import { createClient } from '@/prismicio';
import * as prismic from '@prismicio/client';
import { PrismicCustomType, PrismicPageType } from '@utils/prismic/enums';

type CustomTypes =
  | NavigationDocument
  | FooterDocument
  | AccountNavigationDocument
  | AccountNextStepsSectionDocument
  | BillingDocument
  | FormDocument
  | SubscriptionsDocument
  | ShopCartDocument
  | OrderHistoryDocument
  | HelpFooterDocument
  | HelpHeaderDocument
  | BlogAdCardDocument
  | BlogAuthorDocument
  | BlogNewsletterDocument
  | GlobalBannerDocument;

type MetaDataTypes = Exclude<AllDocumentTypes, CustomTypes>;

const prismicPageToMetadata = (
  page: AllDocumentTypes,
  relativePath?: string
) => {
  // Exclude non page types
  if (page.type in PrismicCustomType) {
    return {};
  }
  let relativeUrl = new URL(`${process.env.NEXT_PUBLIC_BASE_URL}`);
  if (relativePath) {
    relativeUrl = new URL(`${process.env.NEXT_PUBLIC_BASE_URL}${relativePath}`);
  }

  const meta = page as MetaDataTypes;
  return {
    metadataBase: new URL(
      process.env.NEXT_PUBLIC_BASE_URL ?? 'http://localhost:3000'
    ),
    alternates: {
      canonical: relativeUrl,
    },
    title: meta.data.meta_title,
    description: meta.data.meta_description,
    openGraph: {
      title: meta.data.meta_title,
      description: meta.data.meta_description,
      images: prismic.asImageSrc(meta.data.meta_image),
      locale: 'en_US',
      type: 'website',
      url: relativeUrl,
      siteName: 'Cortina Health',
    },
    twitter: {
      cardType: 'summary_large_image',
      site: '@getcortina',
      title: meta.data.meta_title,
      description: meta.data.meta_description,
      image: prismic.asImageSrc(meta.data.meta_image),
    },
    additionalMetaTags: [
      {
        property: 'og:url',
        content: relativeUrl.toString(),
      },
      {
        property: 'og:type',
        content: 'website',
      },
      {
        property: 'og:site_name',
        content: 'Cortina Health',
      },
      {
        property: 'og:locale',
        content: 'en_US',
      },
      {
        property: 'twitter:creator',
        content: '@getcortina',
      },
    ],
  };
};

const queryPage = async (pageType: PrismicPageType, uid?: string) => {
  const client = createClient();

  if (uid) {
    return await client.getByUID(pageType, uid).catch(() => notFound());
  } else {
    return await client.getSingle(pageType).catch(() => notFound());
  }
};

type NavigationItem =
  prismic.ContentRelationshipField<PrismicCustomType.NAVIGATION>;

export const queryNavigationItems = async (
  initialNavigation: NavigationItem,
  scrollNavigation: NavigationItem
) => {
  try {
    if (
      prismic.isFilled.contentRelationship(initialNavigation) &&
      prismic.isFilled.contentRelationship(scrollNavigation)
    ) {
      const [initialNavigationData, scrollNavigationData, footer] =
        await Promise.all([
          queryMenuData(initialNavigation),
          queryMenuData(scrollNavigation),
          getFooter(),
        ]);

      return {
        initialNavigationData,
        scrollNavigationData,
        footer,
      };
    }
  } catch (error) {
    return {
      initialNavigationData: null,
      scrollNavigationData: null,
      footer: null,
    };
  }

  return {
    initialNavigationData: null,
    scrollNavigationData: null,
    footer: null,
  };
};

const getFooter = async () => {
  const client = createClient();

  return await client
    .getSingle<FooterDocument>(PrismicCustomType.FOOTER)
    .catch(() => null);
};

const queryMenuData = async (
  linkedItem: prismic.ContentRelationshipField<PrismicCustomType.NAVIGATION>
) => {
  if (!prismic.isFilled.contentRelationship(linkedItem) || !linkedItem?.uid)
    return null;

  const client = createClient();

  return await client
    .getByUID<NavigationDocument>(linkedItem.type, linkedItem.uid)
    .catch(() => notFound());
};

type DocumentData<
  TDocumentType extends prismic.Content.AllDocumentTypes['type']
> = Extract<prismic.Content.AllDocumentTypes, { type: TDocumentType }>['data'];

function isFilledRelatedData<
  TDocumentType extends prismic.Content.AllDocumentTypes['type'],
  TFieldID extends keyof DocumentData<TDocumentType>
>(
  linkField: prismic.LinkField,
  documentType: TDocumentType,
  fieldID: TFieldID
): linkField is prismic.FilledContentRelationshipField & {
  data: {
    [P in keyof DocumentData<TDocumentType> as P extends TFieldID
      ? P
      : never]: DocumentData<TDocumentType>[P];
  };
} {
  return (
    prismic.isFilled.contentRelationship(linkField) &&
    linkField.type === documentType &&
    typeof linkField.data === 'object' &&
    linkField.data !== null &&
    fieldID in linkField.data
  );
}

export { isFilledRelatedData, prismicPageToMetadata, queryPage };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/prismic/enums.ts

export enum PrismicPageType {
  HOME = 'home',
  PAGE = 'page',
  BLOG_HOME = 'bloghome',
  BLOG_POST = 'blogpost',
  BLOG_CATEGORY = 'blogcategory',
  BLOG_SEARCH = 'blog_search',
  HELP_HOME = 'help_home',
  HELP_COLLECTION = 'help_collection',
  HELP_ARTICLE = 'help_article',
  BLOG_AUTHOR = 'blogauthor',
  ACCOUNT_HOME = 'accounthome',
  ACCOUNT_PAGE = 'accountpage',
  MESSAGING_PAGE = 'messagingpage',
  CONCIERGE_PAGE = 'conciergeaccountpage',
  PRODUCT_PAGE = 'product_page',
  SHOP_PAGE = 'shop_page',
  SHOP_HOME = 'shop_home',
  CASES_PAGE = 'cases_page',
  ESTHETICIAN_PAGE = 'esthetician_page',
  BLOG_TAG = 'blog_tag',
  SIGNIN = 'signin',
}

export enum PrismicCustomType {
  NAVIGATION = 'navigation',
  FOOTER = 'footer',
  ACCOUNT_NAVIGATION = 'account_navigation',
  ACCOUNT_NEXT_STEPS = 'account_next_steps_section',
  BILLING = 'billing',
  FORM = 'form',
  SUBSCRIPTIONS = 'subscriptions',
  SHOPCART = 'shop_cart',
  ORDERHISTORY = 'order_history',
  HELP_FOOTER = 'help_footer',
  HELP_HEADER = 'help_header',
  BLOG_AD_CARD = 'blog_ad_card',
  BLOG_AUTHOR = 'blog_author',
  BLOG_NEWSLETTER = 'blog_newsletter',
  GLOBAL_BANNER = 'global_banner',
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/submission-helpers/create-case.ts

import { ExtendedUser } from '@/app/shared/models/extensions/identity/types/identityTypes';
import {
  CaseStatus,
  MessageStatus,
  ThreadAction,
  ThreadStatus,
  ThreadType,
} from '@prisma/client';

import { prisma } from '../clients/mongo/prismaClient';
import { transformUploadToMediaType } from '../file-upload/upload-helpers';
import { redeemConsultation } from '../helpers/helpers';
import { SubmitFamilyIntakeType, SubmitSelfIntakeType } from './zod-schemas';

export const createCase = async (
  user: ExtendedUser,
  data: SubmitFamilyIntakeType | SubmitSelfIntakeType,
  complaint?: string
) => {
  const conditionMedia = transformUploadToMediaType(
    data.conditionMedia as any[]
  );

  // Redeem a consultation if this is a new case
  const availableConsultationId = await redeemConsultation(user);

  if (!availableConsultationId) {
    throw new Error('No available consultation found');
  }

  const newCase = await prisma.case.create({
    data: {
      complaint: complaint ?? '',
      userId: user.id,
      status: CaseStatus.OPEN,
      redeemedProductId: availableConsultationId,
      media: conditionMedia,
      thread: {
        create: [
          {
            user: { connect: { id: user.id } },
            type: ThreadType.MEDICAL,
            messages: {
              create: [
                {
                  fromUserId: user.id,
                  status: MessageStatus.SENT,
                  content: data.doctorMessage ?? "I'm ready to chat!",
                  sentWhen: new Date(Date.now()),
                  readByIds: {
                    set: [user.id],
                  },
                },
              ],
            },
            lastMessageDate: new Date(Date.now()),
            status: ThreadStatus.ACTIVE,
            history: {
              create: {
                triggeredById: user.id,
                statusTo: ThreadStatus.ACTIVE,
                action: ThreadAction.CREATED,
              },
            },
          },
        ],
      },
      intakeForm: {
        formId: data.intakeForm.intakeFormID,
        questions: data.intakeForm.questions,
      },
    },
  });

  return newCase;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/submission-helpers/post-submit-events.ts

import { ExtendedUser } from '@/app/shared/models/extensions/identity/types/identityTypes';
import { User } from '@prisma/client';

import { prisma } from '../clients/mongo/prismaClient';
import SlackClient from '../clients/slack/slackClient';
import { UserEventNames } from '../user-events/enums';
import UserEventsClient from '../user-events/user-events-client';

export const postSubmitEvents = async (
  user: User | ExtendedUser,
  complaint = ''
) => {
  try {
    // Post submission events
    await UserEventsClient.addEvent(
      user,
      UserEventNames.DERMI_CONSULTATION_SUBMITTED,
      {}
    );

    await UserEventsClient.addEvent(
      user,
      UserEventNames.DERMI_CASE_STARTED,
      {}
    );

    await UserEventsClient.addEvent(
      user,
      UserEventNames.DERMI_COMPLAINT_PREFIX + complaint,
      {}
    );

    await UserEventsClient.addEvent(
      user,
      UserEventNames.DERMI_CASE_SUBMITTED,
      {}
    );

    // Log new case in slack
    if (process.env.ENVIRONMENT_NAME === 'production') {
      await SlackClient.logNewCase(user.email ?? 'unknown email');
    }

    // Clear user's form data
    await prisma.formData.updateMany({
      where: {
        userId: { equals: user.id },
      },
      data: {
        archived: true,
      },
    });
  } catch (error) {
    // Don't fail submission on eventing errors
    console.log('Error in postSubmissionProcessing', error);
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/submission-helpers/setup-dosespot-user.ts

import { ExtendedUser } from '@/app/shared/models/extensions/identity/types/identityTypes';

import DosespotClient from '../clients/dosespot/dosespotClient';
import { DoseSpotUser } from '../clients/dosespot/dosespotUtils';

export const setupDoseSpotUser = async (
  user: ExtendedUser,
  dsPayload: DoseSpotUser,
  pharmacyId?: string
) => {
  // Push user data to DoseSpot
  const dsResult = await DosespotClient.pushUserDataToDoseSpot(dsPayload, user);

  if (!dsResult.success && !dsResult.error.shouldContinue) {
    throw new Error(dsResult.error.errorMessage);
  }

  const dosespotId =
    user.dosespotId ??
    (dsResult.success ? dsResult.patientDoseSpotId : undefined);

  if (dosespotId) {
    // Add the default pharmacy for the user
    await DosespotClient.addPatientPharmacy(
      dosespotId,
      process.env.DEFAULT_PHARMACY_ID || '14973'
    );
  }

  // Add the selected pharmacy for the user
  if (pharmacyId && dosespotId) {
    await DosespotClient.addPatientPharmacy(dosespotId, pharmacyId);
  }

  return dosespotId;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/submission-helpers/zod-schemas.ts

import { z } from 'zod';

import { SexAtBirthEnum } from '@prisma/client';
import { validateUSPhoneNumber } from '@prisma/custom-validators/phoneNumberValidation';
import {
  AddressCreateInputSchema,
  FormAnswerTypeSchema,
  InputJsonValueSchema,
  UserSchema,
} from '@prisma/generated/zod';

const typesToCoerceToString = z.union([z.string(), z.number(), z.boolean()]);

const stringCoercion = typesToCoerceToString
  .transform((val) => {
    return String(val);
  })
  .pipe(z.coerce.string())
  .refine(
    (val) => {
      return typeof val === 'string';
    },
    { message: 'Coercion to string failed' }
  );

const fileUploadSchema = z.object({
  id: z.string().optional(),
  file: z.any().optional(),
  size: z.number().optional(),
  name: z.string().optional(),
  type: z.string().optional(),
  status: z.string().optional(),
  s3Url: z.string().optional(),
});

const pharmacySchema = z.object({
  PharmacyId: z.number(),
});

const intakeFormSchema = z.object({
  intakeFormID: z.string(),
  questions: z
    .object({
      question: z.string(),
      answerSingle: stringCoercion.optional().nullable(),
      answerObject: InputJsonValueSchema.optional().nullable(),
      answerArray: stringCoercion.array().optional(),
      answerObjects: InputJsonValueSchema.array().optional(),
      answerType: FormAnswerTypeSchema,
    })
    .array(),
});

export const submitSelfIntakeSchema = z.object({
  firstName: z.string(),
  lastName: z.string(),
  phoneNumber: z.string().refine((val) => validateUSPhoneNumber(val)),
  addresses: AddressCreateInputSchema.array(),
  sexAtBirth: z.nativeEnum(SexAtBirthEnum),
  dob: z.coerce.date(),
  skinType: z.string(),
  skinProfile: z.string(),
  condition: z.string().optional(),
  complaint: z.string().optional(),
  medicalConditions: z.string().optional(),
  medications: z
    .object({
      DispensableDrugId: z.number().optional().nullable(),
    })
    .array()
    .optional(),
  allergies: z
    .object({
      AllergenId: z.number().optional().nullable(),
    })
    .array()
    .optional(),
  primaryCarePhysicianName: z.string().optional(),
  primaryCarePhysicianAddress: AddressCreateInputSchema.optional(),
  doctorMessage: z.string().optional(),
  conditionMedia: z.array(fileUploadSchema),
  patientMedia: z.array(fileUploadSchema),
  selectedPharmacy: pharmacySchema,
  intakeForm: intakeFormSchema,
});

export const submitFamilyIntakeSchema = z.object({
  existingMember: UserSchema.optional().or(z.string().optional()),
  condition: z.string().optional(),
  complaint: z.string().optional(),
  firstName: z.string(),
  lastName: z.string(),
  addresses: AddressCreateInputSchema.array(),
  sexAtBirth: z.nativeEnum(SexAtBirthEnum),
  dob: z.coerce.date(),
  skinType: z.string(),
  skinProfile: z.string(),
  guardianFirstName: z.string(),
  guardianLastName: z.string(),
  guardianPhone: z.string().refine((val) => validateUSPhoneNumber(val)),
  guardianAddresses: AddressCreateInputSchema.array(),
  guardianSexAtBirth: z.nativeEnum(SexAtBirthEnum),
  guardianDOB: z.coerce.date(),
  doctorMessage: z.string().optional(),
  conditionMedia: z.array(fileUploadSchema),
  patientMedia: z.array(fileUploadSchema),
  selectedPharmacy: pharmacySchema,
  intakeForm: intakeFormSchema,
  primaryCarePhysicianName: z.string().optional(),
  primaryCarePhysicianAddress: AddressCreateInputSchema.optional(),
  medicalConditions: z.string().optional(),
  medications: z
    .object({
      DispensableDrugId: z.number().optional().nullable(),
    })
    .array()
    .optional(),
  allergies: z
    .object({
      AllergenId: z.number().optional().nullable(),
    })
    .array()
    .optional(),
  height: z.string(),
  weight: z.coerce.string(),
});

export type SubmitSelfIntakeType = z.output<typeof submitSelfIntakeSchema>;
export type SubmitFamilyIntakeType = z.output<typeof submitFamilyIntakeSchema>;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/submission-helpers/submit-family-intake.ts

import { ExtendedUser } from '@/app/shared/models/extensions/identity/types/identityTypes';
import { User, UserRole } from '@prisma/client';

import {
  DoseSpotUser,
  convertHeightToDoseSpotFormat,
  convertWeightToDoseSpotFormat,
} from '../clients/dosespot/dosespotUtils';
import { prisma } from '../clients/mongo/prismaClient';
import { transformUploadToMediaType } from '../file-upload/upload-helpers';
import {
  reassignConciergeFromParentToMember,
  transformAllergenPayloadToDSInput,
  transformMedicationPayloadToDSInput,
} from '../helpers/helpers';
import { createCase } from './create-case';
import { setupDoseSpotUser } from './setup-dosespot-user';
import { SubmitFamilyIntakeType } from './zod-schemas';

enum UserType {
  Guardian = 'guardian',
  Patient = 'patient',
}

export const submitFamilyIntake = async (
  guardian: ExtendedUser,
  data: SubmitFamilyIntakeType
) => {
  const complaint =
    data.complaint && data.complaint.length > 0
      ? data.complaint
      : data.condition;

  // Setup the family member (creates a user shell with the bare minimum if not existing user)
  const member = await setupFamilyMember(guardian, data);

  // Update the guardian user
  const updatedGuardian = await updateGuardian(guardian, data);

  // Update the family member user
  const updatedMember = await updateFamilyMember(updatedGuardian, member, data);

  // Create a new case
  const newCase = await createCase(updatedMember, data, complaint);

  // Reassign concierge from guardian to member
  await reassignConciergeFromParentToMember(
    updatedGuardian.id,
    updatedMember.id
  );

  return { guardian: updatedGuardian, member: updatedMember, case: newCase };
};

const setupFamilyMember = async (
  guardian: ExtendedUser,
  data: SubmitFamilyIntakeType
) => {
  let user: User | null = null;

  if (
    data.existingMember &&
    typeof data.existingMember !== 'string' &&
    data.existingMember.id
  ) {
    user = await prisma.user.findUnique({
      where: { id: data.existingMember.id },
      include: { medicalProfile: true },
    });
  }

  if (user == null) {
    user = await prisma.user.create({
      data: {
        firstName: data.firstName,
        lastName: data.lastName,
        addresses: data.addresses,
        email: guardian.email,
        stripeId: guardian.stripeId,
        phoneNumber: data.guardianPhone,
        roles: [UserRole.PATIENT],
        guardianId: guardian.id,
      },
    });
  }

  return user;
};

const updateFamilyMember = async (
  guardian: ExtendedUser,
  member: User,
  data: SubmitFamilyIntakeType
) => {
  const dsPayload = createDoseSpotUserPayload(data, UserType.Patient);

  const memberDosespotId = await setupDoseSpotUser(
    member,
    dsPayload,
    data.selectedPharmacy?.PharmacyId?.toString?.()
  );

  const dsHeight = convertHeightToDoseSpotFormat(member, data.height);
  const dsWeight = convertWeightToDoseSpotFormat(member, data.weight);

  const medicalProfileData = {
    sexAtBirth: data.sexAtBirth,
    dob: data.dob,
    skinType: data.skinType,
    skinProfile: data.skinProfile,
    height: dsHeight.height,
    heightUnit: dsHeight.units,
    weight: dsWeight.weight,
    weightUnit: dsWeight.units,
    primaryCarePhysicianName: data.primaryCarePhysicianName,
    primaryCarePhysicianAddress: data.primaryCarePhysicianAddress,
    medicalConditions: data.medicalConditions,
    medicalProfileCompletedDate: new Date(Date.now()),
  };

  const patientMedia = transformUploadToMediaType(data.patientMedia as any[]);

  const updatedUser = await prisma.user.update({
    where: { id: member.id },
    data: {
      firstName: data.firstName,
      lastName: data.lastName,
      addresses: data.addresses,
      email: guardian.email,
      stripeId: guardian.stripeId,
      phoneNumber: data.guardianPhone,
      dosespotId: memberDosespotId,
      media: patientMedia,
      medicalProfile: {
        upsert: {
          create: medicalProfileData,
          update: medicalProfileData,
        },
      },
    },
    include: { medicalProfile: true },
  });

  return updatedUser;
};

const updateGuardian = async (
  guardian: ExtendedUser,
  data: SubmitFamilyIntakeType
) => {
  const dsPayload = createDoseSpotUserPayload(data, UserType.Guardian);

  const guardianDosespotId = await setupDoseSpotUser(guardian, dsPayload);

  const medicalProfileData = {
    sexAtBirth: data.guardianSexAtBirth,
    dob: data.guardianDOB,
  };

  const updatedUser = await prisma.user.update({
    where: { id: guardian.id },
    data: {
      firstName: data.guardianFirstName,
      lastName: data.guardianLastName,
      addresses: data.guardianAddresses,
      phoneNumber: data.guardianPhone,
      dosespotId: guardianDosespotId,
      medicalProfile: {
        upsert: {
          create: medicalProfileData,
          update: medicalProfileData,
        },
      },
    },
    include: { medicalProfile: true },
  });

  return updatedUser;
};

const createDoseSpotUserPayload = (
  data: SubmitFamilyIntakeType,
  userType: UserType = UserType.Guardian
): DoseSpotUser => {
  if (userType === UserType.Guardian) {
    return {
      firstName: data.guardianFirstName,
      phoneNumber: data.guardianPhone,
      lastName: data.guardianLastName,
      addresses: data.guardianAddresses,
      medicalProfile: {
        sexAtBirth: data.guardianSexAtBirth,
        dob: data.guardianDOB,
      },
    };
  }

  // If not guardian, treat user as patient
  const allergies = transformAllergenPayloadToDSInput(data.allergies);
  const medications = transformMedicationPayloadToDSInput(data.medications);

  return {
    firstName: data.firstName,
    phoneNumber: data.guardianPhone,
    lastName: data.lastName,
    addresses: data.addresses,
    medicalProfile: {
      sexAtBirth: data.sexAtBirth,
      dob: data.dob,
      skinType: data.skinType,
      skinProfile: data.skinProfile,
      allergies,
      medications,
    },
    height: data.height,
    weight: data.weight,
  };
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/submission-helpers/submit-self-intake.ts

import { ExtendedUser } from '@/app/shared/models/extensions/identity/types/identityTypes';
import { prisma } from '@utils/clients/mongo/prismaClient';

import { transformUploadToMediaType } from '../file-upload/upload-helpers';
import {
  transformAllergenPayloadToDSInput,
  transformMedicationPayloadToDSInput,
} from '../helpers/helpers';
import { createCase } from './create-case';
import { postSubmitEvents } from './post-submit-events';
import { setupDoseSpotUser } from './setup-dosespot-user';
import { SubmitSelfIntakeType } from './zod-schemas';

export const submitSelfIntake = async (
  user: ExtendedUser,
  data: SubmitSelfIntakeType
) => {
  const complaint =
    data.complaint && data.complaint.length > 0
      ? data.complaint
      : data.condition;

  // Update user data
  const updatedUser = await updateUser(user, data);

  // Create a new case
  const newCase = await createCase(updatedUser, data, complaint);

  // Post submission events (email, slack, etc.)
  await postSubmitEvents(user, complaint);

  return { user: updatedUser, case: newCase };
};

const updateUser = async (user: ExtendedUser, data: SubmitSelfIntakeType) => {
  const allergies = transformAllergenPayloadToDSInput(data.allergies);
  const medications = transformMedicationPayloadToDSInput(data.medications);

  const dsPayload = {
    firstName: data.firstName,
    phoneNumber: data.phoneNumber,
    lastName: data.lastName,
    addresses: data.addresses,
    medicalProfile: {
      sexAtBirth: data.sexAtBirth,
      dob: data.dob,
      skinType: data.skinType,
      skinProfile: data.skinProfile,
      allergies,
      medications,
    },
  };

  const dosespotId = await setupDoseSpotUser(
    user,
    dsPayload,
    data.selectedPharmacy?.PharmacyId?.toString?.()
  );

  const patientMedia = transformUploadToMediaType(data.patientMedia as any[]);

  const medicalProfileData = {
    sexAtBirth: data.sexAtBirth,
    dob: data.dob,
    skinType: data.skinType,
    skinProfile: data.skinProfile,
    medicalConditions: data.medicalConditions,
    primaryCarePhysicianName: data.primaryCarePhysicianName,
    primaryCarePhysicianAddress: data.primaryCarePhysicianAddress,
    medicalProfileCompletedDate: new Date(Date.now()),
  };

  const updatedUser = await prisma.user.update({
    where: { id: user.id },
    data: {
      firstName: data.firstName,
      lastName: data.lastName,
      phoneNumber: data.phoneNumber,
      addresses: data.addresses,
      dosespotId,
      media: patientMedia,
      medicalProfile: {
        upsert: {
          update: medicalProfileData,
          create: medicalProfileData,
        },
      },
    },
  });

  return updatedUser;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/seeders/constants/seedingConstants.ts

enum PageIds {
  HomePage = '64a71881354bf258d211ce8d',
}

enum SectionIds {
  HomeSlider = '64a71881354bf258d211ce90',
  QuoteSection = '64a71881354bf258d211ce81',
}

export { PageIds, SectionIds };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/file-upload/file-upload.ts

import {
  GetObjectCommand,
  HeadObjectCommand,
  PutObjectCommand,
  S3Client,
} from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { UploadStatus } from '@utils/enums';

import LoggerUtil from '../clients/logging/apiUtilLogger';

export interface ICustomFile {
  id?: string;
  file: File;
  size: number;
  name: string;
  type: string;
  status?: UploadStatus;
  s3Url?: string;
}

type UploadFileToS3Type = (
  bucket: string,
  s3Key: string,
  file: File,
  s3Client?: S3Client
) => Promise<ICustomFile>;

type GetS3UrlType = (p: {
  mediaUrl?: string;
  bucket?: string;
  key?: string;
  expiresIn?: number;
  s3Client?: S3Client;
  source?: string;
}) => Promise<{ s3Url?: string; error: boolean; errorMessage?: string }>;

export const uploadFileToS3: UploadFileToS3Type = async (
  bucket,
  s3Key,
  file,
  s3Client
) => {
  try {
    let s3 = s3Client;
    if (!s3Client) {
      s3 = new S3Client({
        region: process.env.AWS_REGION,
        credentials: {
          accessKeyId: process.env.FORM_S3_AWS_ACCESS_KEY as string,
          secretAccessKey: process.env.FORM_S3_SECRET_ACCESS_KEY as string,
        },
      });
    }

    if (!s3) throw new Error('Failed to create s3 client');

    const putParams = {
      Bucket: bucket,
      Key: s3Key,
      Body: (await file.arrayBuffer()) as Buffer,
      Metadata: {
        name: file.name,
        size: file.size.toString(),
        contentType: file.type,
      },
    };

    await s3.send(new PutObjectCommand(putParams));

    return {
      file: file,
      name: file.name,
      type: file.type,
      size: file.size,
      status: UploadStatus.SUCCESS,
      s3Url: `https://${bucket}.s3.amazonaws.com/${s3Key}`,
    };
  } catch (error) {
    await LoggerUtil.logError('error_uploading_file', 'uploadFileToS3', error, {
      bucket,
      file,
      s3Key,
    });
    return {
      file: file,
      name: file.name,
      type: file.type,
      size: file.size,
      status: UploadStatus.ERROR,
      s3Url: undefined,
    };
  }
};

export const getS3Url: GetS3UrlType = async ({
  mediaUrl,
  bucket,
  key,
  expiresIn,
  s3Client,
  source,
}) => {
  try {
    let s3Bucket = bucket;
    let s3Key = key;

    LoggerUtil.logInfo('get_s3_url', source ?? 'Undefined Source', {
      s3Bucket,
      mediaUrl,
    });

    if (!!mediaUrl && typeof mediaUrl === 'string') {
      const urlParts = new URL(mediaUrl);
      const hostnameParts = urlParts.hostname.split('.');
      s3Bucket = hostnameParts?.[0];
      s3Key = urlParts.pathname.slice(1);
    }

    if (!s3Bucket || !s3Key) {
      throw new Error('Must include a mediaUrl or s3 bucket and key');
    }

    let s3 = s3Client;
    if (!s3Client) {
      s3 = new S3Client({
        region: process.env.AWS_REGION,
        credentials: {
          accessKeyId: process.env.FORM_S3_AWS_ACCESS_KEY as string,
          secretAccessKey: process.env.FORM_S3_SECRET_ACCESS_KEY as string,
        },
      });
    }

    if (!s3) throw new Error('Failed to create s3 client');

    const command = new GetObjectCommand({
      Bucket: s3Bucket,
      Key: decodeURI(s3Key),
    });
    const s3Url = await getSignedUrl(s3, command, {
      expiresIn: expiresIn ?? 3600,
    });

    return { s3Url, error: false, errorMessage: '' };
  } catch (error) {
    await LoggerUtil.logError(
      'error_getting_s3_url',
      source ?? 'Undefined Source',
      error,
      {
        mediaUrl,
        bucket,
        key,
      }
    );

    return {
      s3Url: undefined,
      error: true,
      errorMessage: (error as Error).message,
    };
  }
};

export const getS3FileInfo = async (mediaUrl: string, s3Client: S3Client) => {
  try {
    let s3Bucket;
    let s3Key;

    if (!!mediaUrl && typeof mediaUrl === 'string') {
      const urlParts = new URL(mediaUrl);
      const hostnameParts = urlParts.hostname.split('.');
      s3Bucket = hostnameParts?.[0];
      s3Key = urlParts.pathname.slice(1);
    }

    if (!s3Bucket || !s3Key) {
      throw new Error('Must include a mediaUrl or s3 bucket and key');
    }

    let s3 = s3Client;
    if (!s3Client) {
      s3 = new S3Client({
        region: process.env.AWS_REGION,
        credentials: {
          accessKeyId: process.env.FORM_S3_AWS_ACCESS_KEY as string,
          secretAccessKey: process.env.FORM_S3_SECRET_ACCESS_KEY as string,
        },
      });
    }

    if (!s3) throw new Error('Failed to create s3 client');

    const command = new HeadObjectCommand({
      Bucket: s3Bucket,
      Key: decodeURI(s3Key),
    });

    const s3Data = await s3.send(command);

    return {
      name: s3Data.Metadata?.name,
      type: s3Data.Metadata?.contenttype,
      size: s3Data.Metadata?.size,
      s3Url: mediaUrl,
      status: UploadStatus.SUCCESS,
    };
  } catch (error) {
    await LoggerUtil.logError(
      'error_getting_s3_file_info',
      'getS3FileInfo',
      error,
      {
        mediaUrl,
      }
    );

    return {
      s3Url: undefined,
      error: true,
      errorMessage: (error as Error).message,
    };
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/file-upload/upload-helpers.ts

import { Media, MediaType } from '@prisma/client';

import { ICustomFile } from './file-upload';

const IMAGE_TYPES = [
  'image/svg+xml',
  'image/gif',
  'image/jpeg',
  'image/png',
  'image/webp',
];
const VIDEO_TYPES = ['video/mpeg', 'video/mp4'];

// prefix filename with date.now to ensure uniqueness
export const getSafeFileName = (fileName: string) =>
  `${Date.now()}_${fileName}`;

export const isFileTypeValid = (fileType: string) =>
  [...IMAGE_TYPES, ...VIDEO_TYPES].includes(fileType);

// TODO: Expand MIME type check
export const getMediaTypeForFile = (fileType: string) =>
  IMAGE_TYPES.includes(fileType) ? MediaType.IMAGE : MediaType.VIDEO;

export const transformUploadToMediaType = (media?: ICustomFile[]) => {
  const result: Media[] = [];
  if (media && media.length > 0) {
    media.forEach((m) => {
      if (m.s3Url) {
        result.push({
          mediaId: `${m.id}`,
          mediaType: getMediaTypeForFile(m.type),
          mediaUrl: m.s3Url,
        });
      }
    });
  }

  return result;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/utility-types/withRequiredProperty.ts

export type WithRequiredProperty<T, K extends keyof T> = T & {
  [Property in K]-?: NonNullable<T[Property]>;
};

export type WithRequiredProperties<T, K extends keyof T> = Omit<T, K> &
  Required<Pick<T, K>>;


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/errors/errorLogger.ts

import { ApiErrorProps } from '@utils/errors/apiErrorHandler';
import { ServerErrorProps } from '@utils/errors/serverErrorHandler';
import HttpStatusCode from '@utils/statusCodes';

import { apiErrorLogger } from '../clients/logging/winstonClient';

export interface BaseError {
  source: string;
  message: string;
  detail: {
    message?: string;
    stack?: string;
    cause?: unknown;
    name?: string;
  };
}

export interface ClientErrorEntry extends BaseError {
  context: {
    //TODO: add other valuable context params from client errors
    page: string;
    action: string;
  };
}

export interface ServerErrorEntry extends BaseError {
  context: {
    //TODO: add other valuable context params from server errors
  };
}

export interface ApiErrorEntry extends BaseError {
  code: HttpStatusCode;
  context: {
    headers?: string;
    body?: string;
    urlIdParams?: { field: string; value: string }[];
  };
}

export interface ApiErrorPropsWithForcedCode extends ApiErrorProps {
  code: HttpStatusCode;
}

const noValueError = {
  message: 'No error message present.',
  name: 'No error name present.',
  stack: 'No error stack present.',
  cause: 'No error cause present.',
};

const logApiError = (apiProps: ApiErrorPropsWithForcedCode) => {
  const {
    message,
    code,
    reqUrl,
    reqBody,
    reqHeaders,
    error,
    additionalContext,
  } = apiProps;

  reqHeaders?.delete('Authorization');

  const reqHeadersString = reqHeaders
    ? Object.fromEntries(reqHeaders.entries())
    : undefined;

  const requestUrl = new URL(reqUrl);
  const strippedPath = replaceGuidValues(requestUrl.pathname);

  const errorDetail: ApiErrorEntry = {
    source: strippedPath.path,
    code: code,
    message: message,
    context: {
      headers: JSON.stringify(reqHeadersString),
      body: reqBody,
      urlIdParams:
        strippedPath.strippedIds.length > 0
          ? strippedPath.strippedIds
          : undefined,
    },
    detail: extractErrorDetail(error),
  };

  apiErrorLogger.error(
    `${errorDetail.source} has thrown a ${errorDetail.code} error with message:\n'${errorDetail.message}.'`,
    {
      metadata: {
        service: 'dermi-api',
        errorDetail,
        additionalContext,
      },
    }
  );
};

const replaceGuidValues = (path: string) => {
  const objectIdRegex = /^[a-f\d]{24}$/i;

  const splitPath = path.split('/');

  const strippedIds: { field: string; value: string }[] = [];

  splitPath.forEach((pathToTest, index) => {
    const match = objectIdRegex.test(pathToTest);
    if (match) {
      strippedIds.push({ field: splitPath[index - 1], value: pathToTest });
      splitPath[index] = '[id]';
    }
  });

  return {
    path: splitPath.join('/'),
    strippedIds,
  };
};

export const logServerError = (serverProps: ServerErrorProps) => {
  const { source, message, error } = serverProps;
  const errorDetail: ServerErrorEntry = {
    source: source,
    message: message,
    context: {},
    detail: extractErrorDetail(error),
  };

  apiErrorLogger.error(
    `${errorDetail.source} has thrown an error with message ${errorDetail.message}.`,
    { metadata: { service: source, errorDetail } }
  );
};

const extractErrorDetail = (error: unknown) => {
  try {
    const { message, stack, cause, name } = error as Error;

    return { message, stack, cause, name };
  } catch (error) {
    return noValueError;
  }
};

export const ErrorLogger = { logApiError };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/errors/serverErrorHandler.ts

import { logServerError } from '@utils/errors/errorLogger';
import HttpStatusCode from '@utils/statusCodes';

export interface ServerErrorProps {
  source: string;
  message: string;
  error?: unknown;
  code?: HttpStatusCode;
}

//TODO: implement handlers for different server side errors
export const handleConnectionIssue = (errorProps: ServerErrorProps) => {
  logServerError(errorProps);
};

export const ServerErrorHandler = { handleConnectionIssue };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/errors/apiErrorHandler.ts

import { NextResponse } from 'next/server';
import { z } from 'zod';

import { Prisma } from '@prisma/client';
import { ErrorLogger } from '@utils/errors';
import HttpStatusCode from '@utils/statusCodes';
import { type WithRequiredProperty } from '@utils/utility-types/withRequiredProperty';

import { PrismaQueryError } from '../clients/mongo/prismaTypes';

export interface ApiErrorProps {
  message: string;
  reqUrl: string;
  reqHeaders?: Headers;
  reqBody?: string;
  error?: unknown;
  code?: HttpStatusCode;
  additionalContext?: any;
  logError?: boolean;
}

const handleCatchAllError = (
  apiProps: Omit<ApiErrorProps, 'message'>
): NextResponse<ErrorNextResponse> => {
  if (apiProps.error instanceof SyntaxError) {
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid JSON body.',
      reqUrl: apiProps.reqUrl,
      reqBody: apiProps.reqBody,
      reqHeaders: apiProps.reqHeaders,
      error: apiProps.error,
    });
  } else if (apiProps.error instanceof z.ZodError) {
    return ApiErrorHandler.handleBadRequest({
      message: apiProps.error.issues
        .map(
          (issue) => (issue.path[0] ? issue.path[0] + ': ' : '') + issue.message
        )
        .join(' | '),
      reqUrl: apiProps.reqUrl,
      reqBody: apiProps.reqBody,
      reqHeaders: apiProps.reqHeaders,
      error: apiProps.error,
    });
  } else {
    const typedError = apiProps.error as Error;

    return ApiErrorHandler.handleServerError({
      message: 'Internal Server Error.' + typedError.message,
      reqUrl: apiProps.reqUrl,
      reqBody: apiProps.reqBody,
      reqHeaders: apiProps.reqHeaders,
      error: apiProps.error,
    });
  }
};

const handleBadRequest = (
  apiProps: ApiErrorProps
): NextResponse<ErrorNextResponse> => {
  apiProps.code ??= HttpStatusCode.BAD_REQUEST;

  //TODO strip out sensitive data from reqBody and reqHeaders

  if (apiProps.logError === undefined || apiProps.logError === true)
    ErrorLogger.logApiError(
      apiProps as WithRequiredProperty<ApiErrorProps, 'code'>
    );

  return generateNextResponse(apiProps);
};

const handleServerError = (
  apiProps: ApiErrorProps
): NextResponse<ErrorNextResponse> => {
  const { error, reqUrl } = apiProps;

  // handle prisma not found errors
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case PrismaQueryError.RecordsNotFound:
        return ApiErrorHandler.handle404Error({
          message: 'Prisma record not found for the provided id.',
          reqUrl: reqUrl,
          error: error,
        });
      case PrismaQueryError.ConstraintViolation:
        return ApiErrorHandler.handleBadRequest({
          message:
            'A record with the provided data violates a constraint on this object.',
          reqUrl: reqUrl,
          error: error,
        });
      case PrismaQueryError.UniqueConstraintViolation:
        return ApiErrorHandler.handleBadRequest({
          message:
            'A record with the provided data violates a unique constraint on this object. ' +
            error.stack,
          error: error,
          reqUrl: reqUrl,
        });
    }
  } else if (apiProps.error instanceof SyntaxError) {
    return ApiErrorHandler.handleBadRequest({
      message: 'Invalid JSON body.',
      reqUrl: apiProps.reqUrl,
      reqBody: apiProps.reqBody,
      reqHeaders: apiProps.reqHeaders,
      error: apiProps.error,
    });
  } else if (apiProps.error instanceof z.ZodError) {
    return ApiErrorHandler.handleBadRequest({
      message: apiProps.error.issues
        .map(
          (issue) => (issue.path[0] ? issue.path[0] + ': ' : '') + issue.message
        )
        .join(' | '),
      reqUrl: apiProps.reqUrl,
      reqBody: apiProps.reqBody,
      reqHeaders: apiProps.reqHeaders,
      error: apiProps.error,
    });
  }

  apiProps.code ??= HttpStatusCode.INTERNAL_SERVER_ERROR;

  //TODO: Strip out sensitive data from reqBody and reqHeaders

  if (apiProps.logError === undefined || apiProps.logError === true)
    ErrorLogger.logApiError(
      apiProps as WithRequiredProperty<ApiErrorProps, 'code'>
    );

  return generateNextResponse(apiProps);
};

const handle404Error = (
  apiProps: ApiErrorProps
): NextResponse<ErrorNextResponse> => {
  apiProps.code ??= HttpStatusCode.NOT_FOUND;

  //TODO strip out sensitive data from reqBody and reqHeaders

  if (apiProps.logError === undefined || apiProps.logError === true)
    ErrorLogger.logApiError(
      apiProps as WithRequiredProperty<ApiErrorProps, 'code'>
    );

  return generateNextResponse(apiProps);
};

const handleUnauthorizedError = (
  apiProps: ApiErrorProps
): NextResponse<ErrorNextResponse> => {
  apiProps.code ??= HttpStatusCode.UNAUTHORIZED;

  //TODO strip out sensitive data from reqBody and reqHeaders

  if (apiProps.logError === undefined || apiProps.logError === true)
    ErrorLogger.logApiError(
      apiProps as WithRequiredProperty<ApiErrorProps, 'code'>
    );

  return generateNextResponse(apiProps);
};

export interface ErrorNextResponse {
  message: string;
  detail?: string;
}

const generateNextResponse = (
  apiProps: ApiErrorProps
): NextResponse<ErrorNextResponse> => {
  const { message, error, code } = apiProps;
  return NextResponse.json(
    {
      message: message,
      detail: getErrorDetail(error),
    },
    {
      status: code,
    }
  );
};

const getErrorDetail = (error: unknown) => {
  return error instanceof Error
    ? (error as Error).message
    : 'No error detail present';
};

export const ApiErrorHandler = {
  handle404Error,
  handleBadRequest,
  handleServerError,
  handleUnauthorizedError,
  handleCatchAllError,
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/errors/clientErrorHandler.ts

import HttpStatusCode from '@utils/statusCodes';

export interface ClientErrorProps {
  message: string;
  url: string;
  action: string;
  code: HttpStatusCode;
  error?: unknown;
}

//TODO: implement handlers for different client side errors


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/errors/index.ts

import { ApiErrorHandler } from '@utils/errors/apiErrorHandler';
import { ErrorLogger } from '@utils/errors/errorLogger';
import { ServerErrorHandler } from '@utils/errors/serverErrorHandler';

export { ErrorLogger, ApiErrorHandler, ServerErrorHandler };


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/helpers/helpers.ts

import { revalidateTag } from 'next/cache';
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';
import { ProductPageDocument } from 'prismicio-types';

import { ThreadCustomType } from '@/app/shared/models/extensions/messaging';
import {
  CartInclude,
  CaseInclude,
  ExtendedUser,
  ExtendedUserAttributes,
  IFamilyStatsResponse,
  ProductWithContent,
} from '@/app/shared/types';
import { createClient } from '@/prismicio';
import { getFamilyIDs } from '@/utils/dependents/dependentUsersUtilities';
import { COOKIE_KEYS } from '@/utils/enums';
import { prisma } from '@clients/mongo/prismaClient';
import {
  CartProducts,
  Case,
  Product,
  ProductCategories,
  Thread,
  ThreadType,
  User,
  UserRole,
  UserSubscription,
} from '@prisma/client';
import { filter } from '@prismicio/client';
import { getBaseUrl } from '@utils/getBaseUrl';

import {
  AllergyReactionType,
  AllergyStatusType,
  PatientMedicationStatusType,
} from '../clients/dosespot/dosespotTypes';
import LoggerUtil from '../clients/logging/apiUtilLogger';
import { getIsProd } from '../get-is-prod';
import { getPrismicProductId } from '../get-prismic-product-id';
import { PrismicPageType } from '../prismic/enums';

const baseUrl = getBaseUrl();
const isProd = getIsProd();

export const getUserNoRedirect = async () => {
  try {
    const res = await fetch(`${baseUrl}/api/user/me`, {
      headers: { Cookie: cookies().toString() },
      next: { tags: ['user'], revalidate: 360 },
    });

    const user = await res.json();

    return user as ExtendedUser;
  } catch (error) {
    return undefined;
  }
};

export const getUser = async () => {
  try {
    const res = await fetch(`${baseUrl}/api/user/me`, {
      headers: { Cookie: cookies().toString() },
      next: { tags: ['user'], revalidate: 360 },
    });

    const user = await res.json();

    return user as ExtendedUser;
  } catch (error) {
    // could not get user, return null
    redirect('/signout');
  }
};

export const isUserLoggedIn = (user?: User | null) => {
  return !!user && !user?.roles?.includes?.(UserRole.ANONYMOUS_PATIENT);
};

export const getUserAvatar = async () => {
  try {
    const res = await fetch(`${baseUrl}/api/user/avatar`, {
      headers: { Cookie: cookies().toString() },
      next: { tags: ['userAvatar'], revalidate: 3600 },
    });

    return (await res.json()) as { s3Url?: string };
  } catch (error) {
    return { s3Url: undefined };
  }
};

export const getThreads = async () => {
  try {
    const res = await fetch(`${baseUrl}/api/messaging/threads`, {
      headers: { Cookie: cookies().toString() },
    });

    if (res.ok) {
      const typedResponse = (await res.json()) as ThreadCustomType[];

      return typedResponse;
    }

    await LoggerUtil.logError(
      'error_fetching_threads_badresponse',
      'getThreads',
      new Error('Bad response from threads endpoint'),
      {
        userId: (await getUser())?.id,
        responseCode: res.status,
        responseStatusText: res.statusText,
        responseBody: res.text(),
      }
    );

    throw new Error('Failed to fetch threads for user.');
  } catch (error) {
    await LoggerUtil.logError(
      'error_fetching_threads',
      'getThreads',
      error,
      {}
    );
    throw error;
  }
};

// Get the form configuration by the id
export const getForm = async (id: string, locale = 'en') => {
  const fetchConfig: RequestInit = {
    method: 'GET',
    headers: {
      locale,
    },
  };

  if (process.env.ENVIRONMENT_NAME === 'production') {
    fetchConfig.next = { tags: ['form', id], revalidate: 300 };
  } else if (process.env.ENVIRONMENT_NAME === 'development') {
    fetchConfig.next = { tags: ['form', id], revalidate: 60 };
  } else {
    fetchConfig.cache = 'no-store'; // local no cache
  }

  try {
    const res = await fetch(`${baseUrl}/api/forms/${id}`, fetchConfig);
    const form = await res.json();

    return form;
  } catch (error) {
    await LoggerUtil.logError('error_fetching_form_config', 'getForm', error, {
      formId: id,
      locale,
    });
    return null;
  }
};

export const getProductList = async () => {
  try {
    const res = await fetch(
      `${baseUrl}/api/ecommerce/product?category=OTC_MEDICATION`
    );

    return (await res.json()) as Product[];
  } catch (error) {
    await LoggerUtil.logError(
      'error_fetching_product_list',
      'getProductList',
      error,
      {}
    );
    return [];
  }
};

export const getProductByID = async (id: string) => {
  try {
    const res = await fetch(`${baseUrl}/api/ecommerce/product/${id}`);

    return (await res.json()) as Product;
  } catch (error) {
    await LoggerUtil.logError(
      'error_fetching_product_by_id',
      'getProductByID',
      error,
      { productId: id }
    );
    return null;
  }
};

export const getProductContent = async (collection?: string | null) => {
  const client = createClient();

  const options: any = {
    filters: [
      filter.at(`my.${PrismicPageType.PRODUCT_PAGE}.is_shop_product`, true),
    ],
  };

  if (collection) {
    options.filters.push(
      filter.at(`my.${PrismicPageType.PRODUCT_PAGE}.type`, collection)
    );
  }
  try {
    const products = await client.getAllByType<ProductPageDocument>(
      PrismicPageType.PRODUCT_PAGE,
      options
    );
    return products;
  } catch (error) {
    return [];
  }
};

export const getProductsWithContent = async (collection?: string | null) => {
  const [systemProducts, productContent] = await Promise.all([
    getProductList(),
    getProductContent(collection),
  ]);

  const activeProducts = systemProducts.filter((product) => product.active);

  const matchedProducts = activeProducts.map((product) => {
    const productContentItem = productContent.find(
      (item) => getPrismicProductId(item.data) === product.id
    );
    return {
      ...(productContentItem ?? {}),
      category: product.category,
      active: productContentItem ? product.active : false,
      price: product.price,
    };
  });

  return matchedProducts.filter(
    (product) => product.active
  ) as ProductWithContent[];
};

export const iso8601Regex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/;

export const convertStringDateToISOString = (date: string) => {
  if (!date.includes('T')) {
    // If 'T' is not present, append 'T00:00' to make it ISO 8601 compliant
    date += 'T00:00';
  }
  // Convert to ISO string regardless of whether we've appended 'T00:00' or not
  return new Date(date).toISOString();
};

// Get Cases
export const getUserCases = async () => {
  try {
    const res = await fetch(`${baseUrl}/api/cases`, {
      headers: { Cookie: cookies().toString() },
    });

    const data = await res.json();

    return data.userCases as CaseInclude[];
  } catch (error) {
    return [];
  }
};

export const getProductContentByIds = async (ids: string[]) => {
  const client = createClient();

  const filterString = !isProd
    ? `my.${PrismicPageType.PRODUCT_PAGE}.dev_product_id`
    : `my.${PrismicPageType.PRODUCT_PAGE}.product_id`;

  try {
    const products = await client.getAllByType<ProductPageDocument>(
      PrismicPageType.PRODUCT_PAGE,
      {
        filters: [filter.any(filterString, ids)],
      }
    );

    return products;
  } catch (error) {
    return [];
  }
};

// Register user w/ Stripe
export const registerUserWithPaymentVendor = async () => {
  try {
    const response = await fetch(`${baseUrl}/api/ecommerce/customer-info`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Cookie: cookies().toString(),
      },
    });

    return await response.json();
  } catch (error) {
    await LoggerUtil.logError(
      'register_user_with_stripe_error',
      'registerUserWithPaymentVendor',
      error,
      {}
    );
    return null;
  }
};

export const getUserAttributes = async (
  user: User
): Promise<ExtendedUser | (User & ExtendedUserAttributes)> => {
  const subscriptions = await getUserConciergeSubscriptions(user);
  const hasConcierge = subscriptions.length > 0 ? true : false;

  const attributes: ExtendedUserAttributes = {
    hasConcierge,
    activeConciergeSubscriptions: subscriptions,
    age: null,
    formattedDOB: null,
  };

  const medicalProfile = await getUserMedicalProfile(user.id);
  if (medicalProfile) {
    attributes.formattedDOB = formatDateString(medicalProfile.dob);
    attributes.age = computeAge(medicalProfile.dob);
  }

  return { ...user, ...attributes };
};

const getUserConciergeSubscriptions = async (
  user: User
): Promise<UserSubscription[]> => {
  try {
    const currentDate = new Date();

    // const sanityCheck = await prisma.userSubscription.findMany({
    //   where: {
    //     userId: user.id,
    //   },
    // });

    const activeConciergeUserSubscriptions =
      await prisma.userSubscription.findMany({
        where: {
          userId: user.id, // Assuming userInfo.user.id contains the ID of the user
          AND: [
            {
              OR: [
                { ended: false },
                {
                  AND: [
                    { ended: true },
                    {
                      OR: [{ endDate: { gt: currentDate } }, { endDate: null }],
                    },
                  ],
                },
              ],
            },
            {
              OR: [
                {
                  subscriptionProductId:
                    process.env.PRODUCT_ID_CONCIERGE_SUBSCRIPTION_MONTHLY,
                },
                {
                  subscriptionProductId:
                    process.env.PRODUCT_ID_CONCIERGE_SUBSCRIPTION_YEARLY,
                },
              ],
            },
          ],
        },
      });

    return activeConciergeUserSubscriptions;
  } catch (error) {
    await LoggerUtil.logError(
      'user_concierge_check_error',
      'getUserConciergeSubscriptions',
      error,
      {
        userId: user.id,
      }
    );
    return [];
  }
};

const getUserMedicalProfile = async (userId: string) => {
  try {
    const medicalProfile = await prisma.medicalProfile.findUnique({
      where: {
        userId,
      },
    });

    return medicalProfile;
  } catch (error) {
    await LoggerUtil.logError(
      'user_medical_profile_fetch_error',
      'getUserMedicalProfile',
      error,
      {
        userId,
      }
    );
    return null;
  }
};

function computeAge(dob: Date | null): number | null {
  if (!dob) {
    return null; // Return null if dob is not provided or invalid
  }

  const today = new Date();
  const birthDate = new Date(dob);
  let age = today.getFullYear() - birthDate.getFullYear();
  const m = today.getMonth() - birthDate.getMonth();

  // Check if the current month is before the birth month or
  // it's the birth month but today's date is before the birth date
  if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
    age--;
  }

  return age;
}

function formatDateString(dateString: Date | string | null): string | null {
  if (!dateString) return null;

  const date = new Date(dateString);
  const month = (date.getMonth() + 1).toString().padStart(2, '0'); // JS months are 0-indexed
  const day = date.getDate().toString().padStart(2, '0');
  const year = date.getFullYear();
  return `${month}-${day}-${year}`;
}

export const postMessageToCaseFromUser = async (
  caseWithThreads: Case,
  caseThreads: Thread[],
  message: string,
  user: User
): Promise<Case> => {
  try {
    const thread = caseThreads.find(
      (t) => t.type === ThreadType.MEDICAL && t.caseId === caseWithThreads.id
    );
    if (!thread) throw new Error('Medical thread not found');

    await prisma.thread.update({
      where: {
        id: thread.id,
      },
      data: {
        messages: {
          create: {
            fromUserId: user.id,
            status: 'SENT',
            content: message,
            sentWhen: new Date(),
            readByIds: {
              set: [user.id],
            },
          },
        },
        lastMessageDate: new Date(),
      },
    });

    return caseWithThreads; // Fallback to the original in case of any issue
  } catch (error) {
    await LoggerUtil.logError(
      'post_message_to_case_error',
      'postMessageToCaseFromUser',
      error,
      {
        caseId: caseWithThreads.id,
        userId: user.id,
      }
    );
    throw new Error('Error updating case with new message.');
  }
};

export const getPhysicianUser = async (physicianId: string | null) => {
  if (!physicianId) return null;
  try {
    const physicianUser = await prisma.user.findUnique({
      where: {
        id: physicianId,
      },
    });
    return physicianUser;
  } catch (error) {
    await LoggerUtil.logError(
      'get_physician_user_error',
      'getPhysicianUser',
      error,
      {
        physicianId,
      }
    );
    return null;
  }
};

export const getUserAllergiesAndMedications = async (
  userId: string | null | undefined
) => {
  if (!userId) return null;

  try {
    const res = await fetch(
      `${baseUrl}/api/dosespot/user-allergies-medications?userid=${userId}`,
      { headers: { Cookie: cookies().toString() } }
    );

    const allergiesAndMedications = await res.json();

    allergiesAndMedications.medications =
      allergiesAndMedications.medications.map((medication: any) => {
        return { ...medication, NameWithRouteDoseForm: medication.DisplayName };
      });

    return allergiesAndMedications;
  } catch (error) {
    await LoggerUtil.logError(
      'get_user_allergies_medications_error',
      'getUserAllergiesAndMedications',
      error,
      {
        userId,
      }
    );
    return null;
  }
};

export const addDependentToUser = async (
  firstName: string,
  lastName: string
): Promise<User | null> => {
  if (!firstName || !lastName) return null;

  try {
    const res = await fetch(`${baseUrl}/api/user/create-dependent`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Cookie: cookies().toString(),
      },
      body: JSON.stringify({ firstName, lastName }),
    });

    return await res.json();
  } catch (error) {
    return null;
  }
};

export const getFamilyStats: () => Promise<IFamilyStatsResponse> = async () => {
  try {
    const result = await fetch(`${baseUrl}/api/user/family-stats`, {
      method: 'GET',
      headers: {
        Cookie: cookies().toString(),
      },
      next: { revalidate: 300 },
    });
    return (await result.json()) as IFamilyStatsResponse;
  } catch (error) {
    await LoggerUtil.logError(
      'get_family_stats_error',
      'getFamilyStats',
      error,
      {}
    );

    return {
      casesDiagnosedInLast7Days: [],
      shippingChangesInLast7Days: [],
      unreadThreads: [],
      casesWithConsultationExpiringWithin7Days: [],
      totalNotifications: 0,
    };
  }
};

export const postFamilyCaseToCase = async (memberId: string, caseData: any) => {
  if (!memberId || !caseData) return null;

  const familyHeaderKey = COOKIE_KEYS.FAMILY_MEMBER;

  try {
    const res = await fetch(`${baseUrl}/api/case`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        [familyHeaderKey]: memberId,
        Cookie: cookies().toString(),
      },
      body: caseData,
    });

    return await res.json();
  } catch (error) {
    return null;
  }
};

export const postCase = async (caseData: any) => {
  if (!caseData) return null;

  try {
    const res = await fetch(`${baseUrl}/api/case`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',

        Cookie: cookies().toString(),
      },
      body: caseData,
    });

    return await res.json();
  } catch (error) {
    return null;
  }
};

export const reassignConciergeFromParentToMember = async (
  accountFrom: string,
  accountTo: string
) => {
  if (!accountFrom || !accountTo) return null;

  await LoggerUtil.logInfo(
    'family_member_concierge_reassignemnt',
    'reassignConciergeFromParentToMember',
    { accountFrom, accountTo }
  );

  try {
    const twentyFourHoursAgo = new Date();
    twentyFourHoursAgo.setHours(twentyFourHoursAgo.getHours() - 24);

    const monthlyConcierge =
      process.env.PRODUCT_ID_CONCIERGE_SUBSCRIPTION_MONTHLY ??
      '65bd01544b2cb6d155e1270c';
    const yearlyConcierge =
      process.env.PRODUCT_ID_CONCIERGE_SUBSCRIPTION_YEARLY ??
      '65cd0775d340db0747cb0196';

    const recentConciergeSubscription = await prisma.userSubscription.findFirst(
      {
        where: {
          userId: accountFrom,
          createdAt: {
            gte: twentyFourHoursAgo,
          },
          subscriptionProductId: {
            in: [monthlyConcierge, yearlyConcierge],
          },
          ended: false,
        },
        orderBy: { createdAt: 'desc' },
      }
    );

    if (!recentConciergeSubscription) return null;

    const updatedSubscription = await prisma.userSubscription.update({
      where: {
        id: recentConciergeSubscription.id,
      },
      data: {
        userId: accountTo,
      },
    });
  } catch (error) {
    await LoggerUtil.logError(
      'family_member_concierge_reassignemnt_error',
      'reassignConciergeFromParentToMember',
      error,
      { accountFrom, accountTo }
    );
    return null;
  }
};

export const splitFullNameIntoFirstAndLast = (fullName: string) => {
  const splitName = fullName.split(' ');
  const firstName = splitName[0] ?? '';
  const lastName = splitName.slice(1).join(' ') ?? '';

  return { firstName, lastName };
};

export const addNameToUserIfNull = async (
  userToUpdate: User,
  firstName: string,
  lastName: string
) => {
  if (!userToUpdate || !firstName || !lastName) return null;

  if (userToUpdate.firstName && userToUpdate.lastName) return userToUpdate;

  try {
    const updatedUser = await prisma.user.update({
      where: {
        id: userToUpdate.id,
      },
      data: {
        firstName,
        lastName,
      },
    });

    revalidateTag('user');
    return updatedUser;
  } catch (error) {
    await LoggerUtil.logError(
      'null_name_update_error',
      'addNameToUserIfNull',
      error,
      { userToUpdate, firstName, lastName }
    );
    return null;
  }
};

export async function redeemConsultation(user: User): Promise<string | null> {
  const userIds = await getFamilyIDs(user);

  const familyOrders = await prisma.order.findMany({
    where: { userId: { in: userIds } },
    select: {
      cartProducts: {
        include: {
          product: {
            select: {
              category: true,
            },
          },
          case: true,
        },
      },
    },
  });

  const foundConsultations = familyOrders.reduce<
    (CartProducts & { case: Case[] })[]
  >((acc, curr) => {
    const consultation = curr.cartProducts.find(
      (cp) => cp.product.category === ProductCategories.CONSULTATION
    );

    if (consultation) acc.push(consultation);

    return acc;
  }, []);

  for (let i = 0; i < foundConsultations.length; i++) {
    const consultationsAvailable =
      foundConsultations[i].quantity - foundConsultations[i].case.length;

    if (consultationsAvailable > 0) return foundConsultations[i].id;
  }

  return null;
}

export const getProductContentForCart = async (cart: CartInclude) => {
  const client = createClient();

  const productIds = cart.cartProducts.map((item) => item.productId);
  const subscriptionProductIds = cart.cartSubscriptionProducts.map(
    (item) => item.subscriptionProductId
  );
  const ids = [...productIds, ...subscriptionProductIds];

  const filterString = !isProd
    ? `my.${PrismicPageType.PRODUCT_PAGE}.dev_product_id`
    : `my.${PrismicPageType.PRODUCT_PAGE}.product_id`;

  try {
    const products = await client.getAllByType<ProductPageDocument>(
      PrismicPageType.PRODUCT_PAGE,
      {
        filters: [filter.any(filterString, ids)],
      }
    );

    return products;
  } catch (error) {
    return [];
  }
};
export function transformAllergenPayloadToDSInput(allergens: any) {
  const validAllergens = (allergens ?? []).filter(
    (allergy: any) => allergy?.AllergenId != null
  );

  return validAllergens.map((allergy: any) => ({
    AllergenId: allergy.AllergenId,
    ReactionType: AllergyReactionType.Allergy,
    StatusType: AllergyStatusType.Active,
  }));
}

export function transformMedicationPayloadToDSInput(medications: any) {
  const validMedications = (medications ?? []).filter(
    (medication: any) => medication?.DispensableDrugId != null
  );

  return validMedications.map((medication: any) => ({
    DispensableDrugId: medication.DispensableDrugId,
    Status: PatientMedicationStatusType.Active,
  }));
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/user-events/user-events-client.ts

import {
  SES,
  SendEmailCommand,
  SendTemplatedEmailCommand,
} from '@aws-sdk/client-ses';
import { User } from '@prisma/client';

import LoggerUtil from '../clients/logging/apiUtilLogger';
import { prisma } from '../clients/mongo/prismaClient';
import { UserEventNames } from './enums';

// Configure AWS
const ses = new SES({
  credentials: {
    accessKeyId: process.env.SES_ACCESS_KEY as string,
    secretAccessKey: process.env.SES_SECRET_KEY as string,
  },
  region: process.env.SES_REGION,
});

export async function sendHelloWorldEmail(recipientEmail: string) {
  const params = {
    Destination: {
      ToAddresses: [recipientEmail],
    },
    Message: {
      Body: {
        Text: {
          Charset: 'UTF-8',
          Data: 'Hello, World!',
        },
      },
      Subject: {
        Charset: 'UTF-8',
        Data: 'Hello from AWS SES',
      },
    },
    Source: process.env.SES_EMAIL_SOURCE,
  };

  try {
    const command = new SendEmailCommand(params);
    const result = await ses.send(command);
    console.log('Email sent successfully:', result.MessageId);
    return result;
  } catch (error) {
    console.error('Error sending email:', error);
    throw error;
  }
}

interface ITemplateData {
  firstName: string;
  lastName: string;
}

// Function to send email using a template
async function sendTemplatedEmail(
  recipientEmail: string,
  templateName: string,
  templateData: ITemplateData
) {
  const params = {
    Destination: {
      ToAddresses: [recipientEmail],
    },
    Template: templateName,
    TemplateData: JSON.stringify(templateData),
    Source: process.env.SES_EMAIL_SOURCE,
  };

  try {
    const command = new SendTemplatedEmailCommand(params);
    const result = await ses.send(command);
    await LoggerUtil.logInfo(
      'user_event_email_sent',
      'User Event > sendTemplatedEmail',
      {
        recipientEmail,
        templateName,
        templateData,
      }
    );
    return result;
  } catch (error) {
    await LoggerUtil.logError(
      'user_event_email_sent_error',
      'User Event > sendTemplatedEmail',
      error,
      {
        recipientEmail,
        templateName,
        templateData,
      }
    );
    throw error;
  }
}

interface IPurchase {
  productId: string;
  price: number;
  quantity?: number;
  properties?: Record<string, any>;
}

export default class UserEventsClient {
  private static async sendEmailIfApplicable(
    user: User,
    name: UserEventNames | string,
    properties: any
  ) {
    const emailEvent = await prisma.userEventEmails.findFirst({
      where: {
        event: name,
      },
    });

    if (emailEvent && user.email) {
      await sendTemplatedEmail(user.email, emailEvent.template, {
        first_name: user.firstName ?? '',
        last_name: user.lastName ?? '',
        ...properties,
      });
    }
  }

  public static async addEvent(
    user: User,
    name: UserEventNames | string,
    properties: any
  ) {
    try {
      const newEvent = await prisma.userEvents.create({
        data: {
          userId: user.id,
          event: name,
          data: properties,
        },
      });

      await UserEventsClient.sendEmailIfApplicable(user, name, properties);

      return newEvent;
    } catch (e) {
      await LoggerUtil.logError(
        'user_event_create_error',
        'User Event > addEvent',
        e,
        {
          userId: user.id,
          name,
          properties,
        }
      );
    }
  }

  public static async addEventByUserId(
    userId: string,
    name: UserEventNames,
    properties: any
  ) {
    try {
      const user = await prisma.user.findUnique({
        where: {
          id: userId,
        },
      });

      if (!user) {
        throw new Error(`User ${userId} does not exist`);
      }

      return await this.addEvent(user, name, properties);
    } catch (e) {
      await LoggerUtil.logError(
        'user_event_create_by_id_error',
        'User Event > addEventByUserId',
        e,
        {
          userId,
          name,
          properties,
        }
      );
    }
  }

  public static async addEventByEmail(
    email: string,
    name: UserEventNames,
    properties: any
  ) {
    try {
      const foundUser = await prisma.user.findFirst({
        where: {
          email: email,
        },
      });

      if (!foundUser) {
        throw new Error(`User with email ${email} not found`);
      }

      return await this.addEvent(foundUser, name, properties);
    } catch (e) {
      await LoggerUtil.logError(
        'user_event_create_by_email_error',
        'User Event > addEventByEmail',
        e,
        {
          email,
          name,
          properties,
        }
      );
    }
  }

  public static async addPurchaseEvent(
    user: User,
    eventName: UserEventNames,
    properties: any,
    purchases?: IPurchase[]
  ) {
    try {
      const purchaseEventData = properties;

      // Set Purchase Event
      if (purchases && purchases.length > 0) {
        const purchaseObjectData = purchases.map((purchase) => {
          return {
            external_id: user.id,
            time: new Date(),
            currency: 'USD',
            product_id: purchase.productId,
            price: purchase.price > 0 ? purchase.price / 100 : purchase.price,
            quantity: purchase?.quantity ?? 1,
            properties: {
              ...purchase.properties,
            },
          };
        });

        purchaseEventData.purchases = purchaseObjectData;
      }

      return await this.addEvent(user, eventName, purchaseEventData);
    } catch (e) {
      await LoggerUtil.logError(
        'user_event_create_purchase_event_error',
        'User Event > addPurchaseEvent',
        e,
        {
          userId: user.id,
          eventName,
          properties,
          purchases,
        }
      );
    }
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/user-events/user-event-utils.ts

import {
  Message,
  Product,
  ProductCategories,
  SubscriptionProduct,
  User,
} from '@prisma/client';

import { prisma } from '../clients/mongo/prismaClient';
import { UserEventNames, UserEventConstants } from './enums';
import UserEventsClient from './user-events-client';

const categoryToAddEventNameMap = {
  [ProductCategories.PRESCRIPTION_MEDICATION]:
    UserEventNames.DERMI_ADDED_TO_CART_RX,
  [ProductCategories.OTC_MEDICATION]: UserEventNames.DERMI_ADDED_TO_CART_OTC,
  [ProductCategories.CONSULTATION]:
    UserEventNames.DERMI_ADDED_TO_CART_CONSULTATION,
  [ProductCategories.CONCIERGE]: UserEventNames.DERMI_ADDED_TO_CART_CONCIERGE,
};

const categoryToRemoveEventNameMap = {
  [ProductCategories.PRESCRIPTION_MEDICATION]:
    UserEventNames.DERMI_REMOVED_FROM_CART_RX,
  [ProductCategories.OTC_MEDICATION]:
    UserEventNames.DERMI_REMOVED_FROM_CART_OTC,
  [ProductCategories.CONSULTATION]:
    UserEventNames.DERMI_REMOVED_FROM_CART_CONSULTATION,
  [ProductCategories.CONCIERGE]:
    UserEventNames.DERMI_REMOVED_FROM_CART_CONCIERGE,
};

const categoryToPurchaseEventNameMap = {
  [ProductCategories.PRESCRIPTION_MEDICATION]: UserEventNames.DERMI_PURCHASE_RX,
  [ProductCategories.OTC_MEDICATION]: UserEventNames.DERMI_PURCHASE_OTC,
  [ProductCategories.CONSULTATION]: UserEventNames.DERMI_PURCHASE_CONSULTATION,
  [ProductCategories.CONCIERGE]: UserEventNames.DERMI_PURCHASE_CONCIERGE,
};

export const postUserCartEvent = async (
  user: User,
  productId: string,
  quantity: number,
  isSubscription = false,
  eventNamesMap: Record<string, UserEventNames>
) => {
  const queryOptions = {
    where: {
      id: productId,
    },
    select: {
      name: true,
      category: true,
      price: true,
    },
  };

  let product;
  if (isSubscription) {
    product = await prisma.subscriptionProduct.findUnique(queryOptions);
  } else {
    product = await prisma.product.findUnique(queryOptions);
  }

  if (product) {
    const eventName = eventNamesMap[product.category];
    await UserEventsClient.addEvent(user, eventName, {
      id: productId,
      name: product.name,
      category: product.category,
      unit_price: product.price,
      quantity,
    });
  }
};

export const postUserAddToCartEvent = async (
  user: User,
  productId: string,
  quantity: number,
  isSubscription = false
) => {
  await postUserCartEvent(
    user,
    productId,
    quantity,
    isSubscription,
    categoryToAddEventNameMap
  );
};

export const postUserRemoveFromCartEvent = async (
  user: User,
  productId: string,
  quantity: number,
  isSubscription = false
) => {
  await postUserCartEvent(
    user,
    productId,
    quantity,
    isSubscription,
    categoryToRemoveEventNameMap
  );
};

export const postPurchaseEvent = async (
  user: User,
  priceDetails: {
    productId: string;
    unitPrice: number;
    priceAfterPromo: number;
    priceAfterConcierge: number;
    productDetails: Product;
    quantity: number;
  }[]
) => {
  const sendEventpromises = priceDetails.map((priceDetail) => {
    const category = priceDetail.productDetails.category;
    const eventName = categoryToPurchaseEventNameMap[category];

    UserEventsClient.addPurchaseEvent(user, eventName, {}, [
      {
        productId: priceDetail.productDetails.name,
        price: priceDetail.priceAfterConcierge,
        quantity: priceDetail.quantity,
        properties: {
          productId: priceDetail.productId,
          unitPrice: priceDetail.unitPrice,
          priceAfterPromo: priceDetail.priceAfterPromo,
          priceAfterConcierge: priceDetail.priceAfterConcierge,
          category: priceDetail.productDetails.category,
        },
      },
    ]);
  });

  await Promise.all(sendEventpromises);
};

export const postSubscriptionPurchaseEvent = async (
  user: User,
  priceDetails: {
    productId: string;
    unitPrice: number;
    priceAfterPromo: number;
    priceAfterConcierge: number;
    subscriptionDetails: SubscriptionProduct;
    quantity: number;
    amountDueToday: number;
    subscriptionOnTrial: boolean;
  }[],
  renewal = false
) => {
  const sendEventpromises = priceDetails.map((priceDetail) => {
    const category = priceDetail.subscriptionDetails.category;
    const eventName = renewal
      ? UserEventNames.DERMI_SUBSCRIPTION_RENEWAL
      : categoryToPurchaseEventNameMap[category];

    UserEventsClient.addPurchaseEvent(user, eventName, {}, [
      {
        productId: priceDetail.subscriptionDetails.name,
        price: priceDetail.amountDueToday,
        quantity: priceDetail.quantity,
        properties: {
          productId: priceDetail.productId,
          unitPrice: priceDetail.unitPrice,
          priceAfterPromo: priceDetail.priceAfterPromo,
          priceAfterConcierge: priceDetail.priceAfterConcierge,
          category: priceDetail.subscriptionDetails.category,
          subscriptionOnTrial: priceDetail.subscriptionOnTrial,
        },
      },
    ]);
  });

  await Promise.all(sendEventpromises);
};

interface UserWithAttributes extends User {
  isPatient?: boolean | null;
}

export const raiseMessageSentUserEvent = async (
  message: Message,
  sendingUser: UserWithAttributes
): Promise<void> => {
  if (!sendingUser || !message || !message.threadId) {
    return;
  }

  const threadWithPatient = await prisma.thread.findUnique({
    where: {
      id: message.threadId,
    },
    select: {
      id: true,
      case: true,
      user: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          phoneNumber: true,
        },
      },
    },
  });

  if (!threadWithPatient) {
    return;
  }

  if (sendingUser.isPatient) {
    if (threadWithPatient.case == null) {
      await UserEventsClient.addEvent(
        sendingUser,
        UserEventNames.DERMI_PATIENT_CUSTOMER_SUPPORT_MESSAGE_SENT,
        {}
      );
      await UserEventsClient.addEventByUserId(
        UserEventConstants.CUSTOMER_SUPPORT_USER_ID,
        UserEventNames.DERMI_NOTIFY_CUSTOMER_SUPPORT_OF_MESSAGE,
        {}
      );
    } else {
      await UserEventsClient.addEvent(
        sendingUser,
        UserEventNames.DERMI_PATIENT_MEDICAL_MESSAGE_SENT,
        {}
      );
      if (threadWithPatient.case.physicianId) {
        await UserEventsClient.addEventByUserId(
          threadWithPatient.case.physicianId,
          UserEventNames.DERMI_NOTIFY_DOCTOR_OF_MESSAGE,
          { case_id: threadWithPatient.case.id }
        );
      }
    }
  } else {
    await UserEventsClient.addEventByUserId(
      threadWithPatient.user?.id,
      UserEventNames.DERMI_CORTINA_GENERIC_MESSAGE_SENT,
      {}
    );
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/utils/user-events/enums.ts

export enum UserEventConstants {
  CUSTOMER_SUPPORT_USER_ID = 'cortina-support',
}

export enum UserEventNames {
  // Blocked by Lack of Data or APIs
  // DERMI_OTC_ORDER_DELIVERED = 'dermi_otc_order_delivered',

  DERMI_NEWSLETTER_SIGNUP = 'dermi_newsletter_signup',
  DERMI_COMPANY_CONTACT = 'dermi_company_contact',

  DERMI_CHECKOUT_STARTED = 'dermi_checkout_started',
  DERMI_CHECKOUT_COMPLETED_AND_PURCHASE = 'dermi_checkout_completed',

  DERMI_ADDED_TO_CART_RX = 'dermi_added_to_cart_rx',
  DERMI_ADDED_TO_CART_CONCIERGE = 'dermi_added_to_cart_concierge',
  DERMI_ADDED_TO_CART_OTC = 'dermi_added_to_cart_otc',
  DERMI_ADDED_TO_CART_CONSULTATION = 'dermi_added_to_cart_consultation',

  DERMI_REMOVED_FROM_CART_RX = 'dermi_removed_from_cart_rx',
  DERMI_REMOVED_FROM_CART_CONCIERGE = 'dermi_removed_from_cart_concierge',
  DERMI_REMOVED_FROM_CART_OTC = 'dermi_removed_from_cart_otc',
  DERMI_REMOVED_FROM_CART_CONSULTATION = 'dermi_removed_from_cart_consultation',

  DERMI_PURCHASE_RX = 'dermi_purchase_rx',
  DERMI_PURCHASE_CONCIERGE = 'dermi_purchase_concierge',
  DERMI_PURCHASE_OTC = 'dermi_purchase_otc',
  DERMI_PURCHASE_CONSULTATION = 'dermi_purchase_consultation',

  DERMI_OTC_ORDER_SHIPPED = 'dermi_otc_order_shipped',
  DERMI_RX_ORDER_SHIPPED = 'dermi_rx_order_shipped',

  DERMI_RX_ORDER_DELIVERED = 'dermi_rx_order_delivered',

  DERMI_SUBSCRIPTION_RENEWAL = 'dermi_subscription_renewal',

  DERMI_ACCOUNT_CREATED = 'dermi_account_created',
  DERMI_CASE_DIAGNOSED = 'dermi_case_diagnosed',
  DERMI_CASE_STARTED = 'dermi_case_started',
  DERMI_CASE_UPDATED = 'dermi_case_updated',
  DERMI_CASE_SUBMITTED = 'dermi_case_submitted',
  DERMI_CASE_SUBMITTED_IN_PREPAYMENT = 'dermi_case_submitted_in_prepayment',
  DERMI_COMPLAINT_PREFIX = 'dermi_case_submissions_complaint_',
  DERMI_CONCIERGE_CANCELLED = 'dermi_concierge_cancelled',
  DERMI_CONSULTATION_SUBMITTED = 'dermi_consultation_submitted',
  DERMI_CORTINA_GENERIC_MESSAGE_SENT = 'dermi_cortina_generic_message_sent',
  DERMI_PATIENT_CUSTOMER_SUPPORT_MESSAGE_SENT = 'dermi_patient_customer_support_message_sent',
  DERMI_PATIENT_MEDICAL_MESSAGE_SENT = 'dermi_patient_medical_message_sent',
  DERMI_NOTIFY_DOCTOR_OF_MESSAGE = 'dermi_notify_doctor_of_message',
  DERMI_NOTIFY_CUSTOMER_SUPPORT_OF_MESSAGE = 'dermi_notify_customer_support_of_message',

  DERMI_SEND_ORDERS_REPORT = 'dermi_send_orders_report',
  DERMI_SEND_CONSULTATIONS_REPORT = 'dermi_send_consultations_report',
  DERMI_SEND_USER_TREND_REPORT = 'dermi_send_user_trend_report',

  // RETIRED:
  // DERMI_PATIENT_GENERIC_MESSAGE_SENT = 'dermi_patient_generic_message_sent',

  // NON-CRITICAL / NICE TO HAVE:
  // DERMI_CUSTOMER_SUPPORT_MESSAGE_SENT = 'dermi_customer_support_message_sent',
  // DERMI_PHYSICIAN_MESSAGE_SENT = 'dermi_physician_message_sent',
  // DERMI_BLOG_NEW_ENTRY = 'dermi_blog_new_entry',
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi/src/styles/font-loader.ts

import { NextFontWithVariable } from 'next/dist/compiled/@next/font';
import { DM_Serif_Display } from 'next/font/google';
import localFont from 'next/font/local';

export const Financier = localFont({
  variable: '--font-financier',
  src: './fonts/financier-display-semibold.woff2',
  weight: '600',
});

export const DMSerifDisplay = DM_Serif_Display({
  variable: '--font-dmserifdisplay' as any,
  weight: '400',
  display: 'swap',
  subsets: ['latin'],
}) as NextFontWithVariable;

export const DMSans = localFont({
  variable: '--font-dmsans',
  src: [
    {
      path: './fonts/DMSans-Thin.ttf',
      weight: '100',
      style: 'normal',
    },
    {
      path: './fonts/DMSans-ThinItalic.ttf',
      weight: '100',
      style: 'italic',
    },
    {
      path: './fonts/DMSans-ExtraLight.ttf',
      weight: '200',
      style: 'normal',
    },
    {
      path: './fonts/DMSans-ExtraLightItalic.ttf',
      weight: '200',
      style: 'italic',
    },
    {
      path: './fonts/DMSans-Light.ttf',
      weight: '300',
      style: 'normal',
    },
    {
      path: './fonts/DMSans-LightItalic.ttf',
      weight: '300',
      style: 'italic',
    },
    {
      path: './fonts/DMSans-Regular.ttf',
      weight: '400',
      style: 'normal',
    },
    {
      path: './fonts/DMSans-Regular.ttf',
      weight: '400',
      style: 'italic',
    },
    {
      path: './fonts/DMSans-Medium.ttf',
      weight: '500',
      style: 'normal',
    },
    {
      path: './fonts/DMSans-MediumItalic.ttf',
      weight: '500',
      style: 'italic',
    },
    {
      path: './fonts/DMSans-SemiBold.ttf',
      weight: '600',
      style: 'normal',
    },
    {
      path: './fonts/DMSans-SemiBoldItalic.ttf',
      weight: '600',
      style: 'italic',
    },
    {
      path: './fonts/DMSans-Bold.ttf',
      weight: '700',
      style: 'normal',
    },
    {
      path: './fonts/DMSans-BoldItalic.ttf',
      weight: '700',
      style: 'italic',
    },
    {
      path: './fonts/DMSans-ExtraBold.ttf',
      weight: '800',
      style: 'normal',
    },
    {
      path: './fonts/DMSans-ExtraBoldItalic.ttf',
      weight: '800',
      style: 'italic',
    },
    {
      path: './fonts/DMSans-Black.ttf',
      weight: '900',
      style: 'normal',
    },
    {
      path: './fonts/DMSans-BlackItalic.ttf',
      weight: '900',
      style: 'italic',
    },
  ],
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/package.json

{
  "name": "dermi-tests",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {},
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@playwright/test": "^1.43.1",
    "@types/node": "^20.12.8"
  },
  "dependencies": {
    "@slack/bolt": "^3.18.0",
    "@types/chance": "^1.1.6",
    "@types/nodemailer": "^6.4.15",
    "@types/pdfkit": "^0.13.4",
    "@types/promise-fs": "^2.1.5",
    "axios": "^1.6.8",
    "chance": "^1.1.11",
    "dotenv": "^16.4.5",
    "fs": "^0.0.1-security",
    "moment": "^2.30.1",
    "nodemailer": "^6.9.13",
    "pdf-lib": "^1.17.1",
    "pdfkit": "^0.15.0",
    "twilio": "^5.0.4"
  }
}


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/playwright.config.ts

import dotenv from 'dotenv';
import path from 'path';

import { defineConfig, devices } from '@playwright/test';

export const STORAGE_STATE = path.join(
  __dirname,
  process.env.PATIENT_AUTH_FILE ?? 'playwright/.auth/patient.json'
);

dotenv.config();

export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: [['html'], ['./reporters/slackReporter.ts']],
  use: {
    baseURL: process.env.BASE_URL ?? 'https://dev.cortinahealth.com',
    trace: 'on-first-retry',
  },

  projects: [
    {
      name: 'chrome',
      use: {
        ...devices['Desktop Chrome'],
        viewport: { width: 1280, height: 740 },
      },
      testMatch: /end-to-end/,
    },
    {
      name: 'firefox',
      use: {
        ...devices['Desktop Firefox'],
        viewport: { width: 1280, height: 740 },
      },
      testMatch: /end-to-end/,
    },

    {
      name: 'safari',
      use: {
        ...devices['Desktop Safari'],
        viewport: { width: 1280, height: 740 },
      },
      testMatch: /end-to-end/,
    },
    {
      name: 'm-chrome',
      use: { ...devices['Pixel 5'], viewport: { width: 400, height: 660 } },
      testMatch: /end-to-end/,
    },
    {
      name: 'm-safari',
      use: { ...devices['iPhone 12'] },
      testMatch: /end-to-end/,
    },
    {
      name: 'unit-tests',
      use: { ...devices['Desktop Chrome'] },
      testMatch: /unit-tests/,
    },
  ],
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/tests/auth-patient.setup.ts

import { test as setup, expect } from '@playwright/test';

import { signIn } from '../utils/auth-helpers/authUtils';

setup('authenticate as patient', async ({ page, request }) => {
  await signIn(page, 'fenton+patient1@dermi.io', 'Testing123!');

  // wait for redirects to be done
  await page.waitForURL('/');

  await page.goto('/account');

  // make sure its not redirected back to signin
  await expect(page).toHaveURL('/account');

  await page.context().storageState({
    path: process.env.PATIENT_AUTH_FILE ?? 'playwright/.auth/patient.json',
  });
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/tests/auth-physician.setup.ts

import { test as setup, expect } from '@playwright/test';

import { signIn, userHasRole } from '../utils/auth-helpers/authUtils';

setup('authenticate as physician', async ({ page, context }) => {
  const userAlreadyAuthed = await userHasRole(context, 'PHYSICIAN');

  if (!userAlreadyAuthed) {
    await signIn(page, 'fenton+physician@dermi.io', 'Testing123!');

    // make sure the session token is there
    await expect
      .poll(async () => {
        const cookies = await context.cookies(page.url());
        return cookies.find(({ name }) => name === 'next-auth.session-token');
      })
      .toBeDefined();

    const userHasPhysicianRole = await userHasRole(context, 'PHYSICIAN');

    expect(userHasPhysicianRole).toBeTruthy();

    // End of authentication steps.

    await page.context().storageState({
      path:
        process.env.PHYSICIAN_AUTH_FILE ?? 'playwright/.auth/physician.json',
    });
  }
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/tests/signup-patient.setup.ts

import { test as setup, expect } from '@playwright/test';

import { signUp } from '../utils/auth-helpers/authUtils';
import {
  ScreenshotCounter,
  saveScreenShot,
} from '../utils/flow-helpers/screenshotUtil';

setup('signup as a patient', async ({ page }, testInfo) => {
  const screenshotCounter: ScreenshotCounter = { count: 0 };

  await signUp(page, testInfo, screenshotCounter);

  await page.waitForURL('/account');

  await saveScreenShot('account-page', page, testInfo, screenshotCounter);

  await expect(page).toHaveURL('/account');

  await page.context().storageState({
    path: process.env.PATIENT_AUTH_FILE ?? 'playwright/.auth/patient.json',
  });
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/tests/unit-tests/generatePdf.spec.ts

import fs from 'fs/promises';
import { PDFDocument } from 'pdf-lib';

import test, { expect } from '@playwright/test';

import { generateTestResultPdf } from '../../utils/pdfUtils';

// test PDF generation
test('Generates PDF from mock data', async () => {
  // make a dummy testInfo obj to pass mocked folders to
  const testInfo = {
    outputDir:
      '/Users/timfenton/Cortina/Code/Dermi/dermi-tests/tests/unit-tests/mocked/pdfoutput/lasjdfla',
  } as any;

  const pdfPath = await generateTestResultPdf(testInfo, fs, PDFDocument);

  expect(pdfPath).toBeTruthy();
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/tests/end-to-end/case-creation/new-support-message.spec.ts

import { test, expect } from '@playwright/test';

import { SlackLogLevel, slackLogLevel } from '../../../reporters/slackReporter';
import { signIn } from '../../../utils/auth-helpers/authUtils';
import { saveScreenShot } from '../../../utils/flow-helpers/screenshotUtil';
import { ScreenshotCounter } from '../../../utils/flow-helpers/screenshotUtil';
import { generateTestResultPdf } from '../../../utils/pdfUtils';
import { uploadAndSendResults } from '../../../utils/slackUtils';

test.afterAll(async ({}, testInfo) => {
  const filePath = await generateTestResultPdf(testInfo);

  if (!filePath) {
    console.log('pdf result generation failed.');
    return;
  }

  if (slackLogLevel !== SlackLogLevel.None)
    await uploadAndSendResults(filePath, testInfo);
});

test.describe.configure({ mode: 'serial' });
test.setTimeout(60000);

test.use({ storageState: undefined });

test('Send Support Message', async ({ page }, testInfo) => {
  const screenshotCounter: ScreenshotCounter = { count: 0 };

  //Sign in as patient
  await signIn(page, 'christina+testing-user@dermi.io', 'Asdf1Asdf1!');
  await page.waitForURL('/account');
  await saveScreenShot('account-page', page, testInfo, screenshotCounter);
  await expect(page).toHaveURL('/account');

  // Navigate to Messages section
  await page.getByRole('link', { name: 'Messages' }).click();
  await saveScreenShot('messages-page', page, testInfo, screenshotCounter);
  await expect(page).toHaveURL('/account/messaging');

  // Click on New Message
  await page.getByRole('button', { name: 'New' }).click();
  await saveScreenShot(
    'message-support-modal',
    page,
    testInfo,
    screenshotCounter
  );
  await expect(page.locator('text=Message Cortina Support')).toBeVisible();

  //Send a message to support
  await page.getByRole('button', { name: 'Message Cortina Support' }).click();
  await saveScreenShot(
    'message-input-modal',
    page,
    testInfo,
    screenshotCounter
  );
  await page.getByPlaceholder('Type message here...').click();
  await expect(page.locator('text=Cortina Support Message')).toBeVisible();
  await page.getByPlaceholder('Type message here...').fill('Hello I need help');
  await page.getByRole('button', { name: 'Send Message' }).click();
  await saveScreenShot('message-sent', page, testInfo, screenshotCounter);
  await expect(page.locator('text=Hello I need help')).toBeVisible();
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/tests/end-to-end/case-creation/acne-self-newuser.spec.ts

import { test, expect } from '@playwright/test';

import { STORAGE_STATE } from '../../../playwright.config';
import { SlackLogLevel, slackLogLevel } from '../../../reporters/slackReporter';
import { signUp } from '../../../utils/auth-helpers/authUtils';
import {
  finishConsultation,
  purchaseConsultation,
} from '../../../utils/flow-helpers/consultationUtils';
import {
  fillMedicationsAndAllergies,
  fillPrimaryCareProvider,
  fillUserDobAndSex,
  fillUserMedicalConditions,
} from '../../../utils/flow-helpers/flowHelper';
import { saveScreenShot } from '../../../utils/flow-helpers/screenshotUtil';
import { ScreenshotCounter } from '../../../utils/flow-helpers/screenshotUtil';
import { generateAcneUser } from '../../../utils/generators/acneUserGenerator';
import { generateTestResultPdf } from '../../../utils/pdfUtils';
import { uploadAndSendResults } from '../../../utils/slackUtils';

test.afterAll(async ({}, testInfo) => {
  const filePath = await generateTestResultPdf(testInfo);

  if (!filePath) {
    console.log('pdf result generation failed.');
    return;
  }

  if (slackLogLevel !== SlackLogLevel.None)
    await uploadAndSendResults(filePath, testInfo);
});

// generate the user data to use for the new user
const fakeUser = generateAcneUser();

test.describe.configure({ mode: 'serial' });
test.setTimeout(90000);

test.use({ storageState: undefined });

test('Create user', async ({ page }, testInfo) => {
  const screenshotCounter: ScreenshotCounter = { count: 0 };

  await signUp(page, testInfo, screenshotCounter);

  await page.waitForURL('/account');

  await saveScreenShot('account-page', page, testInfo, screenshotCounter);

  await expect(page).toHaveURL('/account');

  await page.context().storageState({
    path: STORAGE_STATE,
  });
});

test.describe('Acne Flow', () => {
  test.use({ storageState: STORAGE_STATE });

  test('Purchase Consultation', async ({ page }, testInfo) => {
    const screenshotCounter: ScreenshotCounter = { count: 0 };

    await page.goto('/account');
    // are we authenticated?
    await expect(page).toHaveURL('/account');

    await saveScreenShot('account-page', page, testInfo, screenshotCounter);

    // new vs returning
    if (
      !(await page
        .getByRole('link', { name: 'Start a Consultation' })
        .isVisible())
    )
      await page.getByRole('button', { name: 'New Consultation' }).click();
    else await page.getByRole('link', { name: 'Start a Consultation' }).click();

    await page.waitForURL('/account/start');

    await saveScreenShot(
      'account-start-page',
      page,
      testInfo,
      screenshotCounter
    );
    await page.getByRole('link', { name: 'For Myself' }).click();

    await purchaseConsultation(
      page,
      fakeUser,
      'Acne',
      testInfo,
      screenshotCounter
    );

    // purchase success?
    await page.waitForURL('/account/your-medical-history?condition=Acne');
    await saveScreenShot(
      'medical-profile-start',
      page,
      testInfo,
      screenshotCounter
    );

    await expect(page).toHaveURL(
      '/account/your-medical-history?condition=Acne'
    );
  });

  test('Create Medical Profile', async ({ page, storageState }, testInfo) => {
    page.context().storageState({ path: STORAGE_STATE });
    const screenshotCounter: ScreenshotCounter = { count: 0 };
    // medical profile
    await page.goto('/account/your-medical-history?condition=Acne');
    await saveScreenShot('dob-and-sex', page, testInfo, screenshotCounter);

    await fillUserDobAndSex(page, fakeUser);
    await page.getByRole('button', { name: 'Next' }).click();

    await saveScreenShot(
      'medications-and-allergies',
      page,
      testInfo,
      screenshotCounter
    );
    const allergyCount = await page
      .locator('#field-1-medicationallergies-input > div')
      .count();
    const medicationCount = await page
      .locator('#field-0-currentmedications-input > div')
      .count();
    if (allergyCount < 2 && medicationCount < 2)
      await fillMedicationsAndAllergies(page, fakeUser);
    await page.getByRole('button', { name: 'Next' }).click();
    await saveScreenShot(
      'medical-conditions',
      page,
      testInfo,
      screenshotCounter
    );
    await fillUserMedicalConditions(page, fakeUser);
    await page.getByRole('button', { name: 'Next' }).click();
    await saveScreenShot('primary-care', page, testInfo, screenshotCounter);
    await fillPrimaryCareProvider(page, fakeUser);
    await page.getByRole('button', { name: 'Next' }).click();
    await saveScreenShot(
      'review-medical-profile',
      page,
      testInfo,
      screenshotCounter
    );
    await page.getByRole('button', { name: 'Submit' }).click();

    await page.waitForURL('/account/acne?condition=Acne');
    await saveScreenShot('acne-form-start', page, testInfo, screenshotCounter);
    await expect(page).toHaveURL('/account/acne?condition=Acne');
  });

  test('Complete Acne Consultation', async ({ page }, testInfo) => {
    const screenshotCounter: ScreenshotCounter = { count: 0 };
    await page.goto('/account/acne?condition=Acne');
    await saveScreenShot(
      'skin-care-products',
      page,
      testInfo,
      screenshotCounter
    );

    for (const skinProduct of fakeUser.flowAnswers.skinCareProducts)
      await page.getByText(skinProduct).click();

    await page.getByRole('button', { name: 'Next' }).click();
    await saveScreenShot('ailment-symptoms', page, testInfo, screenshotCounter);
    for (const symptom of fakeUser.flowAnswers.symptoms)
      await page.getByText(symptom).click();
    await page.getByRole('button', { name: 'Next' }).click();
    await saveScreenShot('acne-flow-lowT', page, testInfo, screenshotCounter);
    await page.getByText(fakeUser.flowAnswers.lowT).click();
    await page.getByRole('button', { name: 'Next' }).click();
    if (await page.getByText('Family Planning').isVisible()) {
      await saveScreenShot(
        'family-planning',
        page,
        testInfo,
        screenshotCounter
      );
      await page.getByText(fakeUser.flowAnswers.familyPlanning).click();
      await page.getByRole('button', { name: 'Next' }).click();
    }
    await saveScreenShot('tretinoin-info', page, testInfo, screenshotCounter);
    await page.getByRole('button', { name: 'Next' }).click();
    // physician message to submit
    await finishConsultation(page, fakeUser, testInfo, screenshotCounter);
  });
});


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/utils/pdfUtils.ts

import fs from 'fs/promises';
import path from 'path';
import { PDFDocument, StandardFonts, rgb } from 'pdf-lib';

interface MappedFolder {
  creationTime: number;
  testName: string;
  files: {
    filePath: string;
    stepNum: number;
  }[];
}

export const generateTestResultPdf = async (
  testInfo: { outputDir: string },
  fsModule: typeof fs = fs, // allow module injection for testing
  pdfLibModule: typeof PDFDocument = PDFDocument // allow module injection for testing
): Promise<string | null> => {
  const doc = await pdfLibModule.create();
  const helveticaFont = await doc.embedFont(StandardFonts.Helvetica);

  try {
    const outputDir = path.join(testInfo.outputDir, '../');

    const rawFolders = await fsModule.readdir(outputDir, {
      withFileTypes: true,
    });

    // filter out weird hidden files
    const folders = rawFolders
      .filter((f) => f.isDirectory() && !f.name.startsWith('.'))
      .map((f) => f.name);

    const mappedFoldersPromises = folders.map(
      async (folderName): Promise<MappedFolder> => {
        const dirPath = path.join(outputDir, folderName);
        const testName = folderName.split('_')?.[1];

        // Get folder creation time
        const stats = await fsModule.stat(dirPath);
        const creationTime = stats.birthtime.getTime();

        // Get files in the folder
        const files = await fsModule.readdir(dirPath);

        // Map file paths
        const filePaths = files.map((fileName) => {
          const step = parseInt(
            fileName.split('.')?.[1]?.replace('Step ', '') ?? '-1'
          );

          return {
            filePath: path.join(dirPath, fileName),
            stepNum: step,
          };
        });

        filePaths.sort((a, b) => a.stepNum - b.stepNum);

        return {
          creationTime,
          testName,
          files: filePaths,
        };
      }
    );

    const mappedFolders = await Promise.all(mappedFoldersPromises);

    mappedFolders.sort((a, b) => a.creationTime - b.creationTime);

    const textPadding = 70;

    for (const folderInfo of mappedFolders) {
      for (const fileInfo of folderInfo.files) {
        console.log('processing file', fileInfo);
        const { filePath: file, stepNum } = fileInfo;
        if (file.endsWith('.jpg')) {
          const screenshotPath = file;
          const imageBytes = await fsModule.readFile(screenshotPath);
          const image = await doc.embedJpg(imageBytes);
          const { width, height } = image.scale(0.5);
          const page = doc.addPage([width, height + textPadding]);

          // split file based on naming in screenshotUtil > getScreenshotPath
          const splitPath = file.split('.');
          const splitDirs = splitPath[0].split('/');
          const flowName = splitDirs[splitDirs.length - 1];
          const stepNum = splitPath[1];
          const stepName =
            splitPath[2].charAt(0).toUpperCase() +
            splitPath[2].replace(/-/g, ' ').slice(1);

          page.setFont(helveticaFont);

          page.drawText(`${stepNum}: ${stepName}`, {
            x: 20,
            y: 20,
            color: rgb(0.5, 0.5, 0.5),
            size: 10,
          });

          page.drawText(`${flowName} flow`, {
            x: 20,
            y: 40,
            color: rgb(0.2, 0.2, 0.4),
            size: 14,
          });

          page.drawLine({
            start: { x: 0, y: textPadding },
            end: { x: width, y: textPadding },
            thickness: 1,
            color: rgb(0.7, 0.7, 0.7),
          });

          page.drawImage(image, {
            x: 0,
            y: textPadding,
            width: width,
            height: height,
          });
        }
      }
    }

    const pdfBytes = await doc.save();
    const pdfPath = path.join(
      testInfo.outputDir,
      `../${Date.now()}.screenshots.pdf`
    );

    await fsModule.writeFile(pdfPath, pdfBytes, {
      encoding: 'utf8',
      flag: 'w',
    });

    return pdfPath;
  } catch (err) {
    console.log('error saving pdf', err);
    return null;
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/utils/isMobile.ts

export const isMobile = (
  viewportSize: { width: number; height: number } | null
) => {
  if (!viewportSize || viewportSize.width > 768) return false;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/utils/getApiUrl.ts

export const getApiUrl = (route: string) => {
  const cleanedRoute = !route.startsWith('/') ? `/${route}` : route;
  const apiUrlWithRoute = `${String(process.env.BASE_URL)}/api${cleanedRoute}`;
  return apiUrlWithRoute;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/utils/slackUtils.ts

import dotenv from 'dotenv';
import moment from 'moment';

import { TestInfo } from '@playwright/test';
import { App } from '@slack/bolt';

const testingSlackChannel = String(process.env.SLACK_TEST_CHANNEL_WEBHOOK);

const appToken = String(process.env.SLACK_BOT_TOKEN);
const appSecret = String(process.env.SLACK_SIGNING_SECRET);

const app = new App({
  token: appToken,
  signingSecret: appSecret,
});

export const uploadAndSendResults = async (
  filePath: string,
  testInfo: TestInfo
) => {
  const splitPath = filePath.split('/');

  const result = await app.client.filesUploadV2({
    file: filePath,
    filename: splitPath[splitPath.length - 1],
    initial_comment: `Screenshots from the Test run @ ${moment()}`,
    channel_id: String(process.env.SLACK_TEST_CHANNEL_ID),
  });

  if (result.error) {
    console.log('error uploading the file to slack.', result);
    throw result.error;
  }
};

export const sendSlackMessage = async (body: string): Promise<boolean> => {
  console.log('slack url', testingSlackChannel);
  try {
    if (!testingSlackChannel) {
      console.log('slack url is missing');
      return false;
    }

    const response = await fetch(testingSlackChannel, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body,
    });

    if (!response.ok) {
      console.log('slack message failed', response.body);
      return false;
    }

    return true;
  } catch (error) {
    console.log('an error occurred sending slack message', error);
    return false;
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/utils/flow-helpers/screenshotUtil.ts

import { type Page, TestInfo, ElementHandle } from '@playwright/test';

import { waitForTranslation } from './waitingUtils';

export interface ScreenshotCounter {
  count: number;
}

export const saveScreenShot = async (
  name: string,
  page: Page,
  testInfo: TestInfo,
  screenshotCounter: ScreenshotCounter
) => {
  try {
    if (page.url().startsWith(String(process.env.BASE_URL))) {
      // wait for loading spinner to stop
      await page
        .locator('.animate-spin')
        .first()
        .waitFor({ state: 'detached' });

      // wait for skeletons to go away
      await page
        .locator('.animate-pulse')
        .first()
        .waitFor({ state: 'detached' });

      // wait for sliding form steps
      if ((await page.locator('.form-step').count()) > 0) {
        console.log('waiting for animation');
        await waitForTranslation(page, '.form-step');
      }
    }
    await page.screenshot({
      path: getScreenshotPath(name, testInfo, screenshotCounter),
      fullPage: true,
      type: 'jpeg',
      timeout: 30000,
    });
  } catch (e) {
    console.log('Error trying to screenshot: ', e);
  }
};

const getScreenshotPath = (
  name: string,
  testInfo: TestInfo,
  screenshotCounter: ScreenshotCounter
) => {
  const outputDir = testInfo.outputDir;

  const filePath = `${outputDir}/${
    testInfo.title
  }.Step ${++screenshotCounter.count}.${name}.jpg`;
  return filePath;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/utils/flow-helpers/waitingUtils.ts

import { Page, expect } from '@playwright/test';

export const waitForTranslation = (page: Page, selector: string) => {
  return expect(page.locator(selector)).toHaveCSS('transform', 'none');
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/utils/flow-helpers/flowHelper.ts

import { Page, TestInfo, expect } from '@playwright/test';

import { FakeUser } from '../generators/dataGenerator';
import { ScreenshotCounter, saveScreenShot } from './screenshotUtil';

export const fillUserDobAndSex = async (page: Page, fakeUser: FakeUser) => {
  await page.getByPlaceholder('Select date').click();
  await page
    .locator('div')
    .filter({ hasText: /^Today$/ })
    .getByRole('textbox')
    .fill(fakeUser.medicalProfile.dob);
  await page
    .locator('div')
    .filter({ hasText: /^Today$/ })
    .getByRole('textbox')
    .press('Enter');
  await page.getByRole('button', { name: 'Apply' }).click();
  await page.getByText(fakeUser.medicalProfile.gender, { exact: true }).click();
};

export const fillUserAddress = async (page: Page, fakeUser: FakeUser) => {
  const hasAddress = !(await page
    .getByRole('button', { name: 'Add an address' })
    .isVisible());

  if (!hasAddress)
    await page.getByRole('button', { name: 'Add an address' }).click();
  else await page.getByRole('button', { name: 'Edit' }).click();
  await page.getByPlaceholder('e.g. Home').fill('Home');
  await page.waitForSelector('#undefined-input');
  await page.getByPlaceholder('Enter a location').fill(fakeUser.address1);
  if (fakeUser.address2)
    await page
      .getByRole('textbox', { name: 'address2' })
      .fill(fakeUser.address2);
  await page.getByRole('textbox', { name: 'city' }).fill(fakeUser.city);
  await page.getByLabel('State', { exact: true }).click();
  await page.getByRole('option', { name: fakeUser.state, exact: true }).click();
  await page.getByRole('textbox', { name: 'zip' }).fill(fakeUser.zip);
  if (!hasAddress) await page.getByRole('button', { name: 'Add' }).click();
  else await page.getByRole('button', { name: 'Update' }).click();
};

export const addPaymentAndSubmit = async (
  page: Page,
  testInfo: TestInfo,
  screenshotCounter: ScreenshotCounter,
  promoCode?: string
) => {
  await page.waitForURL(/\/shop\/checkout/);
  await saveScreenShot('checkout-page', page, testInfo, screenshotCounter);

  const paymentFrame = page
    .frameLocator('iframe[title="Secure payment input frame"]')
    .first();
  await paymentFrame.locator('#Field-numberInput').fill('4242 4242 4242 42422');
  await paymentFrame.locator('#Field-expiryInput').fill('02 / 56');
  await paymentFrame.locator('#Field-cvcInput').fill('123');

  const sameAsShipping = paymentFrame.locator('.CheckboxInput')?.first();
  expect(sameAsShipping).toBeTruthy();
  await sameAsShipping.check();

  if (promoCode) {
    await page.getByLabel('Promo Code', { exact: true }).fill(promoCode);
    await page.getByText('Apply', { exact: true }).click();
  }

  const completeOrderBtn = page.getByRole('button', { name: 'Checkout' });
  await completeOrderBtn.scrollIntoViewIfNeeded();
  await expect(completeOrderBtn).toBeEnabled();
  await completeOrderBtn.click({ delay: 1000 });
  await page
    .getByRole('button', { name: /Submitting/ })
    .scrollIntoViewIfNeeded();
  await expect(
    page.getByRole('button', { name: /Submitting/ })
  ).toBeInViewport();
};

export const fillMedicationsAndAllergies = async (
  page: Page,
  fakeUser: FakeUser
) => {
  if (fakeUser.medicalProfile.medications) {
    for (const medication of fakeUser.medicalProfile.medications) {
      const medicationField = page.getByPlaceholder('Search for medications…');
      await medicationField.fill(medication);
      const firstMedication = page
        .getByRole('option', {
          name: medication,
        })
        .first();
      await firstMedication.click();
    }
  }

  if (fakeUser.medicalProfile.allergies) {
    for (const allergy of fakeUser.medicalProfile.allergies) {
      await page
        .getByPlaceholder('Search for allergies...')
        .fill('acetaminophen');
      const firstAllergy = page
        .getByRole('option', {
          name: allergy,
        })
        .first();
      await firstAllergy.click();
    }
  }
};

export const fillUserMedicalConditions = async (
  page: Page,
  fakeUser: FakeUser
) => {
  if (!fakeUser.medicalProfile.medicalConditions)
    await page.getByText('No', { exact: true }).click();
  else {
    await page.getByText('Yes', { exact: true }).click();
    await page
      .getByRole('textbox', { name: 'aboutMedicalCondition' })
      .fill(fakeUser.medicalProfile.medicalConditions);
  }
};

export const fillPrimaryCareProvider = async (
  page: Page,
  fakeUser: FakeUser
) => {
  if (fakeUser.medicalProfile.primaryCareProvider) {
    const { name, address1, address2, state, city, zip } =
      fakeUser.medicalProfile.primaryCareProvider;
    await page.getByText('Yes', { exact: true }).click();
    await page.getByLabel('Name of the primary care provider').fill(name);
    await page.waitForSelector('#field-2-addressaddressline1-input');
    await page.getByPlaceholder('Enter a location').fill(address1);
    if (address2)
      await page
        .getByRole('textbox', { name: 'address.addressLine2' })
        .fill(address2);
    await page.getByLabel('State', { exact: true }).click();
    await page
      .getByRole('option', {
        name: state,
        exact: true,
      })
      .click();
    await page.getByLabel('City').fill(city);
    await page.getByLabel('Zip Code').fill(zip);
  } else {
    await page.getByText('No', { exact: true }).click();
  }
};

export const waitForElementCount = async (page, selector, count) => {
  await page.waitForSelector(selector, { state: 'attached' });
  await page.waitForFunction(
    (selector, count) => document.querySelectorAll(selector).length === count,
    {},
    selector,
    count
  );
};

export const uploadFile = async (page: Page, imagePaths: string[]) => {
  const fileChooserPromise = page.waitForEvent('filechooser');
  await page.getByText('Click to upload').click();
  const fileChooser = await fileChooserPromise;
  await fileChooser.setFiles(imagePaths);
  // validate the files uploaded
  await page.waitForFunction(
    ({ imagePaths }) => {
      const allButtons = Array.from(document.querySelectorAll('button'));
      const previewButtons = allButtons.filter(
        (button) => button?.textContent?.trim() === 'View Preview'
      );
      return previewButtons.length === imagePaths.length;
    },
    {
      imagePaths,
    }
  );
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/utils/flow-helpers/consultationUtils.ts

import { Page, TestInfo, expect } from '@playwright/test';

import { FakeUser } from '../generators/dataGenerator';
import {
  addPaymentAndSubmit,
  fillUserAddress,
  fillUserDobAndSex,
  uploadFile,
} from './flowHelper';
import { ScreenshotCounter, saveScreenShot } from './screenshotUtil';

export const purchaseConsultation = async (
  page: Page,
  fakeUser: FakeUser,
  consultationType: string,
  testInfo: TestInfo,
  screenshotCounter: ScreenshotCounter
) => {
  await page.waitForURL('/account/consultation');
  await saveScreenShot('consultation-type', page, testInfo, screenshotCounter);
  await page.getByText(consultationType).click();
  await page.getByRole('button', { name: 'Next' }).click();
  await saveScreenShot('condition-info', page, testInfo, screenshotCounter);
  await page.getByRole('button', { name: 'Next' }).click();
  await saveScreenShot('how-long-question', page, testInfo, screenshotCounter);
  await page.getByText(fakeUser.flowAnswers.howLong).click();
  await page.getByRole('button', { name: 'Next' }).click();
  await saveScreenShot('concierge-info', page, testInfo, screenshotCounter);
  await page.getByRole('button', { name: 'Next' }).click();
  await saveScreenShot('skin-profile', page, testInfo, screenshotCounter);
  await page.getByText(fakeUser.medicalProfile.skinTone).click();
  await page.getByText(fakeUser.medicalProfile.skinType).click();
  await page.getByRole('button', { name: 'Next' }).click();
  await saveScreenShot('skin-info', page, testInfo, screenshotCounter);
  await page.getByRole('button', { name: 'Next' }).click();
  await saveScreenShot('user-profile', page, testInfo, screenshotCounter);
  await page.getByLabel('First Name').fill(fakeUser.firstName);
  await page.getByLabel('Last Name').fill(fakeUser.lastName);
  await page.getByLabel('Phone Number').fill(fakeUser.phoneNumber);

  await fillUserAddress(page, fakeUser);
  await fillUserDobAndSex(page, fakeUser);

  await page.getByLabel('By clicking this box, I').check();
  await page.getByRole('button', { name: 'Submit' }).click();

  await addPaymentAndSubmit(page, testInfo, screenshotCounter);
};

export const finishConsultation = async (
  page: Page,
  fakeUser: FakeUser,
  testInfo: TestInfo,
  screenshotCounter: ScreenshotCounter
) => {
  await saveScreenShot('doctor-message', page, testInfo, screenshotCounter);
  await page.getByPlaceholder('Enter any additional').click();
  await page
    .getByPlaceholder('Enter any additional')
    .fill(fakeUser.flowAnswers.messageToDoctor);
  await page.getByRole('button', { name: 'Next' }).click();
  await saveScreenShot('pharmacy-entry', page, testInfo, screenshotCounter);
  await page.getByPlaceholder('Pharmacy Name').fill('sholl');
  await page.getByRole('button', { name: 'Search' }).click();
  await page.getByRole('button', { name: 'Select' }).click();
  await page.getByRole('button', { name: 'Next' }).click();
  await saveScreenShot(
    'condition-photo-location',
    page,
    testInfo,
    screenshotCounter
  );
  await page
    .getByText(fakeUser.flowAnswers.photosOfConditions.location)
    .first()
    .click();
  await page.getByRole('button', { name: 'Next' }).click();
  await saveScreenShot(
    'condition-photo-upload',
    page,
    testInfo,
    screenshotCounter
  );

  await uploadFile(page, fakeUser.flowAnswers.photosOfConditions.images);

  await page.getByRole('button', { name: 'Next' }).click();
  await saveScreenShot(
    'drivers-license-upload',
    page,
    testInfo,
    screenshotCounter
  );

  await uploadFile(page, fakeUser.driversLicenseImages);

  await page.getByRole('button', { name: 'Next' }).click();
  await saveScreenShot('review-case', page, testInfo, screenshotCounter);
  await page.getByRole('button', { name: 'Submit' }).click();

  // Normal Acne Flow
  //const submitSuccess = page.getByText('Consultation Submitted!');

  // Current Sync Visit Submission Screen
  const submitSuccess = page.getByText('Schedule Video Visit');

  await submitSuccess.waitFor({ state: 'visible', timeout: 10000 });

  await expect(submitSuccess).toBeAttached();

  await saveScreenShot(
    'consultation-submitted',
    page,
    testInfo,
    screenshotCounter
  );
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/utils/generators/acneUserGenerator.ts

import path from 'path';

import { FakeUser, chance, generateBaseUser } from './dataGenerator';

export const generateAcneUser = (): FakeUser => {
  const acneUser = generateBaseUser();

  const acneImages = [];
  const dlImages = [];

  acneUser.flowAnswers = {
    howLong: chance.pickone(['Days', 'Weeks', 'Months', 'Years']),
    skinCareProducts: chance.pickset([
      'Cleanser',
      'Toner',
      'Moisturizer',
      'Serum',
      'Oils',
      'Eye Cream',
      'Anti-Aging',
    ]),
    symptoms: chance.bool()
      ? chance.pickset([
          'Abdominal pain',
          'Anxiety or depression',
          'Blood in stool',
          'Blood in urine',
          'Chest pain',
          'Discharge',
          'Fatigue',
          'Fever or malaise',
          'Headaches',
          'Joint pain',
          'Muscle pain',
          'Nose bleeds',
          'Shortness of breath',
          'Sore throat',
          'Swollen lymph nodes',
          'Visual change',
          'Weight loss',
        ])
      : ['None of the above'],
    lowT: chance.bool()
      ? 'I have experienced and/or been diagnosed with low testosterone levels (hypogonadism)'
      : 'This does not apply to me',
    familyPlanning:
      acneUser.medicalProfile.gender === 'FEMALE'
        ? chance.pickone([
            "I haven't started menstruating yet",
            "I have menstrual cycles, but I'm not pregnant, attempting to conceive or breastfeeding",
            'I am attempting to conceive',
            'I am expecting a baby',
            'I am presently breastfeeding',
            'I am going through menopause',
          ])
        : "I haven't started menstruating yet",
    messageToDoctor: chance.paragraph(),
    photosOfConditions: {
      location: chance.pickone([
        'Head / Neck',
        'Back',
        'Legs / Feet',
        'Chest',
        'Arms / Hands',
        'Armpits',
        'Other',
      ]),
      images: [
        path.join(
          __dirname,
          '../',
          '../',
          `test-files/acne-images/face/image${chance.integer({
            min: 1,
            max: 10,
          })}.jpg`
        ),
        path.join(
          __dirname,
          '../',
          '../',
          `test-files/acne-images/face/image${chance.integer({
            min: 1,
            max: 10,
          })}.jpg`
        ),
      ],
    },
  };

  return acneUser;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/utils/generators/dataGenerator.ts

import Chance from 'chance';
import moment from 'moment';
import path from 'path';

export const chance = new Chance();

export interface FakeUser {
  firstName: string;
  lastName: string;
  phoneNumber: string;
  address1: string;
  address2?: string;
  city: string;
  state: string;
  zip: string;
  driversLicenseImages: string[];
  medicalProfile: {
    dob: string;
    gender: string;
    medications?: string[];
    allergies?: string[];
    skinTone: string;
    skinType: string;
    medicalConditions?: string;
    primaryCareProvider?: {
      name: string;
      address1: string;
      address2?: string;
      state: string;
      city: string;
      zip: string;
    };
  };
  flowAnswers: any;
}

const generateRandomState = (): string => {
  const randomState = chance.state({ full: true });

  if (randomState === 'District of Columbia') {
    return 'Tennessee';
  }

  return randomState;
};

export const generateBaseUser = (): FakeUser => {
  const fakeUserGender = chance.gender().toUpperCase();

  const fakeUser: FakeUser = {
    firstName: chance.first(),
    lastName: chance.last(),
    phoneNumber: `1${chance.phone({ formatted: false })}`,
    address1: chance.address(),
    city: chance.city(),
    state: generateRandomState(),
    zip: chance.zip(),
    driversLicenseImages: [
      path.join(
        __dirname,
        '../',
        '../',
        `test-files/drivers-license/image${chance.integer({
          min: 1,
          max: 10,
        })}.jpg`
      ),
    ],
    medicalProfile: {
      dob: moment(
        new Date(
          chance.birthday({
            string: true,
            year: chance.year({
              min: moment().year() - 100,
              max: moment().year() - 19,
            }),
          })
        )
      ).format('MMM DD, YYYY'),
      gender: fakeUserGender,
      medications: ['tylenol'],
      allergies: ['acetaminophen'],
      skinTone: chance.pickone([
        'Very Fair / Very Light',
        'Fair / Light',
        'Olive or Medium',
        'Light Brown',
        'Dark Brown',
        'Very Dark',
      ]),
      skinType: chance.pickone([
        'Normal',
        'Oily',
        'Sensitive',
        'Combination',
        'Dry',
      ]),
      primaryCareProvider: {
        name: chance.name(),
        address1: chance.address(),
        city: chance.city(),
        state: chance.state({ full: true }),
        zip: chance.zip(),
      },
    },
    flowAnswers: {},
  };
  return fakeUser;
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/utils/auth-helpers/getSessionFromFile.ts

import { readFile } from 'fs/promises';

import { BrowserContext } from '@playwright/test';

export const getSessionFromFile = async (
  context: BrowserContext,
  sessionFile: string
) => {
  const sessionStorage = JSON.parse(await readFile(sessionFile, 'utf-8'));
  await context.addInitScript((storage) => {
    for (const [key, value] of Object.entries(storage)) {
      const stringValue = value ? value.toString() : '';
      window.sessionStorage.setItem(key, stringValue);
    }
  }, sessionStorage);
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/utils/auth-helpers/authUtils.ts

import axios from 'axios';
import ChanceJS from 'chance';

import {
  BrowserContext,
  Page,
  TestInfo,
  errors,
  expect,
} from '@playwright/test';

import {
  ScreenshotCounter,
  saveScreenShot,
} from '../flow-helpers/screenshotUtil';

export const userHasRole = async (
  context: BrowserContext,
  role: string
): Promise<boolean> => {
  const checkMe = await context.request.get('/api/user/me');

  if (!checkMe.ok()) return false;

  return (await checkMe.json())?.roles.contains(role);
};

export const signIn = async (page: Page, email: string, password: string) => {
  await page.goto('/signin');

  await page.getByLabel('Email Address').click();
  await page.getByLabel('Email Address').fill(email);
  await page.getByLabel('Password').click();
  await page.getByLabel('Password').fill(password);

  await page.getByRole('button', { name: 'Log in' }).click();
};

export const signUp = async (
  page: Page,
  testInfo: TestInfo,
  screenshotCounter: ScreenshotCounter
) => {
  const tag = await generateRandomTag();

  const email = `${process.env.TESTMAIL_NAMESPACE}.${tag}@inbox.testmail.app`;
  const password = 'Testing123!';

  await page.goto('/account');
  await page.waitForURL(/signin\?callbackUrl=/);

  await saveScreenShot('login-page', page, testInfo, screenshotCounter);
  await page.getByRole('button', { name: 'Sign up' }).click();

  await saveScreenShot('signup-page', page, testInfo, screenshotCounter);
  await page.getByLabel('Email Address').click();
  await page.getByLabel('Email Address').fill(email);
  await page.getByLabel('Password', { exact: true }).click();
  await page.getByLabel('Password', { exact: true }).fill(password);
  await page.getByLabel('Confirm Password').click();
  await page.getByLabel('Confirm Password').fill(password);

  const signupTime = Date.now(); // capture the time the button is pushed
  await page.getByRole('button', { name: 'Sign up' }).click();

  await page.waitForSelector('#code', {
    state: 'attached',
  });
  await saveScreenShot('confirmation-page', page, testInfo, screenshotCounter);
  const confirmationCode = await getConfirmationCode(tag, signupTime);
  await page.getByLabel('Confirmation Code').click();
  await page.getByLabel('Confirmation Code').fill(confirmationCode);
  await page.getByRole('button', { name: 'Confirm Account' }).click();
};

export const generateRandomTag = async (): Promise<string> => {
  const chance = new ChanceJS();
  const randomTag = chance.string({
    length: 12,
    pool: 'abcdefghijklmnopqrstuvwxyz0123456789',
  });

  return randomTag;
};

export const getConfirmationCode = async (
  tag: string,
  signupTime: number
): Promise<string> => {
  const testmailApiRoute = `https://api.testmail.app/api/json?apikey=${process.env.TESTMAIL_APIKEY}&namespace=${process.env.TESTMAIL_NAMESPACE}`;

  const response = await axios.get(
    `${testmailApiRoute}&tag=${tag}&timestamp_from=${signupTime}&livequery=true`,
    { timeout: 300000 } // using live query 307 loops, set long timeout to ensure email comes within 5 minutes
  );

  if (response && response.status === 200) {
    const inbox = response.data;
    const latestEmail = inbox.emails[0].html;

    const regex = /Your confirmation code is (\d+)/;
    const match = latestEmail.match(regex);

    if (match) {
      const confirmationCode = match[1]; // Extract the captured digits

      return confirmationCode;
    } else {
      throw Error('No confirmation code found.');
    }
  } else {
    throw Error('Bad response from tesmail api.');
  }
};


// Contents of file: /Users/tritz/Desktop/CODE/DERMI/VERCEL_BUILD_ONE/Dermi/dermi-tests/reporters/slackReporter.ts

import type {
  FullConfig,
  FullResult,
  Reporter,
  Suite,
  TestCase,
  TestResult,
} from '@playwright/test/reporter';

import { sendSlackMessage } from '../utils/slackUtils';

export enum SlackLogLevel {
  None = 0,
  Basic = 1,
  Full = 2,
}

export const slackLogLevel = parseInt(
  String(process.env.SLACK_LOG_LEVEL)
) as SlackLogLevel;

class SlackReporter implements Reporter {
  async onBegin(
    config: FullConfig,
    suite: Suite
  ): Promise<{ status?: FullResult['status'] } | undefined | void> {
    console.log(`Starting the run with ${suite.allTests().length} tests`);
    if (slackLogLevel === SlackLogLevel.Full)
      await sendSlackMessage(
        JSON.stringify({
          blocks: [
            {
              type: 'section',
              text: {
                type: 'mrkdwn',
                text: `:test_tube: End to end tests are running on development. Executing ${
                  suite.allTests().length
                } tests. `,
              },
            },
          ],
        })
      );
  }

  async onTestBegin(
    test: TestCase,
    result: TestResult
  ): Promise<{ status?: FullResult['status'] } | undefined | void> {
    console.log(`Starting test ${test.title}`);
  }

  async onTestEnd(
    test: TestCase,
    result: TestResult
  ): Promise<{ status?: FullResult['status'] } | undefined | void> {
    console.log(`Finished test ${test.title}: ${result.status}`);
    if (
      (slackLogLevel === SlackLogLevel.Basic && result.status !== 'passed') ||
      slackLogLevel === SlackLogLevel.Full
    )
      await sendSlackMessage(
        JSON.stringify({
          blocks: [
            {
              type: 'section',
              text: {
                type: 'mrkdwn',
                text: `:test_tube: Test complete`,
              },
            },
            {
              type: 'section',
              fields: [
                {
                  type: 'mrkdwn',
                  text: `*Name:*\n${test.title}`,
                },
                {
                  type: 'mrkdwn',
                  text: `*Test duration:*\n${Math.floor(
                    result.duration / 1000
                  )} seconds`,
                },
                {
                  type: 'mrkdwn',
                  text: `*Test result:*\n${result.status}`,
                },
                {
                  type: 'mrkdwn',
                  text: result.error
                    ? `*Test errors:*\nSnippet: ${result.error.snippet}\nStack: ${result.error.stack}`
                    : '*No errors detected.*',
                },
              ],
            },
          ],
        })
      );
  }

  async onEnd(
    result: FullResult
  ): Promise<{ status?: FullResult['status'] } | undefined | void> {
    console.log(`Finished the run: ${result.status}`);
    if (slackLogLevel === SlackLogLevel.Full)
      await sendSlackMessage(
        JSON.stringify({
          blocks: [
            {
              type: 'section',
              text: {
                type: 'mrkdwn',
                text: `:test_tube: Tests have all completed. See blow for summary details.`,
              },
            },
            {
              type: 'section',
              fields: [
                {
                  type: 'mrkdwn',
                  text: `*Overall test status:*\n${result.status}`,
                },
                {
                  type: 'mrkdwn',
                  text: `*Test duration:*\n${Math.floor(
                    result.duration / 1000
                  )} seconds`,
                },
              ],
            },
          ],
        })
      );
  }
}

export default SlackReporter;


